# Security Summary

## 1. Service Overview
The service is a message broker and streaming platform designed for handling client connections, message delivery, and managing persistent streams and consumers through its JetStream component. It supports Quality of Service (QoS) for MQTT messages. The system is built for high availability and scalability, leveraging clustering capabilities.

Key architectural components include a core server responsible for client interactions, authentication, authorization, and message routing. JetStream provides a persistence layer for various message types, including session records, QoS 1 and 2 messages, and retained messages, with streams configured for replication (up to 3 replicas). The service offers a WebSocket interface that supports NATS, MQTT, and LeafNode connections. Clustering is enabled via a gossip protocol for discovery, with a focus on leader election and replica management for domains, streams, and consumers. Internally, the service utilizes optimized data structures such as AVL trees for sequence sets and subject trees, along with established lock ordering for concurrency control.

The technical stack is primarily Go, evidenced by the `.go` files and `go.mod` dependencies. Key external dependencies include `github.com/nats-io/jwt/v2` and `github.com/nats-io/nkeys` for identity and access management, `golang.org/x/crypto` for cryptographic functions, and `github.com/klauspost/compress/flate` for data compression. The service integrates with platform-specific features, such as Windows certificate stores. Configuration parsing is handled by a custom lexer.

## 2. Authentication and Authorization
Authentication mechanisms are robust and multi-faceted. The primary method involves JWTs (JSON Web Tokens) for operators and users, which can include specific source IP ranges (`Src`) and time ranges (`Times`) for connection validity. NKEYs are used for signing JWTs and serve as sensitive identity secrets. Password-based authentication is supported, with improvements noted for `bcrypt` usage. Direct token authentication is also available. For WebSocket connections, authentication can be performed via HTTP cookies that carry JWTs, usernames, passwords, or tokens. A `NoAuthUser` option allows a specific user to bypass authentication for WebSockets.

Authorization models are granular, primarily subject-based for message exports and imports, allowing fine-grained control over message flow. Account-level policies enforce resource limits on connections, subscriptions, data, and JetStream usage. The system supports "Multiple Authorization / Access" methods. Stream and service imports require explicit authorization. Multi-tenant accounts with isolated subject spaces are a noted feature.

Identity management revolves around operators, accounts, and users. Operators are the top-level identity, signing accounts, and an `AccountResolver` is required when operators are in use. Accounts are logical isolation units containing users, and `resolverPinnedAccounts` can enforce specific trusted account keys. The system supports credential revocation.

Session handling includes configurable `AuthTimeout` and detection of `AuthExpired` states. A ping timer ensures connection liveness. For MQTT, session records are persisted in the `$MQTT_sess` stream.

Access control implementation includes specific error types for various authentication and authorization failures (e.g., `ErrAuthentication`, `ErrAuthTimeout`, `ErrRevocation`, `ErrSubscribePermissionViolation`, `ErrStreamImportAuthorization`). Resource limits are enforced with errors like `ErrTooManyConnections` and `ErrMaxPayload`. Internal lock ordering, specifically `reloadMu`, is used to prevent client connection races during configuration reloads. WebSocket connections enforce origin checks via `SameOrigin` and `AllowedOrigins` lists.

## 3. Encryption and Data Protection
Data encryption at rest is not explicitly detailed as an encryption mechanism in the provided context for JetStream persistent data. However, JetStream streams (e.g., `$MQTT_sess`, `$MQTT_msgs`) store data persistently and are configured with replica values (up to 3) for durability.

Data encryption in transit is supported through SSL/TLS, explicitly enabled via configuration with `SSL/TLS support` noted as a completed feature. TLS configurations can leverage `cert_file` and `key_file`, or integrate with the Windows Certificate Store. The service supports a range of TLS cipher suites, with a default preference for modern, strong options like `TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256` and `TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256`, and prioritizes strong elliptic curves such as `X25519` and `CurveP256`. WebSocket connections enforce TLS by default to protect sensitive data like JWTs.

Key management involves the secure handling of NKEY seeds as sensitive secrets, with a `wipeSlice` function used to clear their contents from memory. On Windows, the service integrates with the operating system's certificate store to retrieve TLS certificates and private keys, supporting RSA and ECDSA, including PKCS#1 v1.5 and PSS padding for RSA signatures. OCSP (Online Certificate Status Protocol) is utilized for validating certificate revocation status, including checks for response freshness and valid delegation as per RFC 6960. Certificate fingerprints are generated using SHA256. The system supports TLS pinned certificates to restrict connections to pre-approved certificates.

Secure configuration includes extensive input validation for various options, such as network addresses and certificate store parameters. It also checks for conflicting security configurations, such as `TrustedKeys` versus `TrustedOperators` or `cert_file` versus `cert_store`. An example configuration shows the use of hardcoded user credentials, which is an insecure practice.

Data handling and storage features include memory-optimized data structures like AVL trees for storing sequence sets. WebSocket connections support `permessage-deflate` for data compression. The service enforces resource limits such as maximum payload size, maximum control line size, and limits on connections and subscriptions per client or account to prevent resource exhaustion. JetStream streams retain messages based on configurable retention policies (limits or interest).

## 4. Audit Logging and Monitoring
Audit logging mechanisms are comprehensive, particularly for JetStream. The service publishes structured JSON advisories for administrative actions (`JSAPIAudit`), stream and consumer lifecycle events, message delivery metrics and advisories (e.g., acknowledgements, NAKs, delivery exceeding limits), and snapshot/restore operations. Clustering-specific advisories are generated for leader elections and quorum loss. Server health events, such as out-of-storage conditions, server removal, and API limit reach, also trigger advisories. These advisories are published to internal subjects, often within the system account (e.g., `_SYS.>`). Syslog support is a noted capability, indicating external logging integration. Message tracing provides detailed audit logs of message flow, supporting W3C Trace Context.

Log formats and structures primarily involve structured JSON for JetStream advisories and support for W3C Trace Context for message tracing, facilitating standardized data exchange and analysis.

Log retention policies are not explicitly defined for audit logs in the provided context; however, JetStream streams do have configurable retention policies for message storage.

Monitoring systems provide various internal endpoints (e.g., `/varz`, `/connz`, `/routez`) for operational insights. These endpoints report connection statistics, including total connections, start time, uptime, and last activity time per connection. Client information, such as language and version, is collected. Dropped message statistics for slow consumers are tracked. The system also reports CPU and memory (RSS) usage statistics.

Alert mechanisms are implicitly supported through the generation of structured advisories for critical events like server out-of-storage or API limit thresholds being reached, which can be used as triggers for external alerting systems. The monitoring of total connections is noted to help detect spikes.

Compliance reporting is supported by a third-party security audit performed by Trail of Bits in April 2025, with a full report available. The service operates under the Apache License 2.0, which mandates specific terms for redistribution and attribution. The contribution process requires Apache-2.0 sign-offs with legal names, ensuring an auditable trail of code contributions. The structured nature of JetStream audit advisories facilitates compliance reporting by providing clear, machine-readable records of system actions and state changes.