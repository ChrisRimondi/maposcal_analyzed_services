[
  {
    "content": "# Contributor Covenant Code of Conduct\n",
    "source_file": "CODE_OF_CONDUCT.md",
    "chunk_type": "doc"
  },
  {
    "content": "## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.\n",
    "source_file": "CODE_OF_CONDUCT.md",
    "chunk_type": "doc"
  },
  {
    "content": "## Our Standards\n\nExamples of behavior that contributes to creating a positive environment include:\n\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n* The use of sexualized language or imagery and unwelcome sexual attention or advances\n* Trolling, insulting/derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or electronic address, without explicit permission\n* Other conduct which could reasonably be considered inappropriate in a professional setting\n",
    "source_file": "CODE_OF_CONDUCT.md",
    "chunk_type": "doc"
  },
  {
    "content": "## Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.\n",
    "source_file": "CODE_OF_CONDUCT.md",
    "chunk_type": "doc"
  },
  {
    "content": "## Scope\n\nThis Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.\n",
    "source_file": "CODE_OF_CONDUCT.md",
    "chunk_type": "doc"
  },
  {
    "content": "## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at teamgingonic@gmail.com. The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.\n",
    "source_file": "CODE_OF_CONDUCT.md",
    "chunk_type": "doc"
  },
  {
    "content": "## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4, available at [http://contributor-covenant.org/version/1/4][version]\n\n[homepage]: http://contributor-covenant.org\n[version]: http://contributor-covenant.org/version/1/4/",
    "source_file": "CODE_OF_CONDUCT.md",
    "chunk_type": "doc"
  },
  {
    "content": "List of all the awesome people working to make Gin the best Web Framework in Go.\n",
    "source_file": "AUTHORS.md",
    "chunk_type": "doc"
  },
  {
    "content": "## gin 1.x series authors\n\n**Gin Core Team:** Bo-Yi Wu (@appleboy), thinkerou (@thinkerou), Javier Provecho (@javierprovecho)\n",
    "source_file": "AUTHORS.md",
    "chunk_type": "doc"
  },
  {
    "content": "## gin 0.x series authors\n\n**Maintainers:** Manu Martinez-Almeida (@manucorporat), Javier Provecho (@javierprovecho)\n\n------\n\nPeople and companies, who have contributed, in alphabetical order.\n\n- 178inaba <178inaba@users.noreply.github.com>\n- A. F <hello@clivern.com>\n- ABHISHEK SONI <abhishek.rocks26@gmail.com>\n- Abhishek Chanda <achanda@users.noreply.github.com>\n- Abner Chen <houjunchen@gmail.com>\n- AcoNCodes <acongame@gmail.com>\n- Adam Dratwinski <adam.dratwinski@gmail.com>\n- Adam Mckaig <adam.mckaig@gmail.com>\n- Adam Zielinski <MusicAdam@users.noreply.github.com>\n- Adonis <donileo@gmail.com>\n- Alan Wang <azzwacb9001@126.com>\n- Albin Gilles <gilles.albin@gmail.com>\n- Aleksandr Didenko <aa.didenko@yandex.ru>\n- Alessandro (Ale) Segala <43508+ItalyPaleAle@users.noreply.github.com>\n- Alex <AWulkan@users.noreply.github.com>\n- Alexander <alexanderchenmh@gmail.com>\n- Alexander Lokhman <alex.lokhman@gmail.com>\n- Alexander Melentyev <55826637+alexander-melentyev@users.noreply.github.com>\n- Alexander Nyquist <nyquist.alexander@gmail.com>\n- Allen Ren <kulong0105@gmail.com>\n- AllinGo <tanhp@outlook.com>\n- Ammar Bandukwala <ammar@ammar.io>\n- An Xiao (Luffy) <hac@zju.edu.cn>\n- Andre Dublin <81dublin@gmail.com>\n- Andrew Szeto <github@jabagawee.com>\n- Andrey Abramov <andreyabramov.aaa@gmail.com>\n- Andrey Nering <andrey.nering@gmail.com>\n- Andrey Smirnov <Smirnov.Andrey@gmail.com>\n- Andrii Bubis <firstrow@gmail.com>\n- Andr\u00e9 Bazaglia <bazaglia@users.noreply.github.com>\n- Andy Pan <panjf2000@gmail.com>\n- Antoine GIRARD <sapk@users.noreply.github.com>\n- Anup Kumar Panwar <1anuppanwar@gmail.com>\n- Aravinth Sundaram <gosh.aravind@gmail.com>\n- Artem <horechek@gmail.com>\n- Ashwani <ashwanisharma686@gmail.com>\n- Aurelien Regat-Barrel <arb@cyberkarma.net>\n- Austin Heap <me@austinheap.com>\n- Barnabus <jbampton@users.noreply.github.com>\n- Bo-Yi Wu <appleboy.tw@gmail.com>\n- Boris Borshevsky <BorisBorshevsky@gmail.com>\n- Boyi Wu <p581581@gmail.com>\n- BradyBromley <51128276+BradyBromley@users.noreply.github.com>\n- Brendan Fosberry <brendan@shopkeep.com>\n- Brian Wigginton <brianwigginton@gmail.com>\n- Carlos Eduardo <carlosedp@gmail.com>\n- Chad Russell <chaddouglasrussell@gmail.com>\n- Charles <cxjava@gmail.com>\n- Christian Muehlhaeuser <muesli@gmail.com>\n- Christian Persson <saser@live.se>\n- Christopher Harrington <ironiridis@gmail.com>\n- Damon Zhao <yijun.zhao@outlook.com>\n- Dan Markham <dmarkham@gmail.com>\n- Dang Nguyen <hoangdang.me@gmail.com>\n- Daniel Krom <kromdan@gmail.com>\n- Daniel M. Lambea <dmlambea@gmail.com>\n- Danieliu <liudanking@gmail.com>\n- David Irvine <aviddiviner@gmail.com>\n- David Zhang <crispgm@gmail.com>\n- Davor Kapsa <dvrkps@users.noreply.github.com>\n- DeathKing <DeathKing@users.noreply.github.com>\n- Dennis Cho <47404603+forest747@users.noreply.github.com>\n- Dmitry Dorogin <dmirogin@ya.ru>\n- Dmitry Kutakov <vkd.castle@gmail.com>\n- Dmitry Sedykh <dmitrys@d3h.local>\n- Don2Quixote <35610661+Don2Quixote@users.noreply.github.com>\n- Donn Pebe <iam@donnpebe.com>\n- Dustin Decker <dustindecker@protonmail.com>\n- Eason Lin <easonlin404@gmail.com>\n- Edward Betts <edward@4angle.com>\n- Egor Seredin <4819888+agmt@users.noreply.github.com>\n- Emmanuel Goh <emmanuel@visenze.com>\n- Equim <sayaka@ekyu.moe>\n- Eren A. Akyol <eren@redmc.me>\n- Eric_Lee <xplzv@126.com>\n- Erik Bender <erik.bender@develerik.dev>\n- Ethan Kan <ethankan@neoplot.com>\n- Evgeny Persienko <e.persienko@office.ngs.ru>\n- Faisal Alam <ifaisalalam@gmail.com>\n- Fareed Dudhia <fareeddudhia@googlemail.com>\n- Filip Figiel <figiel.filip@gmail.com>\n- Florian Polster <couchpolster@icqmail.com>\n- Frank Bille <github@frankbille.dk>\n- Franz Bettag <franz@bett.ag>\n- Ganlv <ganlvtech@users.noreply.github.com>\n- Gaozhen Ying <yinggaozhen@hotmail.com>\n- George Gabolaev <gabolaev98@gmail.com>\n- George Kirilenko <necryin@users.noreply.github.com>\n- Georges Varouchas <georges.varouchas@gmail.com>\n- Gordon Tyler <gordon@doxxx.net>\n- Harindu Perera <harinduenator@gmail.com>\n- Helios <674876158@qq.com>\n- Henry Kwan <piengeng@users.noreply.github.com>\n- Henry Yee <henry@yearning.io>\n- Himanshu Mishra <OrkoHunter@users.noreply.github.com>\n- Hiroyuki Tanaka <h.tanaka.0325@gmail.com>\n- Ibraheem Ahmed <ibrah1440@gmail.com>\n- Ignacio Galindo <joiggama@gmail.com>\n- Igor H. Vieira <zignd.igor@gmail.com>\n- Ildar1111 <54001462+Ildar1111@users.noreply.github.com>\n- Iskander (Alex) Sharipov <iskander.sharipov@intel.com>\n- Ismail Gjevori <isgjevori@protonmail.com>\n- Ivan Chen <allenivan@gmail.com>\n- JINNOUCHI Yasushi <delphinus@remora.cx>\n- James Pettyjohn <japettyjohn@users.noreply.github.com>\n- Jamie Stackhouse <jamie.stackhouse@redspace.com>\n- Jason Lee <jawc@hotmail.com>\n- Javier Provecho <j.provecho@dartekstudios.com>\n- Javier Provecho <javier.provecho@bq.com>\n- Javier Provecho <javiertitan@gmail.com>\n- Javier Provecho Fernandez <j.provecho@dartekstudios.com>\n- Javier Provecho Fernandez <javiertitan@gmail.com>\n- Jean-Christophe Lebreton <jclebreton@gmail.com>\n- Jeff <laojianzi1994@gmail.com>\n- Jeremy Loy <jeremy.b.loy@icloud.com>\n- Jim Filippou <p3160253@aueb.gr>\n- Jimmy Pettersson <jimmy@expertmaker.com>\n- John Bampton <jbampton@users.noreply.github.com>\n- Johnny Dallas <johnnydallas0308@gmail.com>\n- Johnny Dallas <theonlyjohnny@theonlyjohnny.sh>\n- Jonathan (JC) Chen <jc@dijonkitchen.org>\n- Josep Jesus Bigorra Algaba <42377845+averageflow@users.noreply.github.com>\n- Josh Horowitz <joshua.m.horowitz@gmail.com>\n- Joshua Loper <josh.el3@gmail.com>\n- Julien Schmidt <github@julienschmidt.com>\n- Jun Kimura <jksmphone@gmail.com>\n- Justin Beckwith <justin.beckwith@gmail.com>\n- Justin Israel <justinisrael@gmail.com>\n- Justin Mayhew <mayhew@live.ca>\n- J\u00e9r\u00f4me Laforge <jerome-laforge@users.noreply.github.com>\n- Kacper B\u0105k <56700396+53jk1@users.noreply.github.com>\n- Kamron Batman <kamronbatman@users.noreply.github.com>\n- Kane Rogers <kane@cleanstream.com.au>\n- Kaushik Neelichetty <kaushikneelichetty6132@gmail.com>\n- Keiji Yoshida <yoshida.keiji.84@gmail.com>\n- Kel Cecil <kel.cecil@listhub.com>\n- Kevin Mulvey <kmulvey@linux.com>\n- Kevin Zhu <ipandtcp@gmail.com>\n- Kirill Motkov <motkov.kirill@gmail.com>\n- Klemen Sever <ksever@student.42.fr>\n- Kristoffer A. Iversen <kristoffer.a.iversen@gmail.com>\n- Krzysztof Szafra\u0144ski <k.p.szafranski@gmail.com>\n- Kumar McMillan <kumar.mcmillan@gmail.com>\n- Kyle Mcgill <email@kylescottmcgill.com>\n- Lanco <35420416+lancoLiu@users.noreply.github.com>\n- Levi Olson <olson.levi@gmail.com>\n- Lin Kao-Yuan <mosdeo@gmail.com>\n- Linus Unneb\u00e4ck <linus@folkdatorn.se>\n- Lucas Clemente <lucas@clemente.io>\n- Ludwig Valda Vasquez <bredov@gmail.com>\n- Luis GG <lggomez@users.noreply.github.com>\n- MW Lim <williamchange@gmail.com>\n- Maksimov Sergey <konjoot@gmail.com>\n- Manjusaka <lizheao940510@gmail.com>\n- Manu MA <manu.mtza@gmail.com>\n- Manu MA <manu.valladolid@gmail.com>\n- Manu Mtz-Almeida <manu.valladolid@gmail.com>\n- Manu Mtz.-Almeida <manu.valladolid@gmail.com>\n- Manuel Alonso <manuelalonso@invisionapp.com>\n- Mara Kim <hacker.root@gmail.com>\n- Mario Kostelac <mario@intercom.io>\n- Martin Karlsch <martin@karlsch.com>\n- Matt Newberry <mnewberry@opentable.com>\n- Matt Williams <gh@mattyw.net>\n- Matthieu MOREL <mmorel-35@users.noreply.github.com>\n- Max Hilbrunner <mhilbrunner@users.noreply.github.com>\n- Maxime Soul\u00e9 <btik-git@scoubidou.com>\n- MetalBreaker <johnymichelson@gmail.com>\n- Michael Puncel <mpuncel@squareup.com>\n- MichaelDeSteven <51652084+MichaelDeSteven@users.noreply.github.com>\n- Mike <38686456+icy4ever@users.noreply.github.com>\n- Mike Stipicevic <mst@ableton.com>\n- Miki Tebeka <miki.tebeka@gmail.com>\n- Miles <MilesLin@users.noreply.github.com>\n- Mirza Ceric <mirza.ceric@b2match.com>\n- Mykyta Semenistyi <nikeiwe@gmail.com>\n- Naoki Takano <honten@tinkermode.com>\n- Ngalim Siregar <ngalim.siregar@gmail.com>\n- Ni Hao <supernihaooo@qq.com>\n- Nick Gerakines <nick@gerakines.net>\n- Nikifor Seryakov <nikandfor@gmail.com>\n- Notealot <714804968@qq.com>\n- Olivier Mengu\u00e9 <dolmen@cpan.org>\n- Olivier Robardet <orobardet@users.noreply.github.com>\n- Pablo Moncada <pablo.moncada@bq.com>\n- Pablo Moncada <pmoncadaisla@gmail.com>\n- Panmax <967168@qq.com>\n- Peperoncino <2wua4nlyi@gmail.com>\n- Philipp Meinen <philipp@bind.ch>\n- Pierre Massat <pierre@massat.io>\n- Qt <golang.chen@gmail.com>\n- Quentin ROYER <aydendevg@gmail.com>\n- README Bot <35302948+codetriage-readme-bot@users.noreply.github.com>\n- Rafal Zajac <rzajac@gmail.com>\n- Rahul Datta Roy <rahuldroy@users.noreply.github.com>\n- Rajiv Kilaparti <rajivk085@gmail.com>\n- Raphael Gavache <raphael.gavache@datadoghq.com>\n- Ray Rodriguez <rayrod2030@gmail.com>\n- Regner Blok-Andersen <shadowdf@gmail.com>\n- Remco <remco@dutchcoders.io>\n- Rex Lee(\u674e\u4fca) <duguying2008@gmail.com>\n- Richard Lee <dlackty@gmail.com>\n- Riverside <wangyb65@gmail.com>\n- Robert Wilkinson <wilkinson.robert.a@gmail.com>\n- Rogier Lommers <rogier@lommers.org>\n- Rohan Pai <me@rohanpai.com>\n- Romain Beuque <rbeuque74@gmail.com>\n- Roman Belyakovsky <ihryamzik@gmail.com>\n- Roman Zaynetdinov <627197+zaynetro@users.noreply.github.com>\n- Roman Zaynetdinov <roman.zaynetdinov@lekane.com>\n- Ronald Petty <ronald.petty@rx-m.com>\n- Ross Wolf <31489089+rw-access@users.noreply.github.com>\n- Roy Lou <roylou@gmail.com>\n- Rubi <14269809+codenoid@users.noreply.github.com>\n- Ryan <46182144+ryanker@users.noreply.github.com>\n- Ryan J. Yoder <me@ryanjyoder.com>\n- SRK.Lyu <superalsrk@gmail.com>\n- Sai <sairoutine@gmail.com>\n- Samuel Abreu <sdepaula@gmail.com>\n- Santhosh Kumar <santhoshkumarr1096@gmail.com>\n- Sasha Melentyev <sasha@melentyev.io>\n- Sasha Myasoedov <msoedov@gmail.com>\n- Segev Finer <segev208@gmail.com>\n- Sergey Egorov <egorovhome@gmail.com>\n- Sergey Fedchenko <seregayoga@bk.ru>\n- Sergey Gonimar <sergey.gonimar@gmail.com>\n- Sergey Ponomarev <me@sergey-ponomarev.ru>\n- Serica <943914044@qq.com>\n- Shamus Taylor <Shamus03@me.com>\n- Shilin Wang <jarvisfironman@gmail.com>\n- Shuo <openset.wang@gmail.com>\n- Skuli Oskarsson <skuli@codeiak.io>\n- Snawoot <vladislav-ex-github@vm-0.com>\n- Sridhar Ratnakumar <srid@srid.ca>\n- Steeve Chailloux <steeve@chaahk.com>\n- Sudhir Mishra <sudhirxps@gmail.com>\n- Suhas Karanth <sudo-suhas@users.noreply.github.com>\n- TaeJun Park <miking38@gmail.com>\n- Tatsuya Hoshino <tatsuya7.hoshino7@gmail.com>\n- Tevic <tevic.tt@gmail.com>\n- Tevin Jeffrey <tev.jeffrey@gmail.com>\n- The Gitter Badger <badger@gitter.im>\n- Thibault Jamet <tjamet@users.noreply.github.com>\n- Thomas Boerger <thomas@webhippie.de>\n- Thomas Schaffer <loopfz@gmail.com>\n- Tommy Chu <tommychu2256@gmail.com>\n- Tudor Roman <tudurom@gmail.com>\n- Uwe Dauernheim <djui@users.noreply.github.com>\n- Valentine Oragbakosi <valentine13400@gmail.com>\n- Vas N <pnvasanth@users.noreply.github.com>\n- Vasilyuk Vasiliy <By-Vasiliy@users.noreply.github.com>\n- Victor Castell <victor@victorcastell.com>\n- Vince Yuan <vince.yuan@gmail.com>\n- Vyacheslav Dubinin <vyacheslav.dubinin@gmail.com>\n- Waynerv <ampedee@gmail.com>\n- Weilin Shi <934587911@qq.com>\n- Xudong Cai <fifsky@gmail.com>\n- Yasuhiro Matsumoto <mattn.jp@gmail.com>\n- Yehezkiel Syamsuhadi <ybs@ybs.im>\n- Yoshiki Nakagawa <yyoshiki41@gmail.com>\n- Yoshiyuki Kinjo <yskkin+github@gmail.com>\n- Yue Yang <g1enyy0ung@gmail.com>\n- ZYunH <zyunhjob@163.com>\n- Zach Newburgh <zach.newburgh@gmail.com>\n- Zasda Yusuf Mikail <zasdaym@gmail.com>\n- ZhangYunHao <zyunhjob@163.com>\n- ZhiFeng Hu <hufeng1987@gmail.com>\n- Zhu Xi <zhuxi910511@163.com>\n- a2tt <usera2tt@gmail.com>\n- ahuigo <1781999+ahuigo@users.noreply.github.com>\n- ali <anio@users.noreply.github.com>\n- aljun <salameryy@163.com>\n- andrea <crypto.andrea@protonmail.ch>\n- andriikushch <andrii.kushch@gmail.com>\n- anoty <anjunyou@foxmail.com>\n- awkj <hzzbiu@gmail.com>\n- axiaoxin <254606826@qq.com>\n- bbiao <bbbiao@gmail.com>\n- bestgopher <84328409@qq.com>\n- betahu <zhong.wenhuang@foxmail.com>\n- bigwheel <k.bigwheel+eng@gmail.com>\n- bn4t <17193640+bn4t@users.noreply.github.com>\n- bullgare <bullgare@gmail.com>\n- chainhelen <chainhelen@gmail.com>\n- chenyang929 <chenyang929code@gmail.com>\n- chriswhelix <chris.williams@helix.com>\n- collinmsn <4130944@qq.com>\n- cssivision <cssivision@gmail.com>\n- danielalves <alves.lopes.dan@gmail.com>\n- delphinus <delphinus@remora.cx>\n- dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>\n- dickeyxxx <jeff@dickeyxxx.com>\n- edebernis <emeric.debernis@gmail.com>\n- error10 <error@ioerror.us>\n- esplo <esplo@users.noreply.github.com>\n- eudore <30709860+eudore@users.noreply.github.com>\n- ffhelicopter <32922889+ffhelicopter@users.noreply.github.com>\n- filikos <11477309+filikos@users.noreply.github.com>\n- forging2012 <forging2012@users.noreply.github.com>\n- goqihoo <goqihoo@gmail.com>\n- grapeVine <treeui.old@gmail.com>\n- guonaihong <guonaihong@qq.com>\n- heige <daheige@users.noreply.github.com>\n- heige <zhuwei313@hotmail.com>\n- hellojukay <hellojukay@163.com>\n- henrylee2cn <henrylee2cn@gmail.com>\n- htobenothing <htobenothing@gmail.com>\n- iamhesir <78344375+iamhesir@users.noreply.github.com>\n- ijaa <kailiu2013@gmail.com>\n- ishanray <ishan.iipm@gmail.com>\n- ishanray <ishanray@users.noreply.github.com>\n- itcloudy <272685110@qq.com>\n- jarodsong6 <jarodsong6@gmail.com>\n- jasonrhansen <jasonrodneyhansen@gmail.com>\n- jincheng9 <perfume0607@gmail.com>\n- joeADSP <75027008+joeADSP@users.noreply.github.com>\n- junfengye <junfeng.yejf@gmail.com>\n- kaiiak <aNxFi37X@outlook.com>\n- kebo <kevinke2020@outlook.com>\n- keke <19yamashita15@gmail.com>\n- kishor kunal raj <68464660+kishorkunal-raj@users.noreply.github.com>\n- kyledinh <kyledinh@gmail.com>\n- lantw44 <lantw44@gmail.com>\n- likakuli <1154584512@qq.com>\n- linfangrong <linfangrong.liuxin@qq.com>\n- linzi <873804682@qq.com>\n- llgoer <yanghuxiao@vip.qq.com>\n- long-road <13412081338@163.com>\n- mbesancon <mathieu.besancon@gmail.com>\n- mehdy <mehdy.khoshnoody@gmail.com>\n- metal A-wing <freedom.awing.777@gmail.com>\n- micanzhang <micanzhang@gmail.com>\n- minarc <ragnhildmowinckel@gmail.com>\n- mllu <mornlyn@gmail.com>\n- mopemoepe <yutaka.matsubara@gmail.com>\n- msoedov <msoedov@gmail.com>\n- mstmdev <mstmdev@gmail.com>\n- novaeye <fcoffee@gmail.com>\n- olebedev <oolebedev@gmail.com>\n- phithon <phith0n@users.noreply.github.com>\n- pjgg <pablo.gonzalez.granados@gmail.com>\n- qm012 <67568757+qm012@users.noreply.github.com>\n- raymonder jin <rayjingithub@gmail.com>\n- rns <ruslan.shvedov@gmail.com>\n- root@andrea:~# <crypto.andrea@protonmail.ch>\n- sekky0905 <20237968+sekky0905@users.noreply.github.com>\n- senhtry <w169q169@gmail.com>\n- shadrus <shadrus@gmail.com>\n- silasb <silas.baronda@gmail.com>\n- solos <lxl1217@gmail.com>\n- songjiayang <songjiayang@users.noreply.github.com>\n- sope <shenshouer@163.com>\n- srt180 <30768686+srt180@users.noreply.github.com>\n- stackerzzq <foo_stacker@yeah.net>\n- sunshineplan <sunshineplan@users.noreply.github.com>\n- syssam <s.y.s.sam.sys@gmail.com>\n- techjanitor <puntme@gmail.com>\n- techjanitor <techjanitor@users.noreply.github.com>\n- thinkerou <thinkerou@gmail.com>\n- thinkgo <49174849+thinkgos@users.noreply.github.com>\n- tsirolnik <tsirolnik@users.noreply.github.com>\n- tyltr <31768692+tylitianrui@users.noreply.github.com>\n- vinhha96 <anhvinha1@gmail.com>\n- voidman <retmain@foxmail.com>\n- vz <vzvway@gmail.com>\n- wei <wei840222@gmail.com>\n- weibaohui <weibaohui@yeah.net>\n- whirosan <whirosan@users.noreply.github.com>\n- willnewrelic <will@newrelic.com>\n- wssccc <wssccc@qq.com>\n- wuhuizuo <wuhuizuo@126.com>\n- xyb <xyb4638@gmail.com>\n- y-yagi <yuuji.yaginuma@gmail.com>\n- yiranzai <wuqingdzx@gmail.com>\n- youzeliang <youzel@126.com>\n- yugu <chenzilong_1227@foxmail.com>\n- yuyabe <yuyabee@gmail.com>\n- zebozhuang <zebozhuang@163.com>\n- zero11-0203 <93071220+zero11-0203@users.noreply.github.com>\n- zesani <7sin@outlook.co.th>\n- zhanweidu <zhanweidu@163.com>\n- zhing <zqwillseven@gmail.com>\n- ziheng <zihenglv@gmail.com>\n- zzjin <zzjin@users.noreply.github.com>\n- \u68ee \u512a\u592a <59682979+uta-mori@users.noreply.github.com>\n- \u6770\u54e5 <858806258@qq.com>\n- \u6d9b\u53d4 <hi@taoshu.in>\n- \u5e02\u6c11233 <mengrenxiong@gmail.com>\n- \u5c39\u5b9d\u5f3a <wmdandme@gmail.com>\n- \u68a6\u6eaa\u7b14\u8c08 <loongmxbt@gmail.com>\n- \u98de\u96ea\u65e0\u60c5 <ls8707@gmail.com>\n- \u5bfb\u5bfb\u89c5\u89c5\u7684Gopher <zoujh99@qq.com>",
    "source_file": "AUTHORS.md",
    "chunk_type": "doc"
  },
  {
    "content": "// Copyright 2018 Gin Core Team. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\n// Version is the current gin framework's version.\nconst Version = \"v1.10.0\"\n",
    "source_file": "version.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"os\"\n\t\"runtime\"\n\t\"strings\"\n\t\"time\"\n)\n\nconst dunno = \"???\"\n\nvar dunnoBytes = []byte(dunno)\n\n// RecoveryFunc defines the function passable to CustomRecovery.\ntype RecoveryFunc func(c *Context, err any)\n\n// Recovery returns a middleware that recovers from any panics and writes a 500 if there was one.\nfunc Recovery() HandlerFunc {\n\treturn RecoveryWithWriter(DefaultErrorWriter)\n}\n\n// CustomRecovery returns a middleware that recovers from any panics and calls the provided handle func to handle it.\nfunc CustomRecovery(handle RecoveryFunc) HandlerFunc {\n\treturn RecoveryWithWriter(DefaultErrorWriter, handle)\n}\n\n// RecoveryWithWriter returns a middleware for a given writer that recovers from any panics and writes a 500 if there was one.\nfunc RecoveryWithWriter(out io.Writer, recovery ...RecoveryFunc) HandlerFunc {\n\tif len(recovery) > 0 {\n\t\treturn CustomRecoveryWithWriter(out, recovery[0])\n\t}\n\treturn CustomRecoveryWithWriter(out, defaultHandleRecovery)\n}\n\n// CustomRecoveryWithWriter returns a middleware for a given writer that recovers from any panics and calls the provided handle func to handle it.\nfunc CustomRecoveryWithWriter(out io.Writer, handle RecoveryFunc) HandlerFunc {\n\tvar logger *log.Logger\n\tif out != nil {\n\t\tlogger = log.New(out, \"\\n\\n\\x1b[31m\", log.LstdFlags)\n\t}\n\treturn func(c *Context) {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\t// Check for a broken connection, as it is not really a\n\t\t\t\t// condition that warrants a panic stack trace.\n\t\t\t\tvar brokenPipe bool\n\t\t\t\tif ne, ok := err.(*net.OpError); ok {\n\t\t\t\t\tvar se *os.SyscallError\n\t\t\t\t\tif errors.As(ne, &se) {\n\t\t\t\t\t\tseStr := strings.ToLower(se.Error())\n\t\t\t\t\t\tif strings.Contains(seStr, \"broken pipe\") ||\n\t\t\t\t\t\t\tstrings.Contains(seStr, \"connection reset by peer\") {\n\t\t\t\t\t\t\tbrokenPipe = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif logger != nil {\n\t\t\t\t\tstack := stack(3)\n\t\t\t\t\thttpRequest, _ := httputil.DumpRequest(c.Request, false)\n\t\t\t\t\theaders := strings.Split(string(httpRequest), \"\\r\\n\")\n\t\t\t\t\tmaskAuthorization(headers)\n\t\t\t\t\theadersToStr := strings.Join(headers, \"\\r\\n\")\n\t\t\t\t\tif brokenPipe {\n\t\t\t\t\t\tlogger.Printf(\"%s\\n%s%s\", err, headersToStr, reset)\n\t\t\t\t\t} else if IsDebugging() {\n\t\t\t\t\t\tlogger.Printf(\"[Recovery] %s panic recovered:\\n%s\\n%s\\n%s%s\",\n\t\t\t\t\t\t\ttimeFormat(time.Now()), headersToStr, err, stack, reset)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogger.Printf(\"[Recovery] %s panic recovered:\\n%s\\n%s%s\",\n\t\t\t\t\t\t\ttimeFormat(time.Now()), err, stack, reset)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif brokenPipe {\n\t\t\t\t\t// If the connection is dead, we can't write a status to it.\n\t\t\t\t\tc.Error(err.(error)) //nolint: errcheck\n\t\t\t\t\tc.Abort()\n\t\t\t\t} else {\n\t\t\t\t\thandle(c, err)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t\tc.Next()\n\t}\n}\n\nfunc defaultHandleRecovery(c *Context, _ any) {\n\tc.AbortWithStatus(http.StatusInternalServerError)\n}\n\n// stack returns a nicely formatted stack frame, skipping skip frames.\nfunc stack(skip int) []byte {\n\tbuf := new(bytes.Buffer) // the returned data\n\t// As we loop, we open files and read them. These variables record the currently\n\t// loaded file.\n\tvar lines [][]byte\n\tvar lastFile string\n\tfor i := skip; ; i++ { // Skip the expected number of frames\n\t\tpc, file, line, ok := runtime.Caller(i)\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\t// Print this much at least.  If we can't find the source, it won't show.\n\t\tfmt.Fprintf(buf, \"%s:%d (0x%x)\\n\", file, line, pc)\n\t\tif file != lastFile {\n\t\t\tdata, err := os.ReadFile(file)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tlines = bytes.Split(data, []byte{'\\n'})\n\t\t\tlastFile = file\n\t\t}\n\t\tfmt.Fprintf(buf, \"\\t%s: %s\\n\", function(pc), source(lines, line))\n\t}\n\treturn buf.Bytes()\n}\n\n// maskAuthorization replaces any \"Authorization: <token>\" header with \"Authorization: *\", hiding sensitive credentials.\nfunc maskAuthorization(headers []string) {\n\tfor idx, header := range headers {\n\t\tkey, _, _ := strings.Cut(header, \":\")\n\t\tif strings.EqualFold(key, \"Authorization\") {\n\t\t\theaders[idx] = key + \": *\"\n\t\t}\n\t}\n}\n\n// source returns a space-trimmed slice of the n'th line.\nfunc source(lines [][]byte, n int) []byte {\n\tn-- // in stack trace, lines are 1-indexed but our array is 0-indexed\n\tif n < 0 || n >= len(lines) {\n\t\treturn dunnoBytes\n\t}\n\treturn bytes.TrimSpace(lines[n])\n}\n\n// function returns, if possible, the name of the function containing the PC.\nfunc function(pc uintptr) string {\n\tfn := runtime.FuncForPC(pc)\n\tif fn == nil {\n\t\treturn dunno\n\t}\n\tname := fn.Name()\n\t// The name includes the path name to the package, which is unnecessary\n\t// since the file name is already included.  Plus, it has center dots.\n\t// That is, we see\n\t//\truntime/debug.*T\u00b7ptrmethod\n\t// and want\n\t//\t*T.ptrmethod\n\t// Also the package path might contain dot (e.g. code.google.com/...),\n\t// so first eliminate the path prefix\n\tif lastSlash := strings.LastIndexByte(name, '/'); lastSlash >= 0 {\n\t\tname = name[lastSlash+1:]\n\t}\n\tif period := strings.IndexByte(name, '.'); period >= 0 {\n\t\tname = name[period+1:]\n\t}\n\tname = strings.ReplaceAll(name, \"\u00b7\", \".\")\n\treturn name\n}\n\n// timeFormat returns a customized time string for logger.\nfunc timeFormat(t time.Time) string {\n\treturn t.Format(\"2006/01/02 - 15:04:05\")\n}\n",
    "source_file": "recovery.go",
    "chunk_type": "code"
  },
  {
    "content": "module github.com/gin-gonic/gin\n\ngo 1.23.0\n\nrequire (\n\tgithub.com/bytedance/sonic v1.13.2\n\tgithub.com/gin-contrib/sse v1.1.0\n\tgithub.com/go-playground/validator/v10 v10.26.0\n\tgithub.com/goccy/go-json v0.10.2\n\tgithub.com/goccy/go-yaml v1.18.0\n\tgithub.com/json-iterator/go v1.1.12\n\tgithub.com/mattn/go-isatty v0.0.20\n\tgithub.com/modern-go/reflect2 v1.0.2\n\tgithub.com/pelletier/go-toml/v2 v2.2.4\n\tgithub.com/quic-go/quic-go v0.52.0\n\tgithub.com/stretchr/testify v1.10.0\n\tgithub.com/ugorji/go/codec v1.2.12\n\tgolang.org/x/net v0.41.0\n\tgoogle.golang.org/protobuf v1.36.6\n)\n\nrequire (\n\tgithub.com/bytedance/sonic/loader v0.2.4 // indirect\n\tgithub.com/cloudwego/base64x v0.1.5 // indirect\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/gabriel-vasile/mimetype v1.4.8 // indirect\n\tgithub.com/go-playground/locales v0.14.1 // indirect\n\tgithub.com/go-playground/universal-translator v0.18.1 // indirect\n\tgithub.com/go-task/slim-sprig v0.0.0-20230315185526-52ccab3ef572 // indirect\n\tgithub.com/google/pprof v0.0.0-20210407192527-94a9f03dee38 // indirect\n\tgithub.com/klauspost/cpuid/v2 v2.0.9 // indirect\n\tgithub.com/leodido/go-urn v1.4.0 // indirect\n\tgithub.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421 // indirect\n\tgithub.com/onsi/ginkgo/v2 v2.9.5 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/quic-go/qpack v0.5.1 // indirect\n\tgithub.com/twitchyliquid64/golang-asm v0.15.1 // indirect\n\tgo.uber.org/mock v0.5.0 // indirect\n\tgolang.org/x/arch v0.0.0-20210923205945-b76863e36670 // indirect\n\tgolang.org/x/crypto v0.39.0 // indirect\n\tgolang.org/x/mod v0.25.0 // indirect\n\tgolang.org/x/sync v0.15.0 // indirect\n\tgolang.org/x/sys v0.33.0 // indirect\n\tgolang.org/x/text v0.26.0 // indirect\n\tgolang.org/x/tools v0.33.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n",
    "source_file": "go.mod",
    "chunk_type": "unknown"
  },
  {
    "content": "// Copyright 2013 Julien Schmidt. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be found\n// at https://github.com/julienschmidt/httprouter/blob/master/LICENSE\n\npackage gin\n\nimport (\n\t\"bytes\"\n\t\"net/url\"\n\t\"strings\"\n\t\"unicode\"\n\t\"unicode/utf8\"\n\n\t\"github.com/gin-gonic/gin/internal/bytesconv\"\n)\n\nvar (\n\tstrColon = []byte(\":\")\n\tstrStar  = []byte(\"*\")\n\tstrSlash = []byte(\"/\")\n)\n\n// Param is a single URL parameter, consisting of a key and a value.\ntype Param struct {\n\tKey   string\n\tValue string\n}\n\n// Params is a Param-slice, as returned by the router.\n// The slice is ordered, the first URL parameter is also the first slice value.\n// It is therefore safe to read values by the index.\ntype Params []Param\n\n// Get returns the value of the first Param which key matches the given name and a boolean true.\n// If no matching Param is found, an empty string is returned and a boolean false .\nfunc (ps Params) Get(name string) (string, bool) {\n\tfor _, entry := range ps {\n\t\tif entry.Key == name {\n\t\t\treturn entry.Value, true\n\t\t}\n\t}\n\treturn \"\", false\n}\n\n// ByName returns the value of the first Param which key matches the given name.\n// If no matching Param is found, an empty string is returned.\nfunc (ps Params) ByName(name string) (va string) {\n\tva, _ = ps.Get(name)\n\treturn\n}\n\ntype methodTree struct {\n\tmethod string\n\troot   *node\n}\n\ntype methodTrees []methodTree\n\nfunc (trees methodTrees) get(method string) *node {\n\tfor _, tree := range trees {\n\t\tif tree.method == method {\n\t\t\treturn tree.root\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc longestCommonPrefix(a, b string) int {\n\ti := 0\n\tmax_ := min(len(a), len(b))\n\tfor i < max_ && a[i] == b[i] {\n\t\ti++\n\t}\n\treturn i\n}\n\n// addChild will add a child node, keeping wildcardChild at the end\nfunc (n *node) addChild(child *node) {\n\tif n.wildChild && len(n.children) > 0 {\n\t\twildcardChild := n.children[len(n.children)-1]\n\t\tn.children = append(n.children[:len(n.children)-1], child, wildcardChild)\n\t} else {\n\t\tn.children = append(n.children, child)\n\t}\n}\n\nfunc countParams(path string) uint16 {\n\tvar n uint16\n\ts := bytesconv.StringToBytes(path)\n\tn += uint16(bytes.Count(s, strColon))\n\tn += uint16(bytes.Count(s, strStar))\n\treturn n\n}\n\nfunc countSections(path string) uint16 {\n\ts := bytesconv.StringToBytes(path)\n\treturn uint16(bytes.Count(s, strSlash))\n}\n\ntype nodeType uint8\n\nconst (\n\tstatic nodeType = iota\n\troot\n\tparam\n\tcatchAll\n)\n\ntype node struct {\n\tpath      string\n\tindices   string\n\twildChild bool\n\tnType     nodeType\n\tpriority  uint32\n\tchildren  []*node // child nodes, at most 1 :param style node at the end of the array\n\thandlers  HandlersChain\n\tfullPath  string\n}\n\n// Increments priority of the given child and reorders if necessary\nfunc (n *node) incrementChildPrio(pos int) int {\n\tcs := n.children\n\tcs[pos].priority++\n\tprio := cs[pos].priority\n\n\t// Adjust position (move to front)\n\tnewPos := pos\n\tfor ; newPos > 0 && cs[newPos-1].priority < prio; newPos-- {\n\t\t// Swap node positions\n\t\tcs[newPos-1], cs[newPos] = cs[newPos], cs[newPos-1]\n\t}\n\n\t// Build new index char string\n\tif newPos != pos {\n\t\tn.indices = n.indices[:newPos] + // Unchanged prefix, might be empty\n\t\t\tn.indices[pos:pos+1] + // The index char we move\n\t\t\tn.indices[newPos:pos] + n.indices[pos+1:] // Rest without char at 'pos'\n\t}\n\n\treturn newPos\n}\n\n// addRoute adds a node with the given handle to the path.\n// Not concurrency-safe!\nfunc (n *node) addRoute(path string, handlers HandlersChain) {\n\tfullPath := path\n\tn.priority++\n\n\t// Empty tree\n\tif len(n.path) == 0 && len(n.children) == 0 {\n\t\tn.insertChild(path, fullPath, handlers)\n\t\tn.nType = root\n\t\treturn\n\t}\n\n\tparentFullPathIndex := 0\n\nwalk:\n\tfor {\n\t\t// Find the longest common prefix.\n\t\t// This also implies that the common prefix contains no ':' or '*'\n\t\t// since the existing key can't contain those chars.\n\t\ti := longestCommonPrefix(path, n.path)\n\n\t\t// Split edge\n\t\tif i < len(n.path) {\n\t\t\tchild := node{\n\t\t\t\tpath:      n.path[i:],\n\t\t\t\twildChild: n.wildChild,\n\t\t\t\tnType:     static,\n\t\t\t\tindices:   n.indices,\n\t\t\t\tchildren:  n.children,\n\t\t\t\thandlers:  n.handlers,\n\t\t\t\tpriority:  n.priority - 1,\n\t\t\t\tfullPath:  n.fullPath,\n\t\t\t}\n\n\t\t\tn.children = []*node{&child}\n\t\t\t// []byte for proper unicode char conversion, see #65\n\t\t\tn.indices = bytesconv.BytesToString([]byte{n.path[i]})\n\t\t\tn.path = path[:i]\n\t\t\tn.handlers = nil\n\t\t\tn.wildChild = false\n\t\t\tn.fullPath = fullPath[:parentFullPathIndex+i]\n\t\t}\n\n\t\t// Make new node a child of this node\n\t\tif i < len(path) {\n\t\t\tpath = path[i:]\n\t\t\tc := path[0]\n\n\t\t\t// '/' after param\n\t\t\tif n.nType == param && c == '/' && len(n.children) == 1 {\n\t\t\t\tparentFullPathIndex += len(n.path)\n\t\t\t\tn = n.children[0]\n\t\t\t\tn.priority++\n\t\t\t\tcontinue walk\n\t\t\t}\n\n\t\t\t// Check if a child with the next path byte exists\n\t\t\tfor i, max_ := 0, len(n.indices); i < max_; i++ {\n\t\t\t\tif c == n.indices[i] {\n\t\t\t\t\tparentFullPathIndex += len(n.path)\n\t\t\t\t\ti = n.incrementChildPrio(i)\n\t\t\t\t\tn = n.children[i]\n\t\t\t\t\tcontinue walk\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Otherwise insert it\n\t\t\tif c != ':' && c != '*' && n.nType != catchAll {\n\t\t\t\t// []byte for proper unicode char conversion, see #65\n\t\t\t\tn.indices += bytesconv.BytesToString([]byte{c})\n\t\t\t\tchild := &node{\n\t\t\t\t\tfullPath: fullPath,\n\t\t\t\t}\n\t\t\t\tn.addChild(child)\n\t\t\t\tn.incrementChildPrio(len(n.indices) - 1)\n\t\t\t\tn = child\n\t\t\t} else if n.wildChild {\n\t\t\t\t// inserting a wildcard node, need to check if it conflicts with the existing wildcard\n\t\t\t\tn = n.children[len(n.children)-1]\n\t\t\t\tn.priority++\n\n\t\t\t\t// Check if the wildcard matches\n\t\t\t\tif len(path) >= len(n.path) && n.path == path[:len(n.path)] &&\n\t\t\t\t\t// Adding a child to a catchAll is not possible\n\t\t\t\t\tn.nType != catchAll &&\n\t\t\t\t\t// Check for longer wildcard, e.g. :name and :names\n\t\t\t\t\t(len(n.path) >= len(path) || path[len(n.path)] == '/') {\n\t\t\t\t\tcontinue walk\n\t\t\t\t}\n\n\t\t\t\t// Wildcard conflict\n\t\t\t\tpathSeg := path\n\t\t\t\tif n.nType != catchAll {\n\t\t\t\t\tpathSeg, _, _ = strings.Cut(pathSeg, \"/\")\n\t\t\t\t}\n\t\t\t\tprefix := fullPath[:strings.Index(fullPath, pathSeg)] + n.path\n\t\t\t\tpanic(\"'\" + pathSeg +\n\t\t\t\t\t\"' in new path '\" + fullPath +\n\t\t\t\t\t\"' conflicts with existing wildcard '\" + n.path +\n\t\t\t\t\t\"' in existing prefix '\" + prefix +\n\t\t\t\t\t\"'\")\n\t\t\t}\n\n\t\t\tn.insertChild(path, fullPath, handlers)\n\t\t\treturn\n\t\t}\n\n\t\t// Otherwise add handle to current node\n\t\tif n.handlers != nil {\n\t\t\tpanic(\"handlers are already registered for path '\" + fullPath + \"'\")\n\t\t}\n\t\tn.handlers = handlers\n\t\tn.fullPath = fullPath\n\t\treturn\n\t}\n}\n\n// Search for a wildcard segment and check the name for invalid characters.\n// Returns -1 as index, if no wildcard was found.\nfunc findWildcard(path string) (wildcard string, i int, valid bool) {\n\t// Find start\n\tescapeColon := false\n\tfor start, c := range []byte(path) {\n\t\tif escapeColon {\n\t\t\tescapeColon = false\n\t\t\tif c == ':' {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tpanic(\"invalid escape string in path '\" + path + \"'\")\n\t\t}\n\t\tif c == '\\\\' {\n\t\t\tescapeColon = true\n\t\t\tcontinue\n\t\t}\n\t\t// A wildcard starts with ':' (param) or '*' (catch-all)\n\t\tif c != ':' && c != '*' {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Find end and check for invalid characters\n\t\tvalid = true\n\t\tfor end, c := range []byte(path[start+1:]) {\n\t\t\tswitch c {\n\t\t\tcase '/':\n\t\t\t\treturn path[start : start+1+end], start, valid\n\t\t\tcase ':', '*':\n\t\t\t\tvalid = false\n\t\t\t}\n\t\t}\n\t\treturn path[start:], start, valid\n\t}\n\treturn \"\", -1, false\n}\n\nfunc (n *node) insertChild(path string, fullPath string, handlers HandlersChain) {\n\tfor {\n\t\t// Find prefix until first wildcard\n\t\twildcard, i, valid := findWildcard(path)\n\t\tif i < 0 { // No wildcard found\n\t\t\tbreak\n\t\t}\n\n\t\t// The wildcard name must only contain one ':' or '*' character\n\t\tif !valid {\n\t\t\tpanic(\"only one wildcard per path segment is allowed, has: '\" +\n\t\t\t\twildcard + \"' in path '\" + fullPath + \"'\")\n\t\t}\n\n\t\t// check if the wildcard has a name\n\t\tif len(wildcard) < 2 {\n\t\t\tpanic(\"wildcards must be named with a non-empty name in path '\" + fullPath + \"'\")\n\t\t}\n\n\t\tif wildcard[0] == ':' { // param\n\t\t\tif i > 0 {\n\t\t\t\t// Insert prefix before the current wildcard\n\t\t\t\tn.path = path[:i]\n\t\t\t\tpath = path[i:]\n\t\t\t}\n\n\t\t\tchild := &node{\n\t\t\t\tnType:    param,\n\t\t\t\tpath:     wildcard,\n\t\t\t\tfullPath: fullPath,\n\t\t\t}\n\t\t\tn.addChild(child)\n\t\t\tn.wildChild = true\n\t\t\tn = child\n\t\t\tn.priority++\n\n\t\t\t// if the path doesn't end with the wildcard, then there\n\t\t\t// will be another subpath starting with '/'\n\t\t\tif len(wildcard) < len(path) {\n\t\t\t\tpath = path[len(wildcard):]\n\n\t\t\t\tchild := &node{\n\t\t\t\t\tpriority: 1,\n\t\t\t\t\tfullPath: fullPath,\n\t\t\t\t}\n\t\t\t\tn.addChild(child)\n\t\t\t\tn = child\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Otherwise we're done. Insert the handle in the new leaf\n\t\t\tn.handlers = handlers\n\t\t\treturn\n\t\t}\n\n\t\t// catchAll\n\t\tif i+len(wildcard) != len(path) {\n\t\t\tpanic(\"catch-all routes are only allowed at the end of the path in path '\" + fullPath + \"'\")\n\t\t}\n\n\t\tif len(n.path) > 0 && n.path[len(n.path)-1] == '/' {\n\t\t\tpathSeg := \"\"\n\t\t\tif len(n.children) != 0 {\n\t\t\t\tpathSeg, _, _ = strings.Cut(n.children[0].path, \"/\")\n\t\t\t}\n\t\t\tpanic(\"catch-all wildcard '\" + path +\n\t\t\t\t\"' in new path '\" + fullPath +\n\t\t\t\t\"' conflicts with existing path segment '\" + pathSeg +\n\t\t\t\t\"' in existing prefix '\" + n.path + pathSeg +\n\t\t\t\t\"'\")\n\t\t}\n\n\t\t// currently fixed width 1 for '/'\n\t\ti--\n\t\tif i < 0 || path[i] != '/' {\n\t\t\tpanic(\"no / before catch-all in path '\" + fullPath + \"'\")\n\t\t}\n\n\t\tn.path = path[:i]\n\n\t\t// First node: catchAll node with empty path\n\t\tchild := &node{\n\t\t\twildChild: true,\n\t\t\tnType:     catchAll,\n\t\t\tfullPath:  fullPath,\n\t\t}\n\n\t\tn.addChild(child)\n\t\tn.indices = string('/')\n\t\tn = child\n\t\tn.priority++\n\n\t\t// second node: node holding the variable\n\t\tchild = &node{\n\t\t\tpath:     path[i:],\n\t\t\tnType:    catchAll,\n\t\t\thandlers: handlers,\n\t\t\tpriority: 1,\n\t\t\tfullPath: fullPath,\n\t\t}\n\t\tn.children = []*node{child}\n\n\t\treturn\n\t}\n\n\t// If no wildcard was found, simply insert the path and handle\n\tn.path = path\n\tn.handlers = handlers\n\tn.fullPath = fullPath\n}\n\n// nodeValue holds return values of (*Node).getValue method\ntype nodeValue struct {\n\thandlers HandlersChain\n\tparams   *Params\n\ttsr      bool\n\tfullPath string\n}\n\ntype skippedNode struct {\n\tpath        string\n\tnode        *node\n\tparamsCount int16\n}\n\n// Returns the handle registered with the given path (key). The values of\n// wildcards are saved to a map.\n// If no handle can be found, a TSR (trailing slash redirect) recommendation is\n// made if a handle exists with an extra (without the) trailing slash for the\n// given path.\nfunc (n *node) getValue(path string, params *Params, skippedNodes *[]skippedNode, unescape bool) (value nodeValue) {\n\tvar globalParamsCount int16\n\nwalk: // Outer loop for walking the tree\n\tfor {\n\t\tprefix := n.path\n\t\tif len(path) > len(prefix) {\n\t\t\tif path[:len(prefix)] == prefix {\n\t\t\t\tpath = path[len(prefix):]\n\n\t\t\t\t// Try all the non-wildcard children first by matching the indices\n\t\t\t\tidxc := path[0]\n\t\t\t\tfor i, c := range []byte(n.indices) {\n\t\t\t\t\tif c == idxc {\n\t\t\t\t\t\t//  strings.HasPrefix(n.children[len(n.children)-1].path, \":\") == n.wildChild\n\t\t\t\t\t\tif n.wildChild {\n\t\t\t\t\t\t\tindex := len(*skippedNodes)\n\t\t\t\t\t\t\t*skippedNodes = (*skippedNodes)[:index+1]\n\t\t\t\t\t\t\t(*skippedNodes)[index] = skippedNode{\n\t\t\t\t\t\t\t\tpath: prefix + path,\n\t\t\t\t\t\t\t\tnode: &node{\n\t\t\t\t\t\t\t\t\tpath:      n.path,\n\t\t\t\t\t\t\t\t\twildChild: n.wildChild,\n\t\t\t\t\t\t\t\t\tnType:     n.nType,\n\t\t\t\t\t\t\t\t\tpriority:  n.priority,\n\t\t\t\t\t\t\t\t\tchildren:  n.children,\n\t\t\t\t\t\t\t\t\thandlers:  n.handlers,\n\t\t\t\t\t\t\t\t\tfullPath:  n.fullPath,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tparamsCount: globalParamsCount,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tn = n.children[i]\n\t\t\t\t\t\tcontinue walk\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif !n.wildChild {\n\t\t\t\t\t// If the path at the end of the loop is not equal to '/' and the current node has no child nodes\n\t\t\t\t\t// the current node needs to roll back to last valid skippedNode\n\t\t\t\t\tif path != \"/\" {\n\t\t\t\t\t\tfor length := len(*skippedNodes); length > 0; length-- {\n\t\t\t\t\t\t\tskippedNode := (*skippedNodes)[length-1]\n\t\t\t\t\t\t\t*skippedNodes = (*skippedNodes)[:length-1]\n\t\t\t\t\t\t\tif strings.HasSuffix(skippedNode.path, path) {\n\t\t\t\t\t\t\t\tpath = skippedNode.path\n\t\t\t\t\t\t\t\tn = skippedNode.node\n\t\t\t\t\t\t\t\tif value.params != nil {\n\t\t\t\t\t\t\t\t\t*value.params = (*value.params)[:skippedNode.paramsCount]\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tglobalParamsCount = skippedNode.paramsCount\n\t\t\t\t\t\t\t\tcontinue walk\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Nothing found.\n\t\t\t\t\t// We can recommend to redirect to the same URL without a\n\t\t\t\t\t// trailing slash if a leaf exists for that path.\n\t\t\t\t\tvalue.tsr = path == \"/\" && n.handlers != nil\n\t\t\t\t\treturn value\n\t\t\t\t}\n\n\t\t\t\t// Handle wildcard child, which is always at the end of the array\n\t\t\t\tn = n.children[len(n.children)-1]\n\t\t\t\tglobalParamsCount++\n\n\t\t\t\tswitch n.nType {\n\t\t\t\tcase param:\n\t\t\t\t\t// fix truncate the parameter\n\t\t\t\t\t// tree_test.go  line: 204\n\n\t\t\t\t\t// Find param end (either '/' or path end)\n\t\t\t\t\tend := 0\n\t\t\t\t\tfor end < len(path) && path[end] != '/' {\n\t\t\t\t\t\tend++\n\t\t\t\t\t}\n\n\t\t\t\t\t// Save param value\n\t\t\t\t\tif params != nil {\n\t\t\t\t\t\t// Preallocate capacity if necessary\n\t\t\t\t\t\tif cap(*params) < int(globalParamsCount) {\n\t\t\t\t\t\t\tnewParams := make(Params, len(*params), globalParamsCount)\n\t\t\t\t\t\t\tcopy(newParams, *params)\n\t\t\t\t\t\t\t*params = newParams\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif value.params == nil {\n\t\t\t\t\t\t\tvalue.params = params\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Expand slice within preallocated capacity\n\t\t\t\t\t\ti := len(*value.params)\n\t\t\t\t\t\t*value.params = (*value.params)[:i+1]\n\t\t\t\t\t\tval := path[:end]\n\t\t\t\t\t\tif unescape {\n\t\t\t\t\t\t\tif v, err := url.QueryUnescape(val); err == nil {\n\t\t\t\t\t\t\t\tval = v\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t(*value.params)[i] = Param{\n\t\t\t\t\t\t\tKey:   n.path[1:],\n\t\t\t\t\t\t\tValue: val,\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// we need to go deeper!\n\t\t\t\t\tif end < len(path) {\n\t\t\t\t\t\tif len(n.children) > 0 {\n\t\t\t\t\t\t\tpath = path[end:]\n\t\t\t\t\t\t\tn = n.children[0]\n\t\t\t\t\t\t\tcontinue walk\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// ... but we can't\n\t\t\t\t\t\tvalue.tsr = len(path) == end+1\n\t\t\t\t\t\treturn value\n\t\t\t\t\t}\n\n\t\t\t\t\tif value.handlers = n.handlers; value.handlers != nil {\n\t\t\t\t\t\tvalue.fullPath = n.fullPath\n\t\t\t\t\t\treturn value\n\t\t\t\t\t}\n\t\t\t\t\tif len(n.children) == 1 {\n\t\t\t\t\t\t// No handle found. Check if a handle for this path + a\n\t\t\t\t\t\t// trailing slash exists for TSR recommendation\n\t\t\t\t\t\tn = n.children[0]\n\t\t\t\t\t\tvalue.tsr = (n.path == \"/\" && n.handlers != nil) || (n.path == \"\" && n.indices == \"/\")\n\t\t\t\t\t}\n\t\t\t\t\treturn value\n\n\t\t\t\tcase catchAll:\n\t\t\t\t\t// Save param value\n\t\t\t\t\tif params != nil {\n\t\t\t\t\t\t// Preallocate capacity if necessary\n\t\t\t\t\t\tif cap(*params) < int(globalParamsCount) {\n\t\t\t\t\t\t\tnewParams := make(Params, len(*params), globalParamsCount)\n\t\t\t\t\t\t\tcopy(newParams, *params)\n\t\t\t\t\t\t\t*params = newParams\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif value.params == nil {\n\t\t\t\t\t\t\tvalue.params = params\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Expand slice within preallocated capacity\n\t\t\t\t\t\ti := len(*value.params)\n\t\t\t\t\t\t*value.params = (*value.params)[:i+1]\n\t\t\t\t\t\tval := path\n\t\t\t\t\t\tif unescape {\n\t\t\t\t\t\t\tif v, err := url.QueryUnescape(path); err == nil {\n\t\t\t\t\t\t\t\tval = v\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t(*value.params)[i] = Param{\n\t\t\t\t\t\t\tKey:   n.path[2:],\n\t\t\t\t\t\t\tValue: val,\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tvalue.handlers = n.handlers\n\t\t\t\t\tvalue.fullPath = n.fullPath\n\t\t\t\t\treturn value\n\n\t\t\t\tdefault:\n\t\t\t\t\tpanic(\"invalid node type\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif path == prefix {\n\t\t\t// If the current path does not equal '/' and the node does not have a registered handle and the most recently matched node has a child node\n\t\t\t// the current node needs to roll back to last valid skippedNode\n\t\t\tif n.handlers == nil && path != \"/\" {\n\t\t\t\tfor length := len(*skippedNodes); length > 0; length-- {\n\t\t\t\t\tskippedNode := (*skippedNodes)[length-1]\n\t\t\t\t\t*skippedNodes = (*skippedNodes)[:length-1]\n\t\t\t\t\tif strings.HasSuffix(skippedNode.path, path) {\n\t\t\t\t\t\tpath = skippedNode.path\n\t\t\t\t\t\tn = skippedNode.node\n\t\t\t\t\t\tif value.params != nil {\n\t\t\t\t\t\t\t*value.params = (*value.params)[:skippedNode.paramsCount]\n\t\t\t\t\t\t}\n\t\t\t\t\t\tglobalParamsCount = skippedNode.paramsCount\n\t\t\t\t\t\tcontinue walk\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//\tn = latestNode.children[len(latestNode.children)-1]\n\t\t\t}\n\t\t\t// We should have reached the node containing the handle.\n\t\t\t// Check if this node has a handle registered.\n\t\t\tif value.handlers = n.handlers; value.handlers != nil {\n\t\t\t\tvalue.fullPath = n.fullPath\n\t\t\t\treturn value\n\t\t\t}\n\n\t\t\t// If there is no handle for this route, but this route has a\n\t\t\t// wildcard child, there must be a handle for this path with an\n\t\t\t// additional trailing slash\n\t\t\tif path == \"/\" && n.wildChild && n.nType != root {\n\t\t\t\tvalue.tsr = true\n\t\t\t\treturn value\n\t\t\t}\n\n\t\t\tif path == \"/\" && n.nType == static {\n\t\t\t\tvalue.tsr = true\n\t\t\t\treturn value\n\t\t\t}\n\n\t\t\t// No handle found. Check if a handle for this path + a\n\t\t\t// trailing slash exists for trailing slash recommendation\n\t\t\tfor i, c := range []byte(n.indices) {\n\t\t\t\tif c == '/' {\n\t\t\t\t\tn = n.children[i]\n\t\t\t\t\tvalue.tsr = (len(n.path) == 1 && n.handlers != nil) ||\n\t\t\t\t\t\t(n.nType == catchAll && n.children[0].handlers != nil)\n\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn value\n\t\t}\n\n\t\t// Nothing found. We can recommend to redirect to the same URL with an\n\t\t// extra trailing slash if a leaf exists for that path\n\t\tvalue.tsr = path == \"/\" ||\n\t\t\t(len(prefix) == len(path)+1 && prefix[len(path)] == '/' &&\n\t\t\t\tpath == prefix[:len(prefix)-1] && n.handlers != nil)\n\n\t\t// roll back to last valid skippedNode\n\t\tif !value.tsr && path != \"/\" {\n\t\t\tfor length := len(*skippedNodes); length > 0; length-- {\n\t\t\t\tskippedNode := (*skippedNodes)[length-1]\n\t\t\t\t*skippedNodes = (*skippedNodes)[:length-1]\n\t\t\t\tif strings.HasSuffix(skippedNode.path, path) {\n\t\t\t\t\tpath = skippedNode.path\n\t\t\t\t\tn = skippedNode.node\n\t\t\t\t\tif value.params != nil {\n\t\t\t\t\t\t*value.params = (*value.params)[:skippedNode.paramsCount]\n\t\t\t\t\t}\n\t\t\t\t\tglobalParamsCount = skippedNode.paramsCount\n\t\t\t\t\tcontinue walk\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn value\n\t}\n}\n\n// Makes a case-insensitive lookup of the given path and tries to find a handler.\n// It can optionally also fix trailing slashes.\n// It returns the case-corrected path and a bool indicating whether the lookup\n// was successful.\nfunc (n *node) findCaseInsensitivePath(path string, fixTrailingSlash bool) ([]byte, bool) {\n\tconst stackBufSize = 128\n\n\t// Use a static sized buffer on the stack in the common case.\n\t// If the path is too long, allocate a buffer on the heap instead.\n\tbuf := make([]byte, 0, stackBufSize)\n\tif length := len(path) + 1; length > stackBufSize {\n\t\tbuf = make([]byte, 0, length)\n\t}\n\n\tciPath := n.findCaseInsensitivePathRec(\n\t\tpath,\n\t\tbuf,       // Preallocate enough memory for new path\n\t\t[4]byte{}, // Empty rune buffer\n\t\tfixTrailingSlash,\n\t)\n\n\treturn ciPath, ciPath != nil\n}\n\n// Shift bytes in array by n bytes left\nfunc shiftNRuneBytes(rb [4]byte, n int) [4]byte {\n\tswitch n {\n\tcase 0:\n\t\treturn rb\n\tcase 1:\n\t\treturn [4]byte{rb[1], rb[2], rb[3], 0}\n\tcase 2:\n\t\treturn [4]byte{rb[2], rb[3]}\n\tcase 3:\n\t\treturn [4]byte{rb[3]}\n\tdefault:\n\t\treturn [4]byte{}\n\t}\n}\n\n// Recursive case-insensitive lookup function used by n.findCaseInsensitivePath\nfunc (n *node) findCaseInsensitivePathRec(path string, ciPath []byte, rb [4]byte, fixTrailingSlash bool) []byte {\n\tnpLen := len(n.path)\n\nwalk: // Outer loop for walking the tree\n\tfor len(path) >= npLen && (npLen == 0 || strings.EqualFold(path[1:npLen], n.path[1:])) {\n\t\t// Add common prefix to result\n\t\toldPath := path\n\t\tpath = path[npLen:]\n\t\tciPath = append(ciPath, n.path...)\n\n\t\tif len(path) == 0 {\n\t\t\t// We should have reached the node containing the handle.\n\t\t\t// Check if this node has a handle registered.\n\t\t\tif n.handlers != nil {\n\t\t\t\treturn ciPath\n\t\t\t}\n\n\t\t\t// No handle found.\n\t\t\t// Try to fix the path by adding a trailing slash\n\t\t\tif fixTrailingSlash {\n\t\t\t\tfor i, c := range []byte(n.indices) {\n\t\t\t\t\tif c == '/' {\n\t\t\t\t\t\tn = n.children[i]\n\t\t\t\t\t\tif (len(n.path) == 1 && n.handlers != nil) ||\n\t\t\t\t\t\t\t(n.nType == catchAll && n.children[0].handlers != nil) {\n\t\t\t\t\t\t\treturn append(ciPath, '/')\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\t// If this node does not have a wildcard (param or catchAll) child,\n\t\t// we can just look up the next child node and continue to walk down\n\t\t// the tree\n\t\tif !n.wildChild {\n\t\t\t// Skip rune bytes already processed\n\t\t\trb = shiftNRuneBytes(rb, npLen)\n\n\t\t\tif rb[0] != 0 {\n\t\t\t\t// Old rune not finished\n\t\t\t\tidxc := rb[0]\n\t\t\t\tfor i, c := range []byte(n.indices) {\n\t\t\t\t\tif c == idxc {\n\t\t\t\t\t\t// continue with child node\n\t\t\t\t\t\tn = n.children[i]\n\t\t\t\t\t\tnpLen = len(n.path)\n\t\t\t\t\t\tcontinue walk\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Process a new rune\n\t\t\t\tvar rv rune\n\n\t\t\t\t// Find rune start.\n\t\t\t\t// Runes are up to 4 byte long,\n\t\t\t\t// -4 would definitely be another rune.\n\t\t\t\tvar off int\n\t\t\t\tfor max_ := min(npLen, 3); off < max_; off++ {\n\t\t\t\t\tif i := npLen - off; utf8.RuneStart(oldPath[i]) {\n\t\t\t\t\t\t// read rune from cached path\n\t\t\t\t\t\trv, _ = utf8.DecodeRuneInString(oldPath[i:])\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Calculate lowercase bytes of current rune\n\t\t\t\tlo := unicode.ToLower(rv)\n\t\t\t\tutf8.EncodeRune(rb[:], lo)\n\n\t\t\t\t// Skip already processed bytes\n\t\t\t\trb = shiftNRuneBytes(rb, off)\n\n\t\t\t\tidxc := rb[0]\n\t\t\t\tfor i, c := range []byte(n.indices) {\n\t\t\t\t\t// Lowercase matches\n\t\t\t\t\tif c == idxc {\n\t\t\t\t\t\t// must use a recursive approach since both the\n\t\t\t\t\t\t// uppercase byte and the lowercase byte might exist\n\t\t\t\t\t\t// as an index\n\t\t\t\t\t\tif out := n.children[i].findCaseInsensitivePathRec(\n\t\t\t\t\t\t\tpath, ciPath, rb, fixTrailingSlash,\n\t\t\t\t\t\t); out != nil {\n\t\t\t\t\t\t\treturn out\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If we found no match, the same for the uppercase rune,\n\t\t\t\t// if it differs\n\t\t\t\tif up := unicode.ToUpper(rv); up != lo {\n\t\t\t\t\tutf8.EncodeRune(rb[:], up)\n\t\t\t\t\trb = shiftNRuneBytes(rb, off)\n\n\t\t\t\t\tidxc := rb[0]\n\t\t\t\t\tfor i, c := range []byte(n.indices) {\n\t\t\t\t\t\t// Uppercase matches\n\t\t\t\t\t\tif c == idxc {\n\t\t\t\t\t\t\t// Continue with child node\n\t\t\t\t\t\t\tn = n.children[i]\n\t\t\t\t\t\t\tnpLen = len(n.path)\n\t\t\t\t\t\t\tcontinue walk\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Nothing found. We can recommend to redirect to the same URL\n\t\t\t// without a trailing slash if a leaf exists for that path\n\t\t\tif fixTrailingSlash && path == \"/\" && n.handlers != nil {\n\t\t\t\treturn ciPath\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\tn = n.children[0]\n\t\tswitch n.nType {\n\t\tcase param:\n\t\t\t// Find param end (either '/' or path end)\n\t\t\tend := 0\n\t\t\tfor end < len(path) && path[end] != '/' {\n\t\t\t\tend++\n\t\t\t}\n\n\t\t\t// Add param value to case insensitive path\n\t\t\tciPath = append(ciPath, path[:end]...)\n\n\t\t\t// We need to go deeper!\n\t\t\tif end < len(path) {\n\t\t\t\tif len(n.children) > 0 {\n\t\t\t\t\t// Continue with child node\n\t\t\t\t\tn = n.children[0]\n\t\t\t\t\tnpLen = len(n.path)\n\t\t\t\t\tpath = path[end:]\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\t// ... but we can't\n\t\t\t\tif fixTrailingSlash && len(path) == end+1 {\n\t\t\t\t\treturn ciPath\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tif n.handlers != nil {\n\t\t\t\treturn ciPath\n\t\t\t}\n\n\t\t\tif fixTrailingSlash && len(n.children) == 1 {\n\t\t\t\t// No handle found. Check if a handle for this path + a\n\t\t\t\t// trailing slash exists\n\t\t\t\tn = n.children[0]\n\t\t\t\tif n.path == \"/\" && n.handlers != nil {\n\t\t\t\t\treturn append(ciPath, '/')\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn nil\n\n\t\tcase catchAll:\n\t\t\treturn append(ciPath, path...)\n\n\t\tdefault:\n\t\t\tpanic(\"invalid node type\")\n\t\t}\n\t}\n\n\t// Nothing found.\n\t// Try to fix the path by adding / removing a trailing slash\n\tif fixTrailingSlash {\n\t\tif path == \"/\" {\n\t\t\treturn ciPath\n\t\t}\n\t\tif len(path)+1 == npLen && n.path[len(path)] == '/' &&\n\t\t\tstrings.EqualFold(path[1:], n.path[1:len(path)]) && n.handlers != nil {\n\t\t\treturn append(ciPath, n.path...)\n\t\t}\n\t}\n\treturn nil\n}\n",
    "source_file": "tree.go",
    "chunk_type": "code"
  },
  {
    "content": "The MIT License (MIT)\n\nCopyright (c) 2014 Manuel Mart\u00ednez-Almeida\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n",
    "source_file": "LICENSE",
    "chunk_type": "unknown"
  },
  {
    "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"crypto/subtle\"\n\t\"encoding/base64\"\n\t\"net/http\"\n\t\"strconv\"\n\n\t\"github.com/gin-gonic/gin/internal/bytesconv\"\n)\n\n// AuthUserKey is the cookie name for user credential in basic auth.\nconst AuthUserKey = \"user\"\n\n// AuthProxyUserKey is the cookie name for proxy_user credential in basic auth for proxy.\nconst AuthProxyUserKey = \"proxy_user\"\n\n// Accounts defines a key/value for user/pass list of authorized logins.\ntype Accounts map[string]string\n\ntype authPair struct {\n\tvalue string\n\tuser  string\n}\n\ntype authPairs []authPair\n\nfunc (a authPairs) searchCredential(authValue string) (string, bool) {\n\tif authValue == \"\" {\n\t\treturn \"\", false\n\t}\n\tfor _, pair := range a {\n\t\tif subtle.ConstantTimeCompare(bytesconv.StringToBytes(pair.value), bytesconv.StringToBytes(authValue)) == 1 {\n\t\t\treturn pair.user, true\n\t\t}\n\t}\n\treturn \"\", false\n}\n\n// BasicAuthForRealm returns a Basic HTTP Authorization middleware. It takes as arguments a map[string]string where\n// the key is the user name and the value is the password, as well as the name of the Realm.\n// If the realm is empty, \"Authorization Required\" will be used by default.\n// (see http://tools.ietf.org/html/rfc2617#section-1.2)\nfunc BasicAuthForRealm(accounts Accounts, realm string) HandlerFunc {\n\tif realm == \"\" {\n\t\trealm = \"Authorization Required\"\n\t}\n\trealm = \"Basic realm=\" + strconv.Quote(realm)\n\tpairs := processAccounts(accounts)\n\treturn func(c *Context) {\n\t\t// Search user in the slice of allowed credentials\n\t\tuser, found := pairs.searchCredential(c.requestHeader(\"Authorization\"))\n\t\tif !found {\n\t\t\t// Credentials doesn't match, we return 401 and abort handlers chain.\n\t\t\tc.Header(\"WWW-Authenticate\", realm)\n\t\t\tc.AbortWithStatus(http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// The user credentials was found, set user's id to key AuthUserKey in this context, the user's id can be read later using\n\t\t// c.MustGet(gin.AuthUserKey).\n\t\tc.Set(AuthUserKey, user)\n\t}\n}\n\n// BasicAuth returns a Basic HTTP Authorization middleware. It takes as argument a map[string]string where\n// the key is the user name and the value is the password.\nfunc BasicAuth(accounts Accounts) HandlerFunc {\n\treturn BasicAuthForRealm(accounts, \"\")\n}\n\nfunc processAccounts(accounts Accounts) authPairs {\n\tlength := len(accounts)\n\tassert1(length > 0, \"Empty list of authorized credentials\")\n\tpairs := make(authPairs, 0, length)\n\tfor user, password := range accounts {\n\t\tassert1(user != \"\", \"User can not be empty\")\n\t\tvalue := authorizationHeader(user, password)\n\t\tpairs = append(pairs, authPair{\n\t\t\tvalue: value,\n\t\t\tuser:  user,\n\t\t})\n\t}\n\treturn pairs\n}\n\nfunc authorizationHeader(user, password string) string {\n\tbase := user + \":\" + password\n\treturn \"Basic \" + base64.StdEncoding.EncodeToString(bytesconv.StringToBytes(base))\n}\n\n// BasicAuthForProxy returns a Basic HTTP Proxy-Authorization middleware.\n// If the realm is empty, \"Proxy Authorization Required\" will be used by default.\nfunc BasicAuthForProxy(accounts Accounts, realm string) HandlerFunc {\n\tif realm == \"\" {\n\t\trealm = \"Proxy Authorization Required\"\n\t}\n\trealm = \"Basic realm=\" + strconv.Quote(realm)\n\tpairs := processAccounts(accounts)\n\treturn func(c *Context) {\n\t\tproxyUser, found := pairs.searchCredential(c.requestHeader(\"Proxy-Authorization\"))\n\t\tif !found {\n\t\t\t// Credentials doesn't match, we return 407 and abort handlers chain.\n\t\t\tc.Header(\"Proxy-Authenticate\", realm)\n\t\t\tc.AbortWithStatus(http.StatusProxyAuthRequired)\n\t\t\treturn\n\t\t}\n\t\t// The proxy_user credentials was found, set proxy_user's id to key AuthProxyUserKey in this context, the proxy_user's id can be read later using\n\t\t// c.MustGet(gin.AuthProxyUserKey).\n\t\tc.Set(AuthProxyUserKey, proxyUser)\n\t}\n}\n",
    "source_file": "auth.go",
    "chunk_type": "code"
  },
  {
    "content": "GO ?= go\nGOFMT ?= gofmt \"-s\"\nGO_VERSION=$(shell $(GO) version | cut -c 14- | cut -d' ' -f1 | cut -d'.' -f2)\nPACKAGES ?= $(shell $(GO) list ./...)\nVETPACKAGES ?= $(shell $(GO) list ./... | grep -v /examples/)\nGOFILES := $(shell find . -name \"*.go\")\nTESTFOLDER := $(shell $(GO) list ./... | grep -E 'gin$$|binding$$|render$$' | grep -v examples)\nTESTTAGS ?= \"\"\n\n.PHONY: test\n# Run tests to verify code functionality.\ntest:\n\techo \"mode: count\" > coverage.out\n\tfor d in $(TESTFOLDER); do \\\n\t\t$(GO) test $(TESTTAGS) -v -covermode=count -coverprofile=profile.out $$d > tmp.out; \\\n\t\tcat tmp.out; \\\n\t\tif grep -q \"^--- FAIL\" tmp.out; then \\\n\t\t\trm tmp.out; \\\n\t\t\texit 1; \\\n\t\telif grep -q \"build failed\" tmp.out; then \\\n\t\t\trm tmp.out; \\\n\t\t\texit 1; \\\n\t\telif grep -q \"setup failed\" tmp.out; then \\\n\t\t\trm tmp.out; \\\n\t\t\texit 1; \\\n\t\tfi; \\\n\t\tif [ -f profile.out ]; then \\\n\t\t\tcat profile.out | grep -v \"mode:\" >> coverage.out; \\\n\t\t\trm profile.out; \\\n\t\tfi; \\\n\tdone\n\n.PHONY: fmt\n# Ensure consistent code formatting.\nfmt:\n\t$(GOFMT) -w $(GOFILES)\n\n.PHONY: fmt-check\n# format (check only).\nfmt-check:\n\t@diff=$$($(GOFMT) -d $(GOFILES)); \\\n\tif [ -n \"$$diff\" ]; then \\\n\t\techo \"Please run 'make fmt' and commit the result:\"; \\\n\t\techo \"$${diff}\"; \\\n\t\texit 1; \\\n\tfi;\n\n.PHONY: vet\n# Examine packages and report suspicious constructs if any.\nvet:\n\t$(GO) vet $(VETPACKAGES)\n\n.PHONY: lint\n# Inspect source code for stylistic errors or potential bugs.\nlint:\n\t@hash golint > /dev/null 2>&1; if [ $$? -ne 0 ]; then \\\n\t\t$(GO) get -u golang.org/x/lint/golint; \\\n\tfi\n\tfor PKG in $(PACKAGES); do golint -set_exit_status $$PKG || exit 1; done;\n\n.PHONY: misspell\n# Correct commonly misspelled English words in source code.\nmisspell:\n\t@hash misspell > /dev/null 2>&1; if [ $$? -ne 0 ]; then \\\n\t\t$(GO) get -u github.com/client9/misspell/cmd/misspell; \\\n\tfi\n\tmisspell -w $(GOFILES)\n\n.PHONY: misspell-check\n# misspell (check only).\nmisspell-check:\n\t@hash misspell > /dev/null 2>&1; if [ $$? -ne 0 ]; then \\\n\t\t$(GO) get -u github.com/client9/misspell/cmd/misspell; \\\n\tfi\n\tmisspell -error $(GOFILES)\n\n.PHONY: tools\n# Install tools (golint and misspell).\ntools:\n\t@if [ $(GO_VERSION) -gt 15 ]; then \\\n\t\t$(GO) install golang.org/x/lint/golint@latest; \\\n\t\t$(GO) install github.com/client9/misspell/cmd/misspell@latest; \\\n\telif [ $(GO_VERSION) -lt 16 ]; then \\\n\t\t$(GO) install golang.org/x/lint/golint; \\\n\t\t$(GO) install github.com/client9/misspell/cmd/misspell; \\\n\tfi\n\n.PHONY: help\n# Help.\nhelp:\n\t@echo ''\n\t@echo 'Usage:'\n\t@echo ' make [target]'\n\t@echo ''\n\t@echo 'Targets:'\n\t@awk '/^[a-zA-Z\\-\\0-9]+:/ { \\\n\thelpMessage = match(lastLine, /^# (.*)/); \\\n\t\tif (helpMessage) { \\\n\t\t\thelpCommand = substr($$1, 0, index($$1, \":\")-1); \\\n\t\t\thelpMessage = substr(lastLine, RSTART + 2, RLENGTH); \\\n\t\t\tprintf \" - \\033[36m%-20s\\033[0m %s\\n\", helpCommand, helpMessage; \\\n\t\t} \\\n\t} \\\n\t{ lastLine = $$0 }' $(MAKEFILE_LIST)\n\n.DEFAULT_GOAL := help\n",
    "source_file": "Makefile",
    "chunk_type": "unknown"
  },
  {
    "content": "",
    "source_file": "BENCHMARKS.md",
    "chunk_type": "doc"
  },
  {
    "content": "# Benchmark System\n\n**VM HOST:** Travis\n**Machine:** Ubuntu 16.04.6 LTS x64\n**Date:** May 04th, 2020\n**Version:** Gin v1.6.3\n**Go Version:** 1.14.2 linux/amd64\n**Source:** [Go HTTP Router Benchmark](https://github.com/gin-gonic/go-http-routing-benchmark)\n**Result:** [See the gist](https://gist.github.com/appleboy/b5f2ecfaf50824ae9c64dcfb9165ae5e) or [Travis result](https://travis-ci.org/github/gin-gonic/go-http-routing-benchmark/jobs/682947061)\n",
    "source_file": "BENCHMARKS.md",
    "chunk_type": "doc"
  },
  {
    "content": "## Static Routes: 157\n\n```sh\nGin: 34936 Bytes\n\nHttpServeMux: 14512 Bytes\nAce: 30680 Bytes\nAero: 34536 Bytes\nBear: 30456 Bytes\nBeego: 98456 Bytes\nBone: 40224 Bytes\nChi: 83608 Bytes\nDenco: 10216 Bytes\nEcho: 80328 Bytes\nGocraftWeb: 55288 Bytes\nGoji: 29744 Bytes\nGojiv2: 105840 Bytes\nGoJsonRest: 137496 Bytes\nGoRestful: 816936 Bytes\nGorillaMux: 585632 Bytes\nGowwwRouter: 24968 Bytes\nHttpRouter: 21712 Bytes\nHttpTreeMux: 73448 Bytes\nKocha: 115472 Bytes\nLARS: 30640 Bytes\nMacaron: 38592 Bytes\nMartini: 310864 Bytes\nPat: 19696 Bytes\nPossum: 89920 Bytes\nR2router: 23712 Bytes\nRivet: 24608 Bytes\nTango: 28264 Bytes\nTigerTonic: 78768 Bytes\nTraffic: 538976 Bytes\nVulcan: 369960 Bytes\n```\n",
    "source_file": "BENCHMARKS.md",
    "chunk_type": "doc"
  },
  {
    "content": "## GithubAPI Routes: 203\n\n```sh\nGin: 58512 Bytes\n\nAce: 48688 Bytes\nAero: 318568 Bytes\nBear: 84248 Bytes\nBeego: 150936 Bytes\nBone: 100976 Bytes\nChi: 95112 Bytes\nDenco: 36736 Bytes\nEcho: 100296 Bytes\nGocraftWeb: 95432 Bytes\nGoji: 49680 Bytes\nGojiv2: 104704 Bytes\nGoJsonRest: 141976 Bytes\nGoRestful: 1241656 Bytes\nGorillaMux: 1322784 Bytes\nGowwwRouter: 80008 Bytes\nHttpRouter: 37144 Bytes\nHttpTreeMux: 78800 Bytes\nKocha: 785120 Bytes\nLARS: 48600 Bytes\nMacaron: 92784 Bytes\nMartini: 485264 Bytes\nPat: 21200 Bytes\nPossum: 85312 Bytes\nR2router: 47104 Bytes\nRivet: 42840 Bytes\nTango: 54840 Bytes\nTigerTonic: 95264 Bytes\nTraffic: 921744 Bytes\nVulcan: 425992 Bytes\n```\n",
    "source_file": "BENCHMARKS.md",
    "chunk_type": "doc"
  },
  {
    "content": "## GPlusAPI Routes: 13\n\n```sh\nGin: 4384 Bytes\n\nAce: 3712 Bytes\nAero: 26056 Bytes\nBear: 7112 Bytes\nBeego: 10272 Bytes\nBone: 6688 Bytes\nChi: 8024 Bytes\nDenco: 3264 Bytes\nEcho: 9688 Bytes\nGocraftWeb: 7496 Bytes\nGoji: 3152 Bytes\nGojiv2: 7376 Bytes\nGoJsonRest: 11400 Bytes\nGoRestful: 74328 Bytes\nGorillaMux: 66208 Bytes\nGowwwRouter: 5744 Bytes\nHttpRouter: 2808 Bytes\nHttpTreeMux: 7440 Bytes\nKocha: 128880 Bytes\nLARS: 3656 Bytes\nMacaron: 8656 Bytes\nMartini: 23920 Bytes\nPat: 1856 Bytes\nPossum: 7248 Bytes\nR2router: 3928 Bytes\nRivet: 3064 Bytes\nTango: 5168 Bytes\nTigerTonic: 9408 Bytes\nTraffic: 46400 Bytes\nVulcan: 25544 Bytes\n```\n",
    "source_file": "BENCHMARKS.md",
    "chunk_type": "doc"
  },
  {
    "content": "## ParseAPI Routes: 26\n\n```sh\nGin: 7776 Bytes\n\nAce: 6704 Bytes\nAero: 28488 Bytes\nBear: 12320 Bytes\nBeego: 19280 Bytes\nBone: 11440 Bytes\nChi: 9744 Bytes\nDenco: 4192 Bytes\nEcho: 11664 Bytes\nGocraftWeb: 12800 Bytes\nGoji: 5680 Bytes\nGojiv2: 14464 Bytes\nGoJsonRest: 14072 Bytes\nGoRestful: 116264 Bytes\nGorillaMux: 105880 Bytes\nGowwwRouter: 9344 Bytes\nHttpRouter: 5072 Bytes\nHttpTreeMux: 7848 Bytes\nKocha: 181712 Bytes\nLARS: 6632 Bytes\nMacaron: 13648 Bytes\nMartini: 45888 Bytes\nPat: 2560 Bytes\nPossum: 9200 Bytes\nR2router: 7056 Bytes\nRivet: 5680 Bytes\nTango: 8920 Bytes\nTigerTonic: 9840 Bytes\nTraffic: 79096 Bytes\nVulcan: 44504 Bytes\n```\n",
    "source_file": "BENCHMARKS.md",
    "chunk_type": "doc"
  },
  {
    "content": "## Static Routes\n\n```sh\nBenchmarkGin_StaticAll                   62169         19319 ns/op           0 B/op           0 allocs/op\n\nBenchmarkAce_StaticAll                   65428         18313 ns/op           0 B/op           0 allocs/op\nBenchmarkAero_StaticAll                 121132          9632 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpServeMux_StaticAll          52626         22758 ns/op           0 B/op           0 allocs/op\nBenchmarkBeego_StaticAll                  9962        179058 ns/op       55264 B/op         471 allocs/op\nBenchmarkBear_StaticAll                  14894         80966 ns/op       20272 B/op         469 allocs/op\nBenchmarkBone_StaticAll                  18718         64065 ns/op           0 B/op           0 allocs/op\nBenchmarkChi_StaticAll                   10000        149827 ns/op       67824 B/op         471 allocs/op\nBenchmarkDenco_StaticAll                211393          5680 ns/op           0 B/op           0 allocs/op\nBenchmarkEcho_StaticAll                  49341         24343 ns/op           0 B/op           0 allocs/op\nBenchmarkGocraftWeb_StaticAll            10000        126209 ns/op       46312 B/op         785 allocs/op\nBenchmarkGoji_StaticAll                  27956         43174 ns/op           0 B/op           0 allocs/op\nBenchmarkGojiv2_StaticAll                 3430        370718 ns/op      205984 B/op        1570 allocs/op\nBenchmarkGoJsonRest_StaticAll             9134        188888 ns/op       51653 B/op        1727 allocs/op\nBenchmarkGoRestful_StaticAll               706       1703330 ns/op      613280 B/op        2053 allocs/op\nBenchmarkGorillaMux_StaticAll             1268        924083 ns/op      153233 B/op        1413 allocs/op\nBenchmarkGowwwRouter_StaticAll           63374         18935 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpRouter_StaticAll           109938         10902 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpTreeMux_StaticAll          109166         10861 ns/op           0 B/op           0 allocs/op\nBenchmarkKocha_StaticAll                 92258         12992 ns/op           0 B/op           0 allocs/op\nBenchmarkLARS_StaticAll                  65200         18387 ns/op           0 B/op           0 allocs/op\nBenchmarkMacaron_StaticAll                5671        291501 ns/op      115553 B/op        1256 allocs/op\nBenchmarkMartini_StaticAll                 807       1460498 ns/op      125444 B/op        1717 allocs/op\nBenchmarkPat_StaticAll                     513       2342396 ns/op      602832 B/op       12559 allocs/op\nBenchmarkPossum_StaticAll                10000        128270 ns/op       65312 B/op         471 allocs/op\nBenchmarkR2router_StaticAll              16726         71760 ns/op       22608 B/op         628 allocs/op\nBenchmarkRivet_StaticAll                 41722         28723 ns/op           0 B/op           0 allocs/op\nBenchmarkTango_StaticAll                  7606        205082 ns/op       39209 B/op        1256 allocs/op\nBenchmarkTigerTonic_StaticAll            26247         45806 ns/op        7376 B/op         157 allocs/op\nBenchmarkTraffic_StaticAll                 550       2284518 ns/op      754864 B/op       14601 allocs/op\nBenchmarkVulcan_StaticAll                10000        131343 ns/op       15386 B/op         471 allocs/op\n```\n",
    "source_file": "BENCHMARKS.md",
    "chunk_type": "doc"
  },
  {
    "content": "## Micro Benchmarks\n\n```sh\nBenchmarkGin_Param                    18785022          63.9 ns/op           0 B/op           0 allocs/op\n\nBenchmarkAce_Param                    14689765          81.5 ns/op           0 B/op           0 allocs/op\nBenchmarkAero_Param                   23094770          51.2 ns/op           0 B/op           0 allocs/op\nBenchmarkBear_Param                    1417045           845 ns/op         456 B/op           5 allocs/op\nBenchmarkBeego_Param                   1000000          1080 ns/op         352 B/op           3 allocs/op\nBenchmarkBone_Param                    1000000          1463 ns/op         816 B/op           6 allocs/op\nBenchmarkChi_Param                     1378756           885 ns/op         432 B/op           3 allocs/op\nBenchmarkDenco_Param                   8557899           143 ns/op          32 B/op           1 allocs/op\nBenchmarkEcho_Param                   16433347          75.5 ns/op           0 B/op           0 allocs/op\nBenchmarkGocraftWeb_Param              1000000          1218 ns/op         648 B/op           8 allocs/op\nBenchmarkGoji_Param                    1921248           617 ns/op         336 B/op           2 allocs/op\nBenchmarkGojiv2_Param                   561848          2156 ns/op        1328 B/op          11 allocs/op\nBenchmarkGoJsonRest_Param              1000000          1358 ns/op         649 B/op          13 allocs/op\nBenchmarkGoRestful_Param                224857          5307 ns/op        4192 B/op          14 allocs/op\nBenchmarkGorillaMux_Param               498313          2459 ns/op        1280 B/op          10 allocs/op\nBenchmarkGowwwRouter_Param             1864354           654 ns/op         432 B/op           3 allocs/op\nBenchmarkHttpRouter_Param             26269074          47.7 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpTreeMux_Param             2109829           557 ns/op         352 B/op           3 allocs/op\nBenchmarkKocha_Param                   5050216           243 ns/op          56 B/op           3 allocs/op\nBenchmarkLARS_Param                   19811712          59.9 ns/op           0 B/op           0 allocs/op\nBenchmarkMacaron_Param                  662746          2329 ns/op        1072 B/op          10 allocs/op\nBenchmarkMartini_Param                  279902          4260 ns/op        1072 B/op          10 allocs/op\nBenchmarkPat_Param                     1000000          1382 ns/op         536 B/op          11 allocs/op\nBenchmarkPossum_Param                  1000000          1014 ns/op         496 B/op           5 allocs/op\nBenchmarkR2router_Param                1712559           707 ns/op         432 B/op           5 allocs/op\nBenchmarkRivet_Param                   6648086           182 ns/op          48 B/op           1 allocs/op\nBenchmarkTango_Param                   1221504           994 ns/op         248 B/op           8 allocs/op\nBenchmarkTigerTonic_Param               891661          2261 ns/op         776 B/op          16 allocs/op\nBenchmarkTraffic_Param                  350059          3598 ns/op        1856 B/op          21 allocs/op\nBenchmarkVulcan_Param                  2517823           472 ns/op          98 B/op           3 allocs/op\nBenchmarkAce_Param5                    9214365           130 ns/op           0 B/op           0 allocs/op\nBenchmarkAero_Param5                  15369013          77.9 ns/op           0 B/op           0 allocs/op\nBenchmarkBear_Param5                   1000000          1113 ns/op         501 B/op           5 allocs/op\nBenchmarkBeego_Param5                  1000000          1269 ns/op         352 B/op           3 allocs/op\nBenchmarkBone_Param5                    986820          1873 ns/op         864 B/op           6 allocs/op\nBenchmarkChi_Param5                    1000000          1156 ns/op         432 B/op           3 allocs/op\nBenchmarkDenco_Param5                  3036331           400 ns/op         160 B/op           1 allocs/op\nBenchmarkEcho_Param5                   6447133           186 ns/op           0 B/op           0 allocs/op\nBenchmarkGin_Param5                   10786068           110 ns/op           0 B/op           0 allocs/op\nBenchmarkGocraftWeb_Param5              844820          1944 ns/op         920 B/op          11 allocs/op\nBenchmarkGoji_Param5                   1474965           827 ns/op         336 B/op           2 allocs/op\nBenchmarkGojiv2_Param5                  442820          2516 ns/op        1392 B/op          11 allocs/op\nBenchmarkGoJsonRest_Param5              507555          2711 ns/op        1097 B/op          16 allocs/op\nBenchmarkGoRestful_Param5               216481          6093 ns/op        4288 B/op          14 allocs/op\nBenchmarkGorillaMux_Param5              314402          3628 ns/op        1344 B/op          10 allocs/op\nBenchmarkGowwwRouter_Param5            1624660           733 ns/op         432 B/op           3 allocs/op\nBenchmarkHttpRouter_Param5            13167324          92.0 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpTreeMux_Param5            1000000          1295 ns/op         576 B/op           6 allocs/op\nBenchmarkKocha_Param5                  1000000          1138 ns/op         440 B/op          10 allocs/op\nBenchmarkLARS_Param5                  11580613           105 ns/op           0 B/op           0 allocs/op\nBenchmarkMacaron_Param5                 473596          2755 ns/op        1072 B/op          10 allocs/op\nBenchmarkMartini_Param5                 230756          5111 ns/op        1232 B/op          11 allocs/op\nBenchmarkPat_Param5                     469190          3370 ns/op         888 B/op          29 allocs/op\nBenchmarkPossum_Param5                 1000000          1002 ns/op         496 B/op           5 allocs/op\nBenchmarkR2router_Param5               1422129           844 ns/op         432 B/op           5 allocs/op\nBenchmarkRivet_Param5                  2263789           539 ns/op         240 B/op           1 allocs/op\nBenchmarkTango_Param5                  1000000          1256 ns/op         360 B/op           8 allocs/op\nBenchmarkTigerTonic_Param5              175500          7492 ns/op        2279 B/op          39 allocs/op\nBenchmarkTraffic_Param5                 233631          5816 ns/op        2208 B/op          27 allocs/op\nBenchmarkVulcan_Param5                 1923416           629 ns/op          98 B/op           3 allocs/op\nBenchmarkAce_Param20                   4321266           281 ns/op           0 B/op           0 allocs/op\nBenchmarkAero_Param20                 31501641          35.2 ns/op           0 B/op           0 allocs/op\nBenchmarkBear_Param20                   335204          3489 ns/op        1665 B/op           5 allocs/op\nBenchmarkBeego_Param20                  503674          2860 ns/op         352 B/op           3 allocs/op\nBenchmarkBone_Param20                   298922          4741 ns/op        2031 B/op           6 allocs/op\nBenchmarkChi_Param20                    878181          1957 ns/op         432 B/op           3 allocs/op\nBenchmarkDenco_Param20                 1000000          1360 ns/op         640 B/op           1 allocs/op\nBenchmarkEcho_Param20                  2104946           580 ns/op           0 B/op           0 allocs/op\nBenchmarkGin_Param20                   4167204           290 ns/op           0 B/op           0 allocs/op\nBenchmarkGocraftWeb_Param20             173064          7514 ns/op        3796 B/op          15 allocs/op\nBenchmarkGoji_Param20                   458778          2651 ns/op        1247 B/op           2 allocs/op\nBenchmarkGojiv2_Param20                 364862          3178 ns/op        1632 B/op          11 allocs/op\nBenchmarkGoJsonRest_Param20             125514          9760 ns/op        4485 B/op          20 allocs/op\nBenchmarkGoRestful_Param20              101217         11964 ns/op        6715 B/op          18 allocs/op\nBenchmarkGorillaMux_Param20             147654          8132 ns/op        3452 B/op          12 allocs/op\nBenchmarkGowwwRouter_Param20           1000000          1225 ns/op         432 B/op           3 allocs/op\nBenchmarkHttpRouter_Param20            4920895           247 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpTreeMux_Param20            173202          6605 ns/op        3196 B/op          10 allocs/op\nBenchmarkKocha_Param20                  345988          3620 ns/op        1808 B/op          27 allocs/op\nBenchmarkLARS_Param20                  4592326           262 ns/op           0 B/op           0 allocs/op\nBenchmarkMacaron_Param20                166492          7286 ns/op        2924 B/op          12 allocs/op\nBenchmarkMartini_Param20                122162         10653 ns/op        3595 B/op          13 allocs/op\nBenchmarkPat_Param20                     78630         15239 ns/op        4424 B/op          93 allocs/op\nBenchmarkPossum_Param20                1000000          1008 ns/op         496 B/op           5 allocs/op\nBenchmarkR2router_Param20               294981          4587 ns/op        2284 B/op           7 allocs/op\nBenchmarkRivet_Param20                  691798          2090 ns/op        1024 B/op           1 allocs/op\nBenchmarkTango_Param20                  842440          2505 ns/op         856 B/op           8 allocs/op\nBenchmarkTigerTonic_Param20              38614         31509 ns/op        9870 B/op         119 allocs/op\nBenchmarkTraffic_Param20                 57633         21107 ns/op        7853 B/op          47 allocs/op\nBenchmarkVulcan_Param20                1000000          1178 ns/op          98 B/op           3 allocs/op\nBenchmarkAce_ParamWrite                7330743           180 ns/op           8 B/op           1 allocs/op\nBenchmarkAero_ParamWrite              13833598          86.7 ns/op           0 B/op           0 allocs/op\nBenchmarkBear_ParamWrite               1363321           867 ns/op         456 B/op           5 allocs/op\nBenchmarkBeego_ParamWrite              1000000          1104 ns/op         360 B/op           4 allocs/op\nBenchmarkBone_ParamWrite               1000000          1475 ns/op         816 B/op           6 allocs/op\nBenchmarkChi_ParamWrite                1320590           892 ns/op         432 B/op           3 allocs/op\nBenchmarkDenco_ParamWrite              7093605           172 ns/op          32 B/op           1 allocs/op\nBenchmarkEcho_ParamWrite               8434424           161 ns/op           8 B/op           1 allocs/op\nBenchmarkGin_ParamWrite               10377034           118 ns/op           0 B/op           0 allocs/op\nBenchmarkGocraftWeb_ParamWrite         1000000          1266 ns/op         656 B/op           9 allocs/op\nBenchmarkGoji_ParamWrite               1874168           654 ns/op         336 B/op           2 allocs/op\nBenchmarkGojiv2_ParamWrite              459032          2352 ns/op        1360 B/op          13 allocs/op\nBenchmarkGoJsonRest_ParamWrite          499434          2145 ns/op        1128 B/op          18 allocs/op\nBenchmarkGoRestful_ParamWrite           241087          5470 ns/op        4200 B/op          15 allocs/op\nBenchmarkGorillaMux_ParamWrite          425686          2522 ns/op        1280 B/op          10 allocs/op\nBenchmarkGowwwRouter_ParamWrite         922172          1778 ns/op         976 B/op           8 allocs/op\nBenchmarkHttpRouter_ParamWrite        15392049          77.7 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpTreeMux_ParamWrite        1973385           597 ns/op         352 B/op           3 allocs/op\nBenchmarkKocha_ParamWrite              4262500           281 ns/op          56 B/op           3 allocs/op\nBenchmarkLARS_ParamWrite              10764410           113 ns/op           0 B/op           0 allocs/op\nBenchmarkMacaron_ParamWrite             486769          2726 ns/op        1176 B/op          14 allocs/op\nBenchmarkMartini_ParamWrite             264804          4842 ns/op        1176 B/op          14 allocs/op\nBenchmarkPat_ParamWrite                 735116          2047 ns/op         960 B/op          15 allocs/op\nBenchmarkPossum_ParamWrite             1000000          1004 ns/op         496 B/op           5 allocs/op\nBenchmarkR2router_ParamWrite           1592136           768 ns/op         432 B/op           5 allocs/op\nBenchmarkRivet_ParamWrite              3582051           339 ns/op         112 B/op           2 allocs/op\nBenchmarkTango_ParamWrite              2237337           534 ns/op         136 B/op           4 allocs/op\nBenchmarkTigerTonic_ParamWrite          439608          3136 ns/op        1216 B/op          21 allocs/op\nBenchmarkTraffic_ParamWrite             306979          4328 ns/op        2280 B/op          25 allocs/op\nBenchmarkVulcan_ParamWrite             2529973           472 ns/op          98 B/op           3 allocs/op\n```\n",
    "source_file": "BENCHMARKS.md",
    "chunk_type": "doc"
  },
  {
    "content": "## GitHub\n\n```sh\nBenchmarkGin_GithubStatic             15629472          76.7 ns/op           0 B/op           0 allocs/op\n\nBenchmarkAce_GithubStatic             15542612          75.9 ns/op           0 B/op           0 allocs/op\nBenchmarkAero_GithubStatic            24777151          48.5 ns/op           0 B/op           0 allocs/op\nBenchmarkBear_GithubStatic             2788894           435 ns/op         120 B/op           3 allocs/op\nBenchmarkBeego_GithubStatic            1000000          1064 ns/op         352 B/op           3 allocs/op\nBenchmarkBone_GithubStatic               93507         12838 ns/op        2880 B/op          60 allocs/op\nBenchmarkChi_GithubStatic              1387743           860 ns/op         432 B/op           3 allocs/op\nBenchmarkDenco_GithubStatic           39384996          30.4 ns/op           0 B/op           0 allocs/op\nBenchmarkEcho_GithubStatic            12076382          99.1 ns/op           0 B/op           0 allocs/op\nBenchmarkGocraftWeb_GithubStatic       1596495           756 ns/op         296 B/op           5 allocs/op\nBenchmarkGoji_GithubStatic             6364876           189 ns/op           0 B/op           0 allocs/op\nBenchmarkGojiv2_GithubStatic            550202          2098 ns/op        1312 B/op          10 allocs/op\nBenchmarkGoRestful_GithubStatic         102183         12552 ns/op        4256 B/op          13 allocs/op\nBenchmarkGoJsonRest_GithubStatic       1000000          1029 ns/op         329 B/op          11 allocs/op\nBenchmarkGorillaMux_GithubStatic        255552          5190 ns/op         976 B/op           9 allocs/op\nBenchmarkGowwwRouter_GithubStatic     15531916          77.1 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpRouter_GithubStatic      27920724          43.1 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpTreeMux_GithubStatic     21448953          55.8 ns/op           0 B/op           0 allocs/op\nBenchmarkKocha_GithubStatic           21405310          56.0 ns/op           0 B/op           0 allocs/op\nBenchmarkLARS_GithubStatic            13625156          89.0 ns/op           0 B/op           0 allocs/op\nBenchmarkMacaron_GithubStatic          1000000          1747 ns/op         736 B/op           8 allocs/op\nBenchmarkMartini_GithubStatic           187186          7326 ns/op         768 B/op           9 allocs/op\nBenchmarkPat_GithubStatic               109143         11563 ns/op        3648 B/op          76 allocs/op\nBenchmarkPossum_GithubStatic           1575898           770 ns/op         416 B/op           3 allocs/op\nBenchmarkR2router_GithubStatic         3046231           404 ns/op         144 B/op           4 allocs/op\nBenchmarkRivet_GithubStatic           11484826           105 ns/op           0 B/op           0 allocs/op\nBenchmarkTango_GithubStatic            1000000          1153 ns/op         248 B/op           8 allocs/op\nBenchmarkTigerTonic_GithubStatic       4929780           249 ns/op          48 B/op           1 allocs/op\nBenchmarkTraffic_GithubStatic           106351         11819 ns/op        4664 B/op          90 allocs/op\nBenchmarkVulcan_GithubStatic           1613271           722 ns/op          98 B/op           3 allocs/op\nBenchmarkAce_GithubParam               8386032           143 ns/op           0 B/op           0 allocs/op\nBenchmarkAero_GithubParam             11816200           102 ns/op           0 B/op           0 allocs/op\nBenchmarkBear_GithubParam              1000000          1012 ns/op         496 B/op           5 allocs/op\nBenchmarkBeego_GithubParam             1000000          1157 ns/op         352 B/op           3 allocs/op\nBenchmarkBone_GithubParam               184653          6912 ns/op        1888 B/op          19 allocs/op\nBenchmarkChi_GithubParam               1000000          1102 ns/op         432 B/op           3 allocs/op\nBenchmarkDenco_GithubParam             3484798           352 ns/op         128 B/op           1 allocs/op\nBenchmarkEcho_GithubParam              6337380           189 ns/op           0 B/op           0 allocs/op\nBenchmarkGin_GithubParam               9132032           131 ns/op           0 B/op           0 allocs/op\nBenchmarkGocraftWeb_GithubParam        1000000          1446 ns/op         712 B/op           9 allocs/op\nBenchmarkGoji_GithubParam              1248640           977 ns/op         336 B/op           2 allocs/op\nBenchmarkGojiv2_GithubParam             383233          2784 ns/op        1408 B/op          13 allocs/op\nBenchmarkGoJsonRest_GithubParam        1000000          1991 ns/op         713 B/op          14 allocs/op\nBenchmarkGoRestful_GithubParam           76414         16015 ns/op        4352 B/op          16 allocs/op\nBenchmarkGorillaMux_GithubParam         150026          7663 ns/op        1296 B/op          10 allocs/op\nBenchmarkGowwwRouter_GithubParam       1592044           751 ns/op         432 B/op           3 allocs/op\nBenchmarkHttpRouter_GithubParam       10420628           115 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpTreeMux_GithubParam       1403755           835 ns/op         384 B/op           4 allocs/op\nBenchmarkKocha_GithubParam             2286170           533 ns/op         128 B/op           5 allocs/op\nBenchmarkLARS_GithubParam              9540374           129 ns/op           0 B/op           0 allocs/op\nBenchmarkMacaron_GithubParam            533154          2742 ns/op        1072 B/op          10 allocs/op\nBenchmarkMartini_GithubParam            119397          9638 ns/op        1152 B/op          11 allocs/op\nBenchmarkPat_GithubParam                150675          8858 ns/op        2408 B/op          48 allocs/op\nBenchmarkPossum_GithubParam            1000000          1001 ns/op         496 B/op           5 allocs/op\nBenchmarkR2router_GithubParam          1602886           761 ns/op         432 B/op           5 allocs/op\nBenchmarkRivet_GithubParam             2986579           409 ns/op          96 B/op           1 allocs/op\nBenchmarkTango_GithubParam             1000000          1356 ns/op         344 B/op           8 allocs/op\nBenchmarkTigerTonic_GithubParam         388899          3429 ns/op        1176 B/op          22 allocs/op\nBenchmarkTraffic_GithubParam            123160          9734 ns/op        2816 B/op          40 allocs/op\nBenchmarkVulcan_GithubParam            1000000          1138 ns/op          98 B/op           3 allocs/op\nBenchmarkAce_GithubAll                   40543         29670 ns/op           0 B/op           0 allocs/op\nBenchmarkAero_GithubAll                  57632         20648 ns/op           0 B/op           0 allocs/op\nBenchmarkBear_GithubAll                   9234        216179 ns/op       86448 B/op         943 allocs/op\nBenchmarkBeego_GithubAll                  7407        243496 ns/op       71456 B/op         609 allocs/op\nBenchmarkBone_GithubAll                    420       2922835 ns/op      720160 B/op        8620 allocs/op\nBenchmarkChi_GithubAll                    7620        238331 ns/op       87696 B/op         609 allocs/op\nBenchmarkDenco_GithubAll                 18355         64494 ns/op       20224 B/op         167 allocs/op\nBenchmarkEcho_GithubAll                  31251         38479 ns/op           0 B/op           0 allocs/op\nBenchmarkGin_GithubAll                   43550         27364 ns/op           0 B/op           0 allocs/op\nBenchmarkGocraftWeb_GithubAll             4117        300062 ns/op      131656 B/op        1686 allocs/op\nBenchmarkGoji_GithubAll                   3274        416158 ns/op       56112 B/op         334 allocs/op\nBenchmarkGojiv2_GithubAll                 1402        870518 ns/op      352720 B/op        4321 allocs/op\nBenchmarkGoJsonRest_GithubAll             2976        401507 ns/op      134371 B/op        2737 allocs/op\nBenchmarkGoRestful_GithubAll               410       2913158 ns/op      910144 B/op        2938 allocs/op\nBenchmarkGorillaMux_GithubAll              346       3384987 ns/op      251650 B/op        1994 allocs/op\nBenchmarkGowwwRouter_GithubAll           10000        143025 ns/op       72144 B/op         501 allocs/op\nBenchmarkHttpRouter_GithubAll            55938         21360 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpTreeMux_GithubAll           10000        153944 ns/op       65856 B/op         671 allocs/op\nBenchmarkKocha_GithubAll                 10000        106315 ns/op       23304 B/op         843 allocs/op\nBenchmarkLARS_GithubAll                  47779         25084 ns/op           0 B/op           0 allocs/op\nBenchmarkMacaron_GithubAll                3266        371907 ns/op      149409 B/op        1624 allocs/op\nBenchmarkMartini_GithubAll                 331       3444706 ns/op      226551 B/op        2325 allocs/op\nBenchmarkPat_GithubAll                     273       4381818 ns/op     1483152 B/op       26963 allocs/op\nBenchmarkPossum_GithubAll                10000        164367 ns/op       84448 B/op         609 allocs/op\nBenchmarkR2router_GithubAll              10000        160220 ns/op       77328 B/op         979 allocs/op\nBenchmarkRivet_GithubAll                 14625         82453 ns/op       16272 B/op         167 allocs/op\nBenchmarkTango_GithubAll                  6255        279611 ns/op       63826 B/op        1618 allocs/op\nBenchmarkTigerTonic_GithubAll             2008        687874 ns/op      193856 B/op        4474 allocs/op\nBenchmarkTraffic_GithubAll                 355       3478508 ns/op      820744 B/op       14114 allocs/op\nBenchmarkVulcan_GithubAll                 6885        193333 ns/op       19894 B/op         609 allocs/op\n```\n",
    "source_file": "BENCHMARKS.md",
    "chunk_type": "doc"
  },
  {
    "content": "## Google+\n\n```sh\nBenchmarkGin_GPlusStatic              19247326          62.2 ns/op           0 B/op           0 allocs/op\n\nBenchmarkAce_GPlusStatic              20235060          59.2 ns/op           0 B/op           0 allocs/op\nBenchmarkAero_GPlusStatic             31978935          37.6 ns/op           0 B/op           0 allocs/op\nBenchmarkBear_GPlusStatic              3516523           341 ns/op         104 B/op           3 allocs/op\nBenchmarkBeego_GPlusStatic             1212036           991 ns/op         352 B/op           3 allocs/op\nBenchmarkBone_GPlusStatic              6736242           183 ns/op          32 B/op           1 allocs/op\nBenchmarkChi_GPlusStatic               1490640           814 ns/op         432 B/op           3 allocs/op\nBenchmarkDenco_GPlusStatic            55006856          21.8 ns/op           0 B/op           0 allocs/op\nBenchmarkEcho_GPlusStatic             17688258          67.9 ns/op           0 B/op           0 allocs/op\nBenchmarkGocraftWeb_GPlusStatic        1829181           666 ns/op         280 B/op           5 allocs/op\nBenchmarkGoji_GPlusStatic              9147451           130 ns/op           0 B/op           0 allocs/op\nBenchmarkGojiv2_GPlusStatic             594015          2063 ns/op        1312 B/op          10 allocs/op\nBenchmarkGoJsonRest_GPlusStatic        1264906           950 ns/op         329 B/op          11 allocs/op\nBenchmarkGoRestful_GPlusStatic          231558          5341 ns/op        3872 B/op          13 allocs/op\nBenchmarkGorillaMux_GPlusStatic         908418          1809 ns/op         976 B/op           9 allocs/op\nBenchmarkGowwwRouter_GPlusStatic      40684604          29.5 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpRouter_GPlusStatic       46742804          25.7 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpTreeMux_GPlusStatic      32567161          36.9 ns/op           0 B/op           0 allocs/op\nBenchmarkKocha_GPlusStatic            33800060          35.3 ns/op           0 B/op           0 allocs/op\nBenchmarkLARS_GPlusStatic             20431858          60.0 ns/op           0 B/op           0 allocs/op\nBenchmarkMacaron_GPlusStatic           1000000          1745 ns/op         736 B/op           8 allocs/op\nBenchmarkMartini_GPlusStatic            442248          3619 ns/op         768 B/op           9 allocs/op\nBenchmarkPat_GPlusStatic               4328004           292 ns/op          96 B/op           2 allocs/op\nBenchmarkPossum_GPlusStatic            1570753           763 ns/op         416 B/op           3 allocs/op\nBenchmarkR2router_GPlusStatic          3339474           355 ns/op         144 B/op           4 allocs/op\nBenchmarkRivet_GPlusStatic            18570961          64.7 ns/op           0 B/op           0 allocs/op\nBenchmarkTango_GPlusStatic             1388702           860 ns/op         200 B/op           8 allocs/op\nBenchmarkTigerTonic_GPlusStatic        7803543           159 ns/op          32 B/op           1 allocs/op\nBenchmarkTraffic_GPlusStatic            878605          2171 ns/op        1112 B/op          16 allocs/op\nBenchmarkVulcan_GPlusStatic            2742446           437 ns/op          98 B/op           3 allocs/op\nBenchmarkAce_GPlusParam               11626975           105 ns/op           0 B/op           0 allocs/op\nBenchmarkAero_GPlusParam              16914322          71.6 ns/op           0 B/op           0 allocs/op\nBenchmarkBear_GPlusParam               1405173           832 ns/op         480 B/op           5 allocs/op\nBenchmarkBeego_GPlusParam              1000000          1075 ns/op         352 B/op           3 allocs/op\nBenchmarkBone_GPlusParam               1000000          1557 ns/op         816 B/op           6 allocs/op\nBenchmarkChi_GPlusParam                1347926           894 ns/op         432 B/op           3 allocs/op\nBenchmarkDenco_GPlusParam              5513000           212 ns/op          64 B/op           1 allocs/op\nBenchmarkEcho_GPlusParam              11884383           101 ns/op           0 B/op           0 allocs/op\nBenchmarkGin_GPlusParam               12898952          93.1 ns/op           0 B/op           0 allocs/op\nBenchmarkGocraftWeb_GPlusParam         1000000          1194 ns/op         648 B/op           8 allocs/op\nBenchmarkGoji_GPlusParam               1857229           645 ns/op         336 B/op           2 allocs/op\nBenchmarkGojiv2_GPlusParam              520939          2322 ns/op        1328 B/op          11 allocs/op\nBenchmarkGoJsonRest_GPlusParam         1000000          1536 ns/op         649 B/op          13 allocs/op\nBenchmarkGoRestful_GPlusParam           205449          5800 ns/op        4192 B/op          14 allocs/op\nBenchmarkGorillaMux_GPlusParam          395310          3188 ns/op        1280 B/op          10 allocs/op\nBenchmarkGowwwRouter_GPlusParam        1851798           667 ns/op         432 B/op           3 allocs/op\nBenchmarkHttpRouter_GPlusParam        18420789          65.2 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpTreeMux_GPlusParam        1878463           629 ns/op         352 B/op           3 allocs/op\nBenchmarkKocha_GPlusParam              4495610           273 ns/op          56 B/op           3 allocs/op\nBenchmarkLARS_GPlusParam              14615976          83.2 ns/op           0 B/op           0 allocs/op\nBenchmarkMacaron_GPlusParam             584145          2549 ns/op        1072 B/op          10 allocs/op\nBenchmarkMartini_GPlusParam             250501          4583 ns/op        1072 B/op          10 allocs/op\nBenchmarkPat_GPlusParam                1000000          1645 ns/op         576 B/op          11 allocs/op\nBenchmarkPossum_GPlusParam             1000000          1008 ns/op         496 B/op           5 allocs/op\nBenchmarkR2router_GPlusParam           1708191           688 ns/op         432 B/op           5 allocs/op\nBenchmarkRivet_GPlusParam              5795014           211 ns/op          48 B/op           1 allocs/op\nBenchmarkTango_GPlusParam              1000000          1091 ns/op         264 B/op           8 allocs/op\nBenchmarkTigerTonic_GPlusParam          760221          2489 ns/op         856 B/op          16 allocs/op\nBenchmarkTraffic_GPlusParam             309774          4039 ns/op        1872 B/op          21 allocs/op\nBenchmarkVulcan_GPlusParam             1935730           623 ns/op          98 B/op           3 allocs/op\nBenchmarkAce_GPlus2Params              9158314           134 ns/op           0 B/op           0 allocs/op\nBenchmarkAero_GPlus2Params            11300517           107 ns/op           0 B/op           0 allocs/op\nBenchmarkBear_GPlus2Params             1239238           961 ns/op         496 B/op           5 allocs/op\nBenchmarkBeego_GPlus2Params            1000000          1202 ns/op         352 B/op           3 allocs/op\nBenchmarkBone_GPlus2Params              335576          3725 ns/op        1168 B/op          10 allocs/op\nBenchmarkChi_GPlus2Params              1000000          1014 ns/op         432 B/op           3 allocs/op\nBenchmarkDenco_GPlus2Params            4394598           280 ns/op          64 B/op           1 allocs/op\nBenchmarkEcho_GPlus2Params             7851861           154 ns/op           0 B/op           0 allocs/op\nBenchmarkGin_GPlus2Params              9958588           120 ns/op           0 B/op           0 allocs/op\nBenchmarkGocraftWeb_GPlus2Params       1000000          1433 ns/op         712 B/op           9 allocs/op\nBenchmarkGoji_GPlus2Params             1325134           909 ns/op         336 B/op           2 allocs/op\nBenchmarkGojiv2_GPlus2Params            405955          2870 ns/op        1408 B/op          14 allocs/op\nBenchmarkGoJsonRest_GPlus2Params        977038          1987 ns/op         713 B/op          14 allocs/op\nBenchmarkGoRestful_GPlus2Params         205018          6142 ns/op        4384 B/op          16 allocs/op\nBenchmarkGorillaMux_GPlus2Params        205641          6015 ns/op        1296 B/op          10 allocs/op\nBenchmarkGowwwRouter_GPlus2Params      1748542           684 ns/op         432 B/op           3 allocs/op\nBenchmarkHttpRouter_GPlus2Params      14047102          87.7 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpTreeMux_GPlus2Params      1418673           828 ns/op         384 B/op           4 allocs/op\nBenchmarkKocha_GPlus2Params            2334562           520 ns/op         128 B/op           5 allocs/op\nBenchmarkLARS_GPlus2Params            11954094           101 ns/op           0 B/op           0 allocs/op\nBenchmarkMacaron_GPlus2Params           491552          2890 ns/op        1072 B/op          10 allocs/op\nBenchmarkMartini_GPlus2Params           120532          9545 ns/op        1200 B/op          13 allocs/op\nBenchmarkPat_GPlus2Params               194739          6766 ns/op        2168 B/op          33 allocs/op\nBenchmarkPossum_GPlus2Params           1201224          1009 ns/op         496 B/op           5 allocs/op\nBenchmarkR2router_GPlus2Params         1575535           756 ns/op         432 B/op           5 allocs/op\nBenchmarkRivet_GPlus2Params            3698930           325 ns/op          96 B/op           1 allocs/op\nBenchmarkTango_GPlus2Params            1000000          1212 ns/op         344 B/op           8 allocs/op\nBenchmarkTigerTonic_GPlus2Params        349350          3660 ns/op        1200 B/op          22 allocs/op\nBenchmarkTraffic_GPlus2Params           169714          7862 ns/op        2248 B/op          28 allocs/op\nBenchmarkVulcan_GPlus2Params           1222288           974 ns/op          98 B/op           3 allocs/op\nBenchmarkAce_GPlusAll                   845606          1398 ns/op           0 B/op           0 allocs/op\nBenchmarkAero_GPlusAll                 1000000          1009 ns/op           0 B/op           0 allocs/op\nBenchmarkBear_GPlusAll                  103830         11386 ns/op        5488 B/op          61 allocs/op\nBenchmarkBeego_GPlusAll                  82653         14784 ns/op        4576 B/op          39 allocs/op\nBenchmarkBone_GPlusAll                   36601         33123 ns/op       11744 B/op         109 allocs/op\nBenchmarkChi_GPlusAll                    95264         12831 ns/op        5616 B/op          39 allocs/op\nBenchmarkDenco_GPlusAll                 567681          2950 ns/op         672 B/op          11 allocs/op\nBenchmarkEcho_GPlusAll                  720366          1665 ns/op           0 B/op           0 allocs/op\nBenchmarkGin_GPlusAll                  1000000          1185 ns/op           0 B/op           0 allocs/op\nBenchmarkGocraftWeb_GPlusAll             71575         16365 ns/op        8040 B/op         103 allocs/op\nBenchmarkGoji_GPlusAll                  136352          9191 ns/op        3696 B/op          22 allocs/op\nBenchmarkGojiv2_GPlusAll                 38006         31802 ns/op       17616 B/op         154 allocs/op\nBenchmarkGoJsonRest_GPlusAll             57238         21561 ns/op        8117 B/op         170 allocs/op\nBenchmarkGoRestful_GPlusAll              15147         79276 ns/op       55520 B/op         192 allocs/op\nBenchmarkGorillaMux_GPlusAll             24446         48410 ns/op       16112 B/op         128 allocs/op\nBenchmarkGowwwRouter_GPlusAll           150112          7770 ns/op        4752 B/op          33 allocs/op\nBenchmarkHttpRouter_GPlusAll           1367820           878 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpTreeMux_GPlusAll           166628          8004 ns/op        4032 B/op          38 allocs/op\nBenchmarkKocha_GPlusAll                 265694          4570 ns/op         976 B/op          43 allocs/op\nBenchmarkLARS_GPlusAll                 1000000          1068 ns/op           0 B/op           0 allocs/op\nBenchmarkMacaron_GPlusAll                54564         23305 ns/op        9568 B/op         104 allocs/op\nBenchmarkMartini_GPlusAll                16274         73845 ns/op       14016 B/op         145 allocs/op\nBenchmarkPat_GPlusAll                    27181         44478 ns/op       15264 B/op         271 allocs/op\nBenchmarkPossum_GPlusAll                122587         10277 ns/op        5408 B/op          39 allocs/op\nBenchmarkR2router_GPlusAll              130137          9297 ns/op        5040 B/op          63 allocs/op\nBenchmarkRivet_GPlusAll                 532438          3323 ns/op         768 B/op          11 allocs/op\nBenchmarkTango_GPlusAll                  86054         14531 ns/op        3656 B/op         104 allocs/op\nBenchmarkTigerTonic_GPlusAll             33936         35356 ns/op       11600 B/op         242 allocs/op\nBenchmarkTraffic_GPlusAll                17833         68181 ns/op       26248 B/op         341 allocs/op\nBenchmarkVulcan_GPlusAll                120109          9861 ns/op        1274 B/op          39 allocs/op\n```\n",
    "source_file": "BENCHMARKS.md",
    "chunk_type": "doc"
  },
  {
    "content": "## Parse.com\n\n```sh\nBenchmarkGin_ParseStatic              18877833          63.5 ns/op           0 B/op           0 allocs/op\n\nBenchmarkAce_ParseStatic              19663731          60.8 ns/op           0 B/op           0 allocs/op\nBenchmarkAero_ParseStatic             28967341          41.5 ns/op           0 B/op           0 allocs/op\nBenchmarkBear_ParseStatic              3006984           402 ns/op         120 B/op           3 allocs/op\nBenchmarkBeego_ParseStatic             1000000          1031 ns/op         352 B/op           3 allocs/op\nBenchmarkBone_ParseStatic              1782482           675 ns/op         144 B/op           3 allocs/op\nBenchmarkChi_ParseStatic               1453261           819 ns/op         432 B/op           3 allocs/op\nBenchmarkDenco_ParseStatic            45023595          26.5 ns/op           0 B/op           0 allocs/op\nBenchmarkEcho_ParseStatic             17330470          69.3 ns/op           0 B/op           0 allocs/op\nBenchmarkGocraftWeb_ParseStatic        1644006           731 ns/op         296 B/op           5 allocs/op\nBenchmarkGoji_ParseStatic              7026930           170 ns/op           0 B/op           0 allocs/op\nBenchmarkGojiv2_ParseStatic             517618          2037 ns/op        1312 B/op          10 allocs/op\nBenchmarkGoJsonRest_ParseStatic        1227080           975 ns/op         329 B/op          11 allocs/op\nBenchmarkGoRestful_ParseStatic          192458          6659 ns/op        4256 B/op          13 allocs/op\nBenchmarkGorillaMux_ParseStatic         744062          2109 ns/op         976 B/op           9 allocs/op\nBenchmarkGowwwRouter_ParseStatic      37781062          31.8 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpRouter_ParseStatic       45311223          26.5 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpTreeMux_ParseStatic      21383475          56.1 ns/op           0 B/op           0 allocs/op\nBenchmarkKocha_ParseStatic            29953290          40.1 ns/op           0 B/op           0 allocs/op\nBenchmarkLARS_ParseStatic             20036196          62.7 ns/op           0 B/op           0 allocs/op\nBenchmarkMacaron_ParseStatic           1000000          1740 ns/op         736 B/op           8 allocs/op\nBenchmarkMartini_ParseStatic            404156          3801 ns/op         768 B/op           9 allocs/op\nBenchmarkPat_ParseStatic               1547180           772 ns/op         240 B/op           5 allocs/op\nBenchmarkPossum_ParseStatic            1608991           757 ns/op         416 B/op           3 allocs/op\nBenchmarkR2router_ParseStatic          3177936           385 ns/op         144 B/op           4 allocs/op\nBenchmarkRivet_ParseStatic            17783205          67.4 ns/op           0 B/op           0 allocs/op\nBenchmarkTango_ParseStatic             1210777           990 ns/op         248 B/op           8 allocs/op\nBenchmarkTigerTonic_ParseStatic        5316440           231 ns/op          48 B/op           1 allocs/op\nBenchmarkTraffic_ParseStatic            496050          2539 ns/op        1256 B/op          19 allocs/op\nBenchmarkVulcan_ParseStatic            2462798           488 ns/op          98 B/op           3 allocs/op\nBenchmarkAce_ParseParam               13393669          89.6 ns/op           0 B/op           0 allocs/op\nBenchmarkAero_ParseParam              19836619          60.4 ns/op           0 B/op           0 allocs/op\nBenchmarkBear_ParseParam               1405954           864 ns/op         467 B/op           5 allocs/op\nBenchmarkBeego_ParseParam              1000000          1065 ns/op         352 B/op           3 allocs/op\nBenchmarkBone_ParseParam               1000000          1698 ns/op         896 B/op           7 allocs/op\nBenchmarkChi_ParseParam                1356037           873 ns/op         432 B/op           3 allocs/op\nBenchmarkDenco_ParseParam              6241392           204 ns/op          64 B/op           1 allocs/op\nBenchmarkEcho_ParseParam              14088100          85.1 ns/op           0 B/op           0 allocs/op\nBenchmarkGin_ParseParam               17426064          68.9 ns/op           0 B/op           0 allocs/op\nBenchmarkGocraftWeb_ParseParam         1000000          1254 ns/op         664 B/op           8 allocs/op\nBenchmarkGoji_ParseParam               1682574           713 ns/op         336 B/op           2 allocs/op\nBenchmarkGojiv2_ParseParam              502224          2333 ns/op        1360 B/op          12 allocs/op\nBenchmarkGoJsonRest_ParseParam         1000000          1401 ns/op         649 B/op          13 allocs/op\nBenchmarkGoRestful_ParseParam           182623          7097 ns/op        4576 B/op          14 allocs/op\nBenchmarkGorillaMux_ParseParam          482332          2477 ns/op        1280 B/op          10 allocs/op\nBenchmarkGowwwRouter_ParseParam        1834873           657 ns/op         432 B/op           3 allocs/op\nBenchmarkHttpRouter_ParseParam        23593393          51.0 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpTreeMux_ParseParam        2100160           574 ns/op         352 B/op           3 allocs/op\nBenchmarkKocha_ParseParam              4837220           252 ns/op          56 B/op           3 allocs/op\nBenchmarkLARS_ParseParam              18411192          66.2 ns/op           0 B/op           0 allocs/op\nBenchmarkMacaron_ParseParam             571870          2398 ns/op        1072 B/op          10 allocs/op\nBenchmarkMartini_ParseParam             286262          4268 ns/op        1072 B/op          10 allocs/op\nBenchmarkPat_ParseParam                 692906          2157 ns/op         992 B/op          15 allocs/op\nBenchmarkPossum_ParseParam             1000000          1011 ns/op         496 B/op           5 allocs/op\nBenchmarkR2router_ParseParam           1722735           697 ns/op         432 B/op           5 allocs/op\nBenchmarkRivet_ParseParam              6058054           203 ns/op          48 B/op           1 allocs/op\nBenchmarkTango_ParseParam              1000000          1061 ns/op         280 B/op           8 allocs/op\nBenchmarkTigerTonic_ParseParam          890275          2277 ns/op         784 B/op          15 allocs/op\nBenchmarkTraffic_ParseParam             351322          3543 ns/op        1896 B/op          21 allocs/op\nBenchmarkVulcan_ParseParam             2076544           572 ns/op          98 B/op           3 allocs/op\nBenchmarkAce_Parse2Params             11718074           101 ns/op           0 B/op           0 allocs/op\nBenchmarkAero_Parse2Params            16264988          73.4 ns/op           0 B/op           0 allocs/op\nBenchmarkBear_Parse2Params             1238322           973 ns/op         496 B/op           5 allocs/op\nBenchmarkBeego_Parse2Params            1000000          1120 ns/op         352 B/op           3 allocs/op\nBenchmarkBone_Parse2Params             1000000          1632 ns/op         848 B/op           6 allocs/op\nBenchmarkChi_Parse2Params              1239477           955 ns/op         432 B/op           3 allocs/op\nBenchmarkDenco_Parse2Params            4944133           245 ns/op          64 B/op           1 allocs/op\nBenchmarkEcho_Parse2Params            10518286           114 ns/op           0 B/op           0 allocs/op\nBenchmarkGin_Parse2Params             14505195          82.7 ns/op           0 B/op           0 allocs/op\nBenchmarkGocraftWeb_Parse2Params       1000000          1437 ns/op         712 B/op           9 allocs/op\nBenchmarkGoji_Parse2Params             1689883           707 ns/op         336 B/op           2 allocs/op\nBenchmarkGojiv2_Parse2Params            502334          2308 ns/op        1344 B/op          11 allocs/op\nBenchmarkGoJsonRest_Parse2Params       1000000          1771 ns/op         713 B/op          14 allocs/op\nBenchmarkGoRestful_Parse2Params         159092          7583 ns/op        4928 B/op          14 allocs/op\nBenchmarkGorillaMux_Parse2Params        417548          2980 ns/op        1296 B/op          10 allocs/op\nBenchmarkGowwwRouter_Parse2Params      1751737           686 ns/op         432 B/op           3 allocs/op\nBenchmarkHttpRouter_Parse2Params      18089204          66.3 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpTreeMux_Parse2Params      1556986           777 ns/op         384 B/op           4 allocs/op\nBenchmarkKocha_Parse2Params            2493082           485 ns/op         128 B/op           5 allocs/op\nBenchmarkLARS_Parse2Params            15350108          78.5 ns/op           0 B/op           0 allocs/op\nBenchmarkMacaron_Parse2Params           530974          2605 ns/op        1072 B/op          10 allocs/op\nBenchmarkMartini_Parse2Params           247069          4673 ns/op        1152 B/op          11 allocs/op\nBenchmarkPat_Parse2Params               816295          2126 ns/op         752 B/op          16 allocs/op\nBenchmarkPossum_Parse2Params           1000000          1002 ns/op         496 B/op           5 allocs/op\nBenchmarkR2router_Parse2Params         1569771           733 ns/op         432 B/op           5 allocs/op\nBenchmarkRivet_Parse2Params            4080546           295 ns/op          96 B/op           1 allocs/op\nBenchmarkTango_Parse2Params            1000000          1121 ns/op         312 B/op           8 allocs/op\nBenchmarkTigerTonic_Parse2Params        399556          3470 ns/op        1168 B/op          22 allocs/op\nBenchmarkTraffic_Parse2Params           314194          4159 ns/op        1944 B/op          22 allocs/op\nBenchmarkVulcan_Parse2Params           1827559           664 ns/op          98 B/op           3 allocs/op\nBenchmarkAce_ParseAll                   478395          2503 ns/op           0 B/op           0 allocs/op\nBenchmarkAero_ParseAll                  715392          1658 ns/op           0 B/op           0 allocs/op\nBenchmarkBear_ParseAll                   59191         20124 ns/op        8928 B/op         110 allocs/op\nBenchmarkBeego_ParseAll                  45507         27266 ns/op        9152 B/op          78 allocs/op\nBenchmarkBone_ParseAll                   29328         41459 ns/op       16208 B/op         147 allocs/op\nBenchmarkChi_ParseAll                    48531         25053 ns/op       11232 B/op          78 allocs/op\nBenchmarkDenco_ParseAll                 325532          4284 ns/op         928 B/op          16 allocs/op\nBenchmarkEcho_ParseAll                  433771          2759 ns/op           0 B/op           0 allocs/op\nBenchmarkGin_ParseAll                   576316          2082 ns/op           0 B/op           0 allocs/op\nBenchmarkGocraftWeb_ParseAll             41500         29692 ns/op       13728 B/op         181 allocs/op\nBenchmarkGoji_ParseAll                   80833         15563 ns/op        5376 B/op          32 allocs/op\nBenchmarkGojiv2_ParseAll                 19836         60335 ns/op       34448 B/op         277 allocs/op\nBenchmarkGoJsonRest_ParseAll             32210         38027 ns/op       13866 B/op         321 allocs/op\nBenchmarkGoRestful_ParseAll               6644        190842 ns/op      117600 B/op         354 allocs/op\nBenchmarkGorillaMux_ParseAll             12634         95894 ns/op       30288 B/op         250 allocs/op\nBenchmarkGowwwRouter_ParseAll            98152         12159 ns/op        6912 B/op          48 allocs/op\nBenchmarkHttpRouter_ParseAll            933208          1273 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpTreeMux_ParseAll           107191         11554 ns/op        5728 B/op          51 allocs/op\nBenchmarkKocha_ParseAll                 184862          6225 ns/op        1112 B/op          54 allocs/op\nBenchmarkLARS_ParseAll                  644546          1858 ns/op           0 B/op           0 allocs/op\nBenchmarkMacaron_ParseAll                26145         46484 ns/op       19136 B/op         208 allocs/op\nBenchmarkMartini_ParseAll                10000        121838 ns/op       25072 B/op         253 allocs/op\nBenchmarkPat_ParseAll                    25417         47196 ns/op       15216 B/op         308 allocs/op\nBenchmarkPossum_ParseAll                 58550         20735 ns/op       10816 B/op          78 allocs/op\nBenchmarkR2router_ParseAll               72732         16584 ns/op        8352 B/op         120 allocs/op\nBenchmarkRivet_ParseAll                 281365          4968 ns/op         912 B/op          16 allocs/op\nBenchmarkTango_ParseAll                  42831         28668 ns/op        7168 B/op         208 allocs/op\nBenchmarkTigerTonic_ParseAll             23774         49972 ns/op       16048 B/op         332 allocs/op\nBenchmarkTraffic_ParseAll                10000        104679 ns/op       45520 B/op         605 allocs/op\nBenchmarkVulcan_ParseAll                 64810         18108 ns/op        2548 B/op          78 allocs/op\n```",
    "source_file": "BENCHMARKS.md",
    "chunk_type": "doc"
  },
  {
    "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"log\"\n\n\t\"github.com/gin-gonic/gin/binding\"\n)\n\n// BindWith binds the passed struct pointer using the specified binding engine.\n// See the binding package.\n//\n// Deprecated: Use MustBindWith or ShouldBindWith.\nfunc (c *Context) BindWith(obj any, b binding.Binding) error {\n\tlog.Println(`BindWith(\\\"any, binding.Binding\\\") error is going to\n\tbe deprecated, please check issue #662 and either use MustBindWith() if you\n\twant HTTP 400 to be automatically returned if any error occur, or use\n\tShouldBindWith() if you need to manage the error.`)\n\treturn c.MustBindWith(obj, b)\n}\n",
    "source_file": "deprecated.go",
    "chunk_type": "code"
  },
  {
    "content": "github.com/bytedance/sonic v1.13.2 h1:8/H1FempDZqC4VqjptGo14QQlJx8VdZJegxs6wwfqpQ=\ngithub.com/bytedance/sonic v1.13.2/go.mod h1:o68xyaF9u2gvVBuGHPlUVCy+ZfmNNO5ETf1+KgkJhz4=\ngithub.com/bytedance/sonic/loader v0.1.1/go.mod h1:ncP89zfokxS5LZrJxl5z0UJcsk4M4yY2JpfqGeCtNLU=\ngithub.com/bytedance/sonic/loader v0.2.4 h1:ZWCw4stuXUsn1/+zQDqeE7JKP+QO47tz7QCNan80NzY=\ngithub.com/bytedance/sonic/loader v0.2.4/go.mod h1:N8A3vUdtUebEY2/VQC0MyhYeKUFosQU6FxH2JmUe6VI=\ngithub.com/chzyer/logex v1.1.10/go.mod h1:+Ywpsq7O8HXn0nuIou7OrIPyXbp3wmkHB+jjWRnGsAI=\ngithub.com/chzyer/readline v0.0.0-20180603132655-2972be24d48e/go.mod h1:nSuG5e5PlCu98SY8svDHJxuZscDgtXS6KTTbou5AhLI=\ngithub.com/chzyer/test v0.0.0-20180213035817-a1ea475d72b1/go.mod h1:Q3SI9o4m/ZMnBNeIyt5eFwwo7qiLfzFZmjNmxjkiQlU=\ngithub.com/cloudwego/base64x v0.1.5 h1:XPciSp1xaq2VCSt6lF0phncD4koWyULpl5bUxbfCyP4=\ngithub.com/cloudwego/base64x v0.1.5/go.mod h1:0zlkT4Wn5C6NdauXdJRhSKRlJvmclQ1hhJgA0rcu/8w=\ngithub.com/cloudwego/iasm v0.2.0/go.mod h1:8rXZaNYT2n95jn+zTI1sDr+IgcD2GVs0nlbbQPiEFhY=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/gabriel-vasile/mimetype v1.4.8 h1:FfZ3gj38NjllZIeJAmMhr+qKL8Wu+nOoI3GqacKw1NM=\ngithub.com/gabriel-vasile/mimetype v1.4.8/go.mod h1:ByKUIKGjh1ODkGM1asKUbQZOLGrPjydw3hYPU2YU9t8=\ngithub.com/gin-contrib/sse v1.1.0 h1:n0w2GMuUpWDVp7qSpvze6fAu9iRxJY4Hmj6AmBOU05w=\ngithub.com/gin-contrib/sse v1.1.0/go.mod h1:hxRZ5gVpWMT7Z0B0gSNYqqsSCNIJMjzvm6fqCz9vjwM=\ngithub.com/go-logr/logr v1.2.4 h1:g01GSCwiDw2xSZfjJ2/T9M+S6pFdcNtFYsp+Y43HYDQ=\ngithub.com/go-logr/logr v1.2.4/go.mod h1:jdQByPbusPIv2/zmleS9BjJVeZ6kBagPoEUsqbVz/1A=\ngithub.com/go-playground/assert/v2 v2.2.0 h1:JvknZsQTYeFEAhQwI4qEt9cyV5ONwRHC+lYKSsYSR8s=\ngithub.com/go-playground/assert/v2 v2.2.0/go.mod h1:VDjEfimB/XKnb+ZQfWdccd7VUvScMdVu0Titje2rxJ4=\ngithub.com/go-playground/locales v0.14.1 h1:EWaQ/wswjilfKLTECiXz7Rh+3BjFhfDFKv/oXslEjJA=\ngithub.com/go-playground/locales v0.14.1/go.mod h1:hxrqLVvrK65+Rwrd5Fc6F2O76J/NuW9t0sjnWqG1slY=\ngithub.com/go-playground/universal-translator v0.18.1 h1:Bcnm0ZwsGyWbCzImXv+pAJnYK9S473LQFuzCbDbfSFY=\ngithub.com/go-playground/universal-translator v0.18.1/go.mod h1:xekY+UJKNuX9WP91TpwSH2VMlDf28Uj24BCp08ZFTUY=\ngithub.com/go-playground/validator/v10 v10.26.0 h1:SP05Nqhjcvz81uJaRfEV0YBSSSGMc/iMaVtFbr3Sw2k=\ngithub.com/go-playground/validator/v10 v10.26.0/go.mod h1:I5QpIEbmr8On7W0TktmJAumgzX4CA1XNl4ZmDuVHKKo=\ngithub.com/go-task/slim-sprig v0.0.0-20230315185526-52ccab3ef572 h1:tfuBGBXKqDEevZMzYi5KSi8KkcZtzBcTgAUUtapy0OI=\ngithub.com/go-task/slim-sprig v0.0.0-20230315185526-52ccab3ef572/go.mod h1:9Pwr4B2jHnOSGXyyzV8ROjYa2ojvAY6HCGYYfMoC3Ls=\ngithub.com/goccy/go-json v0.10.2 h1:CrxCmQqYDkv1z7lO7Wbh2HN93uovUHgrECaO5ZrCXAU=\ngithub.com/goccy/go-json v0.10.2/go.mod h1:6MelG93GURQebXPDq3khkgXZkazVtN9CRI+MGFi0w8I=\ngithub.com/goccy/go-yaml v1.18.0 h1:8W7wMFS12Pcas7KU+VVkaiCng+kG8QiFeFwzFb+rwuw=\ngithub.com/goccy/go-yaml v1.18.0/go.mod h1:XBurs7gK8ATbW4ZPGKgcbrY1Br56PdM69F7LkFRi1kA=\ngithub.com/golang/protobuf v1.5.3 h1:KhyjKVUg7Usr/dYsdSqoFveMYd5ko72D+zANwlG1mmg=\ngithub.com/golang/protobuf v1.5.3/go.mod h1:XVQd3VNwM+JqD3oG2Ue2ip4fOMUkwXdXDdiuN0vRsmY=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/google/gofuzz v1.0.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg=\ngithub.com/google/pprof v0.0.0-20210407192527-94a9f03dee38 h1:yAJXTCF9TqKcTiHJAE8dj7HMvPfh66eeA2JYW7eFpSE=\ngithub.com/google/pprof v0.0.0-20210407192527-94a9f03dee38/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=\ngithub.com/ianlancetaylor/demangle v0.0.0-20200824232613-28f6c0f3b639/go.mod h1:aSSvb/t6k1mPoxDqO4vJh6VOCGPwU4O0C2/Eqndh1Sc=\ngithub.com/json-iterator/go v1.1.12 h1:PV8peI4a0ysnczrg+LtxykD8LfKY9ML6u2jnxaEnrnM=\ngithub.com/json-iterator/go v1.1.12/go.mod h1:e30LSqwooZae/UwlEbR2852Gd8hjQvJoHmT4TnhNGBo=\ngithub.com/klauspost/cpuid/v2 v2.0.9 h1:lgaqFMSdTdQYdZ04uHyN2d/eKdOMyi2YLSvlQIBFYa4=\ngithub.com/klauspost/cpuid/v2 v2.0.9/go.mod h1:FInQzS24/EEf25PyTYn52gqo7WaD8xa0213Md/qVLRg=\ngithub.com/knz/go-libedit v1.10.1/go.mod h1:MZTVkCWyz0oBc7JOWP3wNAzd002ZbM/5hgShxwh4x8M=\ngithub.com/leodido/go-urn v1.4.0 h1:WT9HwE9SGECu3lg4d/dIA+jxlljEa1/ffXKmRjqdmIQ=\ngithub.com/leodido/go-urn v1.4.0/go.mod h1:bvxc+MVxLKB4z00jd1z+Dvzr47oO32F/QSNjSBOlFxI=\ngithub.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=\ngithub.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\ngithub.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421 h1:ZqeYNhU3OHLH3mGKHDcjJRFFRrJa6eAM5H+CtDdOsPc=\ngithub.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=\ngithub.com/modern-go/reflect2 v1.0.2 h1:xBagoLtFs94CBntxluKeaWgTMpvLxC4ur3nMaC9Gz0M=\ngithub.com/modern-go/reflect2 v1.0.2/go.mod h1:yWuevngMOJpCy52FWWMvUC8ws7m/LJsjYzDa0/r8luk=\ngithub.com/onsi/ginkgo/v2 v2.9.5 h1:+6Hr4uxzP4XIUyAkg61dWBw8lb/gc4/X5luuxN/EC+Q=\ngithub.com/onsi/ginkgo/v2 v2.9.5/go.mod h1:tvAoo1QUJwNEU2ITftXTpR7R1RbCzoZUOs3RonqW57k=\ngithub.com/onsi/gomega v1.27.6 h1:ENqfyGeS5AX/rlXDd/ETokDz93u0YufY1Pgxuy/PvWE=\ngithub.com/onsi/gomega v1.27.6/go.mod h1:PIQNjfQwkP3aQAH7lf7j87O/5FiNr+ZR8+ipb+qQlhg=\ngithub.com/pelletier/go-toml/v2 v2.2.4 h1:mye9XuhQ6gvn5h28+VilKrrPoQVanw5PMw/TB0t5Ec4=\ngithub.com/pelletier/go-toml/v2 v2.2.4/go.mod h1:2gIqNv+qfxSVS7cM2xJQKtLSTLUE9V8t9Stt+h56mCY=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/quic-go/qpack v0.5.1 h1:giqksBPnT/HDtZ6VhtFKgoLOWmlyo9Ei6u9PqzIMbhI=\ngithub.com/quic-go/qpack v0.5.1/go.mod h1:+PC4XFrEskIVkcLzpEkbLqq1uCoxPhQuvK5rH1ZgaEg=\ngithub.com/quic-go/quic-go v0.52.0 h1:/SlHrCRElyaU6MaEPKqKr9z83sBg2v4FLLvWM+Z47pA=\ngithub.com/quic-go/quic-go v0.52.0/go.mod h1:MFlGGpcpJqRAfmYi6NC2cptDPSxRWTOGNuP4wqrWmzQ=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=\ngithub.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=\ngithub.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\ngithub.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=\ngithub.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=\ngithub.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=\ngithub.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngithub.com/twitchyliquid64/golang-asm v0.15.1 h1:SU5vSMR7hnwNxj24w34ZyCi/FmDZTkS4MhqMhdFk5YI=\ngithub.com/twitchyliquid64/golang-asm v0.15.1/go.mod h1:a1lVb/DtPvCB8fslRZhAngC2+aY1QWCk3Cedj/Gdt08=\ngithub.com/ugorji/go/codec v1.2.12 h1:9LC83zGrHhuUA9l16C9AHXAqEV/2wBQ4nkvumAE65EE=\ngithub.com/ugorji/go/codec v1.2.12/go.mod h1:UNopzCgEMSXjBc6AOMqYvWC1ktqTAfzJZUZgYf6w6lg=\ngo.uber.org/mock v0.5.0 h1:KAMbZvZPyBPWgD14IrIQ38QCyjwpvVVV6K/bHl1IwQU=\ngo.uber.org/mock v0.5.0/go.mod h1:ge71pBPLYDk7QIi1LupWxdAykm7KIEFchiOqd6z7qMM=\ngolang.org/x/arch v0.0.0-20210923205945-b76863e36670 h1:18EFjUmQOcUvxNYSkA6jO9VAiXCnxFY6NyDX0bHDmkU=\ngolang.org/x/arch v0.0.0-20210923205945-b76863e36670/go.mod h1:5om86z9Hs0C8fWVUuoMHwpExlXzs5Tkyp9hOrfG7pp8=\ngolang.org/x/crypto v0.39.0 h1:SHs+kF4LP+f+p14esP5jAoDpHU8Gu/v9lFRK6IT5imM=\ngolang.org/x/crypto v0.39.0/go.mod h1:L+Xg3Wf6HoL4Bn4238Z6ft6KfEpN0tJGo53AAPC632U=\ngolang.org/x/mod v0.25.0 h1:n7a+ZbQKQA/Ysbyb0/6IbB1H/X41mKgbhfv7AfG/44w=\ngolang.org/x/mod v0.25.0/go.mod h1:IXM97Txy2VM4PJ3gI61r1YEk/gAj6zAHN3AdZt6S9Ww=\ngolang.org/x/net v0.41.0 h1:vBTly1HeNPEn3wtREYfy4GZ/NECgw2Cnl+nK6Nz3uvw=\ngolang.org/x/net v0.41.0/go.mod h1:B/K4NNqkfmg07DQYrbwvSluqCJOOXwUjeb/5lOisjbA=\ngolang.org/x/sync v0.15.0 h1:KWH3jNZsfyT6xfAfKiz6MRNmd46ByHDYaZ7KSkCtdW8=\ngolang.org/x/sync v0.15.0/go.mod h1:1dzgHSNfp02xaA81J2MS99Qcpr2w7fw1gpm99rleRqA=\ngolang.org/x/sys v0.0.0-20191204072324-ce4227a45e2e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.33.0 h1:q3i8TbbEz+JRD9ywIRlyRAQbM0qF7hu24q3teo2hbuw=\ngolang.org/x/sys v0.33.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=\ngolang.org/x/text v0.26.0 h1:P42AVeLghgTYr4+xUnTRKDMqpar+PtX7KWuNQL21L8M=\ngolang.org/x/text v0.26.0/go.mod h1:QK15LZJUUQVJxhz7wXgxSy/CJaTFjd0G+YLonydOVQA=\ngolang.org/x/tools v0.33.0 h1:4qz2S3zmRxbGIhDIAgjxvFutSvH5EfnsYrRBj0UI0bc=\ngolang.org/x/tools v0.33.0/go.mod h1:CIJMaWEY88juyUfo7UbgPqbC8rU2OqfAV1h2Qp0oMYI=\ngoogle.golang.org/protobuf v1.36.6 h1:z1NpPI8ku2WgiWnf+t9wTPsn6eP1L7ksHUlkfLvd9xY=\ngoogle.golang.org/protobuf v1.36.6/go.mod h1:jduwjTPXsFjZGTmRluh+L6NjiWu7pchiJ2/5YcXBHnY=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\nnullprogram.com/x/optparse v1.0.0/go.mod h1:KdyPE+Igbe0jQUrVfMqDMeJQIJZEuyV7pjYmp6pbG50=\n",
    "source_file": "go.sum",
    "chunk_type": "unknown"
  },
  {
    "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"net/http\"\n\t\"path\"\n\t\"regexp\"\n\t\"strings\"\n)\n\nvar (\n\t// regEnLetter matches english letters for http method name\n\tregEnLetter = regexp.MustCompile(\"^[A-Z]+$\")\n\n\t// anyMethods for RouterGroup Any method\n\tanyMethods = []string{\n\t\thttp.MethodGet, http.MethodPost, http.MethodPut, http.MethodPatch,\n\t\thttp.MethodHead, http.MethodOptions, http.MethodDelete, http.MethodConnect,\n\t\thttp.MethodTrace,\n\t}\n)\n\n// IRouter defines all router handle interface includes single and group router.\ntype IRouter interface {\n\tIRoutes\n\tGroup(string, ...HandlerFunc) *RouterGroup\n}\n\n// IRoutes defines all router handle interface.\ntype IRoutes interface {\n\tUse(...HandlerFunc) IRoutes\n\n\tHandle(string, string, ...HandlerFunc) IRoutes\n\tAny(string, ...HandlerFunc) IRoutes\n\tGET(string, ...HandlerFunc) IRoutes\n\tPOST(string, ...HandlerFunc) IRoutes\n\tDELETE(string, ...HandlerFunc) IRoutes\n\tPATCH(string, ...HandlerFunc) IRoutes\n\tPUT(string, ...HandlerFunc) IRoutes\n\tOPTIONS(string, ...HandlerFunc) IRoutes\n\tHEAD(string, ...HandlerFunc) IRoutes\n\tMatch([]string, string, ...HandlerFunc) IRoutes\n\n\tStaticFile(string, string) IRoutes\n\tStaticFileFS(string, string, http.FileSystem) IRoutes\n\tStatic(string, string) IRoutes\n\tStaticFS(string, http.FileSystem) IRoutes\n}\n\n// RouterGroup is used internally to configure router, a RouterGroup is associated with\n// a prefix and an array of handlers (middleware).\ntype RouterGroup struct {\n\tHandlers HandlersChain\n\tbasePath string\n\tengine   *Engine\n\troot     bool\n}\n\nvar _ IRouter = (*RouterGroup)(nil)\n\n// Use adds middleware to the group, see example code in GitHub.\nfunc (group *RouterGroup) Use(middleware ...HandlerFunc) IRoutes {\n\tgroup.Handlers = append(group.Handlers, middleware...)\n\treturn group.returnObj()\n}\n\n// Group creates a new router group. You should add all the routes that have common middlewares or the same path prefix.\n// For example, all the routes that use a common middleware for authorization could be grouped.\nfunc (group *RouterGroup) Group(relativePath string, handlers ...HandlerFunc) *RouterGroup {\n\treturn &RouterGroup{\n\t\tHandlers: group.combineHandlers(handlers),\n\t\tbasePath: group.calculateAbsolutePath(relativePath),\n\t\tengine:   group.engine,\n\t}\n}\n\n// BasePath returns the base path of router group.\n// For example, if v := router.Group(\"/rest/n/v1/api\"), v.BasePath() is \"/rest/n/v1/api\".\nfunc (group *RouterGroup) BasePath() string {\n\treturn group.basePath\n}\n\nfunc (group *RouterGroup) handle(httpMethod, relativePath string, handlers HandlersChain) IRoutes {\n\tabsolutePath := group.calculateAbsolutePath(relativePath)\n\thandlers = group.combineHandlers(handlers)\n\tgroup.engine.addRoute(httpMethod, absolutePath, handlers)\n\treturn group.returnObj()\n}\n\n// Handle registers a new request handle and middleware with the given path and method.\n// The last handler should be the real handler, the other ones should be middleware that can and should be shared among different routes.\n// See the example code in GitHub.\n//\n// For GET, POST, PUT, PATCH and DELETE requests the respective shortcut\n// functions can be used.\n//\n// This function is intended for bulk loading and to allow the usage of less\n// frequently used, non-standardized or custom methods (e.g. for internal\n// communication with a proxy).\nfunc (group *RouterGroup) Handle(httpMethod, relativePath string, handlers ...HandlerFunc) IRoutes {\n\tif matched := regEnLetter.MatchString(httpMethod); !matched {\n\t\tpanic(\"http method \" + httpMethod + \" is not valid\")\n\t}\n\treturn group.handle(httpMethod, relativePath, handlers)\n}\n\n// POST is a shortcut for router.Handle(\"POST\", path, handlers).\nfunc (group *RouterGroup) POST(relativePath string, handlers ...HandlerFunc) IRoutes {\n\treturn group.handle(http.MethodPost, relativePath, handlers)\n}\n\n// GET is a shortcut for router.Handle(\"GET\", path, handlers).\nfunc (group *RouterGroup) GET(relativePath string, handlers ...HandlerFunc) IRoutes {\n\treturn group.handle(http.MethodGet, relativePath, handlers)\n}\n\n// DELETE is a shortcut for router.Handle(\"DELETE\", path, handlers).\nfunc (group *RouterGroup) DELETE(relativePath string, handlers ...HandlerFunc) IRoutes {\n\treturn group.handle(http.MethodDelete, relativePath, handlers)\n}\n\n// PATCH is a shortcut for router.Handle(\"PATCH\", path, handlers).\nfunc (group *RouterGroup) PATCH(relativePath string, handlers ...HandlerFunc) IRoutes {\n\treturn group.handle(http.MethodPatch, relativePath, handlers)\n}\n\n// PUT is a shortcut for router.Handle(\"PUT\", path, handlers).\nfunc (group *RouterGroup) PUT(relativePath string, handlers ...HandlerFunc) IRoutes {\n\treturn group.handle(http.MethodPut, relativePath, handlers)\n}\n\n// OPTIONS is a shortcut for router.Handle(\"OPTIONS\", path, handlers).\nfunc (group *RouterGroup) OPTIONS(relativePath string, handlers ...HandlerFunc) IRoutes {\n\treturn group.handle(http.MethodOptions, relativePath, handlers)\n}\n\n// HEAD is a shortcut for router.Handle(\"HEAD\", path, handlers).\nfunc (group *RouterGroup) HEAD(relativePath string, handlers ...HandlerFunc) IRoutes {\n\treturn group.handle(http.MethodHead, relativePath, handlers)\n}\n\n// Any registers a route that matches all the HTTP methods.\n// GET, POST, PUT, PATCH, HEAD, OPTIONS, DELETE, CONNECT, TRACE.\nfunc (group *RouterGroup) Any(relativePath string, handlers ...HandlerFunc) IRoutes {\n\tfor _, method := range anyMethods {\n\t\tgroup.handle(method, relativePath, handlers)\n\t}\n\n\treturn group.returnObj()\n}\n\n// Match registers a route that matches the specified methods that you declared.\nfunc (group *RouterGroup) Match(methods []string, relativePath string, handlers ...HandlerFunc) IRoutes {\n\tfor _, method := range methods {\n\t\tgroup.handle(method, relativePath, handlers)\n\t}\n\n\treturn group.returnObj()\n}\n\n// StaticFile registers a single route in order to serve a single file of the local filesystem.\n// router.StaticFile(\"favicon.ico\", \"./resources/favicon.ico\")\nfunc (group *RouterGroup) StaticFile(relativePath, filepath string) IRoutes {\n\treturn group.staticFileHandler(relativePath, func(c *Context) {\n\t\tc.File(filepath)\n\t})\n}\n\n// StaticFileFS works just like `StaticFile` but a custom `http.FileSystem` can be used instead..\n// router.StaticFileFS(\"favicon.ico\", \"./resources/favicon.ico\", Dir{\".\", false})\n// Gin by default uses: gin.Dir()\nfunc (group *RouterGroup) StaticFileFS(relativePath, filepath string, fs http.FileSystem) IRoutes {\n\treturn group.staticFileHandler(relativePath, func(c *Context) {\n\t\tc.FileFromFS(filepath, fs)\n\t})\n}\n\nfunc (group *RouterGroup) staticFileHandler(relativePath string, handler HandlerFunc) IRoutes {\n\tif strings.Contains(relativePath, \":\") || strings.Contains(relativePath, \"*\") {\n\t\tpanic(\"URL parameters can not be used when serving a static file\")\n\t}\n\tgroup.GET(relativePath, handler)\n\tgroup.HEAD(relativePath, handler)\n\treturn group.returnObj()\n}\n\n// Static serves files from the given file system root.\n// Internally a http.FileServer is used, therefore http.NotFound is used instead\n// of the Router's NotFound handler.\n// To use the operating system's file system implementation,\n// use :\n//\n//\trouter.Static(\"/static\", \"/var/www\")\nfunc (group *RouterGroup) Static(relativePath, root string) IRoutes {\n\treturn group.StaticFS(relativePath, Dir(root, false))\n}\n\n// StaticFS works just like `Static()` but a custom `http.FileSystem` can be used instead.\n// Gin by default uses: gin.Dir()\nfunc (group *RouterGroup) StaticFS(relativePath string, fs http.FileSystem) IRoutes {\n\tif strings.Contains(relativePath, \":\") || strings.Contains(relativePath, \"*\") {\n\t\tpanic(\"URL parameters can not be used when serving a static folder\")\n\t}\n\thandler := group.createStaticHandler(relativePath, fs)\n\turlPattern := path.Join(relativePath, \"/*filepath\")\n\n\t// Register GET and HEAD handlers\n\tgroup.GET(urlPattern, handler)\n\tgroup.HEAD(urlPattern, handler)\n\treturn group.returnObj()\n}\n\nfunc (group *RouterGroup) createStaticHandler(relativePath string, fs http.FileSystem) HandlerFunc {\n\tabsolutePath := group.calculateAbsolutePath(relativePath)\n\tfileServer := http.StripPrefix(absolutePath, http.FileServer(fs))\n\n\treturn func(c *Context) {\n\t\tif _, noListing := fs.(*OnlyFilesFS); noListing {\n\t\t\tc.Writer.WriteHeader(http.StatusNotFound)\n\t\t}\n\n\t\tfile := c.Param(\"filepath\")\n\t\t// Check if file exists and/or if we have permission to access it\n\t\tf, err := fs.Open(file)\n\t\tif err != nil {\n\t\t\tc.Writer.WriteHeader(http.StatusNotFound)\n\t\t\tc.handlers = group.engine.noRoute\n\t\t\t// Reset index\n\t\t\tc.index = -1\n\t\t\treturn\n\t\t}\n\t\tf.Close()\n\n\t\tfileServer.ServeHTTP(c.Writer, c.Request)\n\t}\n}\n\nfunc (group *RouterGroup) combineHandlers(handlers HandlersChain) HandlersChain {\n\tfinalSize := len(group.Handlers) + len(handlers)\n\tassert1(finalSize < int(abortIndex), \"too many handlers\")\n\tmergedHandlers := make(HandlersChain, finalSize)\n\tcopy(mergedHandlers, group.Handlers)\n\tcopy(mergedHandlers[len(group.Handlers):], handlers)\n\treturn mergedHandlers\n}\n\nfunc (group *RouterGroup) calculateAbsolutePath(relativePath string) string {\n\treturn joinPaths(group.basePath, relativePath)\n}\n\nfunc (group *RouterGroup) returnObj() IRoutes {\n\tif group.root {\n\t\treturn group.engine\n\t}\n\treturn group\n}\n",
    "source_file": "routergroup.go",
    "chunk_type": "code"
  },
  {
    "content": "# Gin Web Framework\n\n<img align=\"right\" width=\"159px\" src=\"https://raw.githubusercontent.com/gin-gonic/logo/master/color.png\">\n\n[![Build Status](https://github.com/gin-gonic/gin/workflows/Run%20Tests/badge.svg?branch=master)](https://github.com/gin-gonic/gin/actions?query=branch%3Amaster)\n[![codecov](https://codecov.io/gh/gin-gonic/gin/branch/master/graph/badge.svg)](https://codecov.io/gh/gin-gonic/gin)\n[![Go Report Card](https://goreportcard.com/badge/github.com/gin-gonic/gin)](https://goreportcard.com/report/github.com/gin-gonic/gin)\n[![Go Reference](https://pkg.go.dev/badge/github.com/gin-gonic/gin?status.svg)](https://pkg.go.dev/github.com/gin-gonic/gin?tab=doc)\n[![Sourcegraph](https://sourcegraph.com/github.com/gin-gonic/gin/-/badge.svg)](https://sourcegraph.com/github.com/gin-gonic/gin?badge)\n[![Open Source Helpers](https://www.codetriage.com/gin-gonic/gin/badges/users.svg)](https://www.codetriage.com/gin-gonic/gin)\n[![Release](https://img.shields.io/github/release/gin-gonic/gin.svg?style=flat-square)](https://github.com/gin-gonic/gin/releases)\n[![TODOs](https://badgen.net/https/api.tickgit.com/badgen/github.com/gin-gonic/gin)](https://www.tickgit.com/browse?repo=github.com/gin-gonic/gin)\n\nGin is a web framework written in [Go](https://go.dev/). It features a martini-like API with performance that is up to 40 times faster thanks to [httprouter](https://github.com/julienschmidt/httprouter).\nIf you need performance and good productivity, you will love Gin.\n\n**Gin's key features are:**\n\n- Zero allocation router\n- Speed\n- Middleware support\n- Crash-free\n- JSON validation\n- Route grouping\n- Error management\n- Built-in rendering\n- Extensible\n",
    "source_file": "README.md",
    "chunk_type": "doc"
  },
  {
    "content": "## Getting started\n",
    "source_file": "README.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Prerequisites\n\nGin requires [Go](https://go.dev/) version [1.23](https://go.dev/doc/devel/release#go1.23.0) or above.\n",
    "source_file": "README.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Getting Gin\n\nWith [Go's module support](https://go.dev/wiki/Modules#how-to-use-modules), `go [build|run|test]` automatically fetches the necessary dependencies when you add the import in your code:\n\n```sh\nimport \"github.com/gin-gonic/gin\"\n```\n\nAlternatively, use `go get`:\n\n```sh\ngo get -u github.com/gin-gonic/gin\n```\n",
    "source_file": "README.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Running Gin\n\nA basic example:\n\n```go\npackage main\n\nimport (\n  \"net/http\"\n\n  \"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n  r := gin.Default()\n  r.GET(\"/ping\", func(c *gin.Context) {\n    c.JSON(http.StatusOK, gin.H{\n      \"message\": \"pong\",\n    })\n  })\n  r.Run() // listen and serve on 0.0.0.0:8080 (for windows \"localhost:8080\")\n}\n```\n\nTo run the code, use the `go run` command, like:\n\n```sh\ngo run example.go\n```\n\nThen visit [`0.0.0.0:8080/ping`](http://0.0.0.0:8080/ping) in your browser to see the response!\n",
    "source_file": "README.md",
    "chunk_type": "doc"
  },
  {
    "content": "### See more examples\n",
    "source_file": "README.md",
    "chunk_type": "doc"
  },
  {
    "content": "#### Quick Start\n\nLearn and practice with the [Gin Quick Start](docs/doc.md), which includes API examples and builds tag.\n",
    "source_file": "README.md",
    "chunk_type": "doc"
  },
  {
    "content": "#### Examples\n\nA number of ready-to-run examples demonstrating various use cases of Gin are available in the [Gin examples](https://github.com/gin-gonic/examples) repository.\n",
    "source_file": "README.md",
    "chunk_type": "doc"
  },
  {
    "content": "## Documentation\n\nSee the [API documentation on go.dev](https://pkg.go.dev/github.com/gin-gonic/gin).\n\nThe documentation is also available on [gin-gonic.com](https://gin-gonic.com) in several languages:\n\n- [English](https://gin-gonic.com/en/docs/)\n- [\u7b80\u4f53\u4e2d\u6587](https://gin-gonic.com/zh-cn/docs/)\n- [\u7e41\u9ad4\u4e2d\u6587](https://gin-gonic.com/zh-tw/docs/)\n- [\u65e5\u672c\u8a9e](https://gin-gonic.com/ja/docs/)\n- [Espa\u00f1ol](https://gin-gonic.com/es/docs/)\n- [\ud55c\uad6d\uc5b4](https://gin-gonic.com/ko-kr/docs/)\n- [Turkish](https://gin-gonic.com/tr/docs/)\n- [Persian](https://gin-gonic.com/fa/docs/)\n- [Portugu\u00eas](https://gin-gonic.com/pt/docs/)\n- [Russian](https://gin-gonic.com/ru/docs/)\n",
    "source_file": "README.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Articles\n\n- [Tutorial: Developing a RESTful API with Go and Gin](https://go.dev/doc/tutorial/web-service-gin)\n",
    "source_file": "README.md",
    "chunk_type": "doc"
  },
  {
    "content": "## Benchmarks\n\nGin uses a custom version of [HttpRouter](https://github.com/julienschmidt/httprouter), [see all benchmarks](/BENCHMARKS.md).\n\n| Benchmark name                 |       (1) |             (2) |          (3) |             (4) |\n| ------------------------------ | --------: | --------------: | -----------: | --------------: |\n| BenchmarkGin_GithubAll         | **43550** | **27364 ns/op** |   **0 B/op** | **0 allocs/op** |\n| BenchmarkAce_GithubAll         |     40543 |     29670 ns/op |       0 B/op |     0 allocs/op |\n| BenchmarkAero_GithubAll        |     57632 |     20648 ns/op |       0 B/op |     0 allocs/op |\n| BenchmarkBear_GithubAll        |      9234 |    216179 ns/op |   86448 B/op |   943 allocs/op |\n| BenchmarkBeego_GithubAll       |      7407 |    243496 ns/op |   71456 B/op |   609 allocs/op |\n| BenchmarkBone_GithubAll        |       420 |   2922835 ns/op |  720160 B/op |  8620 allocs/op |\n| BenchmarkChi_GithubAll         |      7620 |    238331 ns/op |   87696 B/op |   609 allocs/op |\n| BenchmarkDenco_GithubAll       |     18355 |     64494 ns/op |   20224 B/op |   167 allocs/op |\n| BenchmarkEcho_GithubAll        |     31251 |     38479 ns/op |       0 B/op |     0 allocs/op |\n| BenchmarkGocraftWeb_GithubAll  |      4117 |    300062 ns/op |  131656 B/op |  1686 allocs/op |\n| BenchmarkGoji_GithubAll        |      3274 |    416158 ns/op |   56112 B/op |   334 allocs/op |\n| BenchmarkGojiv2_GithubAll      |      1402 |    870518 ns/op |  352720 B/op |  4321 allocs/op |\n| BenchmarkGoJsonRest_GithubAll  |      2976 |    401507 ns/op |  134371 B/op |  2737 allocs/op |\n| BenchmarkGoRestful_GithubAll   |       410 |   2913158 ns/op |  910144 B/op |  2938 allocs/op |\n| BenchmarkGorillaMux_GithubAll  |       346 |   3384987 ns/op |  251650 B/op |  1994 allocs/op |\n| BenchmarkGowwwRouter_GithubAll |     10000 |    143025 ns/op |   72144 B/op |   501 allocs/op |\n| BenchmarkHttpRouter_GithubAll  |     55938 |     21360 ns/op |       0 B/op |     0 allocs/op |\n| BenchmarkHttpTreeMux_GithubAll |     10000 |    153944 ns/op |   65856 B/op |   671 allocs/op |\n| BenchmarkKocha_GithubAll       |     10000 |    106315 ns/op |   23304 B/op |   843 allocs/op |\n| BenchmarkLARS_GithubAll        |     47779 |     25084 ns/op |       0 B/op |     0 allocs/op |\n| BenchmarkMacaron_GithubAll     |      3266 |    371907 ns/op |  149409 B/op |  1624 allocs/op |\n| BenchmarkMartini_GithubAll     |       331 |   3444706 ns/op |  226551 B/op |  2325 allocs/op |\n| BenchmarkPat_GithubAll         |       273 |   4381818 ns/op | 1483152 B/op | 26963 allocs/op |\n| BenchmarkPossum_GithubAll      |     10000 |    164367 ns/op |   84448 B/op |   609 allocs/op |\n| BenchmarkR2router_GithubAll    |     10000 |    160220 ns/op |   77328 B/op |   979 allocs/op |\n| BenchmarkRivet_GithubAll       |     14625 |     82453 ns/op |   16272 B/op |   167 allocs/op |\n| BenchmarkTango_GithubAll       |      6255 |    279611 ns/op |   63826 B/op |  1618 allocs/op |\n| BenchmarkTigerTonic_GithubAll  |      2008 |    687874 ns/op |  193856 B/op |  4474 allocs/op |\n| BenchmarkTraffic_GithubAll     |       355 |   3478508 ns/op |  820744 B/op | 14114 allocs/op |\n| BenchmarkVulcan_GithubAll      |      6885 |    193333 ns/op |   19894 B/op |   609 allocs/op |\n\n- (1): Total Repetitions achieved in constant time, higher means more confident result\n- (2): Single Repetition Duration (ns/op), lower is better\n- (3): Heap Memory (B/op), lower is better\n- (4): Average Allocations per Repetition (allocs/op), lower is better\n",
    "source_file": "README.md",
    "chunk_type": "doc"
  },
  {
    "content": "## Middleware\n\nYou can find many useful Gin middlewares at [gin-contrib](https://github.com/gin-contrib) and [gin-gonic/contrib](https://github.com/gin-gonic/contrib).\n",
    "source_file": "README.md",
    "chunk_type": "doc"
  },
  {
    "content": "## Uses\n\nHere are some awesome projects that are using the [Gin](https://github.com/gin-gonic/gin) web framework.\n\n- [gorush](https://github.com/appleboy/gorush): A push notification server.\n- [fnproject](https://github.com/fnproject/fn): A container native, cloud agnostic serverless platform.\n- [photoprism](https://github.com/photoprism/photoprism): Personal photo management powered by Google TensorFlow.\n- [lura](https://github.com/luraproject/lura): Ultra performant API Gateway with middleware.\n- [picfit](https://github.com/thoas/picfit): An image resizing server.\n- [dkron](https://github.com/distribworks/dkron): Distributed, fault tolerant job scheduling system.\n",
    "source_file": "README.md",
    "chunk_type": "doc"
  },
  {
    "content": "## Contributing\n\nGin is the work of hundreds of contributors. We appreciate your help!\n\nPlease see [CONTRIBUTING.md](CONTRIBUTING.md) for details on submitting patches and the contribution workflow.",
    "source_file": "README.md",
    "chunk_type": "doc"
  },
  {
    "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"fmt\"\n\t\"html/template\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync/atomic\"\n)\n\nconst ginSupportMinGoVer = 21\n\n// IsDebugging returns true if the framework is running in debug mode.\n// Use SetMode(gin.ReleaseMode) to disable debug mode.\nfunc IsDebugging() bool {\n\treturn atomic.LoadInt32(&ginMode) == debugCode\n}\n\n// DebugPrintRouteFunc indicates debug log output format.\nvar DebugPrintRouteFunc func(httpMethod, absolutePath, handlerName string, nuHandlers int)\n\n// DebugPrintFunc indicates debug log output format.\nvar DebugPrintFunc func(format string, values ...any)\n\nfunc debugPrintRoute(httpMethod, absolutePath string, handlers HandlersChain) {\n\tif IsDebugging() {\n\t\tnuHandlers := len(handlers)\n\t\thandlerName := nameOfFunction(handlers.Last())\n\t\tif DebugPrintRouteFunc == nil {\n\t\t\tdebugPrint(\"%-6s %-25s --> %s (%d handlers)\\n\", httpMethod, absolutePath, handlerName, nuHandlers)\n\t\t} else {\n\t\t\tDebugPrintRouteFunc(httpMethod, absolutePath, handlerName, nuHandlers)\n\t\t}\n\t}\n}\n\nfunc debugPrintLoadTemplate(tmpl *template.Template) {\n\tif IsDebugging() {\n\t\tvar buf strings.Builder\n\t\tfor _, tmpl := range tmpl.Templates() {\n\t\t\tbuf.WriteString(\"\\t- \")\n\t\t\tbuf.WriteString(tmpl.Name())\n\t\t\tbuf.WriteString(\"\\n\")\n\t\t}\n\t\tdebugPrint(\"Loaded HTML Templates (%d): \\n%s\\n\", len(tmpl.Templates()), buf.String())\n\t}\n}\n\nfunc debugPrint(format string, values ...any) {\n\tif !IsDebugging() {\n\t\treturn\n\t}\n\n\tif DebugPrintFunc != nil {\n\t\tDebugPrintFunc(format, values...)\n\t\treturn\n\t}\n\n\tif !strings.HasSuffix(format, \"\\n\") {\n\t\tformat += \"\\n\"\n\t}\n\tfmt.Fprintf(DefaultWriter, \"[GIN-debug] \"+format, values...)\n}\n\nfunc getMinVer(v string) (uint64, error) {\n\tfirst := strings.IndexByte(v, '.')\n\tlast := strings.LastIndexByte(v, '.')\n\tif first == last {\n\t\treturn strconv.ParseUint(v[first+1:], 10, 64)\n\t}\n\treturn strconv.ParseUint(v[first+1:last], 10, 64)\n}\n\nfunc debugPrintWARNINGDefault() {\n\tif v, e := getMinVer(runtime.Version()); e == nil && v < ginSupportMinGoVer {\n\t\tdebugPrint(`[WARNING] Now Gin requires Go 1.23+.\n\n`)\n\t}\n\tdebugPrint(`[WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.\n\n`)\n}\n\nfunc debugPrintWARNINGNew() {\n\tdebugPrint(`[WARNING] Running in \"debug\" mode. Switch to \"release\" mode in production.\n - using env:\texport GIN_MODE=release\n - using code:\tgin.SetMode(gin.ReleaseMode)\n\n`)\n}\n\nfunc debugPrintWARNINGSetHTMLTemplate() {\n\tdebugPrint(`[WARNING] Since SetHTMLTemplate() is NOT thread-safe. It should only be called\nat initialization. ie. before any route is registered or the router is listening in a socket:\n\n\trouter := gin.Default()\n\trouter.SetHTMLTemplate(template) // << good place\n\n`)\n}\n\nfunc debugPrintError(err error) {\n\tif err != nil && IsDebugging() {\n\t\tfmt.Fprintf(DefaultErrorWriter, \"[GIN-debug] [ERROR] %v\\n\", err)\n\t}\n}\n",
    "source_file": "debug.go",
    "chunk_type": "code"
  },
  {
    "content": "/*\nPackage gin implements a HTTP web framework called gin.\n\nSee https://gin-gonic.com/ for more information about gin.\n*/\npackage gin // import \"github.com/gin-gonic/gin\"\n",
    "source_file": "doc.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2017 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"net/http\"\n\t\"os\"\n)\n\n// OnlyFilesFS implements an http.FileSystem without `Readdir` functionality.\ntype OnlyFilesFS struct {\n\tFileSystem http.FileSystem\n}\n\n// Open passes `Open` to the upstream implementation without `Readdir` functionality.\nfunc (o OnlyFilesFS) Open(name string) (http.File, error) {\n\tf, err := o.FileSystem.Open(name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn neutralizedReaddirFile{f}, nil\n}\n\n// neutralizedReaddirFile wraps http.File with a specific implementation of `Readdir`.\ntype neutralizedReaddirFile struct {\n\thttp.File\n}\n\n// Readdir overrides the http.File default implementation and always returns nil.\nfunc (n neutralizedReaddirFile) Readdir(_ int) ([]os.FileInfo, error) {\n\t// this disables directory listing\n\treturn nil, nil\n}\n\n// Dir returns an http.FileSystem that can be used by http.FileServer().\n// It is used internally in router.Static().\n// if listDirectory == true, then it works the same as http.Dir(),\n// otherwise it returns a filesystem that prevents http.FileServer() to list the directory files.\nfunc Dir(root string, listDirectory bool) http.FileSystem {\n\tfs := http.Dir(root)\n\n\tif listDirectory {\n\t\treturn fs\n\t}\n\n\treturn &OnlyFilesFS{FileSystem: fs}\n}\n",
    "source_file": "fs.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/fs\"\n\t\"log\"\n\t\"math\"\n\t\"mime/multipart\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/gin-contrib/sse\"\n\t\"github.com/gin-gonic/gin/binding\"\n\t\"github.com/gin-gonic/gin/render\"\n)\n\n// Content-Type MIME of the most common data formats.\nconst (\n\tMIMEJSON              = binding.MIMEJSON\n\tMIMEHTML              = binding.MIMEHTML\n\tMIMEXML               = binding.MIMEXML\n\tMIMEXML2              = binding.MIMEXML2\n\tMIMEPlain             = binding.MIMEPlain\n\tMIMEPOSTForm          = binding.MIMEPOSTForm\n\tMIMEMultipartPOSTForm = binding.MIMEMultipartPOSTForm\n\tMIMEYAML              = binding.MIMEYAML\n\tMIMEYAML2             = binding.MIMEYAML2\n\tMIMETOML              = binding.MIMETOML\n)\n\n// BodyBytesKey indicates a default body bytes key.\nconst BodyBytesKey = \"_gin-gonic/gin/bodybyteskey\"\n\n// ContextKey is the key that a Context returns itself for.\nconst ContextKey = \"_gin-gonic/gin/contextkey\"\n\ntype ContextKeyType int\n\nconst ContextRequestKey ContextKeyType = 0\n\n// abortIndex represents a typical value used in abort functions.\nconst abortIndex int8 = math.MaxInt8 >> 1\n\n// Context is the most important part of gin. It allows us to pass variables between middleware,\n// manage the flow, validate the JSON of a request and render a JSON response for example.\ntype Context struct {\n\twritermem responseWriter\n\tRequest   *http.Request\n\tWriter    ResponseWriter\n\n\tParams   Params\n\thandlers HandlersChain\n\tindex    int8\n\tfullPath string\n\n\tengine       *Engine\n\tparams       *Params\n\tskippedNodes *[]skippedNode\n\n\t// This mutex protects Keys map.\n\tmu sync.RWMutex\n\n\t// Keys is a key/value pair exclusively for the context of each request.\n\tKeys map[any]any\n\n\t// Errors is a list of errors attached to all the handlers/middlewares who used this context.\n\tErrors errorMsgs\n\n\t// Accepted defines a list of manually accepted formats for content negotiation.\n\tAccepted []string\n\n\t// queryCache caches the query result from c.Request.URL.Query().\n\tqueryCache url.Values\n\n\t// formCache caches c.Request.PostForm, which contains the parsed form data from POST, PATCH,\n\t// or PUT body parameters.\n\tformCache url.Values\n\n\t// SameSite allows a server to define a cookie attribute making it impossible for\n\t// the browser to send this cookie along with cross-site requests.\n\tsameSite http.SameSite\n}\n\n/************************************/\n/********** CONTEXT CREATION ********/\n/************************************/\n\nfunc (c *Context) reset() {\n\tc.Writer = &c.writermem\n\tc.Params = c.Params[:0]\n\tc.handlers = nil\n\tc.index = -1\n\n\tc.fullPath = \"\"\n\tc.Keys = nil\n\tc.Errors = c.Errors[:0]\n\tc.Accepted = nil\n\tc.queryCache = nil\n\tc.formCache = nil\n\tc.sameSite = 0\n\t*c.params = (*c.params)[:0]\n\t*c.skippedNodes = (*c.skippedNodes)[:0]\n}\n\n// Copy returns a copy of the current context that can be safely used outside the request's scope.\n// This has to be used when the context has to be passed to a goroutine.\nfunc (c *Context) Copy() *Context {\n\tcp := Context{\n\t\twritermem: c.writermem,\n\t\tRequest:   c.Request,\n\t\tengine:    c.engine,\n\t}\n\n\tcp.writermem.ResponseWriter = nil\n\tcp.Writer = &cp.writermem\n\tcp.index = abortIndex\n\tcp.handlers = nil\n\tcp.fullPath = c.fullPath\n\n\tcKeys := c.Keys\n\tcp.Keys = make(map[any]any, len(cKeys))\n\tc.mu.RLock()\n\tfor k, v := range cKeys {\n\t\tcp.Keys[k] = v\n\t}\n\tc.mu.RUnlock()\n\n\tcParams := c.Params\n\tcp.Params = make([]Param, len(cParams))\n\tcopy(cp.Params, cParams)\n\n\treturn &cp\n}\n\n// HandlerName returns the main handler's name. For example if the handler is \"handleGetUsers()\",\n// this function will return \"main.handleGetUsers\".\nfunc (c *Context) HandlerName() string {\n\treturn nameOfFunction(c.handlers.Last())\n}\n\n// HandlerNames returns a list of all registered handlers for this context in descending order,\n// following the semantics of HandlerName()\nfunc (c *Context) HandlerNames() []string {\n\thn := make([]string, 0, len(c.handlers))\n\tfor _, val := range c.handlers {\n\t\tif val == nil {\n\t\t\tcontinue\n\t\t}\n\t\thn = append(hn, nameOfFunction(val))\n\t}\n\treturn hn\n}\n\n// Handler returns the main handler.\nfunc (c *Context) Handler() HandlerFunc {\n\treturn c.handlers.Last()\n}\n\n// FullPath returns a matched route full path. For not found routes\n// returns an empty string.\n//\n//\trouter.GET(\"/user/:id\", func(c *gin.Context) {\n//\t    c.FullPath() == \"/user/:id\" // true\n//\t})\nfunc (c *Context) FullPath() string {\n\treturn c.fullPath\n}\n\n/************************************/\n/*********** FLOW CONTROL ***********/\n/************************************/\n\n// Next should be used only inside middleware.\n// It executes the pending handlers in the chain inside the calling handler.\n// See example in GitHub.\nfunc (c *Context) Next() {\n\tc.index++\n\tfor c.index < int8(len(c.handlers)) {\n\t\tif c.handlers[c.index] != nil {\n\t\t\tc.handlers[c.index](c)\n\t\t}\n\t\tc.index++\n\t}\n}\n\n// IsAborted returns true if the current context was aborted.\nfunc (c *Context) IsAborted() bool {\n\treturn c.index >= abortIndex\n}\n\n// Abort prevents pending handlers from being called. Note that this will not stop the current handler.\n// Let's say you have an authorization middleware that validates that the current request is authorized.\n// If the authorization fails (ex: the password does not match), call Abort to ensure the remaining handlers\n// for this request are not called.\nfunc (c *Context) Abort() {\n\tc.index = abortIndex\n}\n\n// AbortWithStatus calls `Abort()` and writes the headers with the specified status code.\n// For example, a failed attempt to authenticate a request could use: context.AbortWithStatus(401).\nfunc (c *Context) AbortWithStatus(code int) {\n\tc.Status(code)\n\tc.Writer.WriteHeaderNow()\n\tc.Abort()\n}\n\n// AbortWithStatusJSON calls `Abort()` and then `JSON` internally.\n// This method stops the chain, writes the status code and return a JSON body.\n// It also sets the Content-Type as \"application/json\".\nfunc (c *Context) AbortWithStatusJSON(code int, jsonObj any) {\n\tc.Abort()\n\tc.JSON(code, jsonObj)\n}\n\n// AbortWithError calls `AbortWithStatus()` and `Error()` internally.\n// This method stops the chain, writes the status code and pushes the specified error to `c.Errors`.\n// See Context.Error() for more details.\nfunc (c *Context) AbortWithError(code int, err error) *Error {\n\tc.AbortWithStatus(code)\n\treturn c.Error(err)\n}\n\n/************************************/\n/********* ERROR MANAGEMENT *********/\n/************************************/\n\n// Error attaches an error to the current context. The error is pushed to a list of errors.\n// It's a good idea to call Error for each error that occurred during the resolution of a request.\n// A middleware can be used to collect all the errors and push them to a database together,\n// print a log, or append it in the HTTP response.\n// Error will panic if err is nil.\nfunc (c *Context) Error(err error) *Error {\n\tif err == nil {\n\t\tpanic(\"err is nil\")\n\t}\n\n\tvar parsedError *Error\n\tok := errors.As(err, &parsedError)\n\tif !ok {\n\t\tparsedError = &Error{\n\t\t\tErr:  err,\n\t\t\tType: ErrorTypePrivate,\n\t\t}\n\t}\n\n\tc.Errors = append(c.Errors, parsedError)\n\treturn parsedError\n}\n\n/************************************/\n/******** METADATA MANAGEMENT********/\n/************************************/\n\n// Set is used to store a new key/value pair exclusively for this context.\n// It also lazy initializes  c.Keys if it was not used previously.\nfunc (c *Context) Set(key any, value any) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tif c.Keys == nil {\n\t\tc.Keys = make(map[any]any)\n\t}\n\n\tc.Keys[key] = value\n}\n\n// Get returns the value for the given key, ie: (value, true).\n// If the value does not exist it returns (nil, false)\nfunc (c *Context) Get(key any) (value any, exists bool) {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\tvalue, exists = c.Keys[key]\n\treturn\n}\n\n// MustGet returns the value for the given key if it exists, otherwise it panics.\nfunc (c *Context) MustGet(key any) any {\n\tif value, exists := c.Get(key); exists {\n\t\treturn value\n\t}\n\tpanic(fmt.Sprintf(\"key %v does not exist\", key))\n}\n\nfunc getTyped[T any](c *Context, key any) (res T) {\n\tif val, ok := c.Get(key); ok && val != nil {\n\t\tres, _ = val.(T)\n\t}\n\treturn\n}\n\n// GetString returns the value associated with the key as a string.\nfunc (c *Context) GetString(key any) (s string) {\n\treturn getTyped[string](c, key)\n}\n\n// GetBool returns the value associated with the key as a boolean.\nfunc (c *Context) GetBool(key any) (b bool) {\n\treturn getTyped[bool](c, key)\n}\n\n// GetInt returns the value associated with the key as an integer.\nfunc (c *Context) GetInt(key any) (i int) {\n\treturn getTyped[int](c, key)\n}\n\n// GetInt8 returns the value associated with the key as an integer 8.\nfunc (c *Context) GetInt8(key any) (i8 int8) {\n\treturn getTyped[int8](c, key)\n}\n\n// GetInt16 returns the value associated with the key as an integer 16.\nfunc (c *Context) GetInt16(key any) (i16 int16) {\n\treturn getTyped[int16](c, key)\n}\n\n// GetInt32 returns the value associated with the key as an integer 32.\nfunc (c *Context) GetInt32(key any) (i32 int32) {\n\treturn getTyped[int32](c, key)\n}\n\n// GetInt64 returns the value associated with the key as an integer 64.\nfunc (c *Context) GetInt64(key any) (i64 int64) {\n\treturn getTyped[int64](c, key)\n}\n\n// GetUint returns the value associated with the key as an unsigned integer.\nfunc (c *Context) GetUint(key any) (ui uint) {\n\treturn getTyped[uint](c, key)\n}\n\n// GetUint8 returns the value associated with the key as an unsigned integer 8.\nfunc (c *Context) GetUint8(key any) (ui8 uint8) {\n\treturn getTyped[uint8](c, key)\n}\n\n// GetUint16 returns the value associated with the key as an unsigned integer 16.\nfunc (c *Context) GetUint16(key any) (ui16 uint16) {\n\treturn getTyped[uint16](c, key)\n}\n\n// GetUint32 returns the value associated with the key as an unsigned integer 32.\nfunc (c *Context) GetUint32(key any) (ui32 uint32) {\n\treturn getTyped[uint32](c, key)\n}\n\n// GetUint64 returns the value associated with the key as an unsigned integer 64.\nfunc (c *Context) GetUint64(key any) (ui64 uint64) {\n\treturn getTyped[uint64](c, key)\n}\n\n// GetFloat32 returns the value associated with the key as a float32.\nfunc (c *Context) GetFloat32(key any) (f32 float32) {\n\treturn getTyped[float32](c, key)\n}\n\n// GetFloat64 returns the value associated with the key as a float64.\nfunc (c *Context) GetFloat64(key any) (f64 float64) {\n\treturn getTyped[float64](c, key)\n}\n\n// GetTime returns the value associated with the key as time.\nfunc (c *Context) GetTime(key any) (t time.Time) {\n\treturn getTyped[time.Time](c, key)\n}\n\n// GetDuration returns the value associated with the key as a duration.\nfunc (c *Context) GetDuration(key any) (d time.Duration) {\n\treturn getTyped[time.Duration](c, key)\n}\n\n// GetIntSlice returns the value associated with the key as a slice of integers.\nfunc (c *Context) GetIntSlice(key any) (is []int) {\n\treturn getTyped[[]int](c, key)\n}\n\n// GetInt8Slice returns the value associated with the key as a slice of int8 integers.\nfunc (c *Context) GetInt8Slice(key any) (i8s []int8) {\n\treturn getTyped[[]int8](c, key)\n}\n\n// GetInt16Slice returns the value associated with the key as a slice of int16 integers.\nfunc (c *Context) GetInt16Slice(key any) (i16s []int16) {\n\treturn getTyped[[]int16](c, key)\n}\n\n// GetInt32Slice returns the value associated with the key as a slice of int32 integers.\nfunc (c *Context) GetInt32Slice(key any) (i32s []int32) {\n\treturn getTyped[[]int32](c, key)\n}\n\n// GetInt64Slice returns the value associated with the key as a slice of int64 integers.\nfunc (c *Context) GetInt64Slice(key any) (i64s []int64) {\n\treturn getTyped[[]int64](c, key)\n}\n\n// GetUintSlice returns the value associated with the key as a slice of unsigned integers.\nfunc (c *Context) GetUintSlice(key any) (uis []uint) {\n\treturn getTyped[[]uint](c, key)\n}\n\n// GetUint8Slice returns the value associated with the key as a slice of uint8 integers.\nfunc (c *Context) GetUint8Slice(key any) (ui8s []uint8) {\n\treturn getTyped[[]uint8](c, key)\n}\n\n// GetUint16Slice returns the value associated with the key as a slice of uint16 integers.\nfunc (c *Context) GetUint16Slice(key any) (ui16s []uint16) {\n\treturn getTyped[[]uint16](c, key)\n}\n\n// GetUint32Slice returns the value associated with the key as a slice of uint32 integers.\nfunc (c *Context) GetUint32Slice(key any) (ui32s []uint32) {\n\treturn getTyped[[]uint32](c, key)\n}\n\n// GetUint64Slice returns the value associated with the key as a slice of uint64 integers.\nfunc (c *Context) GetUint64Slice(key any) (ui64s []uint64) {\n\treturn getTyped[[]uint64](c, key)\n}\n\n// GetFloat32Slice returns the value associated with the key as a slice of float32 numbers.\nfunc (c *Context) GetFloat32Slice(key any) (f32s []float32) {\n\treturn getTyped[[]float32](c, key)\n}\n\n// GetFloat64Slice returns the value associated with the key as a slice of float64 numbers.\nfunc (c *Context) GetFloat64Slice(key any) (f64s []float64) {\n\treturn getTyped[[]float64](c, key)\n}\n\n// GetStringSlice returns the value associated with the key as a slice of strings.\nfunc (c *Context) GetStringSlice(key any) (ss []string) {\n\treturn getTyped[[]string](c, key)\n}\n\n// GetStringMap returns the value associated with the key as a map of interfaces.\nfunc (c *Context) GetStringMap(key any) (sm map[string]any) {\n\treturn getTyped[map[string]any](c, key)\n}\n\n// GetStringMapString returns the value associated with the key as a map of strings.\nfunc (c *Context) GetStringMapString(key any) (sms map[string]string) {\n\treturn getTyped[map[string]string](c, key)\n}\n\n// GetStringMapStringSlice returns the value associated with the key as a map to a slice of strings.\nfunc (c *Context) GetStringMapStringSlice(key any) (smss map[string][]string) {\n\treturn getTyped[map[string][]string](c, key)\n}\n\n/************************************/\n/************ INPUT DATA ************/\n/************************************/\n\n// Param returns the value of the URL param.\n// It is a shortcut for c.Params.ByName(key)\n//\n//\trouter.GET(\"/user/:id\", func(c *gin.Context) {\n//\t    // a GET request to /user/john\n//\t    id := c.Param(\"id\") // id == \"john\"\n//\t    // a GET request to /user/john/\n//\t    id := c.Param(\"id\") // id == \"/john/\"\n//\t})\nfunc (c *Context) Param(key string) string {\n\treturn c.Params.ByName(key)\n}\n\n// AddParam adds param to context and\n// replaces path param key with given value for e2e testing purposes\n// Example Route: \"/user/:id\"\n// AddParam(\"id\", 1)\n// Result: \"/user/1\"\nfunc (c *Context) AddParam(key, value string) {\n\tc.Params = append(c.Params, Param{Key: key, Value: value})\n}\n\n// Query returns the keyed url query value if it exists,\n// otherwise it returns an empty string `(\"\")`.\n// It is shortcut for `c.Request.URL.Query().Get(key)`\n//\n//\t    GET /path?id=1234&name=Manu&value=\n//\t\t   c.Query(\"id\") == \"1234\"\n//\t\t   c.Query(\"name\") == \"Manu\"\n//\t\t   c.Query(\"value\") == \"\"\n//\t\t   c.Query(\"wtf\") == \"\"\nfunc (c *Context) Query(key string) (value string) {\n\tvalue, _ = c.GetQuery(key)\n\treturn\n}\n\n// DefaultQuery returns the keyed url query value if it exists,\n// otherwise it returns the specified defaultValue string.\n// See: Query() and GetQuery() for further information.\n//\n//\tGET /?name=Manu&lastname=\n//\tc.DefaultQuery(\"name\", \"unknown\") == \"Manu\"\n//\tc.DefaultQuery(\"id\", \"none\") == \"none\"\n//\tc.DefaultQuery(\"lastname\", \"none\") == \"\"\nfunc (c *Context) DefaultQuery(key, defaultValue string) string {\n\tif value, ok := c.GetQuery(key); ok {\n\t\treturn value\n\t}\n\treturn defaultValue\n}\n\n// GetQuery is like Query(), it returns the keyed url query value\n// if it exists `(value, true)` (even when the value is an empty string),\n// otherwise it returns `(\"\", false)`.\n// It is shortcut for `c.Request.URL.Query().Get(key)`\n//\n//\tGET /?name=Manu&lastname=\n//\t(\"Manu\", true) == c.GetQuery(\"name\")\n//\t(\"\", false) == c.GetQuery(\"id\")\n//\t(\"\", true) == c.GetQuery(\"lastname\")\nfunc (c *Context) GetQuery(key string) (string, bool) {\n\tif values, ok := c.GetQueryArray(key); ok {\n\t\treturn values[0], ok\n\t}\n\treturn \"\", false\n}\n\n// QueryArray returns a slice of strings for a given query key.\n// The length of the slice depends on the number of params with the given key.\nfunc (c *Context) QueryArray(key string) (values []string) {\n\tvalues, _ = c.GetQueryArray(key)\n\treturn\n}\n\nfunc (c *Context) initQueryCache() {\n\tif c.queryCache == nil {\n\t\tif c.Request != nil && c.Request.URL != nil {\n\t\t\tc.queryCache = c.Request.URL.Query()\n\t\t} else {\n\t\t\tc.queryCache = url.Values{}\n\t\t}\n\t}\n}\n\n// GetQueryArray returns a slice of strings for a given query key, plus\n// a boolean value whether at least one value exists for the given key.\nfunc (c *Context) GetQueryArray(key string) (values []string, ok bool) {\n\tc.initQueryCache()\n\tvalues, ok = c.queryCache[key]\n\treturn\n}\n\n// QueryMap returns a map for a given query key.\nfunc (c *Context) QueryMap(key string) (dicts map[string]string) {\n\tdicts, _ = c.GetQueryMap(key)\n\treturn\n}\n\n// GetQueryMap returns a map for a given query key, plus a boolean value\n// whether at least one value exists for the given key.\nfunc (c *Context) GetQueryMap(key string) (map[string]string, bool) {\n\tc.initQueryCache()\n\treturn c.get(c.queryCache, key)\n}\n\n// PostForm returns the specified key from a POST urlencoded form or multipart form\n// when it exists, otherwise it returns an empty string `(\"\")`.\nfunc (c *Context) PostForm(key string) (value string) {\n\tvalue, _ = c.GetPostForm(key)\n\treturn\n}\n\n// DefaultPostForm returns the specified key from a POST urlencoded form or multipart form\n// when it exists, otherwise it returns the specified defaultValue string.\n// See: PostForm() and GetPostForm() for further information.\nfunc (c *Context) DefaultPostForm(key, defaultValue string) string {\n\tif value, ok := c.GetPostForm(key); ok {\n\t\treturn value\n\t}\n\treturn defaultValue\n}\n\n// GetPostForm is like PostForm(key). It returns the specified key from a POST urlencoded\n// form or multipart form when it exists `(value, true)` (even when the value is an empty string),\n// otherwise it returns (\"\", false).\n// For example, during a PATCH request to update the user's email:\n//\n//\t    email=mail@example.com  -->  (\"mail@example.com\", true) := GetPostForm(\"email\") // set email to \"mail@example.com\"\n//\t\t   email=                  -->  (\"\", true) := GetPostForm(\"email\") // set email to \"\"\n//\t                            -->  (\"\", false) := GetPostForm(\"email\") // do nothing with email\nfunc (c *Context) GetPostForm(key string) (string, bool) {\n\tif values, ok := c.GetPostFormArray(key); ok {\n\t\treturn values[0], ok\n\t}\n\treturn \"\", false\n}\n\n// PostFormArray returns a slice of strings for a given form key.\n// The length of the slice depends on the number of params with the given key.\nfunc (c *Context) PostFormArray(key string) (values []string) {\n\tvalues, _ = c.GetPostFormArray(key)\n\treturn\n}\n\nfunc (c *Context) initFormCache() {\n\tif c.formCache == nil {\n\t\tc.formCache = make(url.Values)\n\t\treq := c.Request\n\t\tif err := req.ParseMultipartForm(c.engine.MaxMultipartMemory); err != nil {\n\t\t\tif !errors.Is(err, http.ErrNotMultipart) {\n\t\t\t\tdebugPrint(\"error on parse multipart form array: %v\", err)\n\t\t\t}\n\t\t}\n\t\tc.formCache = req.PostForm\n\t}\n}\n\n// GetPostFormArray returns a slice of strings for a given form key, plus\n// a boolean value whether at least one value exists for the given key.\nfunc (c *Context) GetPostFormArray(key string) (values []string, ok bool) {\n\tc.initFormCache()\n\tvalues, ok = c.formCache[key]\n\treturn\n}\n\n// PostFormMap returns a map for a given form key.\nfunc (c *Context) PostFormMap(key string) (dicts map[string]string) {\n\tdicts, _ = c.GetPostFormMap(key)\n\treturn\n}\n\n// GetPostFormMap returns a map for a given form key, plus a boolean value\n// whether at least one value exists for the given key.\nfunc (c *Context) GetPostFormMap(key string) (map[string]string, bool) {\n\tc.initFormCache()\n\treturn c.get(c.formCache, key)\n}\n\n// get is an internal method and returns a map which satisfies conditions.\nfunc (c *Context) get(m map[string][]string, key string) (map[string]string, bool) {\n\tdicts := make(map[string]string)\n\texist := false\n\tfor k, v := range m {\n\t\tif i := strings.IndexByte(k, '['); i >= 1 && k[0:i] == key {\n\t\t\tif j := strings.IndexByte(k[i+1:], ']'); j >= 1 {\n\t\t\t\texist = true\n\t\t\t\tdicts[k[i+1:][:j]] = v[0]\n\t\t\t}\n\t\t}\n\t}\n\treturn dicts, exist\n}\n\n// FormFile returns the first file for the provided form key.\nfunc (c *Context) FormFile(name string) (*multipart.FileHeader, error) {\n\tif c.Request.MultipartForm == nil {\n\t\tif err := c.Request.ParseMultipartForm(c.engine.MaxMultipartMemory); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tf, fh, err := c.Request.FormFile(name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tf.Close()\n\treturn fh, err\n}\n\n// MultipartForm is the parsed multipart form, including file uploads.\nfunc (c *Context) MultipartForm() (*multipart.Form, error) {\n\terr := c.Request.ParseMultipartForm(c.engine.MaxMultipartMemory)\n\treturn c.Request.MultipartForm, err\n}\n\n// SaveUploadedFile uploads the form file to specific dst.\nfunc (c *Context) SaveUploadedFile(file *multipart.FileHeader, dst string, perm ...fs.FileMode) error {\n\tsrc, err := file.Open()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer src.Close()\n\n\tvar mode os.FileMode = 0o750\n\tif len(perm) > 0 {\n\t\tmode = perm[0]\n\t}\n\tdir := filepath.Dir(dst)\n\tif err = os.MkdirAll(dir, mode); err != nil {\n\t\treturn err\n\t}\n\tif err = os.Chmod(dir, mode); err != nil {\n\t\treturn err\n\t}\n\n\tout, err := os.Create(dst)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer out.Close()\n\n\t_, err = io.Copy(out, src)\n\treturn err\n}\n\n// Bind checks the Method and Content-Type to select a binding engine automatically,\n// Depending on the \"Content-Type\" header different bindings are used, for example:\n//\n//\t\"application/json\" --> JSON binding\n//\t\"application/xml\"  --> XML binding\n//\n// It parses the request's body as JSON if Content-Type == \"application/json\" using JSON or XML as a JSON input.\n// It decodes the json payload into the struct specified as a pointer.\n// It writes a 400 error and sets Content-Type header \"text/plain\" in the response if input is not valid.\nfunc (c *Context) Bind(obj any) error {\n\tb := binding.Default(c.Request.Method, c.ContentType())\n\treturn c.MustBindWith(obj, b)\n}\n\n// BindJSON is a shortcut for c.MustBindWith(obj, binding.JSON).\nfunc (c *Context) BindJSON(obj any) error {\n\treturn c.MustBindWith(obj, binding.JSON)\n}\n\n// BindXML is a shortcut for c.MustBindWith(obj, binding.BindXML).\nfunc (c *Context) BindXML(obj any) error {\n\treturn c.MustBindWith(obj, binding.XML)\n}\n\n// BindQuery is a shortcut for c.MustBindWith(obj, binding.Query).\nfunc (c *Context) BindQuery(obj any) error {\n\treturn c.MustBindWith(obj, binding.Query)\n}\n\n// BindYAML is a shortcut for c.MustBindWith(obj, binding.YAML).\nfunc (c *Context) BindYAML(obj any) error {\n\treturn c.MustBindWith(obj, binding.YAML)\n}\n\n// BindTOML is a shortcut for c.MustBindWith(obj, binding.TOML).\nfunc (c *Context) BindTOML(obj any) error {\n\treturn c.MustBindWith(obj, binding.TOML)\n}\n\n// BindPlain is a shortcut for c.MustBindWith(obj, binding.Plain).\nfunc (c *Context) BindPlain(obj any) error {\n\treturn c.MustBindWith(obj, binding.Plain)\n}\n\n// BindHeader is a shortcut for c.MustBindWith(obj, binding.Header).\nfunc (c *Context) BindHeader(obj any) error {\n\treturn c.MustBindWith(obj, binding.Header)\n}\n\n// BindUri binds the passed struct pointer using binding.Uri.\n// It will abort the request with HTTP 400 if any error occurs.\nfunc (c *Context) BindUri(obj any) error {\n\tif err := c.ShouldBindUri(obj); err != nil {\n\t\tc.AbortWithError(http.StatusBadRequest, err).SetType(ErrorTypeBind) //nolint: errcheck\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// MustBindWith binds the passed struct pointer using the specified binding engine.\n// It will abort the request with HTTP 400 if any error occurs.\n// See the binding package.\nfunc (c *Context) MustBindWith(obj any, b binding.Binding) error {\n\terr := c.ShouldBindWith(obj, b)\n\tif err != nil {\n\t\tvar maxBytesErr *http.MaxBytesError\n\n\t\t// Note: When using sonic or go-json as JSON encoder, they do not propagate the http.MaxBytesError error\n\t\t// https://github.com/goccy/go-json/issues/485\n\t\t// https://github.com/bytedance/sonic/issues/800\n\t\tswitch {\n\t\tcase errors.As(err, &maxBytesErr):\n\t\t\tc.AbortWithError(http.StatusRequestEntityTooLarge, err).SetType(ErrorTypeBind) //nolint: errcheck\n\t\tdefault:\n\t\t\tc.AbortWithError(http.StatusBadRequest, err).SetType(ErrorTypeBind) //nolint: errcheck\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// ShouldBind checks the Method and Content-Type to select a binding engine automatically,\n// Depending on the \"Content-Type\" header different bindings are used, for example:\n//\n//\t\"application/json\" --> JSON binding\n//\t\"application/xml\"  --> XML binding\n//\n// It parses the request's body as JSON if Content-Type == \"application/json\" using JSON or XML as a JSON input.\n// It decodes the json payload into the struct specified as a pointer.\n// Like c.Bind() but this method does not set the response status code to 400 or abort if input is not valid.\nfunc (c *Context) ShouldBind(obj any) error {\n\tb := binding.Default(c.Request.Method, c.ContentType())\n\treturn c.ShouldBindWith(obj, b)\n}\n\n// ShouldBindJSON is a shortcut for c.ShouldBindWith(obj, binding.JSON).\nfunc (c *Context) ShouldBindJSON(obj any) error {\n\treturn c.ShouldBindWith(obj, binding.JSON)\n}\n\n// ShouldBindXML is a shortcut for c.ShouldBindWith(obj, binding.XML).\nfunc (c *Context) ShouldBindXML(obj any) error {\n\treturn c.ShouldBindWith(obj, binding.XML)\n}\n\n// ShouldBindQuery is a shortcut for c.ShouldBindWith(obj, binding.Query).\nfunc (c *Context) ShouldBindQuery(obj any) error {\n\treturn c.ShouldBindWith(obj, binding.Query)\n}\n\n// ShouldBindYAML is a shortcut for c.ShouldBindWith(obj, binding.YAML).\nfunc (c *Context) ShouldBindYAML(obj any) error {\n\treturn c.ShouldBindWith(obj, binding.YAML)\n}\n\n// ShouldBindTOML is a shortcut for c.ShouldBindWith(obj, binding.TOML).\nfunc (c *Context) ShouldBindTOML(obj any) error {\n\treturn c.ShouldBindWith(obj, binding.TOML)\n}\n\n// ShouldBindPlain is a shortcut for c.ShouldBindWith(obj, binding.Plain).\nfunc (c *Context) ShouldBindPlain(obj any) error {\n\treturn c.ShouldBindWith(obj, binding.Plain)\n}\n\n// ShouldBindHeader is a shortcut for c.ShouldBindWith(obj, binding.Header).\nfunc (c *Context) ShouldBindHeader(obj any) error {\n\treturn c.ShouldBindWith(obj, binding.Header)\n}\n\n// ShouldBindUri binds the passed struct pointer using the specified binding engine.\nfunc (c *Context) ShouldBindUri(obj any) error {\n\tm := make(map[string][]string, len(c.Params))\n\tfor _, v := range c.Params {\n\t\tm[v.Key] = []string{v.Value}\n\t}\n\treturn binding.Uri.BindUri(m, obj)\n}\n\n// ShouldBindWith binds the passed struct pointer using the specified binding engine.\n// See the binding package.\nfunc (c *Context) ShouldBindWith(obj any, b binding.Binding) error {\n\treturn b.Bind(c.Request, obj)\n}\n\n// ShouldBindBodyWith is similar with ShouldBindWith, but it stores the request\n// body into the context, and reuse when it is called again.\n//\n// NOTE: This method reads the body before binding. So you should use\n// ShouldBindWith for better performance if you need to call only once.\nfunc (c *Context) ShouldBindBodyWith(obj any, bb binding.BindingBody) (err error) {\n\tvar body []byte\n\tif cb, ok := c.Get(BodyBytesKey); ok {\n\t\tif cbb, ok := cb.([]byte); ok {\n\t\t\tbody = cbb\n\t\t}\n\t}\n\tif body == nil {\n\t\tbody, err = io.ReadAll(c.Request.Body)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tc.Set(BodyBytesKey, body)\n\t}\n\treturn bb.BindBody(body, obj)\n}\n\n// ShouldBindBodyWithJSON is a shortcut for c.ShouldBindBodyWith(obj, binding.JSON).\nfunc (c *Context) ShouldBindBodyWithJSON(obj any) error {\n\treturn c.ShouldBindBodyWith(obj, binding.JSON)\n}\n\n// ShouldBindBodyWithXML is a shortcut for c.ShouldBindBodyWith(obj, binding.XML).\nfunc (c *Context) ShouldBindBodyWithXML(obj any) error {\n\treturn c.ShouldBindBodyWith(obj, binding.XML)\n}\n\n// ShouldBindBodyWithYAML is a shortcut for c.ShouldBindBodyWith(obj, binding.YAML).\nfunc (c *Context) ShouldBindBodyWithYAML(obj any) error {\n\treturn c.ShouldBindBodyWith(obj, binding.YAML)\n}\n\n// ShouldBindBodyWithTOML is a shortcut for c.ShouldBindBodyWith(obj, binding.TOML).\nfunc (c *Context) ShouldBindBodyWithTOML(obj any) error {\n\treturn c.ShouldBindBodyWith(obj, binding.TOML)\n}\n\n// ShouldBindBodyWithPlain is a shortcut for c.ShouldBindBodyWith(obj, binding.Plain).\nfunc (c *Context) ShouldBindBodyWithPlain(obj any) error {\n\treturn c.ShouldBindBodyWith(obj, binding.Plain)\n}\n\n// ClientIP implements one best effort algorithm to return the real client IP.\n// It calls c.RemoteIP() under the hood, to check if the remote IP is a trusted proxy or not.\n// If it is it will then try to parse the headers defined in Engine.RemoteIPHeaders (defaulting to [X-Forwarded-For, X-Real-IP]).\n// If the headers are not syntactically valid OR the remote IP does not correspond to a trusted proxy,\n// the remote IP (coming from Request.RemoteAddr) is returned.\nfunc (c *Context) ClientIP() string {\n\t// Check if we're running on a trusted platform, continue running backwards if error\n\tif c.engine.TrustedPlatform != \"\" {\n\t\t// Developers can define their own header of Trusted Platform or use predefined constants\n\t\tif addr := c.requestHeader(c.engine.TrustedPlatform); addr != \"\" {\n\t\t\treturn addr\n\t\t}\n\t}\n\n\t// Legacy \"AppEngine\" flag\n\tif c.engine.AppEngine {\n\t\tlog.Println(`The AppEngine flag is going to be deprecated. Please check issues #2723 and #2739 and use 'TrustedPlatform: gin.PlatformGoogleAppEngine' instead.`)\n\t\tif addr := c.requestHeader(\"X-Appengine-Remote-Addr\"); addr != \"\" {\n\t\t\treturn addr\n\t\t}\n\t}\n\n\t// It also checks if the remoteIP is a trusted proxy or not.\n\t// In order to perform this validation, it will see if the IP is contained within at least one of the CIDR blocks\n\t// defined by Engine.SetTrustedProxies()\n\tremoteIP := net.ParseIP(c.RemoteIP())\n\tif remoteIP == nil {\n\t\treturn \"\"\n\t}\n\ttrusted := c.engine.isTrustedProxy(remoteIP)\n\n\tif trusted && c.engine.ForwardedByClientIP && c.engine.RemoteIPHeaders != nil {\n\t\tfor _, headerName := range c.engine.RemoteIPHeaders {\n\t\t\tip, valid := c.engine.validateHeader(c.requestHeader(headerName))\n\t\t\tif valid {\n\t\t\t\treturn ip\n\t\t\t}\n\t\t}\n\t}\n\treturn remoteIP.String()\n}\n\n// RemoteIP parses the IP from Request.RemoteAddr, normalizes and returns the IP (without the port).\nfunc (c *Context) RemoteIP() string {\n\tip, _, err := net.SplitHostPort(strings.TrimSpace(c.Request.RemoteAddr))\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\treturn ip\n}\n\n// ContentType returns the Content-Type header of the request.\nfunc (c *Context) ContentType() string {\n\treturn filterFlags(c.requestHeader(\"Content-Type\"))\n}\n\n// IsWebsocket returns true if the request headers indicate that a websocket\n// handshake is being initiated by the client.\nfunc (c *Context) IsWebsocket() bool {\n\tif strings.Contains(strings.ToLower(c.requestHeader(\"Connection\")), \"upgrade\") &&\n\t\tstrings.EqualFold(c.requestHeader(\"Upgrade\"), \"websocket\") {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (c *Context) requestHeader(key string) string {\n\treturn c.Request.Header.Get(key)\n}\n\n/************************************/\n/******** RESPONSE RENDERING ********/\n/************************************/\n\n// bodyAllowedForStatus is a copy of http.bodyAllowedForStatus non-exported function.\nfunc bodyAllowedForStatus(status int) bool {\n\tswitch {\n\tcase status >= 100 && status <= 199:\n\t\treturn false\n\tcase status == http.StatusNoContent:\n\t\treturn false\n\tcase status == http.StatusNotModified:\n\t\treturn false\n\t}\n\treturn true\n}\n\n// Status sets the HTTP response code.\nfunc (c *Context) Status(code int) {\n\tc.Writer.WriteHeader(code)\n}\n\n// Header is an intelligent shortcut for c.Writer.Header().Set(key, value).\n// It writes a header in the response.\n// If value == \"\", this method removes the header `c.Writer.Header().Del(key)`\nfunc (c *Context) Header(key, value string) {\n\tif value == \"\" {\n\t\tc.Writer.Header().Del(key)\n\t\treturn\n\t}\n\tc.Writer.Header().Set(key, value)\n}\n\n// GetHeader returns value from request headers.\nfunc (c *Context) GetHeader(key string) string {\n\treturn c.requestHeader(key)\n}\n\n// GetRawData returns stream data.\nfunc (c *Context) GetRawData() ([]byte, error) {\n\tif c.Request.Body == nil {\n\t\treturn nil, errors.New(\"cannot read nil body\")\n\t}\n\treturn io.ReadAll(c.Request.Body)\n}\n\n// SetSameSite with cookie\nfunc (c *Context) SetSameSite(samesite http.SameSite) {\n\tc.sameSite = samesite\n}\n\n// SetCookie adds a Set-Cookie header to the ResponseWriter's headers.\n// The provided cookie must have a valid Name. Invalid cookies may be\n// silently dropped.\nfunc (c *Context) SetCookie(name, value string, maxAge int, path, domain string, secure, httpOnly bool) {\n\tif path == \"\" {\n\t\tpath = \"/\"\n\t}\n\thttp.SetCookie(c.Writer, &http.Cookie{\n\t\tName:     name,\n\t\tValue:    url.QueryEscape(value),\n\t\tMaxAge:   maxAge,\n\t\tPath:     path,\n\t\tDomain:   domain,\n\t\tSameSite: c.sameSite,\n\t\tSecure:   secure,\n\t\tHttpOnly: httpOnly,\n\t})\n}\n\n// SetCookieData adds a Set-Cookie header to the ResponseWriter's headers.\n// It accepts a pointer to http.Cookie structure for more flexibility in setting cookie attributes.\n// The provided cookie must have a valid Name. Invalid cookies may be silently dropped.\nfunc (c *Context) SetCookieData(cookie *http.Cookie) {\n\tif cookie.Path == \"\" {\n\t\tcookie.Path = \"/\"\n\t}\n\tif cookie.SameSite == http.SameSiteDefaultMode {\n\t\tcookie.SameSite = c.sameSite\n\t}\n\thttp.SetCookie(c.Writer, cookie)\n}\n\n// Cookie returns the named cookie provided in the request or\n// ErrNoCookie if not found. And return the named cookie is unescaped.\n// If multiple cookies match the given name, only one cookie will\n// be returned.\nfunc (c *Context) Cookie(name string) (string, error) {\n\tcookie, err := c.Request.Cookie(name)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tval, _ := url.QueryUnescape(cookie.Value)\n\treturn val, nil\n}\n\n// Render writes the response headers and calls render.Render to render data.\nfunc (c *Context) Render(code int, r render.Render) {\n\tc.Status(code)\n\n\tif !bodyAllowedForStatus(code) {\n\t\tr.WriteContentType(c.Writer)\n\t\tc.Writer.WriteHeaderNow()\n\t\treturn\n\t}\n\n\tif err := r.Render(c.Writer); err != nil {\n\t\t// Pushing error to c.Errors\n\t\t_ = c.Error(err)\n\t\tc.Abort()\n\t}\n}\n\n// HTML renders the HTTP template specified by its file name.\n// It also updates the HTTP code and sets the Content-Type as \"text/html\".\n// See http://golang.org/doc/articles/wiki/\nfunc (c *Context) HTML(code int, name string, obj any) {\n\tinstance := c.engine.HTMLRender.Instance(name, obj)\n\tc.Render(code, instance)\n}\n\n// IndentedJSON serializes the given struct as pretty JSON (indented + endlines) into the response body.\n// It also sets the Content-Type as \"application/json\".\n// WARNING: we recommend using this only for development purposes since printing pretty JSON is\n// more CPU and bandwidth consuming. Use Context.JSON() instead.\nfunc (c *Context) IndentedJSON(code int, obj any) {\n\tc.Render(code, render.IndentedJSON{Data: obj})\n}\n\n// SecureJSON serializes the given struct as Secure JSON into the response body.\n// Default prepends \"while(1),\" to response body if the given struct is array values.\n// It also sets the Content-Type as \"application/json\".\nfunc (c *Context) SecureJSON(code int, obj any) {\n\tc.Render(code, render.SecureJSON{Prefix: c.engine.secureJSONPrefix, Data: obj})\n}\n\n// JSONP serializes the given struct as JSON into the response body.\n// It adds padding to response body to request data from a server residing in a different domain than the client.\n// It also sets the Content-Type as \"application/javascript\".\nfunc (c *Context) JSONP(code int, obj any) {\n\tcallback := c.DefaultQuery(\"callback\", \"\")\n\tif callback == \"\" {\n\t\tc.Render(code, render.JSON{Data: obj})\n\t\treturn\n\t}\n\tc.Render(code, render.JsonpJSON{Callback: callback, Data: obj})\n}\n\n// JSON serializes the given struct as JSON into the response body.\n// It also sets the Content-Type as \"application/json\".\nfunc (c *Context) JSON(code int, obj any) {\n\tc.Render(code, render.JSON{Data: obj})\n}\n\n// AsciiJSON serializes the given struct as JSON into the response body with unicode to ASCII string.\n// It also sets the Content-Type as \"application/json\".\nfunc (c *Context) AsciiJSON(code int, obj any) {\n\tc.Render(code, render.AsciiJSON{Data: obj})\n}\n\n// PureJSON serializes the given struct as JSON into the response body.\n// PureJSON, unlike JSON, does not replace special html characters with their unicode entities.\nfunc (c *Context) PureJSON(code int, obj any) {\n\tc.Render(code, render.PureJSON{Data: obj})\n}\n\n// XML serializes the given struct as XML into the response body.\n// It also sets the Content-Type as \"application/xml\".\nfunc (c *Context) XML(code int, obj any) {\n\tc.Render(code, render.XML{Data: obj})\n}\n\n// YAML serializes the given struct as YAML into the response body.\nfunc (c *Context) YAML(code int, obj any) {\n\tc.Render(code, render.YAML{Data: obj})\n}\n\n// TOML serializes the given struct as TOML into the response body.\nfunc (c *Context) TOML(code int, obj any) {\n\tc.Render(code, render.TOML{Data: obj})\n}\n\n// ProtoBuf serializes the given struct as ProtoBuf into the response body.\nfunc (c *Context) ProtoBuf(code int, obj any) {\n\tc.Render(code, render.ProtoBuf{Data: obj})\n}\n\n// String writes the given string into the response body.\nfunc (c *Context) String(code int, format string, values ...any) {\n\tc.Render(code, render.String{Format: format, Data: values})\n}\n\n// Redirect returns an HTTP redirect to the specific location.\nfunc (c *Context) Redirect(code int, location string) {\n\tc.Render(-1, render.Redirect{\n\t\tCode:     code,\n\t\tLocation: location,\n\t\tRequest:  c.Request,\n\t})\n}\n\n// Data writes some data into the body stream and updates the HTTP code.\nfunc (c *Context) Data(code int, contentType string, data []byte) {\n\tc.Render(code, render.Data{\n\t\tContentType: contentType,\n\t\tData:        data,\n\t})\n}\n\n// DataFromReader writes the specified reader into the body stream and updates the HTTP code.\nfunc (c *Context) DataFromReader(code int, contentLength int64, contentType string, reader io.Reader, extraHeaders map[string]string) {\n\tc.Render(code, render.Reader{\n\t\tHeaders:       extraHeaders,\n\t\tContentType:   contentType,\n\t\tContentLength: contentLength,\n\t\tReader:        reader,\n\t})\n}\n\n// File writes the specified file into the body stream in an efficient way.\nfunc (c *Context) File(filepath string) {\n\thttp.ServeFile(c.Writer, c.Request, filepath)\n}\n\n// FileFromFS writes the specified file from http.FileSystem into the body stream in an efficient way.\nfunc (c *Context) FileFromFS(filepath string, fs http.FileSystem) {\n\tdefer func(old string) {\n\t\tc.Request.URL.Path = old\n\t}(c.Request.URL.Path)\n\n\tc.Request.URL.Path = filepath\n\n\thttp.FileServer(fs).ServeHTTP(c.Writer, c.Request)\n}\n\nvar quoteEscaper = strings.NewReplacer(\"\\\\\", \"\\\\\\\\\", `\"`, \"\\\\\\\"\")\n\nfunc escapeQuotes(s string) string {\n\treturn quoteEscaper.Replace(s)\n}\n\n// FileAttachment writes the specified file into the body stream in an efficient way\n// On the client side, the file will typically be downloaded with the given filename\nfunc (c *Context) FileAttachment(filepath, filename string) {\n\tif isASCII(filename) {\n\t\tc.Writer.Header().Set(\"Content-Disposition\", `attachment; filename=\"`+escapeQuotes(filename)+`\"`)\n\t} else {\n\t\tc.Writer.Header().Set(\"Content-Disposition\", `attachment; filename*=UTF-8''`+url.QueryEscape(filename))\n\t}\n\thttp.ServeFile(c.Writer, c.Request, filepath)\n}\n\n// SSEvent writes a Server-Sent Event into the body stream.\nfunc (c *Context) SSEvent(name string, message any) {\n\tc.Render(-1, sse.Event{\n\t\tEvent: name,\n\t\tData:  message,\n\t})\n}\n\n// Stream sends a streaming response and returns a boolean\n// indicates \"Is client disconnected in middle of stream\"\nfunc (c *Context) Stream(step func(w io.Writer) bool) bool {\n\tw := c.Writer\n\tclientGone := w.CloseNotify()\n\tfor {\n\t\tselect {\n\t\tcase <-clientGone:\n\t\t\treturn true\n\t\tdefault:\n\t\t\tkeepOpen := step(w)\n\t\t\tw.Flush()\n\t\t\tif !keepOpen {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n}\n\n/************************************/\n/******** CONTENT NEGOTIATION *******/\n/************************************/\n\n// Negotiate contains all negotiations data.\ntype Negotiate struct {\n\tOffered  []string\n\tHTMLName string\n\tHTMLData any\n\tJSONData any\n\tXMLData  any\n\tYAMLData any\n\tData     any\n\tTOMLData any\n}\n\n// Negotiate calls different Render according to acceptable Accept format.\nfunc (c *Context) Negotiate(code int, config Negotiate) {\n\tswitch c.NegotiateFormat(config.Offered...) {\n\tcase binding.MIMEJSON:\n\t\tdata := chooseData(config.JSONData, config.Data)\n\t\tc.JSON(code, data)\n\n\tcase binding.MIMEHTML:\n\t\tdata := chooseData(config.HTMLData, config.Data)\n\t\tc.HTML(code, config.HTMLName, data)\n\n\tcase binding.MIMEXML:\n\t\tdata := chooseData(config.XMLData, config.Data)\n\t\tc.XML(code, data)\n\n\tcase binding.MIMEYAML, binding.MIMEYAML2:\n\t\tdata := chooseData(config.YAMLData, config.Data)\n\t\tc.YAML(code, data)\n\n\tcase binding.MIMETOML:\n\t\tdata := chooseData(config.TOMLData, config.Data)\n\t\tc.TOML(code, data)\n\n\tdefault:\n\t\tc.AbortWithError(http.StatusNotAcceptable, errors.New(\"the accepted formats are not offered by the server\")) //nolint: errcheck\n\t}\n}\n\n// NegotiateFormat returns an acceptable Accept format.\nfunc (c *Context) NegotiateFormat(offered ...string) string {\n\tassert1(len(offered) > 0, \"you must provide at least one offer\")\n\n\tif c.Accepted == nil {\n\t\tc.Accepted = parseAccept(c.requestHeader(\"Accept\"))\n\t}\n\tif len(c.Accepted) == 0 {\n\t\treturn offered[0]\n\t}\n\tfor _, accepted := range c.Accepted {\n\t\tfor _, offer := range offered {\n\t\t\t// According to RFC 2616 and RFC 2396, non-ASCII characters are not allowed in headers,\n\t\t\t// therefore we can just iterate over the string without casting it into []rune\n\t\t\ti := 0\n\t\t\tfor ; i < len(accepted) && i < len(offer); i++ {\n\t\t\t\tif accepted[i] == '*' || offer[i] == '*' {\n\t\t\t\t\treturn offer\n\t\t\t\t}\n\t\t\t\tif accepted[i] != offer[i] {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif i == len(accepted) {\n\t\t\t\treturn offer\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\"\n}\n\n// SetAccepted sets Accept header data.\nfunc (c *Context) SetAccepted(formats ...string) {\n\tc.Accepted = formats\n}\n\n/************************************/\n/***** GOLANG.ORG/X/NET/CONTEXT *****/\n/************************************/\n\n// hasRequestContext returns whether c.Request has Context and fallback.\nfunc (c *Context) hasRequestContext() bool {\n\thasFallback := c.engine != nil && c.engine.ContextWithFallback\n\thasRequestContext := c.Request != nil && c.Request.Context() != nil\n\treturn hasFallback && hasRequestContext\n}\n\n// Deadline returns that there is no deadline (ok==false) when c.Request has no Context.\nfunc (c *Context) Deadline() (deadline time.Time, ok bool) {\n\tif !c.hasRequestContext() {\n\t\treturn\n\t}\n\treturn c.Request.Context().Deadline()\n}\n\n// Done returns nil (chan which will wait forever) when c.Request has no Context.\nfunc (c *Context) Done() <-chan struct{} {\n\tif !c.hasRequestContext() {\n\t\treturn nil\n\t}\n\treturn c.Request.Context().Done()\n}\n\n// Err returns nil when c.Request has no Context.\nfunc (c *Context) Err() error {\n\tif !c.hasRequestContext() {\n\t\treturn nil\n\t}\n\treturn c.Request.Context().Err()\n}\n\n// Value returns the value associated with this context for key, or nil\n// if no value is associated with key. Successive calls to Value with\n// the same key returns the same result.\nfunc (c *Context) Value(key any) any {\n\tif key == ContextRequestKey {\n\t\treturn c.Request\n\t}\n\tif key == ContextKey {\n\t\treturn c\n\t}\n\tif keyAsString, ok := key.(string); ok {\n\t\tif val, exists := c.Get(keyAsString); exists {\n\t\t\treturn val\n\t\t}\n\t}\n\tif !c.hasRequestContext() {\n\t\treturn nil\n\t}\n\treturn c.Request.Context().Value(key)\n}\n",
    "source_file": "context.go",
    "chunk_type": "code"
  },
  {
    "content": "## Contributing\n\n- With issues:\n  - Use the search tool before opening a new issue.\n  - Please provide source code and commit sha if you found a bug.\n  - Review existing issues and provide feedback or react to them.\n\n- With pull requests:\n  - Open your pull request against `master`\n  - Your pull request should have no more than two commits, if not you should squash them.\n  - It should pass all tests in the available continuous integration systems such as GitHub Actions.\n  - You should add/modify tests to cover your proposed code changes.\n  - If your pull request contains a new feature, please document it on the README.",
    "source_file": "CONTRIBUTING.md",
    "chunk_type": "doc"
  },
  {
    "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"encoding/xml\"\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"strings\"\n\t\"unicode\"\n)\n\n// BindKey indicates a default bind key.\nconst BindKey = \"_gin-gonic/gin/bindkey\"\n\n// Bind is a helper function for given interface object and returns a Gin middleware.\nfunc Bind(val any) HandlerFunc {\n\tvalue := reflect.ValueOf(val)\n\tif value.Kind() == reflect.Ptr {\n\t\tpanic(`Bind struct can not be a pointer. Example:\n\tUse: gin.Bind(Struct{}) instead of gin.Bind(&Struct{})\n`)\n\t}\n\ttyp := value.Type()\n\n\treturn func(c *Context) {\n\t\tobj := reflect.New(typ).Interface()\n\t\tif c.Bind(obj) == nil {\n\t\t\tc.Set(BindKey, obj)\n\t\t}\n\t}\n}\n\n// WrapF is a helper function for wrapping http.HandlerFunc and returns a Gin middleware.\nfunc WrapF(f http.HandlerFunc) HandlerFunc {\n\treturn func(c *Context) {\n\t\tf(c.Writer, c.Request)\n\t}\n}\n\n// WrapH is a helper function for wrapping http.Handler and returns a Gin middleware.\nfunc WrapH(h http.Handler) HandlerFunc {\n\treturn func(c *Context) {\n\t\th.ServeHTTP(c.Writer, c.Request)\n\t}\n}\n\n// H is a shortcut for map[string]any\ntype H map[string]any\n\n// MarshalXML allows type H to be used with xml.Marshal.\nfunc (h H) MarshalXML(e *xml.Encoder, start xml.StartElement) error {\n\tstart.Name = xml.Name{\n\t\tSpace: \"\",\n\t\tLocal: \"map\",\n\t}\n\tif err := e.EncodeToken(start); err != nil {\n\t\treturn err\n\t}\n\tfor key, value := range h {\n\t\telem := xml.StartElement{\n\t\t\tName: xml.Name{Space: \"\", Local: key},\n\t\t\tAttr: []xml.Attr{},\n\t\t}\n\t\tif err := e.EncodeElement(value, elem); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn e.EncodeToken(xml.EndElement{Name: start.Name})\n}\n\nfunc assert1(guard bool, text string) {\n\tif !guard {\n\t\tpanic(text)\n\t}\n}\n\nfunc filterFlags(content string) string {\n\tfor i, char := range content {\n\t\tif char == ' ' || char == ';' {\n\t\t\treturn content[:i]\n\t\t}\n\t}\n\treturn content\n}\n\nfunc chooseData(custom, wildcard any) any {\n\tif custom != nil {\n\t\treturn custom\n\t}\n\tif wildcard != nil {\n\t\treturn wildcard\n\t}\n\tpanic(\"negotiation config is invalid\")\n}\n\nfunc parseAccept(acceptHeader string) []string {\n\tparts := strings.Split(acceptHeader, \",\")\n\tout := make([]string, 0, len(parts))\n\tfor _, part := range parts {\n\t\tif i := strings.IndexByte(part, ';'); i > 0 {\n\t\t\tpart = part[:i]\n\t\t}\n\t\tif part = strings.TrimSpace(part); part != \"\" {\n\t\t\tout = append(out, part)\n\t\t}\n\t}\n\treturn out\n}\n\nfunc lastChar(str string) uint8 {\n\tif str == \"\" {\n\t\tpanic(\"The length of the string can't be 0\")\n\t}\n\treturn str[len(str)-1]\n}\n\nfunc nameOfFunction(f any) string {\n\treturn runtime.FuncForPC(reflect.ValueOf(f).Pointer()).Name()\n}\n\nfunc joinPaths(absolutePath, relativePath string) string {\n\tif relativePath == \"\" {\n\t\treturn absolutePath\n\t}\n\n\tfinalPath := path.Join(absolutePath, relativePath)\n\tif lastChar(relativePath) == '/' && lastChar(finalPath) != '/' {\n\t\treturn finalPath + \"/\"\n\t}\n\treturn finalPath\n}\n\nfunc resolveAddress(addr []string) string {\n\tswitch len(addr) {\n\tcase 0:\n\t\tif port := os.Getenv(\"PORT\"); port != \"\" {\n\t\t\tdebugPrint(\"Environment variable PORT=\\\"%s\\\"\", port)\n\t\t\treturn \":\" + port\n\t\t}\n\t\tdebugPrint(\"Environment variable PORT is undefined. Using port :8080 by default\")\n\t\treturn \":8080\"\n\tcase 1:\n\t\treturn addr[0]\n\tdefault:\n\t\tpanic(\"too many parameters\")\n\t}\n}\n\n// https://stackoverflow.com/questions/53069040/checking-a-string-contains-only-ascii-characters\nfunc isASCII(s string) bool {\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] > unicode.MaxASCII {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n",
    "source_file": "utils.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"bufio\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n)\n\nconst (\n\tnoWritten     = -1\n\tdefaultStatus = http.StatusOK\n)\n\n// ResponseWriter ...\ntype ResponseWriter interface {\n\thttp.ResponseWriter\n\thttp.Hijacker\n\thttp.Flusher\n\thttp.CloseNotifier\n\n\t// Status returns the HTTP response status code of the current request.\n\tStatus() int\n\n\t// Size returns the number of bytes already written into the response http body.\n\t// See Written()\n\tSize() int\n\n\t// WriteString writes the string into the response body.\n\tWriteString(string) (int, error)\n\n\t// Written returns true if the response body was already written.\n\tWritten() bool\n\n\t// WriteHeaderNow forces to write the http header (status code + headers).\n\tWriteHeaderNow()\n\n\t// Pusher get the http.Pusher for server push\n\tPusher() http.Pusher\n}\n\ntype responseWriter struct {\n\thttp.ResponseWriter\n\tsize   int\n\tstatus int\n}\n\nvar _ ResponseWriter = (*responseWriter)(nil)\n\nfunc (w *responseWriter) Unwrap() http.ResponseWriter {\n\treturn w.ResponseWriter\n}\n\nfunc (w *responseWriter) reset(writer http.ResponseWriter) {\n\tw.ResponseWriter = writer\n\tw.size = noWritten\n\tw.status = defaultStatus\n}\n\nfunc (w *responseWriter) WriteHeader(code int) {\n\tif code > 0 && w.status != code {\n\t\tif w.Written() {\n\t\t\tdebugPrint(\"[WARNING] Headers were already written. Wanted to override status code %d with %d\", w.status, code)\n\t\t\treturn\n\t\t}\n\t\tw.status = code\n\t}\n}\n\nfunc (w *responseWriter) WriteHeaderNow() {\n\tif !w.Written() {\n\t\tw.size = 0\n\t\tw.ResponseWriter.WriteHeader(w.status)\n\t}\n}\n\nfunc (w *responseWriter) Write(data []byte) (n int, err error) {\n\tw.WriteHeaderNow()\n\tn, err = w.ResponseWriter.Write(data)\n\tw.size += n\n\treturn\n}\n\nfunc (w *responseWriter) WriteString(s string) (n int, err error) {\n\tw.WriteHeaderNow()\n\tn, err = io.WriteString(w.ResponseWriter, s)\n\tw.size += n\n\treturn\n}\n\nfunc (w *responseWriter) Status() int {\n\treturn w.status\n}\n\nfunc (w *responseWriter) Size() int {\n\treturn w.size\n}\n\nfunc (w *responseWriter) Written() bool {\n\treturn w.size != noWritten\n}\n\n// Hijack implements the http.Hijacker interface.\nfunc (w *responseWriter) Hijack() (net.Conn, *bufio.ReadWriter, error) {\n\tif w.size < 0 {\n\t\tw.size = 0\n\t}\n\treturn w.ResponseWriter.(http.Hijacker).Hijack()\n}\n\n// CloseNotify implements the http.CloseNotifier interface.\nfunc (w *responseWriter) CloseNotify() <-chan bool {\n\treturn w.ResponseWriter.(http.CloseNotifier).CloseNotify()\n}\n\n// Flush implements the http.Flusher interface.\nfunc (w *responseWriter) Flush() {\n\tw.WriteHeaderNow()\n\tw.ResponseWriter.(http.Flusher).Flush()\n}\n\nfunc (w *responseWriter) Pusher() (pusher http.Pusher) {\n\tif pusher, ok := w.ResponseWriter.(http.Pusher); ok {\n\t\treturn pusher\n\t}\n\treturn nil\n}\n",
    "source_file": "response_writer.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"flag\"\n\t\"io\"\n\t\"os\"\n\t\"sync/atomic\"\n\n\t\"github.com/gin-gonic/gin/binding\"\n)\n\n// EnvGinMode indicates environment name for gin mode.\nconst EnvGinMode = \"GIN_MODE\"\n\nconst (\n\t// DebugMode indicates gin mode is debug.\n\tDebugMode = \"debug\"\n\t// ReleaseMode indicates gin mode is release.\n\tReleaseMode = \"release\"\n\t// TestMode indicates gin mode is test.\n\tTestMode = \"test\"\n)\n\nconst (\n\tdebugCode = iota\n\treleaseCode\n\ttestCode\n)\n\n// DefaultWriter is the default io.Writer used by Gin for debug output and\n// middleware output like Logger() or Recovery().\n// Note that both Logger and Recovery provides custom ways to configure their\n// output io.Writer.\n// To support coloring in Windows use:\n//\n//\timport \"github.com/mattn/go-colorable\"\n//\tgin.DefaultWriter = colorable.NewColorableStdout()\nvar DefaultWriter io.Writer = os.Stdout\n\n// DefaultErrorWriter is the default io.Writer used by Gin to debug errors\nvar DefaultErrorWriter io.Writer = os.Stderr\n\nvar (\n\tginMode  int32 = debugCode\n\tmodeName atomic.Value\n)\n\nfunc init() {\n\tmode := os.Getenv(EnvGinMode)\n\tSetMode(mode)\n}\n\n// SetMode sets gin mode according to input string.\nfunc SetMode(value string) {\n\tif value == \"\" {\n\t\tif flag.Lookup(\"test.v\") != nil {\n\t\t\tvalue = TestMode\n\t\t} else {\n\t\t\tvalue = DebugMode\n\t\t}\n\t}\n\n\tswitch value {\n\tcase DebugMode, \"\":\n\t\tatomic.StoreInt32(&ginMode, debugCode)\n\tcase ReleaseMode:\n\t\tatomic.StoreInt32(&ginMode, releaseCode)\n\tcase TestMode:\n\t\tatomic.StoreInt32(&ginMode, testCode)\n\tdefault:\n\t\tpanic(\"gin mode unknown: \" + value + \" (available mode: debug release test)\")\n\t}\n\tmodeName.Store(value)\n}\n\n// DisableBindValidation closes the default validator.\nfunc DisableBindValidation() {\n\tbinding.Validator = nil\n}\n\n// EnableJsonDecoderUseNumber sets true for binding.EnableDecoderUseNumber to\n// call the UseNumber method on the JSON Decoder instance.\nfunc EnableJsonDecoderUseNumber() {\n\tbinding.EnableDecoderUseNumber = true\n}\n\n// EnableJsonDecoderDisallowUnknownFields sets true for binding.EnableDecoderDisallowUnknownFields to\n// call the DisallowUnknownFields method on the JSON Decoder instance.\nfunc EnableJsonDecoderDisallowUnknownFields() {\n\tbinding.EnableDecoderDisallowUnknownFields = true\n}\n\n// Mode returns current gin mode.\nfunc Mode() string {\n\treturn modeName.Load().(string)\n}\n",
    "source_file": "mode.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2017 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\n//go:build appengine\n\npackage gin\n\nfunc init() {\n\tdefaultPlatform = PlatformGoogleAppEngine\n}\n",
    "source_file": "context_appengine.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2013 Julien Schmidt. All rights reserved.\n// Based on the path package, Copyright 2009 The Go Authors.\n// Use of this source code is governed by a BSD-style license that can be found\n// at https://github.com/julienschmidt/httprouter/blob/master/LICENSE.\n\npackage gin\n\n// cleanPath is the URL version of path.Clean, it returns a canonical URL path\n// for p, eliminating . and .. elements.\n//\n// The following rules are applied iteratively until no further processing can\n// be done:\n//  1. Replace multiple slashes with a single slash.\n//  2. Eliminate each . path name element (the current directory).\n//  3. Eliminate each inner .. path name element (the parent directory)\n//     along with the non-.. element that precedes it.\n//  4. Eliminate .. elements that begin a rooted path:\n//     that is, replace \"/..\" by \"/\" at the beginning of a path.\n//\n// If the result of this process is an empty string, \"/\" is returned.\nfunc cleanPath(p string) string {\n\tconst stackBufSize = 128\n\t// Turn empty string into \"/\"\n\tif p == \"\" {\n\t\treturn \"/\"\n\t}\n\n\t// Reasonably sized buffer on stack to avoid allocations in the common case.\n\t// If a larger buffer is required, it gets allocated dynamically.\n\tbuf := make([]byte, 0, stackBufSize)\n\n\tn := len(p)\n\n\t// Invariants:\n\t//      reading from path; r is index of next byte to process.\n\t//      writing to buf; w is index of next byte to write.\n\n\t// path must start with '/'\n\tr := 1\n\tw := 1\n\n\tif p[0] != '/' {\n\t\tr = 0\n\n\t\tif n+1 > stackBufSize {\n\t\t\tbuf = make([]byte, n+1)\n\t\t} else {\n\t\t\tbuf = buf[:n+1]\n\t\t}\n\t\tbuf[0] = '/'\n\t}\n\n\ttrailing := n > 1 && p[n-1] == '/'\n\n\t// A bit more clunky without a 'lazybuf' like the path package, but the loop\n\t// gets completely inlined (bufApp calls).\n\t// loop has no expensive function calls (except 1x make)\t\t// So in contrast to the path package this loop has no expensive function\n\t// calls (except make, if needed).\n\n\tfor r < n {\n\t\tswitch {\n\t\tcase p[r] == '/':\n\t\t\t// empty path element, trailing slash is added after the end\n\t\t\tr++\n\n\t\tcase p[r] == '.' && r+1 == n:\n\t\t\ttrailing = true\n\t\t\tr++\n\n\t\tcase p[r] == '.' && p[r+1] == '/':\n\t\t\t// . element\n\t\t\tr += 2\n\n\t\tcase p[r] == '.' && p[r+1] == '.' && (r+2 == n || p[r+2] == '/'):\n\t\t\t// .. element: remove to last /\n\t\t\tr += 3\n\n\t\t\tif w > 1 {\n\t\t\t\t// can backtrack\n\t\t\t\tw--\n\n\t\t\t\tif len(buf) == 0 {\n\t\t\t\t\tfor w > 1 && p[w] != '/' {\n\t\t\t\t\t\tw--\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor w > 1 && buf[w] != '/' {\n\t\t\t\t\t\tw--\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Real path element.\n\t\t\t// Add slash if needed\n\t\t\tif w > 1 {\n\t\t\t\tbufApp(&buf, p, w, '/')\n\t\t\t\tw++\n\t\t\t}\n\n\t\t\t// Copy element\n\t\t\tfor r < n && p[r] != '/' {\n\t\t\t\tbufApp(&buf, p, w, p[r])\n\t\t\t\tw++\n\t\t\t\tr++\n\t\t\t}\n\t\t}\n\t}\n\n\t// Re-append trailing slash\n\tif trailing && w > 1 {\n\t\tbufApp(&buf, p, w, '/')\n\t\tw++\n\t}\n\n\t// If the original string was not modified (or only shortened at the end),\n\t// return the respective substring of the original string.\n\t// Otherwise return a new string from the buffer.\n\tif len(buf) == 0 {\n\t\treturn p[:w]\n\t}\n\treturn string(buf[:w])\n}\n\n// Internal helper to lazily create a buffer if necessary.\n// Calls to this function get inlined.\nfunc bufApp(buf *[]byte, s string, w int, c byte) {\n\tb := *buf\n\tif len(b) == 0 {\n\t\t// No modification of the original string so far.\n\t\t// If the next character is the same as in the original string, we do\n\t\t// not yet have to allocate a buffer.\n\t\tif s[w] == c {\n\t\t\treturn\n\t\t}\n\n\t\t// Otherwise use either the stack buffer, if it is large enough, or\n\t\t// allocate a new buffer on the heap, and copy all previous characters.\n\t\tlength := len(s)\n\t\tif length > cap(b) {\n\t\t\t*buf = make([]byte, length)\n\t\t} else {\n\t\t\t*buf = (*buf)[:length]\n\t\t}\n\t\tb = *buf\n\n\t\tcopy(b, s[:w])\n\t}\n\tb[w] = c\n}\n",
    "source_file": "path.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\n\t\"github.com/gin-gonic/gin/codec/json\"\n)\n\n// ErrorType is an unsigned 64-bit error code as defined in the gin spec.\ntype ErrorType uint64\n\nconst (\n\t// ErrorTypeBind is used when Context.Bind() fails.\n\tErrorTypeBind ErrorType = 1 << 63\n\t// ErrorTypeRender is used when Context.Render() fails.\n\tErrorTypeRender ErrorType = 1 << 62\n\t// ErrorTypePrivate indicates a private error.\n\tErrorTypePrivate ErrorType = 1 << 0\n\t// ErrorTypePublic indicates a public error.\n\tErrorTypePublic ErrorType = 1 << 1\n\t// ErrorTypeAny indicates any other error.\n\tErrorTypeAny ErrorType = 1<<64 - 1\n\t// ErrorTypeNu indicates any other error.\n\tErrorTypeNu = 2\n)\n\n// Error represents a error's specification.\ntype Error struct {\n\tErr  error\n\tType ErrorType\n\tMeta any\n}\n\ntype errorMsgs []*Error\n\nvar _ error = (*Error)(nil)\n\n// SetType sets the error's type.\nfunc (msg *Error) SetType(flags ErrorType) *Error {\n\tmsg.Type = flags\n\treturn msg\n}\n\n// SetMeta sets the error's meta data.\nfunc (msg *Error) SetMeta(data any) *Error {\n\tmsg.Meta = data\n\treturn msg\n}\n\n// JSON creates a properly formatted JSON\nfunc (msg *Error) JSON() any {\n\tjsonData := H{}\n\tif msg.Meta != nil {\n\t\tvalue := reflect.ValueOf(msg.Meta)\n\t\tswitch value.Kind() {\n\t\tcase reflect.Struct:\n\t\t\treturn msg.Meta\n\t\tcase reflect.Map:\n\t\t\tfor _, key := range value.MapKeys() {\n\t\t\t\tjsonData[key.String()] = value.MapIndex(key).Interface()\n\t\t\t}\n\t\tdefault:\n\t\t\tjsonData[\"meta\"] = msg.Meta\n\t\t}\n\t}\n\tif _, ok := jsonData[\"error\"]; !ok {\n\t\tjsonData[\"error\"] = msg.Error()\n\t}\n\treturn jsonData\n}\n\n// MarshalJSON implements the json.Marshaller interface.\nfunc (msg *Error) MarshalJSON() ([]byte, error) {\n\treturn json.API.Marshal(msg.JSON())\n}\n\n// Error implements the error interface.\nfunc (msg Error) Error() string {\n\treturn msg.Err.Error()\n}\n\n// IsType judges one error.\nfunc (msg *Error) IsType(flags ErrorType) bool {\n\treturn (msg.Type & flags) > 0\n}\n\n// Unwrap returns the wrapped error, to allow interoperability with errors.Is(), errors.As() and errors.Unwrap()\nfunc (msg Error) Unwrap() error {\n\treturn msg.Err\n}\n\n// ByType returns a readonly copy filtered the byte.\n// ie ByType(gin.ErrorTypePublic) returns a slice of errors with type=ErrorTypePublic.\nfunc (a errorMsgs) ByType(typ ErrorType) errorMsgs {\n\tif len(a) == 0 {\n\t\treturn nil\n\t}\n\tif typ == ErrorTypeAny {\n\t\treturn a\n\t}\n\tvar result errorMsgs\n\tfor _, msg := range a {\n\t\tif msg.IsType(typ) {\n\t\t\tresult = append(result, msg)\n\t\t}\n\t}\n\treturn result\n}\n\n// Last returns the last error in the slice. It returns nil if the array is empty.\n// Shortcut for errors[len(errors)-1].\nfunc (a errorMsgs) Last() *Error {\n\tif length := len(a); length > 0 {\n\t\treturn a[length-1]\n\t}\n\treturn nil\n}\n\n// Errors returns an array with all the error messages.\n// Example:\n//\n//\tc.Error(errors.New(\"first\"))\n//\tc.Error(errors.New(\"second\"))\n//\tc.Error(errors.New(\"third\"))\n//\tc.Errors.Errors() // == []string{\"first\", \"second\", \"third\"}\nfunc (a errorMsgs) Errors() []string {\n\tif len(a) == 0 {\n\t\treturn nil\n\t}\n\terrorStrings := make([]string, len(a))\n\tfor i, err := range a {\n\t\terrorStrings[i] = err.Error()\n\t}\n\treturn errorStrings\n}\n\nfunc (a errorMsgs) JSON() any {\n\tswitch length := len(a); length {\n\tcase 0:\n\t\treturn nil\n\tcase 1:\n\t\treturn a.Last().JSON()\n\tdefault:\n\t\tjsonData := make([]any, length)\n\t\tfor i, err := range a {\n\t\t\tjsonData[i] = err.JSON()\n\t\t}\n\t\treturn jsonData\n\t}\n}\n\n// MarshalJSON implements the json.Marshaller interface.\nfunc (a errorMsgs) MarshalJSON() ([]byte, error) {\n\treturn json.API.Marshal(a.JSON())\n}\n\nfunc (a errorMsgs) String() string {\n\tif len(a) == 0 {\n\t\treturn \"\"\n\t}\n\tvar buffer strings.Builder\n\tfor i, msg := range a {\n\t\tfmt.Fprintf(&buffer, \"Error #%02d: %s\\n\", i+1, msg.Err)\n\t\tif msg.Meta != nil {\n\t\t\tfmt.Fprintf(&buffer, \"     Meta: %v\\n\", msg.Meta)\n\t\t}\n\t}\n\treturn buffer.String()\n}\n",
    "source_file": "errors.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"fmt\"\n\t\"html/template\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n\t\"regexp\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/gin-gonic/gin/internal/bytesconv\"\n\tfilesystem \"github.com/gin-gonic/gin/internal/fs\"\n\t\"github.com/gin-gonic/gin/render\"\n\t\"github.com/quic-go/quic-go/http3\"\n\t\"golang.org/x/net/http2\"\n\t\"golang.org/x/net/http2/h2c\"\n)\n\nconst defaultMultipartMemory = 32 << 20 // 32 MB\nconst escapedColon = \"\\\\:\"\nconst colon = \":\"\nconst backslash = \"\\\\\"\n\nvar (\n\tdefault404Body = []byte(\"404 page not found\")\n\tdefault405Body = []byte(\"405 method not allowed\")\n)\n\nvar defaultPlatform string\n\nvar defaultTrustedCIDRs = []*net.IPNet{\n\t{ // 0.0.0.0/0 (IPv4)\n\t\tIP:   net.IP{0x0, 0x0, 0x0, 0x0},\n\t\tMask: net.IPMask{0x0, 0x0, 0x0, 0x0},\n\t},\n\t{ // ::/0 (IPv6)\n\t\tIP:   net.IP{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},\n\t\tMask: net.IPMask{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},\n\t},\n}\n\nvar regSafePrefix = regexp.MustCompile(\"[^a-zA-Z0-9/-]+\")\nvar regRemoveRepeatedChar = regexp.MustCompile(\"/{2,}\")\n\n// HandlerFunc defines the handler used by gin middleware as return value.\ntype HandlerFunc func(*Context)\n\n// OptionFunc defines the function to change the default configuration\ntype OptionFunc func(*Engine)\n\n// HandlersChain defines a HandlerFunc slice.\ntype HandlersChain []HandlerFunc\n\n// Last returns the last handler in the chain. i.e. the last handler is the main one.\nfunc (c HandlersChain) Last() HandlerFunc {\n\tif length := len(c); length > 0 {\n\t\treturn c[length-1]\n\t}\n\treturn nil\n}\n\n// RouteInfo represents a request route's specification which contains method and path and its handler.\ntype RouteInfo struct {\n\tMethod      string\n\tPath        string\n\tHandler     string\n\tHandlerFunc HandlerFunc\n}\n\n// RoutesInfo defines a RouteInfo slice.\ntype RoutesInfo []RouteInfo\n\n// Trusted platforms\nconst (\n\t// PlatformGoogleAppEngine when running on Google App Engine. Trust X-Appengine-Remote-Addr\n\t// for determining the client's IP\n\tPlatformGoogleAppEngine = \"X-Appengine-Remote-Addr\"\n\t// PlatformCloudflare when using Cloudflare's CDN. Trust CF-Connecting-IP for determining\n\t// the client's IP\n\tPlatformCloudflare = \"CF-Connecting-IP\"\n\t// PlatformFlyIO when running on Fly.io. Trust Fly-Client-IP for determining the client's IP\n\tPlatformFlyIO = \"Fly-Client-IP\"\n)\n\n// Engine is the framework's instance, it contains the muxer, middleware and configuration settings.\n// Create an instance of Engine, by using New() or Default()\ntype Engine struct {\n\tRouterGroup\n\n\t// RedirectTrailingSlash enables automatic redirection if the current route can't be matched but a\n\t// handler for the path with (without) the trailing slash exists.\n\t// For example if /foo/ is requested but a route only exists for /foo, the\n\t// client is redirected to /foo with http status code 301 for GET requests\n\t// and 307 for all other request methods.\n\tRedirectTrailingSlash bool\n\n\t// RedirectFixedPath if enabled, the router tries to fix the current request path, if no\n\t// handle is registered for it.\n\t// First superfluous path elements like ../ or // are removed.\n\t// Afterwards the router does a case-insensitive lookup of the cleaned path.\n\t// If a handle can be found for this route, the router makes a redirection\n\t// to the corrected path with status code 301 for GET requests and 307 for\n\t// all other request methods.\n\t// For example /FOO and /..//Foo could be redirected to /foo.\n\t// RedirectTrailingSlash is independent of this option.\n\tRedirectFixedPath bool\n\n\t// HandleMethodNotAllowed if enabled, the router checks if another method is allowed for the\n\t// current route, if the current request can not be routed.\n\t// If this is the case, the request is answered with 'Method Not Allowed'\n\t// and HTTP status code 405.\n\t// If no other Method is allowed, the request is delegated to the NotFound\n\t// handler.\n\tHandleMethodNotAllowed bool\n\n\t// ForwardedByClientIP if enabled, client IP will be parsed from the request's headers that\n\t// match those stored at `(*gin.Engine).RemoteIPHeaders`. If no IP was\n\t// fetched, it falls back to the IP obtained from\n\t// `(*gin.Context).Request.RemoteAddr`.\n\tForwardedByClientIP bool\n\n\t// AppEngine was deprecated.\n\t// Deprecated: USE `TrustedPlatform` WITH VALUE `gin.PlatformGoogleAppEngine` INSTEAD\n\t// #726 #755 If enabled, it will trust some headers starting with\n\t// 'X-AppEngine...' for better integration with that PaaS.\n\tAppEngine bool\n\n\t// UseRawPath if enabled, the url.RawPath will be used to find parameters.\n\tUseRawPath bool\n\n\t// UnescapePathValues if true, the path value will be unescaped.\n\t// If UseRawPath is false (by default), the UnescapePathValues effectively is true,\n\t// as url.Path gonna be used, which is already unescaped.\n\tUnescapePathValues bool\n\n\t// RemoveExtraSlash a parameter can be parsed from the URL even with extra slashes.\n\t// See the PR #1817 and issue #1644\n\tRemoveExtraSlash bool\n\n\t// RemoteIPHeaders list of headers used to obtain the client IP when\n\t// `(*gin.Engine).ForwardedByClientIP` is `true` and\n\t// `(*gin.Context).Request.RemoteAddr` is matched by at least one of the\n\t// network origins of list defined by `(*gin.Engine).SetTrustedProxies()`.\n\tRemoteIPHeaders []string\n\n\t// TrustedPlatform if set to a constant of value gin.Platform*, trusts the headers set by\n\t// that platform, for example to determine the client IP\n\tTrustedPlatform string\n\n\t// MaxMultipartMemory value of 'maxMemory' param that is given to http.Request's ParseMultipartForm\n\t// method call.\n\tMaxMultipartMemory int64\n\n\t// UseH2C enable h2c support.\n\tUseH2C bool\n\n\t// ContextWithFallback enable fallback Context.Deadline(), Context.Done(), Context.Err() and Context.Value() when Context.Request.Context() is not nil.\n\tContextWithFallback bool\n\n\tdelims           render.Delims\n\tsecureJSONPrefix string\n\tHTMLRender       render.HTMLRender\n\tFuncMap          template.FuncMap\n\tallNoRoute       HandlersChain\n\tallNoMethod      HandlersChain\n\tnoRoute          HandlersChain\n\tnoMethod         HandlersChain\n\tpool             sync.Pool\n\ttrees            methodTrees\n\tmaxParams        uint16\n\tmaxSections      uint16\n\ttrustedProxies   []string\n\ttrustedCIDRs     []*net.IPNet\n}\n\nvar _ IRouter = (*Engine)(nil)\n\n// New returns a new blank Engine instance without any middleware attached.\n// By default, the configuration is:\n// - RedirectTrailingSlash:  true\n// - RedirectFixedPath:      false\n// - HandleMethodNotAllowed: false\n// - ForwardedByClientIP:    true\n// - UseRawPath:             false\n// - UnescapePathValues:     true\nfunc New(opts ...OptionFunc) *Engine {\n\tdebugPrintWARNINGNew()\n\tengine := &Engine{\n\t\tRouterGroup: RouterGroup{\n\t\t\tHandlers: nil,\n\t\t\tbasePath: \"/\",\n\t\t\troot:     true,\n\t\t},\n\t\tFuncMap:                template.FuncMap{},\n\t\tRedirectTrailingSlash:  true,\n\t\tRedirectFixedPath:      false,\n\t\tHandleMethodNotAllowed: false,\n\t\tForwardedByClientIP:    true,\n\t\tRemoteIPHeaders:        []string{\"X-Forwarded-For\", \"X-Real-IP\"},\n\t\tTrustedPlatform:        defaultPlatform,\n\t\tUseRawPath:             false,\n\t\tRemoveExtraSlash:       false,\n\t\tUnescapePathValues:     true,\n\t\tMaxMultipartMemory:     defaultMultipartMemory,\n\t\ttrees:                  make(methodTrees, 0, 9),\n\t\tdelims:                 render.Delims{Left: \"{{\", Right: \"}}\"},\n\t\tsecureJSONPrefix:       \"while(1);\",\n\t\ttrustedProxies:         []string{\"0.0.0.0/0\", \"::/0\"},\n\t\ttrustedCIDRs:           defaultTrustedCIDRs,\n\t}\n\tengine.engine = engine\n\tengine.pool.New = func() any {\n\t\treturn engine.allocateContext(engine.maxParams)\n\t}\n\treturn engine.With(opts...)\n}\n\n// Default returns an Engine instance with the Logger and Recovery middleware already attached.\nfunc Default(opts ...OptionFunc) *Engine {\n\tdebugPrintWARNINGDefault()\n\tengine := New()\n\tengine.Use(Logger(), Recovery())\n\treturn engine.With(opts...)\n}\n\nfunc (engine *Engine) Handler() http.Handler {\n\tif !engine.UseH2C {\n\t\treturn engine\n\t}\n\n\th2s := &http2.Server{}\n\treturn h2c.NewHandler(engine, h2s)\n}\n\nfunc (engine *Engine) allocateContext(maxParams uint16) *Context {\n\tv := make(Params, 0, maxParams)\n\tskippedNodes := make([]skippedNode, 0, engine.maxSections)\n\treturn &Context{engine: engine, params: &v, skippedNodes: &skippedNodes}\n}\n\n// Delims sets template left and right delims and returns an Engine instance.\nfunc (engine *Engine) Delims(left, right string) *Engine {\n\tengine.delims = render.Delims{Left: left, Right: right}\n\treturn engine\n}\n\n// SecureJsonPrefix sets the secureJSONPrefix used in Context.SecureJSON.\nfunc (engine *Engine) SecureJsonPrefix(prefix string) *Engine {\n\tengine.secureJSONPrefix = prefix\n\treturn engine\n}\n\n// LoadHTMLGlob loads HTML files identified by glob pattern\n// and associates the result with HTML renderer.\nfunc (engine *Engine) LoadHTMLGlob(pattern string) {\n\tleft := engine.delims.Left\n\tright := engine.delims.Right\n\ttempl := template.Must(template.New(\"\").Delims(left, right).Funcs(engine.FuncMap).ParseGlob(pattern))\n\n\tif IsDebugging() {\n\t\tdebugPrintLoadTemplate(templ)\n\t\tengine.HTMLRender = render.HTMLDebug{Glob: pattern, FuncMap: engine.FuncMap, Delims: engine.delims}\n\t\treturn\n\t}\n\n\tengine.SetHTMLTemplate(templ)\n}\n\n// LoadHTMLFiles loads a slice of HTML files\n// and associates the result with HTML renderer.\nfunc (engine *Engine) LoadHTMLFiles(files ...string) {\n\tif IsDebugging() {\n\t\tengine.HTMLRender = render.HTMLDebug{Files: files, FuncMap: engine.FuncMap, Delims: engine.delims}\n\t\treturn\n\t}\n\n\ttempl := template.Must(template.New(\"\").Delims(engine.delims.Left, engine.delims.Right).Funcs(engine.FuncMap).ParseFiles(files...))\n\tengine.SetHTMLTemplate(templ)\n}\n\n// LoadHTMLFS loads an http.FileSystem and a slice of patterns\n// and associates the result with HTML renderer.\nfunc (engine *Engine) LoadHTMLFS(fs http.FileSystem, patterns ...string) {\n\tif IsDebugging() {\n\t\tengine.HTMLRender = render.HTMLDebug{FileSystem: fs, Patterns: patterns, FuncMap: engine.FuncMap, Delims: engine.delims}\n\t\treturn\n\t}\n\n\ttempl := template.Must(template.New(\"\").Delims(engine.delims.Left, engine.delims.Right).Funcs(engine.FuncMap).ParseFS(\n\t\tfilesystem.FileSystem{FileSystem: fs}, patterns...))\n\tengine.SetHTMLTemplate(templ)\n}\n\n// SetHTMLTemplate associate a template with HTML renderer.\nfunc (engine *Engine) SetHTMLTemplate(templ *template.Template) {\n\tif len(engine.trees) > 0 {\n\t\tdebugPrintWARNINGSetHTMLTemplate()\n\t}\n\n\tengine.HTMLRender = render.HTMLProduction{Template: templ.Funcs(engine.FuncMap)}\n}\n\n// SetFuncMap sets the FuncMap used for template.FuncMap.\nfunc (engine *Engine) SetFuncMap(funcMap template.FuncMap) {\n\tengine.FuncMap = funcMap\n}\n\n// NoRoute adds handlers for NoRoute. It returns a 404 code by default.\nfunc (engine *Engine) NoRoute(handlers ...HandlerFunc) {\n\tengine.noRoute = handlers\n\tengine.rebuild404Handlers()\n}\n\n// NoMethod sets the handlers called when Engine.HandleMethodNotAllowed = true.\nfunc (engine *Engine) NoMethod(handlers ...HandlerFunc) {\n\tengine.noMethod = handlers\n\tengine.rebuild405Handlers()\n}\n\n// Use attaches a global middleware to the router. i.e. the middleware attached through Use() will be\n// included in the handlers chain for every single request. Even 404, 405, static files...\n// For example, this is the right place for a logger or error management middleware.\nfunc (engine *Engine) Use(middleware ...HandlerFunc) IRoutes {\n\tengine.RouterGroup.Use(middleware...)\n\tengine.rebuild404Handlers()\n\tengine.rebuild405Handlers()\n\treturn engine\n}\n\n// With returns an Engine with the configuration set in the OptionFunc.\nfunc (engine *Engine) With(opts ...OptionFunc) *Engine {\n\tfor _, opt := range opts {\n\t\topt(engine)\n\t}\n\n\treturn engine\n}\n\nfunc (engine *Engine) rebuild404Handlers() {\n\tengine.allNoRoute = engine.combineHandlers(engine.noRoute)\n}\n\nfunc (engine *Engine) rebuild405Handlers() {\n\tengine.allNoMethod = engine.combineHandlers(engine.noMethod)\n}\n\nfunc (engine *Engine) addRoute(method, path string, handlers HandlersChain) {\n\tassert1(path[0] == '/', \"path must begin with '/'\")\n\tassert1(method != \"\", \"HTTP method can not be empty\")\n\tassert1(len(handlers) > 0, \"there must be at least one handler\")\n\n\tdebugPrintRoute(method, path, handlers)\n\n\troot := engine.trees.get(method)\n\tif root == nil {\n\t\troot = new(node)\n\t\troot.fullPath = \"/\"\n\t\tengine.trees = append(engine.trees, methodTree{method: method, root: root})\n\t}\n\troot.addRoute(path, handlers)\n\n\tif paramsCount := countParams(path); paramsCount > engine.maxParams {\n\t\tengine.maxParams = paramsCount\n\t}\n\n\tif sectionsCount := countSections(path); sectionsCount > engine.maxSections {\n\t\tengine.maxSections = sectionsCount\n\t}\n}\n\n// Routes returns a slice of registered routes, including some useful information, such as:\n// the http method, path, and the handler name.\nfunc (engine *Engine) Routes() (routes RoutesInfo) {\n\tfor _, tree := range engine.trees {\n\t\troutes = iterate(\"\", tree.method, routes, tree.root)\n\t}\n\treturn routes\n}\n\nfunc iterate(path, method string, routes RoutesInfo, root *node) RoutesInfo {\n\tpath += root.path\n\tif len(root.handlers) > 0 {\n\t\thandlerFunc := root.handlers.Last()\n\t\troutes = append(routes, RouteInfo{\n\t\t\tMethod:      method,\n\t\t\tPath:        path,\n\t\t\tHandler:     nameOfFunction(handlerFunc),\n\t\t\tHandlerFunc: handlerFunc,\n\t\t})\n\t}\n\tfor _, child := range root.children {\n\t\troutes = iterate(path, method, routes, child)\n\t}\n\treturn routes\n}\n\nfunc (engine *Engine) prepareTrustedCIDRs() ([]*net.IPNet, error) {\n\tif engine.trustedProxies == nil {\n\t\treturn nil, nil\n\t}\n\n\tcidr := make([]*net.IPNet, 0, len(engine.trustedProxies))\n\tfor _, trustedProxy := range engine.trustedProxies {\n\t\tif !strings.Contains(trustedProxy, \"/\") {\n\t\t\tip := parseIP(trustedProxy)\n\t\t\tif ip == nil {\n\t\t\t\treturn cidr, &net.ParseError{Type: \"IP address\", Text: trustedProxy}\n\t\t\t}\n\n\t\t\tswitch len(ip) {\n\t\t\tcase net.IPv4len:\n\t\t\t\ttrustedProxy += \"/32\"\n\t\t\tcase net.IPv6len:\n\t\t\t\ttrustedProxy += \"/128\"\n\t\t\t}\n\t\t}\n\t\t_, cidrNet, err := net.ParseCIDR(trustedProxy)\n\t\tif err != nil {\n\t\t\treturn cidr, err\n\t\t}\n\t\tcidr = append(cidr, cidrNet)\n\t}\n\treturn cidr, nil\n}\n\n// SetTrustedProxies set a list of network origins (IPv4 addresses,\n// IPv4 CIDRs, IPv6 addresses or IPv6 CIDRs) from which to trust\n// request's headers that contain alternative client IP when\n// `(*gin.Engine).ForwardedByClientIP` is `true`. `TrustedProxies`\n// feature is enabled by default, and it also trusts all proxies\n// by default. If you want to disable this feature, use\n// Engine.SetTrustedProxies(nil), then Context.ClientIP() will\n// return the remote address directly.\nfunc (engine *Engine) SetTrustedProxies(trustedProxies []string) error {\n\tengine.trustedProxies = trustedProxies\n\treturn engine.parseTrustedProxies()\n}\n\n// isUnsafeTrustedProxies checks if Engine.trustedCIDRs contains all IPs, it's not safe if it has (returns true)\nfunc (engine *Engine) isUnsafeTrustedProxies() bool {\n\treturn engine.isTrustedProxy(net.ParseIP(\"0.0.0.0\")) || engine.isTrustedProxy(net.ParseIP(\"::\"))\n}\n\n// parseTrustedProxies parse Engine.trustedProxies to Engine.trustedCIDRs\nfunc (engine *Engine) parseTrustedProxies() error {\n\ttrustedCIDRs, err := engine.prepareTrustedCIDRs()\n\tengine.trustedCIDRs = trustedCIDRs\n\treturn err\n}\n\n// isTrustedProxy will check whether the IP address is included in the trusted list according to Engine.trustedCIDRs\nfunc (engine *Engine) isTrustedProxy(ip net.IP) bool {\n\tif engine.trustedCIDRs == nil {\n\t\treturn false\n\t}\n\tfor _, cidr := range engine.trustedCIDRs {\n\t\tif cidr.Contains(ip) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// validateHeader will parse X-Forwarded-For header and return the trusted client IP address\nfunc (engine *Engine) validateHeader(header string) (clientIP string, valid bool) {\n\tif header == \"\" {\n\t\treturn \"\", false\n\t}\n\titems := strings.Split(header, \",\")\n\tfor i := len(items) - 1; i >= 0; i-- {\n\t\tipStr := strings.TrimSpace(items[i])\n\t\tip := net.ParseIP(ipStr)\n\t\tif ip == nil {\n\t\t\tbreak\n\t\t}\n\n\t\t// X-Forwarded-For is appended by proxy\n\t\t// Check IPs in reverse order and stop when find untrusted proxy\n\t\tif (i == 0) || (!engine.isTrustedProxy(ip)) {\n\t\t\treturn ipStr, true\n\t\t}\n\t}\n\treturn \"\", false\n}\n\n// updateRouteTree do update to the route tree recursively\nfunc updateRouteTree(n *node) {\n\tn.path = strings.ReplaceAll(n.path, escapedColon, colon)\n\tn.fullPath = strings.ReplaceAll(n.fullPath, escapedColon, colon)\n\tn.indices = strings.ReplaceAll(n.indices, backslash, colon)\n\tif n.children == nil {\n\t\treturn\n\t}\n\tfor _, child := range n.children {\n\t\tupdateRouteTree(child)\n\t}\n}\n\n// updateRouteTrees do update to the route trees\nfunc (engine *Engine) updateRouteTrees() {\n\tfor _, tree := range engine.trees {\n\t\tupdateRouteTree(tree.root)\n\t}\n}\n\n// parseIP parse a string representation of an IP and returns a net.IP with the\n// minimum byte representation or nil if input is invalid.\nfunc parseIP(ip string) net.IP {\n\tparsedIP := net.ParseIP(ip)\n\n\tif ipv4 := parsedIP.To4(); ipv4 != nil {\n\t\t// return ip in a 4-byte representation\n\t\treturn ipv4\n\t}\n\n\t// return ip in a 16-byte representation or nil\n\treturn parsedIP\n}\n\n// Run attaches the router to a http.Server and starts listening and serving HTTP requests.\n// It is a shortcut for http.ListenAndServe(addr, router)\n// Note: this method will block the calling goroutine indefinitely unless an error happens.\nfunc (engine *Engine) Run(addr ...string) (err error) {\n\tdefer func() { debugPrintError(err) }()\n\n\tif engine.isUnsafeTrustedProxies() {\n\t\tdebugPrint(\"[WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.\\n\" +\n\t\t\t\"Please check https://github.com/gin-gonic/gin/blob/master/docs/doc.md#dont-trust-all-proxies for details.\")\n\t}\n\tengine.updateRouteTrees()\n\taddress := resolveAddress(addr)\n\tdebugPrint(\"Listening and serving HTTP on %s\\n\", address)\n\terr = http.ListenAndServe(address, engine.Handler())\n\treturn\n}\n\n// RunTLS attaches the router to a http.Server and starts listening and serving HTTPS (secure) requests.\n// It is a shortcut for http.ListenAndServeTLS(addr, certFile, keyFile, router)\n// Note: this method will block the calling goroutine indefinitely unless an error happens.\nfunc (engine *Engine) RunTLS(addr, certFile, keyFile string) (err error) {\n\tdebugPrint(\"Listening and serving HTTPS on %s\\n\", addr)\n\tdefer func() { debugPrintError(err) }()\n\n\tif engine.isUnsafeTrustedProxies() {\n\t\tdebugPrint(\"[WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.\\n\" +\n\t\t\t\"Please check https://github.com/gin-gonic/gin/blob/master/docs/doc.md#dont-trust-all-proxies for details.\")\n\t}\n\n\terr = http.ListenAndServeTLS(addr, certFile, keyFile, engine.Handler())\n\treturn\n}\n\n// RunUnix attaches the router to a http.Server and starts listening and serving HTTP requests\n// through the specified unix socket (i.e. a file).\n// Note: this method will block the calling goroutine indefinitely unless an error happens.\nfunc (engine *Engine) RunUnix(file string) (err error) {\n\tdebugPrint(\"Listening and serving HTTP on unix:/%s\", file)\n\tdefer func() { debugPrintError(err) }()\n\n\tif engine.isUnsafeTrustedProxies() {\n\t\tdebugPrint(\"[WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.\\n\" +\n\t\t\t\"Please check https://github.com/gin-gonic/gin/blob/master/docs/doc.md#dont-trust-all-proxies for details.\")\n\t}\n\n\tlistener, err := net.Listen(\"unix\", file)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer listener.Close()\n\tdefer os.Remove(file)\n\n\terr = http.Serve(listener, engine.Handler())\n\treturn\n}\n\n// RunFd attaches the router to a http.Server and starts listening and serving HTTP requests\n// through the specified file descriptor.\n// Note: this method will block the calling goroutine indefinitely unless an error happens.\nfunc (engine *Engine) RunFd(fd int) (err error) {\n\tdebugPrint(\"Listening and serving HTTP on fd@%d\", fd)\n\tdefer func() { debugPrintError(err) }()\n\n\tif engine.isUnsafeTrustedProxies() {\n\t\tdebugPrint(\"[WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.\\n\" +\n\t\t\t\"Please check https://github.com/gin-gonic/gin/blob/master/docs/doc.md#dont-trust-all-proxies for details.\")\n\t}\n\n\tf := os.NewFile(uintptr(fd), fmt.Sprintf(\"fd@%d\", fd))\n\tlistener, err := net.FileListener(f)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer listener.Close()\n\terr = engine.RunListener(listener)\n\treturn\n}\n\n// RunQUIC attaches the router to a http.Server and starts listening and serving QUIC requests.\n// It is a shortcut for http3.ListenAndServeQUIC(addr, certFile, keyFile, router)\n// Note: this method will block the calling goroutine indefinitely unless an error happens.\nfunc (engine *Engine) RunQUIC(addr, certFile, keyFile string) (err error) {\n\tdebugPrint(\"Listening and serving QUIC on %s\\n\", addr)\n\tdefer func() { debugPrintError(err) }()\n\n\tif engine.isUnsafeTrustedProxies() {\n\t\tdebugPrint(\"[WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.\\n\" +\n\t\t\t\"Please check https://github.com/gin-gonic/gin/blob/master/docs/doc.md#dont-trust-all-proxies for details.\")\n\t}\n\n\terr = http3.ListenAndServeQUIC(addr, certFile, keyFile, engine.Handler())\n\treturn\n}\n\n// RunListener attaches the router to a http.Server and starts listening and serving HTTP requests\n// through the specified net.Listener\nfunc (engine *Engine) RunListener(listener net.Listener) (err error) {\n\tdebugPrint(\"Listening and serving HTTP on listener what's bind with address@%s\", listener.Addr())\n\tdefer func() { debugPrintError(err) }()\n\n\tif engine.isUnsafeTrustedProxies() {\n\t\tdebugPrint(\"[WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.\\n\" +\n\t\t\t\"Please check https://github.com/gin-gonic/gin/blob/master/docs/doc.md#dont-trust-all-proxies for details.\")\n\t}\n\n\terr = http.Serve(listener, engine.Handler())\n\treturn\n}\n\n// ServeHTTP conforms to the http.Handler interface.\nfunc (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n\tc := engine.pool.Get().(*Context)\n\tc.writermem.reset(w)\n\tc.Request = req\n\tc.reset()\n\n\tengine.handleHTTPRequest(c)\n\n\tengine.pool.Put(c)\n}\n\n// HandleContext re-enters a context that has been rewritten.\n// This can be done by setting c.Request.URL.Path to your new target.\n// Disclaimer: You can loop yourself to deal with this, use wisely.\nfunc (engine *Engine) HandleContext(c *Context) {\n\toldIndexValue := c.index\n\toldHandlers := c.handlers\n\tc.reset()\n\tengine.handleHTTPRequest(c)\n\n\tc.index = oldIndexValue\n\tc.handlers = oldHandlers\n}\n\nfunc (engine *Engine) handleHTTPRequest(c *Context) {\n\thttpMethod := c.Request.Method\n\trPath := c.Request.URL.Path\n\tunescape := false\n\tif engine.UseRawPath && len(c.Request.URL.RawPath) > 0 {\n\t\trPath = c.Request.URL.RawPath\n\t\tunescape = engine.UnescapePathValues\n\t}\n\n\tif engine.RemoveExtraSlash {\n\t\trPath = cleanPath(rPath)\n\t}\n\n\t// Find root of the tree for the given HTTP method\n\tt := engine.trees\n\tfor i, tl := 0, len(t); i < tl; i++ {\n\t\tif t[i].method != httpMethod {\n\t\t\tcontinue\n\t\t}\n\t\troot := t[i].root\n\t\t// Find route in tree\n\t\tvalue := root.getValue(rPath, c.params, c.skippedNodes, unescape)\n\t\tif value.params != nil {\n\t\t\tc.Params = *value.params\n\t\t}\n\t\tif value.handlers != nil {\n\t\t\tc.handlers = value.handlers\n\t\t\tc.fullPath = value.fullPath\n\t\t\tc.Next()\n\t\t\tc.writermem.WriteHeaderNow()\n\t\t\treturn\n\t\t}\n\t\tif httpMethod != http.MethodConnect && rPath != \"/\" {\n\t\t\tif value.tsr && engine.RedirectTrailingSlash {\n\t\t\t\tredirectTrailingSlash(c)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif engine.RedirectFixedPath && redirectFixedPath(c, root, engine.RedirectFixedPath) {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tbreak\n\t}\n\n\tif engine.HandleMethodNotAllowed && len(t) > 0 {\n\t\t// According to RFC 7231 section 6.5.5, MUST generate an Allow header field in response\n\t\t// containing a list of the target resource's currently supported methods.\n\t\tallowed := make([]string, 0, len(t)-1)\n\t\tfor _, tree := range engine.trees {\n\t\t\tif tree.method == httpMethod {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif value := tree.root.getValue(rPath, nil, c.skippedNodes, unescape); value.handlers != nil {\n\t\t\t\tallowed = append(allowed, tree.method)\n\t\t\t}\n\t\t}\n\t\tif len(allowed) > 0 {\n\t\t\tc.handlers = engine.allNoMethod\n\t\t\tc.writermem.Header().Set(\"Allow\", strings.Join(allowed, \", \"))\n\t\t\tserveError(c, http.StatusMethodNotAllowed, default405Body)\n\t\t\treturn\n\t\t}\n\t}\n\n\tc.handlers = engine.allNoRoute\n\tserveError(c, http.StatusNotFound, default404Body)\n}\n\nvar mimePlain = []string{MIMEPlain}\n\nfunc serveError(c *Context, code int, defaultMessage []byte) {\n\tc.writermem.status = code\n\tc.Next()\n\tif c.writermem.Written() {\n\t\treturn\n\t}\n\tif c.writermem.Status() == code {\n\t\tc.writermem.Header()[\"Content-Type\"] = mimePlain\n\t\t_, err := c.Writer.Write(defaultMessage)\n\t\tif err != nil {\n\t\t\tdebugPrint(\"cannot write message to writer during serve error: %v\", err)\n\t\t}\n\t\treturn\n\t}\n\tc.writermem.WriteHeaderNow()\n}\n\nfunc redirectTrailingSlash(c *Context) {\n\treq := c.Request\n\tp := req.URL.Path\n\tif prefix := path.Clean(c.Request.Header.Get(\"X-Forwarded-Prefix\")); prefix != \".\" {\n\t\tprefix = regSafePrefix.ReplaceAllString(prefix, \"\")\n\t\tprefix = regRemoveRepeatedChar.ReplaceAllString(prefix, \"/\")\n\n\t\tp = prefix + \"/\" + req.URL.Path\n\t}\n\treq.URL.Path = p + \"/\"\n\tif length := len(p); length > 1 && p[length-1] == '/' {\n\t\treq.URL.Path = p[:length-1]\n\t}\n\tredirectRequest(c)\n}\n\nfunc redirectFixedPath(c *Context, root *node, trailingSlash bool) bool {\n\treq := c.Request\n\trPath := req.URL.Path\n\n\tif fixedPath, ok := root.findCaseInsensitivePath(cleanPath(rPath), trailingSlash); ok {\n\t\treq.URL.Path = bytesconv.BytesToString(fixedPath)\n\t\tredirectRequest(c)\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc redirectRequest(c *Context) {\n\treq := c.Request\n\trPath := req.URL.Path\n\trURL := req.URL.String()\n\n\tcode := http.StatusMovedPermanently // Permanent redirect, request with GET method\n\tif req.Method != http.MethodGet {\n\t\tcode = http.StatusTemporaryRedirect\n\t}\n\tdebugPrint(\"redirecting request %d: %s --> %s\", code, rPath, rURL)\n\thttp.Redirect(c.Writer, req, rURL, code)\n\tc.writermem.WriteHeaderNow()\n}\n",
    "source_file": "gin.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage render\n\nimport \"net/http\"\n\n// Render interface is to be implemented by JSON, XML, HTML, YAML and so on.\ntype Render interface {\n\t// Render writes data with custom ContentType.\n\tRender(http.ResponseWriter) error\n\t// WriteContentType writes custom ContentType.\n\tWriteContentType(w http.ResponseWriter)\n}\n\nvar (\n\t_ Render     = (*JSON)(nil)\n\t_ Render     = (*IndentedJSON)(nil)\n\t_ Render     = (*SecureJSON)(nil)\n\t_ Render     = (*JsonpJSON)(nil)\n\t_ Render     = (*XML)(nil)\n\t_ Render     = (*String)(nil)\n\t_ Render     = (*Redirect)(nil)\n\t_ Render     = (*Data)(nil)\n\t_ Render     = (*HTML)(nil)\n\t_ HTMLRender = (*HTMLDebug)(nil)\n\t_ HTMLRender = (*HTMLProduction)(nil)\n\t_ Render     = (*YAML)(nil)\n\t_ Render     = (*Reader)(nil)\n\t_ Render     = (*AsciiJSON)(nil)\n\t_ Render     = (*ProtoBuf)(nil)\n\t_ Render     = (*TOML)(nil)\n)\n\nfunc writeContentType(w http.ResponseWriter, value []string) {\n\theader := w.Header()\n\tif val := header[\"Content-Type\"]; len(val) == 0 {\n\t\theader[\"Content-Type\"] = value\n\t}\n}\n",
    "source_file": "render/render.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2017 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\n//go:build !nomsgpack\n\npackage render\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/ugorji/go/codec\"\n)\n\n// Check interface implemented here to support go build tag nomsgpack.\n// See: https://github.com/gin-gonic/gin/pull/1852/\nvar (\n\t_ Render = MsgPack{}\n)\n\n// MsgPack contains the given interface object.\ntype MsgPack struct {\n\tData any\n}\n\nvar msgpackContentType = []string{\"application/msgpack; charset=utf-8\"}\n\n// WriteContentType (MsgPack) writes MsgPack ContentType.\nfunc (r MsgPack) WriteContentType(w http.ResponseWriter) {\n\twriteContentType(w, msgpackContentType)\n}\n\n// Render (MsgPack) encodes the given interface object and writes data with custom ContentType.\nfunc (r MsgPack) Render(w http.ResponseWriter) error {\n\treturn WriteMsgPack(w, r.Data)\n}\n\n// WriteMsgPack writes MsgPack ContentType and encodes the given interface object.\nfunc WriteMsgPack(w http.ResponseWriter, obj any) error {\n\twriteContentType(w, msgpackContentType)\n\tvar mh codec.MsgpackHandle\n\treturn codec.NewEncoder(w, &mh).Encode(obj)\n}\n",
    "source_file": "render/msgpack.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage render\n\nimport (\n\t\"encoding/xml\"\n\t\"net/http\"\n)\n\n// XML contains the given interface object.\ntype XML struct {\n\tData any\n}\n\nvar xmlContentType = []string{\"application/xml; charset=utf-8\"}\n\n// Render (XML) encodes the given interface object and writes data with custom ContentType.\nfunc (r XML) Render(w http.ResponseWriter) error {\n\tr.WriteContentType(w)\n\treturn xml.NewEncoder(w).Encode(r.Data)\n}\n\n// WriteContentType (XML) writes XML ContentType for response.\nfunc (r XML) WriteContentType(w http.ResponseWriter) {\n\twriteContentType(w, xmlContentType)\n}\n",
    "source_file": "render/xml.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage render\n\nimport (\n\t\"html/template\"\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin/internal/fs\"\n)\n\n// Delims represents a set of Left and Right delimiters for HTML template rendering.\ntype Delims struct {\n\t// Left delimiter, defaults to {{.\n\tLeft string\n\t// Right delimiter, defaults to }}.\n\tRight string\n}\n\n// HTMLRender interface is to be implemented by HTMLProduction and HTMLDebug.\ntype HTMLRender interface {\n\t// Instance returns an HTML instance.\n\tInstance(string, any) Render\n}\n\n// HTMLProduction contains template reference and its delims.\ntype HTMLProduction struct {\n\tTemplate *template.Template\n\tDelims   Delims\n}\n\n// HTMLDebug contains template delims and pattern and function with file list.\ntype HTMLDebug struct {\n\tFiles      []string\n\tGlob       string\n\tFileSystem http.FileSystem\n\tPatterns   []string\n\tDelims     Delims\n\tFuncMap    template.FuncMap\n}\n\n// HTML contains template reference and its name with given interface object.\ntype HTML struct {\n\tTemplate *template.Template\n\tName     string\n\tData     any\n}\n\nvar htmlContentType = []string{\"text/html; charset=utf-8\"}\n\n// Instance (HTMLProduction) returns an HTML instance which it realizes Render interface.\nfunc (r HTMLProduction) Instance(name string, data any) Render {\n\treturn HTML{\n\t\tTemplate: r.Template,\n\t\tName:     name,\n\t\tData:     data,\n\t}\n}\n\n// Instance (HTMLDebug) returns an HTML instance which it realizes Render interface.\nfunc (r HTMLDebug) Instance(name string, data any) Render {\n\treturn HTML{\n\t\tTemplate: r.loadTemplate(),\n\t\tName:     name,\n\t\tData:     data,\n\t}\n}\n\nfunc (r HTMLDebug) loadTemplate() *template.Template {\n\tif r.FuncMap == nil {\n\t\tr.FuncMap = template.FuncMap{}\n\t}\n\tif len(r.Files) > 0 {\n\t\treturn template.Must(template.New(\"\").Delims(r.Delims.Left, r.Delims.Right).Funcs(r.FuncMap).ParseFiles(r.Files...))\n\t}\n\tif r.Glob != \"\" {\n\t\treturn template.Must(template.New(\"\").Delims(r.Delims.Left, r.Delims.Right).Funcs(r.FuncMap).ParseGlob(r.Glob))\n\t}\n\tif r.FileSystem != nil && len(r.Patterns) > 0 {\n\t\treturn template.Must(template.New(\"\").Delims(r.Delims.Left, r.Delims.Right).Funcs(r.FuncMap).ParseFS(\n\t\t\tfs.FileSystem{FileSystem: r.FileSystem}, r.Patterns...))\n\t}\n\tpanic(\"the HTML debug render was created without files or glob pattern or file system with patterns\")\n}\n\n// Render (HTML) executes template and writes its result with custom ContentType for response.\nfunc (r HTML) Render(w http.ResponseWriter) error {\n\tr.WriteContentType(w)\n\n\tif r.Name == \"\" {\n\t\treturn r.Template.Execute(w, r.Data)\n\t}\n\treturn r.Template.ExecuteTemplate(w, r.Name, r.Data)\n}\n\n// WriteContentType (HTML) writes HTML ContentType.\nfunc (r HTML) WriteContentType(w http.ResponseWriter) {\n\twriteContentType(w, htmlContentType)\n}\n",
    "source_file": "render/html.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage render\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// Redirect contains the http request reference and redirects status code and location.\ntype Redirect struct {\n\tCode     int\n\tRequest  *http.Request\n\tLocation string\n}\n\n// Render (Redirect) redirects the http request to new location and writes redirect response.\nfunc (r Redirect) Render(w http.ResponseWriter) error {\n\tif (r.Code < http.StatusMultipleChoices || r.Code > http.StatusPermanentRedirect) && r.Code != http.StatusCreated {\n\t\tpanic(fmt.Sprintf(\"Cannot redirect with status code %d\", r.Code))\n\t}\n\thttp.Redirect(w, r.Request, r.Location, r.Code)\n\treturn nil\n}\n\n// WriteContentType (Redirect) don't write any ContentType.\nfunc (r Redirect) WriteContentType(http.ResponseWriter) {}\n",
    "source_file": "render/redirect.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage render\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin/internal/bytesconv\"\n)\n\n// String contains the given interface object slice and its format.\ntype String struct {\n\tFormat string\n\tData   []any\n}\n\nvar plainContentType = []string{\"text/plain; charset=utf-8\"}\n\n// Render (String) writes data with custom ContentType.\nfunc (r String) Render(w http.ResponseWriter) error {\n\treturn WriteString(w, r.Format, r.Data)\n}\n\n// WriteContentType (String) writes Plain ContentType.\nfunc (r String) WriteContentType(w http.ResponseWriter) {\n\twriteContentType(w, plainContentType)\n}\n\n// WriteString writes data according to its format and write custom ContentType.\nfunc WriteString(w http.ResponseWriter, format string, data []any) (err error) {\n\twriteContentType(w, plainContentType)\n\tif len(data) > 0 {\n\t\t_, err = fmt.Fprintf(w, format, data...)\n\t\treturn\n\t}\n\t_, err = w.Write(bytesconv.StringToBytes(format))\n\treturn\n}\n",
    "source_file": "render/text.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2018 Gin Core Team. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage render\n\nimport (\n\t\"io\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\n// Reader contains the IO reader and its length, and custom ContentType and other headers.\ntype Reader struct {\n\tContentType   string\n\tContentLength int64\n\tReader        io.Reader\n\tHeaders       map[string]string\n}\n\n// Render (Reader) writes data with custom ContentType and headers.\nfunc (r Reader) Render(w http.ResponseWriter) (err error) {\n\tr.WriteContentType(w)\n\tif r.ContentLength >= 0 {\n\t\tif r.Headers == nil {\n\t\t\tr.Headers = map[string]string{}\n\t\t}\n\t\tr.Headers[\"Content-Length\"] = strconv.FormatInt(r.ContentLength, 10)\n\t}\n\tr.writeHeaders(w, r.Headers)\n\t_, err = io.Copy(w, r.Reader)\n\treturn\n}\n\n// WriteContentType (Reader) writes custom ContentType.\nfunc (r Reader) WriteContentType(w http.ResponseWriter) {\n\twriteContentType(w, []string{r.ContentType})\n}\n\n// writeHeaders writes custom Header.\nfunc (r Reader) writeHeaders(w http.ResponseWriter, headers map[string]string) {\n\theader := w.Header()\n\tfor k, v := range headers {\n\t\tif header.Get(k) == \"\" {\n\t\t\theader.Set(k, v)\n\t\t}\n\t}\n}\n",
    "source_file": "render/reader.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage render\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/goccy/go-yaml\"\n)\n\n// YAML contains the given interface object.\ntype YAML struct {\n\tData any\n}\n\nvar yamlContentType = []string{\"application/yaml; charset=utf-8\"}\n\n// Render (YAML) marshals the given interface object and writes data with custom ContentType.\nfunc (r YAML) Render(w http.ResponseWriter) error {\n\tr.WriteContentType(w)\n\n\tbytes, err := yaml.Marshal(r.Data)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = w.Write(bytes)\n\treturn err\n}\n\n// WriteContentType (YAML) writes YAML ContentType for response.\nfunc (r YAML) WriteContentType(w http.ResponseWriter) {\n\twriteContentType(w, yamlContentType)\n}\n",
    "source_file": "render/yaml.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2022 Gin Core Team. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage render\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/pelletier/go-toml/v2\"\n)\n\n// TOML contains the given interface object.\ntype TOML struct {\n\tData any\n}\n\nvar TOMLContentType = []string{\"application/toml; charset=utf-8\"}\n\n// Render (TOML) marshals the given interface object and writes data with custom ContentType.\nfunc (r TOML) Render(w http.ResponseWriter) error {\n\tr.WriteContentType(w)\n\n\tbytes, err := toml.Marshal(r.Data)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = w.Write(bytes)\n\treturn err\n}\n\n// WriteContentType (TOML) writes TOML ContentType for response.\nfunc (r TOML) WriteContentType(w http.ResponseWriter) {\n\twriteContentType(w, TOMLContentType)\n}\n",
    "source_file": "render/toml.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage render\n\nimport \"net/http\"\n\n// Data contains ContentType and bytes data.\ntype Data struct {\n\tContentType string\n\tData        []byte\n}\n\n// Render (Data) writes data with custom ContentType.\nfunc (r Data) Render(w http.ResponseWriter) (err error) {\n\tr.WriteContentType(w)\n\t_, err = w.Write(r.Data)\n\treturn\n}\n\n// WriteContentType (Data) writes custom ContentType.\nfunc (r Data) WriteContentType(w http.ResponseWriter) {\n\twriteContentType(w, []string{r.ContentType})\n}\n",
    "source_file": "render/data.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage render\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"html/template\"\n\t\"net/http\"\n\t\"unicode\"\n\n\t\"github.com/gin-gonic/gin/codec/json\"\n\t\"github.com/gin-gonic/gin/internal/bytesconv\"\n)\n\n// JSON contains the given interface object.\ntype JSON struct {\n\tData any\n}\n\n// IndentedJSON contains the given interface object.\ntype IndentedJSON struct {\n\tData any\n}\n\n// SecureJSON contains the given interface object and its prefix.\ntype SecureJSON struct {\n\tPrefix string\n\tData   any\n}\n\n// JsonpJSON contains the given interface object its callback.\ntype JsonpJSON struct {\n\tCallback string\n\tData     any\n}\n\n// AsciiJSON contains the given interface object.\ntype AsciiJSON struct {\n\tData any\n}\n\n// PureJSON contains the given interface object.\ntype PureJSON struct {\n\tData any\n}\n\nvar (\n\tjsonContentType      = []string{\"application/json; charset=utf-8\"}\n\tjsonpContentType     = []string{\"application/javascript; charset=utf-8\"}\n\tjsonASCIIContentType = []string{\"application/json\"}\n)\n\n// Render (JSON) writes data with custom ContentType.\nfunc (r JSON) Render(w http.ResponseWriter) error {\n\treturn WriteJSON(w, r.Data)\n}\n\n// WriteContentType (JSON) writes JSON ContentType.\nfunc (r JSON) WriteContentType(w http.ResponseWriter) {\n\twriteContentType(w, jsonContentType)\n}\n\n// WriteJSON marshals the given interface object and writes it with custom ContentType.\nfunc WriteJSON(w http.ResponseWriter, obj any) error {\n\twriteContentType(w, jsonContentType)\n\tjsonBytes, err := json.API.Marshal(obj)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = w.Write(jsonBytes)\n\treturn err\n}\n\n// Render (IndentedJSON) marshals the given interface object and writes it with custom ContentType.\nfunc (r IndentedJSON) Render(w http.ResponseWriter) error {\n\tr.WriteContentType(w)\n\tjsonBytes, err := json.API.MarshalIndent(r.Data, \"\", \"    \")\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = w.Write(jsonBytes)\n\treturn err\n}\n\n// WriteContentType (IndentedJSON) writes JSON ContentType.\nfunc (r IndentedJSON) WriteContentType(w http.ResponseWriter) {\n\twriteContentType(w, jsonContentType)\n}\n\n// Render (SecureJSON) marshals the given interface object and writes it with custom ContentType.\nfunc (r SecureJSON) Render(w http.ResponseWriter) error {\n\tr.WriteContentType(w)\n\tjsonBytes, err := json.API.Marshal(r.Data)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// if the jsonBytes is array values\n\tif bytes.HasPrefix(jsonBytes, bytesconv.StringToBytes(\"[\")) && bytes.HasSuffix(jsonBytes,\n\t\tbytesconv.StringToBytes(\"]\")) {\n\t\tif _, err = w.Write(bytesconv.StringToBytes(r.Prefix)); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t_, err = w.Write(jsonBytes)\n\treturn err\n}\n\n// WriteContentType (SecureJSON) writes JSON ContentType.\nfunc (r SecureJSON) WriteContentType(w http.ResponseWriter) {\n\twriteContentType(w, jsonContentType)\n}\n\n// Render (JsonpJSON) marshals the given interface object and writes it and its callback with custom ContentType.\nfunc (r JsonpJSON) Render(w http.ResponseWriter) (err error) {\n\tr.WriteContentType(w)\n\tret, err := json.API.Marshal(r.Data)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif r.Callback == \"\" {\n\t\t_, err = w.Write(ret)\n\t\treturn err\n\t}\n\n\tcallback := template.JSEscapeString(r.Callback)\n\tif _, err = w.Write(bytesconv.StringToBytes(callback)); err != nil {\n\t\treturn err\n\t}\n\n\tif _, err = w.Write(bytesconv.StringToBytes(\"(\")); err != nil {\n\t\treturn err\n\t}\n\n\tif _, err = w.Write(ret); err != nil {\n\t\treturn err\n\t}\n\n\tif _, err = w.Write(bytesconv.StringToBytes(\");\")); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// WriteContentType (JsonpJSON) writes Javascript ContentType.\nfunc (r JsonpJSON) WriteContentType(w http.ResponseWriter) {\n\twriteContentType(w, jsonpContentType)\n}\n\n// Render (AsciiJSON) marshals the given interface object and writes it with custom ContentType.\nfunc (r AsciiJSON) Render(w http.ResponseWriter) error {\n\tr.WriteContentType(w)\n\tret, err := json.API.Marshal(r.Data)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar buffer bytes.Buffer\n\tescapeBuf := make([]byte, 0, 6) // Preallocate 6 bytes for Unicode escape sequences\n\n\tfor _, r := range bytesconv.BytesToString(ret) {\n\t\tif r > unicode.MaxASCII {\n\t\t\tescapeBuf = fmt.Appendf(escapeBuf[:0], \"\\\\u%04x\", r) // Reuse escapeBuf\n\t\t\tbuffer.Write(escapeBuf)\n\t\t} else {\n\t\t\tbuffer.WriteByte(byte(r))\n\t\t}\n\t}\n\n\t_, err = w.Write(buffer.Bytes())\n\treturn err\n}\n\n// WriteContentType (AsciiJSON) writes JSON ContentType.\nfunc (r AsciiJSON) WriteContentType(w http.ResponseWriter) {\n\twriteContentType(w, jsonASCIIContentType)\n}\n\n// Render (PureJSON) writes custom ContentType and encodes the given interface object.\nfunc (r PureJSON) Render(w http.ResponseWriter) error {\n\tr.WriteContentType(w)\n\tencoder := json.API.NewEncoder(w)\n\tencoder.SetEscapeHTML(false)\n\treturn encoder.Encode(r.Data)\n}\n\n// WriteContentType (PureJSON) writes custom ContentType.\nfunc (r PureJSON) WriteContentType(w http.ResponseWriter) {\n\twriteContentType(w, jsonContentType)\n}\n",
    "source_file": "render/json.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2018 Gin Core Team. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage render\n\nimport (\n\t\"net/http\"\n\n\t\"google.golang.org/protobuf/proto\"\n)\n\n// ProtoBuf contains the given interface object.\ntype ProtoBuf struct {\n\tData any\n}\n\nvar protobufContentType = []string{\"application/x-protobuf\"}\n\n// Render (ProtoBuf) marshals the given interface object and writes data with custom ContentType.\nfunc (r ProtoBuf) Render(w http.ResponseWriter) error {\n\tr.WriteContentType(w)\n\n\tbytes, err := proto.Marshal(r.Data.(proto.Message))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = w.Write(bytes)\n\treturn err\n}\n\n// WriteContentType (ProtoBuf) writes ProtoBuf ContentType.\nfunc (r ProtoBuf) WriteContentType(w http.ResponseWriter) {\n\twriteContentType(w, protobufContentType)\n}\n",
    "source_file": "render/protobuf.go",
    "chunk_type": "code"
  },
  {
    "content": "# Gin Default Server\n\nThis is API experiment for Gin.\n\n```go\npackage main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gin-gonic/gin/ginS\"\n)\n\nfunc main() {\n\tginS.GET(\"/\", func(c *gin.Context) { c.String(200, \"Hello World\") })\n\tginS.Run()\n}\n```",
    "source_file": "ginS/README.md",
    "chunk_type": "doc"
  },
  {
    "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage ginS\n\nimport (\n\t\"html/template\"\n\t\"net/http\"\n\t\"sync\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\nvar (\n\tonce           sync.Once\n\tinternalEngine *gin.Engine\n)\n\nfunc engine() *gin.Engine {\n\tonce.Do(func() {\n\t\tinternalEngine = gin.Default()\n\t})\n\treturn internalEngine\n}\n\n// LoadHTMLGlob is a wrapper for Engine.LoadHTMLGlob.\nfunc LoadHTMLGlob(pattern string) {\n\tengine().LoadHTMLGlob(pattern)\n}\n\n// LoadHTMLFiles is a wrapper for Engine.LoadHTMLFiles.\nfunc LoadHTMLFiles(files ...string) {\n\tengine().LoadHTMLFiles(files...)\n}\n\n// LoadHTMLFS is a wrapper for Engine.LoadHTMLFS.\nfunc LoadHTMLFS(fs http.FileSystem, patterns ...string) {\n\tengine().LoadHTMLFS(fs, patterns...)\n}\n\n// SetHTMLTemplate is a wrapper for Engine.SetHTMLTemplate.\nfunc SetHTMLTemplate(templ *template.Template) {\n\tengine().SetHTMLTemplate(templ)\n}\n\n// NoRoute adds handlers for NoRoute. It returns a 404 code by default.\nfunc NoRoute(handlers ...gin.HandlerFunc) {\n\tengine().NoRoute(handlers...)\n}\n\n// NoMethod is a wrapper for Engine.NoMethod.\nfunc NoMethod(handlers ...gin.HandlerFunc) {\n\tengine().NoMethod(handlers...)\n}\n\n// Group creates a new router group. You should add all the routes that have common middlewares or the same path prefix.\n// For example, all the routes that use a common middleware for authorization could be grouped.\nfunc Group(relativePath string, handlers ...gin.HandlerFunc) *gin.RouterGroup {\n\treturn engine().Group(relativePath, handlers...)\n}\n\n// Handle is a wrapper for Engine.Handle.\nfunc Handle(httpMethod, relativePath string, handlers ...gin.HandlerFunc) gin.IRoutes {\n\treturn engine().Handle(httpMethod, relativePath, handlers...)\n}\n\n// POST is a shortcut for router.Handle(\"POST\", path, handle)\nfunc POST(relativePath string, handlers ...gin.HandlerFunc) gin.IRoutes {\n\treturn engine().POST(relativePath, handlers...)\n}\n\n// GET is a shortcut for router.Handle(\"GET\", path, handle)\nfunc GET(relativePath string, handlers ...gin.HandlerFunc) gin.IRoutes {\n\treturn engine().GET(relativePath, handlers...)\n}\n\n// DELETE is a shortcut for router.Handle(\"DELETE\", path, handle)\nfunc DELETE(relativePath string, handlers ...gin.HandlerFunc) gin.IRoutes {\n\treturn engine().DELETE(relativePath, handlers...)\n}\n\n// PATCH is a shortcut for router.Handle(\"PATCH\", path, handle)\nfunc PATCH(relativePath string, handlers ...gin.HandlerFunc) gin.IRoutes {\n\treturn engine().PATCH(relativePath, handlers...)\n}\n\n// PUT is a shortcut for router.Handle(\"PUT\", path, handle)\nfunc PUT(relativePath string, handlers ...gin.HandlerFunc) gin.IRoutes {\n\treturn engine().PUT(relativePath, handlers...)\n}\n\n// OPTIONS is a shortcut for router.Handle(\"OPTIONS\", path, handle)\nfunc OPTIONS(relativePath string, handlers ...gin.HandlerFunc) gin.IRoutes {\n\treturn engine().OPTIONS(relativePath, handlers...)\n}\n\n// HEAD is a shortcut for router.Handle(\"HEAD\", path, handle)\nfunc HEAD(relativePath string, handlers ...gin.HandlerFunc) gin.IRoutes {\n\treturn engine().HEAD(relativePath, handlers...)\n}\n\n// Any is a wrapper for Engine.Any.\nfunc Any(relativePath string, handlers ...gin.HandlerFunc) gin.IRoutes {\n\treturn engine().Any(relativePath, handlers...)\n}\n\n// StaticFile is a wrapper for Engine.StaticFile.\nfunc StaticFile(relativePath, filepath string) gin.IRoutes {\n\treturn engine().StaticFile(relativePath, filepath)\n}\n\n// Static serves files from the given file system root.\n// Internally a http.FileServer is used, therefore http.NotFound is used instead\n// of the Router's NotFound handler.\n// To use the operating system's file system implementation,\n// use :\n//\n//\trouter.Static(\"/static\", \"/var/www\")\nfunc Static(relativePath, root string) gin.IRoutes {\n\treturn engine().Static(relativePath, root)\n}\n\n// StaticFS is a wrapper for Engine.StaticFS.\nfunc StaticFS(relativePath string, fs http.FileSystem) gin.IRoutes {\n\treturn engine().StaticFS(relativePath, fs)\n}\n\n// Use attaches a global middleware to the router. i.e. the middlewares attached through Use() will be\n// included in the handlers chain for every single request. Even 404, 405, static files...\n// For example, this is the right place for a logger or error management middleware.\nfunc Use(middlewares ...gin.HandlerFunc) gin.IRoutes {\n\treturn engine().Use(middlewares...)\n}\n\n// Routes returns a slice of registered routes.\nfunc Routes() gin.RoutesInfo {\n\treturn engine().Routes()\n}\n\n// Run attaches to a http.Server and starts listening and serving HTTP requests.\n// It is a shortcut for http.ListenAndServe(addr, router)\n// Note: this method will block the calling goroutine indefinitely unless an error happens.\nfunc Run(addr ...string) (err error) {\n\treturn engine().Run(addr...)\n}\n\n// RunTLS attaches to a http.Server and starts listening and serving HTTPS requests.\n// It is a shortcut for http.ListenAndServeTLS(addr, certFile, keyFile, router)\n// Note: this method will block the calling goroutine indefinitely unless an error happens.\nfunc RunTLS(addr, certFile, keyFile string) (err error) {\n\treturn engine().RunTLS(addr, certFile, keyFile)\n}\n\n// RunUnix attaches to a http.Server and starts listening and serving HTTP requests\n// through the specified unix socket (i.e. a file)\n// Note: this method will block the calling goroutine indefinitely unless an error happens.\nfunc RunUnix(file string) (err error) {\n\treturn engine().RunUnix(file)\n}\n\n// RunFd attaches the router to a http.Server and starts listening and serving HTTP requests\n// through the specified file descriptor.\n// Note: the method will block the calling goroutine indefinitely unless an error happens.\nfunc RunFd(fd int) (err error) {\n\treturn engine().RunFd(fd)\n}\n",
    "source_file": "ginS/gins.go",
    "chunk_type": "code"
  },
  {
    "content": "# Gin Quick Start\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "## Contents\n\n- [Build Tags](#build-tags)\n  - [Build with json replacement](#build-with-json-replacement)\n  - [Build without `MsgPack` rendering feature](#build-without-msgpack-rendering-feature)\n- [API Examples](#api-examples)\n  - [Using GET, POST, PUT, PATCH, DELETE and OPTIONS](#using-get-post-put-patch-delete-and-options)\n  - [Parameters in path](#parameters-in-path)\n  - [Querystring parameters](#querystring-parameters)\n  - [Multipart/Urlencoded Form](#multiparturlencoded-form)\n  - [Another example: query + post form](#another-example-query--post-form)\n  - [Map as querystring or postform parameters](#map-as-querystring-or-postform-parameters)\n  - [Upload files](#upload-files)\n    - [Single file](#single-file)\n    - [Multiple files](#multiple-files)\n  - [Grouping routes](#grouping-routes)\n  - [Blank Gin without middleware by default](#blank-gin-without-middleware-by-default)\n  - [Using middleware](#using-middleware)\n  - [Custom Recovery behavior](#custom-recovery-behavior)\n  - [How to write log file](#how-to-write-log-file)\n  - [Custom Log Format](#custom-log-format)\n  - [Controlling Log output coloring](#controlling-log-output-coloring)\n  - [Model binding and validation](#model-binding-and-validation)\n  - [Custom Validators](#custom-validators)\n  - [Only Bind Query String](#only-bind-query-string)\n  - [Bind Query String or Post Data](#bind-query-string-or-post-data)\n  - [Bind default value if none provided](#bind-default-value-if-none-provided)\n  - [Collection format for arrays](#collection-format-for-arrays)\n  - [Bind Uri](#bind-uri)\n  - [Bind custom unmarshaler](#bind-custom-unmarshaler)\n  - [Bind Header](#bind-header)\n  - [Bind HTML checkboxes](#bind-html-checkboxes)\n  - [Multipart/Urlencoded binding](#multiparturlencoded-binding)\n  - [XML, JSON, YAML, TOML and ProtoBuf rendering](#xml-json-yaml-toml-and-protobuf-rendering)\n    - [SecureJSON](#securejson)\n    - [JSONP](#jsonp)\n    - [AsciiJSON](#asciijson)\n    - [PureJSON](#purejson)\n  - [Serving static files](#serving-static-files)\n  - [Serving data from file](#serving-data-from-file)\n  - [Serving data from reader](#serving-data-from-reader)\n  - [HTML rendering](#html-rendering)\n    - [Custom Template renderer](#custom-template-renderer)\n    - [Custom Delimiters](#custom-delimiters)\n    - [Custom Template Funcs](#custom-template-funcs)\n  - [Multitemplate](#multitemplate)\n  - [Redirects](#redirects)\n  - [Custom Middleware](#custom-middleware)\n  - [Using BasicAuth() middleware](#using-basicauth-middleware)\n  - [Goroutines inside a middleware](#goroutines-inside-a-middleware)\n  - [Custom HTTP configuration](#custom-http-configuration)\n  - [Support Let's Encrypt](#support-lets-encrypt)\n  - [Run multiple service using Gin](#run-multiple-service-using-gin)\n  - [Graceful shutdown or restart](#graceful-shutdown-or-restart)\n    - [Third-party packages](#third-party-packages)\n    - [Manually](#manually)\n  - [Build a single binary with templates](#build-a-single-binary-with-templates)\n  - [Bind form-data request with custom struct](#bind-form-data-request-with-custom-struct)\n  - [Try to bind body into different structs](#try-to-bind-body-into-different-structs)\n  - [Bind form-data request with custom struct and custom tag](#bind-form-data-request-with-custom-struct-and-custom-tag)\n  - [http2 server push](#http2-server-push)\n  - [Define format for the log of routes](#define-format-for-the-log-of-routes)\n  - [Set and get a cookie](#set-and-get-a-cookie)\n  - [Custom json codec at runtime](#custom-json-codec-at-runtime)\n- [Don't trust all proxies](#dont-trust-all-proxies)\n- [Testing](#testing)\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "## Build tags\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Build with json replacement\n\nGin uses `encoding/json` as the default JSON package but you can change it by building from other tags.\n\n[jsoniter](https://github.com/json-iterator/go)\n\n```sh\ngo build -tags=jsoniter .\n```\n\n[go-json](https://github.com/goccy/go-json)\n\n```sh\ngo build -tags=go_json .\n```\n\n[sonic](https://github.com/bytedance/sonic)\n\n```sh\n$ go build -tags=sonic .\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Build without `MsgPack` rendering feature\n\nGin enables `MsgPack` rendering feature by default. But you can disable this feature by specifying `nomsgpack` build tag.\n\n```sh\ngo build -tags=nomsgpack .\n```\n\nThis is useful to reduce the binary size of executable files. See the [detail information](https://github.com/gin-gonic/gin/pull/1852).\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "## API Examples\n\nYou can find a number of ready-to-run examples at [Gin examples repository](https://github.com/gin-gonic/examples).\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Using GET, POST, PUT, PATCH, DELETE and OPTIONS\n\n```go\nfunc main() {\n  // Creates a gin router with default middleware:\n  // logger and recovery (crash-free) middleware\n  router := gin.Default()\n\n  router.GET(\"/someGet\", getting)\n  router.POST(\"/somePost\", posting)\n  router.PUT(\"/somePut\", putting)\n  router.DELETE(\"/someDelete\", deleting)\n  router.PATCH(\"/somePatch\", patching)\n  router.HEAD(\"/someHead\", head)\n  router.OPTIONS(\"/someOptions\", options)\n\n  // By default, it serves on :8080 unless a\n  // PORT environment variable was defined.\n  router.Run()\n  // router.Run(\":3000\") for a hard coded port\n}\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Parameters in path\n\n```go\nfunc main() {\n  router := gin.Default()\n\n  // This handler will match /user/john but will not match /user/ or /user\n  router.GET(\"/user/:name\", func(c *gin.Context) {\n    name := c.Param(\"name\")\n    c.String(http.StatusOK, \"Hello %s\", name)\n  })\n\n  // However, this one will match /user/john/ and also /user/john/send\n  // If no other routers match /user/john, it will redirect to /user/john/\n  router.GET(\"/user/:name/*action\", func(c *gin.Context) {\n    name := c.Param(\"name\")\n    action := c.Param(\"action\")\n    message := name + \" is \" + action\n    c.String(http.StatusOK, message)\n  })\n\n  // For each matched request Context will hold the route definition\n  router.POST(\"/user/:name/*action\", func(c *gin.Context) {\n    b := c.FullPath() == \"/user/:name/*action\" // true\n    c.String(http.StatusOK, \"%t\", b)\n  })\n\n  // This handler will add a new router for /user/groups.\n  // Exact routes are resolved before param routes, regardless of the order they were defined.\n  // Routes starting with /user/groups are never interpreted as /user/:name/... routes\n  router.GET(\"/user/groups\", func(c *gin.Context) {\n    c.String(http.StatusOK, \"The available groups are [...]\")\n  })\n\n  router.Run(\":8080\")\n}\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Querystring parameters\n\n```go\nfunc main() {\n  router := gin.Default()\n\n  // Query string parameters are parsed using the existing underlying request object.\n  // The request responds to a URL matching: /welcome?firstname=Jane&lastname=Doe\n  router.GET(\"/welcome\", func(c *gin.Context) {\n    firstname := c.DefaultQuery(\"firstname\", \"Guest\")\n    lastname := c.Query(\"lastname\") // shortcut for c.Request.URL.Query().Get(\"lastname\")\n\n    c.String(http.StatusOK, \"Hello %s %s\", firstname, lastname)\n  })\n  router.Run(\":8080\")\n}\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Multipart/Urlencoded Form\n\n```go\nfunc main() {\n  router := gin.Default()\n\n  router.POST(\"/form_post\", func(c *gin.Context) {\n    message := c.PostForm(\"message\")\n    nick := c.DefaultPostForm(\"nick\", \"anonymous\")\n\n    c.JSON(http.StatusOK, gin.H{\n      \"status\":  \"posted\",\n      \"message\": message,\n      \"nick\":    nick,\n    })\n  })\n  router.Run(\":8080\")\n}\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Another example: query + post form\n\n```sh\nPOST /post?id=1234&page=1 HTTP/1.1\nContent-Type: application/x-www-form-urlencoded\n\nname=manu&message=this_is_great\n```\n\n```go\nfunc main() {\n  router := gin.Default()\n\n  router.POST(\"/post\", func(c *gin.Context) {\n\n    id := c.Query(\"id\")\n    page := c.DefaultQuery(\"page\", \"0\")\n    name := c.PostForm(\"name\")\n    message := c.PostForm(\"message\")\n\n    fmt.Printf(\"id: %s; page: %s; name: %s; message: %s\", id, page, name, message)\n  })\n  router.Run(\":8080\")\n}\n```\n\n```sh\nid: 1234; page: 1; name: manu; message: this_is_great\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Map as querystring or postform parameters\n\n```sh\nPOST /post?ids[a]=1234&ids[b]=hello HTTP/1.1\nContent-Type: application/x-www-form-urlencoded\n\nnames[first]=thinkerou&names[second]=tianou\n```\n\n```go\nfunc main() {\n  router := gin.Default()\n\n  router.POST(\"/post\", func(c *gin.Context) {\n\n    ids := c.QueryMap(\"ids\")\n    names := c.PostFormMap(\"names\")\n\n    fmt.Printf(\"ids: %v; names: %v\", ids, names)\n  })\n  router.Run(\":8080\")\n}\n```\n\n```sh\nids: map[b:hello a:1234]; names: map[second:tianou first:thinkerou]\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Upload files\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "#### Single file\n\nReferences issue [#774](https://github.com/gin-gonic/gin/issues/774) and detail [example code](https://github.com/gin-gonic/examples/tree/master/upload-file/single).\n\n`file.Filename` **SHOULD NOT** be trusted. See [`Content-Disposition` on MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition#Directives) and [#1693](https://github.com/gin-gonic/gin/issues/1693)\n\n> The filename is always optional and must not be used blindly by the application: path information should be stripped, and conversion to the server file system rules should be done.\n\n```go\nfunc main() {\n  router := gin.Default()\n  // Set a lower memory limit for multipart forms (default is 32 MiB)\n  router.MaxMultipartMemory = 8 << 20  // 8 MiB\n  router.POST(\"/upload\", func(c *gin.Context) {\n    // Single file\n    file, _ := c.FormFile(\"file\")\n    log.Println(file.Filename)\n\n    // Upload the file to specific dst.\n    c.SaveUploadedFile(file, dst)\n\n    c.String(http.StatusOK, fmt.Sprintf(\"'%s' uploaded!\", file.Filename))\n  })\n  router.Run(\":8080\")\n}\n```\n\nHow to `curl`:\n\n```bash\ncurl -X POST http://localhost:8080/upload \\\n  -F \"file=@/Users/appleboy/test.zip\" \\\n  -H \"Content-Type: multipart/form-data\"\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "#### Multiple files\n\nSee the detailed [example code](https://github.com/gin-gonic/examples/tree/master/upload-file/multiple).\n\n```go\nfunc main() {\n  router := gin.Default()\n  // Set a lower memory limit for multipart forms (default is 32 MiB)\n  router.MaxMultipartMemory = 8 << 20  // 8 MiB\n  router.POST(\"/upload\", func(c *gin.Context) {\n    // Multipart form\n    form, _ := c.MultipartForm()\n    files := form.File[\"upload[]\"]\n\n    for _, file := range files {\n      log.Println(file.Filename)\n\n      // Upload the file to specific dst.\n      c.SaveUploadedFile(file, dst)\n    }\n    c.String(http.StatusOK, fmt.Sprintf(\"%d files uploaded!\", len(files)))\n  })\n  router.Run(\":8080\")\n}\n```\n\nHow to `curl`:\n\n```bash\ncurl -X POST http://localhost:8080/upload \\\n  -F \"upload[]=@/Users/appleboy/test1.zip\" \\\n  -F \"upload[]=@/Users/appleboy/test2.zip\" \\\n  -H \"Content-Type: multipart/form-data\"\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Grouping routes\n\n```go\nfunc main() {\n  router := gin.Default()\n\n  // Simple group: v1\n  {\n    v1 := router.Group(\"/v1\")\n    v1.POST(\"/login\", loginEndpoint)\n    v1.POST(\"/submit\", submitEndpoint)\n    v1.POST(\"/read\", readEndpoint)\n  }\n\n  // Simple group: v2\n  {\n    v2 := router.Group(\"/v2\")\n    v2.POST(\"/login\", loginEndpoint)\n    v2.POST(\"/submit\", submitEndpoint)\n    v2.POST(\"/read\", readEndpoint)\n  }\n\n  router.Run(\":8080\")\n}\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Blank Gin without middleware by default\n\nUse\n\n```go\nr := gin.New()\n```\n\ninstead of\n\n```go\n// Default With the Logger and Recovery middleware already attached\nr := gin.Default()\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Using middleware\n\n```go\nfunc main() {\n  // Creates a router without any middleware by default\n  r := gin.New()\n\n  // Global middleware\n  // Logger middleware will write the logs to gin.DefaultWriter even if you set with GIN_MODE=release.\n  // By default gin.DefaultWriter = os.Stdout\n  r.Use(gin.Logger())\n\n  // Recovery middleware recovers from any panics and writes a 500 if there was one.\n  r.Use(gin.Recovery())\n\n  // Per route middleware, you can add as many as you desire.\n  r.GET(\"/benchmark\", MyBenchLogger(), benchEndpoint)\n\n  // Authorization group\n  // authorized := r.Group(\"/\", AuthRequired())\n  // exactly the same as:\n  authorized := r.Group(\"/\")\n  // per group middleware! in this case we use the custom created\n  // AuthRequired() middleware just in the \"authorized\" group.\n  authorized.Use(AuthRequired())\n  {\n    authorized.POST(\"/login\", loginEndpoint)\n    authorized.POST(\"/submit\", submitEndpoint)\n    authorized.POST(\"/read\", readEndpoint)\n\n    // nested group\n    testing := authorized.Group(\"testing\")\n    // visit 0.0.0.0:8080/testing/analytics\n    testing.GET(\"/analytics\", analyticsEndpoint)\n  }\n\n  // Listen and serve on 0.0.0.0:8080\n  r.Run(\":8080\")\n}\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Custom Recovery behavior\n\n```go\nfunc main() {\n  // Creates a router without any middleware by default\n  r := gin.New()\n\n  // Global middleware\n  // Logger middleware will write the logs to gin.DefaultWriter even if you set with GIN_MODE=release.\n  // By default gin.DefaultWriter = os.Stdout\n  r.Use(gin.Logger())\n\n  // Recovery middleware recovers from any panics and writes a 500 if there was one.\n  r.Use(gin.CustomRecovery(func(c *gin.Context, recovered any) {\n    if err, ok := recovered.(string); ok {\n      c.String(http.StatusInternalServerError, fmt.Sprintf(\"error: %s\", err))\n    }\n    c.AbortWithStatus(http.StatusInternalServerError)\n  }))\n\n  r.GET(\"/panic\", func(c *gin.Context) {\n    // panic with a string -- the custom middleware could save this to a database or report it to the user\n    panic(\"foo\")\n  })\n\n  r.GET(\"/\", func(c *gin.Context) {\n    c.String(http.StatusOK, \"ohai\")\n  })\n\n  // Listen and serve on 0.0.0.0:8080\n  r.Run(\":8080\")\n}\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### How to write log file\n\n```go\nfunc main() {\n  // Disable Console Color, you don't need console color when writing the logs to file.\n  gin.DisableConsoleColor()\n\n  // Logging to a file.\n  f, _ := os.Create(\"gin.log\")\n  gin.DefaultWriter = io.MultiWriter(f)\n\n  // Use the following code if you need to write the logs to file and console at the same time.\n  // gin.DefaultWriter = io.MultiWriter(f, os.Stdout)\n\n  router := gin.Default()\n  router.GET(\"/ping\", func(c *gin.Context) {\n      c.String(http.StatusOK, \"pong\")\n  })\n\n\u00a0 \u00a0router.Run(\":8080\")\n}\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Custom Log Format\n\n```go\nfunc main() {\n  router := gin.New()\n\n  // LoggerWithFormatter middleware will write the logs to gin.DefaultWriter\n  // By default gin.DefaultWriter = os.Stdout\n  router.Use(gin.LoggerWithFormatter(func(param gin.LogFormatterParams) string {\n\n    // your custom format\n    return fmt.Sprintf(\"%s - [%s] \\\"%s %s %s %d %s \\\"%s\\\" %s\\\"\\n\",\n        param.ClientIP,\n        param.TimeStamp.Format(time.RFC1123),\n        param.Method,\n        param.Path,\n        param.Request.Proto,\n        param.StatusCode,\n        param.Latency,\n        param.Request.UserAgent(),\n        param.ErrorMessage,\n    )\n  }))\n  router.Use(gin.Recovery())\n\n  router.GET(\"/ping\", func(c *gin.Context) {\n    c.String(http.StatusOK, \"pong\")\n  })\n\n  router.Run(\":8080\")\n}\n```\n\nSample Output\n\n```sh\n::1 - [Fri, 07 Dec 2018 17:04:38 JST] \"GET /ping HTTP/1.1 200 122.767\u00b5s \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.80 Safari/537.36\" \"\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Skip logging\n\n```go\nfunc main() {\n  router := gin.New()\n\n  // skip logging for desired paths by setting SkipPaths in LoggerConfig\n  loggerConfig := gin.LoggerConfig{SkipPaths: []string{\"/metrics\"}}\n\n  // skip logging based on your logic by setting Skip func in LoggerConfig\n  loggerConfig.Skip = func(c *gin.Context) bool {\n      // as an example skip non server side errors\n      return c.Writer.Status() < http.StatusInternalServerError\n  }\n\n  router.Use(gin.LoggerWithConfig(loggerConfig))\n  router.Use(gin.Recovery())\n\n  // skipped\n  router.GET(\"/metrics\", func(c *gin.Context) {\n      c.Status(http.StatusNotImplemented)\n  })\n\n  // skipped\n  router.GET(\"/ping\", func(c *gin.Context) {\n      c.String(http.StatusOK, \"pong\")\n  })\n\n  // not skipped\n  router.GET(\"/data\", func(c *gin.Context) {\n    c.Status(http.StatusNotImplemented)\n  })\n\n  router.Run(\":8080\")\n}\n\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Controlling Log output coloring\n\nBy default, logs output on console should be colorized depending on the detected TTY.\n\nNever colorize logs:\n\n```go\nfunc main() {\n  // Disable log's color\n  gin.DisableConsoleColor()\n\n  // Creates a gin router with default middleware:\n  // logger and recovery (crash-free) middleware\n  router := gin.Default()\n\n  router.GET(\"/ping\", func(c *gin.Context) {\n      c.String(http.StatusOK, \"pong\")\n  })\n\n  router.Run(\":8080\")\n}\n```\n\nAlways colorize logs:\n\n```go\nfunc main() {\n  // Force log's color\n  gin.ForceConsoleColor()\n\n  // Creates a gin router with default middleware:\n  // logger and recovery (crash-free) middleware\n  router := gin.Default()\n\n  router.GET(\"/ping\", func(c *gin.Context) {\n      c.String(http.StatusOK, \"pong\")\n  })\n\n  router.Run(\":8080\")\n}\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Model binding and validation\n\nTo bind a request body into a type, use model binding. We currently support binding of JSON, XML, YAML, TOML and standard form values (foo=bar&boo=baz).\n\nGin uses [**go-playground/validator/v10**](https://github.com/go-playground/validator) for validation. Check the full docs on tags usage [here](https://pkg.go.dev/github.com/go-playground/validator#hdr-Baked_In_Validators_and_Tags).\n\nNote that you need to set the corresponding binding tag on all fields you want to bind. For example, when binding from JSON, set `json:\"fieldname\"`.\n\nAlso, Gin provides two sets of methods for binding:\n\n- **Type** - Must bind\n  - **Methods** - `Bind`, `BindJSON`, `BindXML`, `BindQuery`, `BindYAML`, `BindHeader`, `BindTOML`\n  - **Behavior** - These methods use `MustBindWith` under the hood. If there is a binding error, the request is aborted with `c.AbortWithError(400, err).SetType(ErrorTypeBind)`. This sets the response status code to 400 and the `Content-Type` header is set to `text/plain; charset=utf-8`. Note that if you try to set the response code after this, it will result in a warning `[GIN-debug] [WARNING] Headers were already written. Wanted to override status code 400 with 422`. If you wish to have greater control over the behavior, consider using the `ShouldBind` equivalent method.\n- **Type** - Should bind\n  - **Methods** - `ShouldBind`, `ShouldBindJSON`, `ShouldBindXML`, `ShouldBindQuery`, `ShouldBindYAML`, `ShouldBindHeader`, `ShouldBindTOML`,\n  - **Behavior** - These methods use `ShouldBindWith` under the hood. If there is a binding error, the error is returned and it is the developer's responsibility to handle the request and error appropriately.\n\nWhen using the Bind-method, Gin tries to infer the binder depending on the Content-Type header. If you are sure what you are binding, you can use `MustBindWith` or `ShouldBindWith`.\n\nYou can also specify that specific fields are required. If a field is decorated with `binding:\"required\"` and has an empty value when binding, an error will be returned.\n\n```go\n// Binding from JSON\ntype Login struct {\n  User     string `form:\"user\" json:\"user\" xml:\"user\" binding:\"required\"`\n  Password string `form:\"password\" json:\"password\" xml:\"password\" binding:\"required\"`\n}\n\nfunc main() {\n  router := gin.Default()\n\n  // Example for binding JSON ({\"user\": \"manu\", \"password\": \"123\"})\n  router.POST(\"/loginJSON\", func(c *gin.Context) {\n    var json Login\n    if err := c.ShouldBindJSON(&json); err != nil {\n      c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})\n      return\n    }\n\n    if json.User != \"manu\" || json.Password != \"123\" {\n      c.JSON(http.StatusUnauthorized, gin.H{\"status\": \"unauthorized\"})\n      return\n    }\n\n    c.JSON(http.StatusOK, gin.H{\"status\": \"you are logged in\"})\n  })\n\n  // Example for binding XML (\n  //  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  //  <root>\n  //    <user>manu</user>\n  //    <password>123</password>\n  //  </root>)\n  router.POST(\"/loginXML\", func(c *gin.Context) {\n    var xml Login\n    if err := c.ShouldBindXML(&xml); err != nil {\n      c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})\n      return\n    }\n\n    if xml.User != \"manu\" || xml.Password != \"123\" {\n      c.JSON(http.StatusUnauthorized, gin.H{\"status\": \"unauthorized\"})\n      return\n    }\n\n    c.JSON(http.StatusOK, gin.H{\"status\": \"you are logged in\"})\n  })\n\n  // Example for binding a HTML form (user=manu&password=123)\n  router.POST(\"/loginForm\", func(c *gin.Context) {\n    var form Login\n    // This will infer what binder to use depending on the content-type header.\n    if err := c.ShouldBind(&form); err != nil {\n      c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})\n      return\n    }\n\n    if form.User != \"manu\" || form.Password != \"123\" {\n      c.JSON(http.StatusUnauthorized, gin.H{\"status\": \"unauthorized\"})\n      return\n    }\n\n    c.JSON(http.StatusOK, gin.H{\"status\": \"you are logged in\"})\n  })\n\n  // Listen and serve on 0.0.0.0:8080\n  router.Run(\":8080\")\n}\n```\n\nSample request\n\n```sh\n$ curl -v -X POST \\\n  http://localhost:8080/loginJSON \\\n  -H 'content-type: application/json' \\\n  -d '{ \"user\": \"manu\" }'\n> POST /loginJSON HTTP/1.1\n> Host: localhost:8080\n> User-Agent: curl/7.51.0\n> Accept: */*\n> content-type: application/json\n> Content-Length: 18\n>\n* upload completely sent off: 18 out of 18 bytes\n< HTTP/1.1 400 Bad Request\n< Content-Type: application/json; charset=utf-8\n< Date: Fri, 04 Aug 2017 03:51:31 GMT\n< Content-Length: 100\n<\n{\"error\":\"Key: 'Login.Password' Error:Field validation for 'Password' failed on the 'required' tag\"}\n```\n\nSkip-validation: Running the example above using the `curl` command returns an error. This is because the example uses `binding:\"required\"` for `Password`. If instead, you use `binding:\"-\"` for `Password`, then it will not return an error when you run the example again.\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Custom Validators\n\nIt is also possible to register custom validators. See the [example code](https://github.com/gin-gonic/examples/tree/master/custom-validation/server.go).\n\n```go\npackage main\n\nimport (\n  \"net/http\"\n  \"time\"\n\n  \"github.com/gin-gonic/gin\"\n  \"github.com/gin-gonic/gin/binding\"\n  \"github.com/go-playground/validator/v10\"\n)\n\n// Booking contains binded and validated data.\ntype Booking struct {\n  CheckIn  time.Time `form:\"check_in\" binding:\"required,bookabledate\" time_format:\"2006-01-02\"`\n  CheckOut time.Time `form:\"check_out\" binding:\"required,gtfield=CheckIn\" time_format:\"2006-01-02\"`\n}\n\nvar bookableDate validator.Func = func(fl validator.FieldLevel) bool {\n  date, ok := fl.Field().Interface().(time.Time)\n  if ok {\n    today := time.Now()\n    if today.After(date) {\n      return false\n    }\n  }\n  return true\n}\n\nfunc main() {\n  route := gin.Default()\n\n  if v, ok := binding.Validator.Engine().(*validator.Validate); ok {\n    v.RegisterValidation(\"bookabledate\", bookableDate)\n  }\n\n  route.GET(\"/bookable\", getBookable)\n  route.Run(\":8085\")\n}\n\nfunc getBookable(c *gin.Context) {\n  var b Booking\n  if err := c.ShouldBindWith(&b, binding.Query); err == nil {\n    c.JSON(http.StatusOK, gin.H{\"message\": \"Booking dates are valid!\"})\n  } else {\n    c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})\n  }\n}\n```\n\n```console\n$ curl \"localhost:8085/bookable?check_in=2030-04-16&check_out=2030-04-17\"\n{\"message\":\"Booking dates are valid!\"}\n\n$ curl \"localhost:8085/bookable?check_in=2030-03-10&check_out=2030-03-09\"\n{\"error\":\"Key: 'Booking.CheckOut' Error:Field validation for 'CheckOut' failed on the 'gtfield' tag\"}\n\n$ curl \"localhost:8085/bookable?check_in=2000-03-09&check_out=2000-03-10\"\n{\"error\":\"Key: 'Booking.CheckIn' Error:Field validation for 'CheckIn' failed on the 'bookabledate' tag\"}%\n```\n\n[Struct level validations](https://github.com/go-playground/validator/releases/tag/v8.7) can also be registered this way.\nSee the [struct-lvl-validation example](https://github.com/gin-gonic/examples/tree/master/struct-lvl-validations) to learn more.\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Only Bind Query String\n\n`ShouldBindQuery` function only binds the query params and not the post data. See the [detail information](https://github.com/gin-gonic/gin/issues/742#issuecomment-315953017).\n\n```go\npackage main\n\nimport (\n  \"log\"\n  \"net/http\"\n\n  \"github.com/gin-gonic/gin\"\n)\n\ntype Person struct {\n  Name    string `form:\"name\"`\n  Address string `form:\"address\"`\n}\n\nfunc main() {\n  route := gin.Default()\n  route.Any(\"/testing\", startPage)\n  route.Run(\":8085\")\n}\n\nfunc startPage(c *gin.Context) {\n  var person Person\n  if c.ShouldBindQuery(&person) == nil {\n    log.Println(\"====== Only Bind By Query String ======\")\n    log.Println(person.Name)\n    log.Println(person.Address)\n  }\n  c.String(http.StatusOK, \"Success\")\n}\n\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Bind Query String or Post Data\n\nSee the [detail information](https://github.com/gin-gonic/gin/issues/742#issuecomment-264681292).\n\n```go\npackage main\n\nimport (\n  \"log\"\n  \"net/http\"\n  \"time\"\n\n  \"github.com/gin-gonic/gin\"\n)\n\ntype Person struct {\n  Name       string    `form:\"name\"`\n  Address    string    `form:\"address\"`\n  Birthday   time.Time `form:\"birthday\" time_format:\"2006-01-02\" time_utc:\"1\"`\n  CreateTime time.Time `form:\"createTime\" time_format:\"unixNano\"`\n  UnixTime   time.Time `form:\"unixTime\" time_format:\"unix\"`\n  UnixMilliTime   time.Time `form:\"unixMilliTime\" time_format:\"unixmilli\"`\n  UnixMicroTime   time.Time `form:\"unixMicroTime\" time_format:\"uNiXmIcRo\"` // case does not matter for \"unix*\" time formats\n}\n\nfunc main() {\n  route := gin.Default()\n  route.GET(\"/testing\", startPage)\n  route.Run(\":8085\")\n}\n\nfunc startPage(c *gin.Context) {\n  var person Person\n  // If `GET`, only `Form` binding engine (`query`) used.\n  // If `POST`, first checks the `content-type` for `JSON` or `XML`, then uses `Form` (`form-data`).\n  // See more at https://github.com/gin-gonic/gin/blob/master/binding/binding.go#L88\n  if c.ShouldBind(&person) == nil {\n    log.Println(person.Name)\n    log.Println(person.Address)\n    log.Println(person.Birthday)\n    log.Println(person.CreateTime)\n    log.Println(person.UnixTime)\n    log.Println(person.UnixMilliTime)\n    log.Println(person.UnixMicroTime)\n  }\n\n  c.String(http.StatusOK, \"Success\")\n}\n```\n\nTest it with:\n\n```sh\ncurl -X GET \"localhost:8085/testing?name=appleboy&address=xyz&birthday=1992-03-15&createTime=1562400033000000123&unixTime=1562400033&unixMilliTime=1562400033001&unixMicroTime=1562400033000012\"\n```\n\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Bind default value if none provided\n\nIf the server should bind a default value to a field when the client does not provide one, specify the default value using the `default` key within the `form` tag:\n\n```go\npackage main\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\ntype Person struct {\n\tName      string    `form:\"name,default=William\"`\n\tAge       int       `form:\"age,default=10\"`\n\tFriends   []string  `form:\"friends,default=Will;Bill\"`\n\tAddresses [2]string `form:\"addresses,default=foo bar\" collection_format:\"ssv\"`\n\tLapTimes  []int     `form:\"lap_times,default=1;2;3\" collection_format:\"csv\"`\n}\n\nfunc main() {\n\tg := gin.Default()\n\tg.POST(\"/person\", func(c *gin.Context) {\n\t\tvar req Person\n\t\tif err := c.ShouldBindQuery(&req); err != nil {\n\t\t\tc.JSON(http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\t\tc.JSON(http.StatusOK, req)\n\t})\n\t_ = g.Run(\"localhost:8080\")\n}\n```\n\n```\ncurl -X POST http://localhost:8080/person\n{\"Name\":\"William\",\"Age\":10,\"Friends\":[\"Will\",\"Bill\"],\"Colors\":[\"red\",\"blue\"],\"LapTimes\":[1,2,3]}\n```\n\nNOTE: For default [collection values](#collection-format-for-arrays), the following rules apply:\n- Since commas are used to delimit tag options, they are not supported within a default value and will result in undefined behavior\n- For the collection formats \"multi\" and \"csv\", a semicolon should be used in place of a comma to delimited default values\n- Since semicolons are used to delimit default values for \"multi\" and \"csv\", they are not supported within a default value for \"multi\" and \"csv\"\n\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "#### Collection format for arrays\n\n| Format          | Description                                               | Example                 |\n| --------------- | --------------------------------------------------------- | ----------------------- |\n| multi (default) | Multiple parameter instances rather than multiple values. | key=foo&key=bar&key=baz |\n| csv             | Comma-separated values.                                   | foo,bar,baz             |\n| ssv             | Space-separated values.                                   | foo bar baz             |\n| tsv             | Tab-separated values.                                     | \"foo\\tbar\\tbaz\"         |\n| pipes           | Pipe-separated values.                                    | foo\\|bar\\|baz           |\n\n```go\npackage main\n\nimport (\n\t\"log\"\n\t\"time\"\n\t\"github.com/gin-gonic/gin\"\n)\n\ntype Person struct {\n\tName       string    `form:\"name\"`\n\tAddresses  []string  `form:\"addresses\" collection_format:\"csv\"`\n\tBirthday   time.Time `form:\"birthday\" time_format:\"2006-01-02\" time_utc:\"1\"`\n\tCreateTime time.Time `form:\"createTime\" time_format:\"unixNano\"`\n\tUnixTime   time.Time `form:\"unixTime\" time_format:\"unix\"`\n}\n\nfunc main() {\n\troute := gin.Default()\n\troute.GET(\"/testing\", startPage)\n\troute.Run(\":8085\")\n}\nfunc startPage(c *gin.Context) {\n\tvar person Person\n\t// If `GET`, only `Form` binding engine (`query`) used.\n\t// If `POST`, first checks the `content-type` for `JSON` or `XML`, then uses `Form` (`form-data`).\n\t// See more at https://github.com/gin-gonic/gin/blob/master/binding/binding.go#L48\n        if c.ShouldBind(&person) == nil {\n                log.Println(person.Name)\n                log.Println(person.Addresses)\n                log.Println(person.Birthday)\n                log.Println(person.CreateTime)\n                log.Println(person.UnixTime)\n        }\n\tc.String(200, \"Success\")\n}\n```\n\nTest it with:\n```sh\n$ curl -X GET \"localhost:8085/testing?name=appleboy&addresses=foo,bar&birthday=1992-03-15&createTime=1562400033000000123&unixTime=1562400033\"\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Bind Uri\n\nSee the [detail information](https://github.com/gin-gonic/gin/issues/846).\n\n```go\npackage main\n\nimport (\n  \"net/http\"\n\n  \"github.com/gin-gonic/gin\"\n)\n\ntype Person struct {\n  ID string `uri:\"id\" binding:\"required,uuid\"`\n  Name string `uri:\"name\" binding:\"required\"`\n}\n\nfunc main() {\n  route := gin.Default()\n  route.GET(\"/:name/:id\", func(c *gin.Context) {\n    var person Person\n    if err := c.ShouldBindUri(&person); err != nil {\n      c.JSON(http.StatusBadRequest, gin.H{\"msg\": err.Error()})\n      return\n    }\n    c.JSON(http.StatusOK, gin.H{\"name\": person.Name, \"uuid\": person.ID})\n  })\n  route.Run(\":8088\")\n}\n```\n\nTest it with:\n\n```sh\ncurl -v localhost:8088/thinkerou/987fbc97-4bed-5078-9f07-9141ba07c9f3\ncurl -v localhost:8088/thinkerou/not-uuid\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Bind custom unmarshaler\n\n```go\npackage main\n\nimport (\n  \"github.com/gin-gonic/gin\"\n  \"strings\"\n)\n\ntype Birthday string\n\nfunc (b *Birthday) UnmarshalParam(param string) error {\n  *b = Birthday(strings.Replace(param, \"-\", \"/\", -1))\n  return nil\n}\n\nfunc main() {\n  route := gin.Default()\n  var request struct {\n    Birthday Birthday `form:\"birthday\"`\n  }\n  route.GET(\"/test\", func(ctx *gin.Context) {\n    _ = ctx.BindQuery(&request)\n    ctx.JSON(200, request.Birthday)\n  })\n  route.Run(\":8088\")\n}\n```\n\nTest it with:\n\n```sh\ncurl 'localhost:8088/test?birthday=2000-01-01'\n```\nResult\n```sh\n\"2000/01/01\"\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Bind Header\n\n```go\npackage main\n\nimport (\n  \"fmt\"\n  \"net/http\"\n\n  \"github.com/gin-gonic/gin\"\n)\n\ntype testHeader struct {\n  Rate   int    `header:\"Rate\"`\n  Domain string `header:\"Domain\"`\n}\n\nfunc main() {\n  r := gin.Default()\n  r.GET(\"/\", func(c *gin.Context) {\n    h := testHeader{}\n\n    if err := c.ShouldBindHeader(&h); err != nil {\n      c.JSON(http.StatusOK, err)\n    }\n\n    fmt.Printf(\"%#v\\n\", h)\n    c.JSON(http.StatusOK, gin.H{\"Rate\": h.Rate, \"Domain\": h.Domain})\n  })\n\n  r.Run()\n\n// client\n// curl -H \"rate:300\" -H \"domain:music\" 127.0.0.1:8080/\n// output\n// {\"Domain\":\"music\",\"Rate\":300}\n}\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Bind HTML checkboxes\n\nSee the [detail information](https://github.com/gin-gonic/gin/issues/129#issuecomment-124260092)\n\nmain.go\n\n```go\n...\n\ntype myForm struct {\n    Colors []string `form:\"colors[]\"`\n}\n\n...\n\nfunc formHandler(c *gin.Context) {\n    var fakeForm myForm\n    c.ShouldBind(&fakeForm)\n    c.JSON(http.StatusOK, gin.H{\"color\": fakeForm.Colors})\n}\n\n...\n\n```\n\nform.html\n\n```html\n<form action=\"/\" method=\"POST\">\n    <p>Check some colors</p>\n    <label for=\"red\">Red</label>\n    <input type=\"checkbox\" name=\"colors[]\" value=\"red\" id=\"red\">\n    <label for=\"green\">Green</label>\n    <input type=\"checkbox\" name=\"colors[]\" value=\"green\" id=\"green\">\n    <label for=\"blue\">Blue</label>\n    <input type=\"checkbox\" name=\"colors[]\" value=\"blue\" id=\"blue\">\n    <input type=\"submit\">\n</form>\n```\n\nresult:\n\n```json\n{\"color\":[\"red\",\"green\",\"blue\"]}\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Multipart/Urlencoded binding\n\n```go\ntype ProfileForm struct {\n  Name   string                `form:\"name\" binding:\"required\"`\n  Avatar *multipart.FileHeader `form:\"avatar\" binding:\"required\"`\n\n  // or for multiple files\n  // Avatars []*multipart.FileHeader `form:\"avatar\" binding:\"required\"`\n}\n\nfunc main() {\n  router := gin.Default()\n  router.POST(\"/profile\", func(c *gin.Context) {\n    // you can bind multipart form with explicit binding declaration:\n    // c.ShouldBindWith(&form, binding.Form)\n    // or you can simply use autobinding with ShouldBind method:\n    var form ProfileForm\n    // in this case proper binding will be automatically selected\n    if err := c.ShouldBind(&form); err != nil {\n      c.String(http.StatusBadRequest, \"bad request\")\n      return\n    }\n\n    err := c.SaveUploadedFile(form.Avatar, form.Avatar.Filename)\n    if err != nil {\n      c.String(http.StatusInternalServerError, \"unknown error\")\n      return\n    }\n\n    // db.Save(&form)\n\n    c.String(http.StatusOK, \"ok\")\n  })\n  router.Run(\":8080\")\n}\n```\n\nTest it with:\n\n```sh\ncurl -X POST -v --form name=user --form \"avatar=@./avatar.png\" http://localhost:8080/profile\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### XML, JSON, YAML, TOML and ProtoBuf rendering\n\n```go\nfunc main() {\n  r := gin.Default()\n\n  // gin.H is a shortcut for map[string]any\n  r.GET(\"/someJSON\", func(c *gin.Context) {\n    c.JSON(http.StatusOK, gin.H{\"message\": \"hey\", \"status\": http.StatusOK})\n  })\n\n  r.GET(\"/moreJSON\", func(c *gin.Context) {\n    // You can also use a struct\n    var msg struct {\n      Name    string `json:\"user\"`\n      Message string\n      Number  int\n    }\n    msg.Name = \"Lena\"\n    msg.Message = \"hey\"\n    msg.Number = 123\n    // Note that msg.Name becomes \"user\" in the JSON\n    // Will output  :   {\"user\": \"Lena\", \"Message\": \"hey\", \"Number\": 123}\n    c.JSON(http.StatusOK, msg)\n  })\n\n  r.GET(\"/someXML\", func(c *gin.Context) {\n    c.XML(http.StatusOK, gin.H{\"message\": \"hey\", \"status\": http.StatusOK})\n  })\n\n  r.GET(\"/someYAML\", func(c *gin.Context) {\n    c.YAML(http.StatusOK, gin.H{\"message\": \"hey\", \"status\": http.StatusOK})\n  })\n\n  r.GET(\"/someTOML\", func(c *gin.Context) {\n    c.TOML(http.StatusOK, gin.H{\"message\": \"hey\", \"status\": http.StatusOK})\n  })\n\n  r.GET(\"/someProtoBuf\", func(c *gin.Context) {\n    reps := []int64{int64(1), int64(2)}\n    label := \"test\"\n    // The specific definition of protobuf is written in the testdata/protoexample file.\n    data := &protoexample.Test{\n      Label: &label,\n      Reps:  reps,\n    }\n    // Note that data becomes binary data in the response\n    // Will output protoexample.Test protobuf serialized data\n    c.ProtoBuf(http.StatusOK, data)\n  })\n\n  // Listen and serve on 0.0.0.0:8080\n  r.Run(\":8080\")\n}\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "#### SecureJSON\n\nUsing SecureJSON to prevent json hijacking. Default prepends `\"while(1),\"` to response body if the given struct is array values.\n\n```go\nfunc main() {\n  r := gin.Default()\n\n  // You can also use your own secure json prefix\n  // r.SecureJsonPrefix(\")]}',\\n\")\n\n  r.GET(\"/someJSON\", func(c *gin.Context) {\n    names := []string{\"lena\", \"austin\", \"foo\"}\n\n    // Will output  :   while(1);[\"lena\",\"austin\",\"foo\"]\n    c.SecureJSON(http.StatusOK, names)\n  })\n\n  // Listen and serve on 0.0.0.0:8080\n  r.Run(\":8080\")\n}\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "#### JSONP\n\nUsing JSONP to request data from a server in a different domain. Add callback to response body if the query parameter callback exists.\n\n```go\nfunc main() {\n  r := gin.Default()\n\n  r.GET(\"/JSONP\", func(c *gin.Context) {\n    data := gin.H{\n      \"foo\": \"bar\",\n    }\n\n    //callback is x\n    // Will output  :   x({\\\"foo\\\":\\\"bar\\\"})\n    c.JSONP(http.StatusOK, data)\n  })\n\n  // Listen and serve on 0.0.0.0:8080\n  r.Run(\":8080\")\n\n        // client\n        // curl http://127.0.0.1:8080/JSONP?callback=x\n}\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "#### AsciiJSON\n\nUsing AsciiJSON to Generates ASCII-only JSON with escaped non-ASCII characters.\n\n```go\nfunc main() {\n  r := gin.Default()\n\n  r.GET(\"/someJSON\", func(c *gin.Context) {\n    data := gin.H{\n      \"lang\": \"GO\u8bed\u8a00\",\n      \"tag\":  \"<br>\",\n    }\n\n    // will output : {\"lang\":\"GO\\u8bed\\u8a00\",\"tag\":\"\\u003cbr\\u003e\"}\n    c.AsciiJSON(http.StatusOK, data)\n  })\n\n  // Listen and serve on 0.0.0.0:8080\n  r.Run(\":8080\")\n}\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "#### PureJSON\n\nNormally, JSON replaces special HTML characters with their unicode entities, e.g. `<` becomes `\\u003c`. If you want to encode such characters literally, you can use PureJSON instead.\nThis feature is unavailable in Go 1.6 and lower.\n\n```go\nfunc main() {\n  r := gin.Default()\n\n  // Serves unicode entities\n  r.GET(\"/json\", func(c *gin.Context) {\n    c.JSON(http.StatusOK, gin.H{\n      \"html\": \"<b>Hello, world!</b>\",\n    })\n  })\n\n  // Serves literal characters\n  r.GET(\"/purejson\", func(c *gin.Context) {\n    c.PureJSON(http.StatusOK, gin.H{\n      \"html\": \"<b>Hello, world!</b>\",\n    })\n  })\n\n  // listen and serve on 0.0.0.0:8080\n  r.Run(\":8080\")\n}\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Serving static files\n\n```go\nfunc main() {\n  router := gin.Default()\n  router.Static(\"/assets\", \"./assets\")\n  router.StaticFS(\"/more_static\", http.Dir(\"my_file_system\"))\n  router.StaticFile(\"/favicon.ico\", \"./resources/favicon.ico\")\n  router.StaticFileFS(\"/more_favicon.ico\", \"more_favicon.ico\", http.Dir(\"my_file_system\"))\n\n  // Listen and serve on 0.0.0.0:8080\n  router.Run(\":8080\")\n}\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Serving data from file\n\n```go\nfunc main() {\n  router := gin.Default()\n\n  router.GET(\"/local/file\", func(c *gin.Context) {\n    c.File(\"local/file.go\")\n  })\n\n  var fs http.FileSystem = // ...\n  router.GET(\"/fs/file\", func(c *gin.Context) {\n    c.FileFromFS(\"fs/file.go\", fs)\n  })\n}\n\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Serving data from reader\n\n```go\nfunc main() {\n  router := gin.Default()\n  router.GET(\"/someDataFromReader\", func(c *gin.Context) {\n    response, err := http.Get(\"https://raw.githubusercontent.com/gin-gonic/logo/master/color.png\")\n    if err != nil || response.StatusCode != http.StatusOK {\n      c.Status(http.StatusServiceUnavailable)\n      return\n    }\n\n    reader := response.Body\n     defer reader.Close()\n    contentLength := response.ContentLength\n    contentType := response.Header.Get(\"Content-Type\")\n\n    extraHeaders := map[string]string{\n      \"Content-Disposition\": `attachment; filename=\"gopher.png\"`,\n    }\n\n    c.DataFromReader(http.StatusOK, contentLength, contentType, reader, extraHeaders)\n  })\n  router.Run(\":8080\")\n}\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### HTML rendering\n\nUsing LoadHTMLGlob() or LoadHTMLFiles() or LoadHTMLFS()\n\n```go\n//go:embed templates/*\nvar templates embed.FS\n\nfunc main() {\n  router := gin.Default()\n  router.LoadHTMLGlob(\"templates/*\")\n  //router.LoadHTMLFiles(\"templates/template1.html\", \"templates/template2.html\")\n  //router.LoadHTMLFS(http.Dir(\"templates\"), \"template1.html\", \"template2.html\")\n  //or\n  //router.LoadHTMLFS(http.FS(templates), \"templates/template1.html\", \"templates/template2.html\")\n  router.GET(\"/index\", func(c *gin.Context) {\n    c.HTML(http.StatusOK, \"index.tmpl\", gin.H{\n      \"title\": \"Main website\",\n    })\n  })\n  router.Run(\":8080\")\n}\n```\n\ntemplates/index.tmpl\n\n```html\n<html>\n  <h1>\n    {{ .title }}\n  </h1>\n</html>\n```\n\nUsing templates with same name in different directories\n\n```go\nfunc main() {\n  router := gin.Default()\n  router.LoadHTMLGlob(\"templates/**/*\")\n  router.GET(\"/posts/index\", func(c *gin.Context) {\n    c.HTML(http.StatusOK, \"posts/index.tmpl\", gin.H{\n      \"title\": \"Posts\",\n    })\n  })\n  router.GET(\"/users/index\", func(c *gin.Context) {\n    c.HTML(http.StatusOK, \"users/index.tmpl\", gin.H{\n      \"title\": \"Users\",\n    })\n  })\n  router.Run(\":8080\")\n}\n```\n\ntemplates/posts/index.tmpl\n\n```html\n{{ define \"posts/index.tmpl\" }}\n<html><h1>\n  {{ .title }}\n</h1>\n<p>Using posts/index.tmpl</p>\n</html>\n{{ end }}\n```\n\ntemplates/users/index.tmpl\n\n```html\n{{ define \"users/index.tmpl\" }}\n<html><h1>\n  {{ .title }}\n</h1>\n<p>Using users/index.tmpl</p>\n</html>\n{{ end }}\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "#### Custom Template renderer\n\nYou can also use your own html template render\n\n```go\nimport \"html/template\"\n\nfunc main() {\n  router := gin.Default()\n  html := template.Must(template.ParseFiles(\"file1\", \"file2\"))\n  router.SetHTMLTemplate(html)\n  router.Run(\":8080\")\n}\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "#### Custom Delimiters\n\nYou may use custom delims\n\n```go\n  r := gin.Default()\n  r.Delims(\"{[{\", \"}]}\")\n  r.LoadHTMLGlob(\"/path/to/templates\")\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "#### Custom Template Funcs\n\nSee the detailed [example code](https://github.com/gin-gonic/examples/tree/master/template).\n\nmain.go\n\n```go\nimport (\n  \"fmt\"\n  \"html/template\"\n  \"net/http\"\n  \"time\"\n\n  \"github.com/gin-gonic/gin\"\n)\n\nfunc formatAsDate(t time.Time) string {\n  year, month, day := t.Date()\n  return fmt.Sprintf(\"%d/%02d/%02d\", year, month, day)\n}\n\nfunc main() {\n  router := gin.Default()\n  router.Delims(\"{[{\", \"}]}\")\n  router.SetFuncMap(template.FuncMap{\n      \"formatAsDate\": formatAsDate,\n  })\n  router.LoadHTMLFiles(\"./testdata/template/raw.tmpl\")\n\n  router.GET(\"/raw\", func(c *gin.Context) {\n      c.HTML(http.StatusOK, \"raw.tmpl\", gin.H{\n          \"now\": time.Date(2017, 07, 01, 0, 0, 0, 0, time.UTC),\n      })\n  })\n\n  router.Run(\":8080\")\n}\n\n```\n\nraw.tmpl\n\n```html\nDate: {[{.now | formatAsDate}]}\n```\n\nResult:\n\n```sh\nDate: 2017/07/01\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Multitemplate\n\nGin allows only one html.Template by default. Check [a multitemplate render](https://github.com/gin-contrib/multitemplate) for using features like go 1.6 `block template`.\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Redirects\n\nIssuing a HTTP redirect is easy. Both internal and external locations are supported.\n\n```go\nr.GET(\"/test\", func(c *gin.Context) {\n  c.Redirect(http.StatusMovedPermanently, \"http://www.google.com/\")\n})\n```\n\nIssuing a HTTP redirect from POST. Refer to issue: [#444](https://github.com/gin-gonic/gin/issues/444)\n\n```go\nr.POST(\"/test\", func(c *gin.Context) {\n  c.Redirect(http.StatusFound, \"/foo\")\n})\n```\n\nIssuing a Router redirect, use `HandleContext` like below.\n\n``` go\nr.GET(\"/test\", func(c *gin.Context) {\n    c.Request.URL.Path = \"/test2\"\n    r.HandleContext(c)\n})\nr.GET(\"/test2\", func(c *gin.Context) {\n    c.JSON(http.StatusOK, gin.H{\"hello\": \"world\"})\n})\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Custom Middleware\n\n```go\nfunc Logger() gin.HandlerFunc {\n  return func(c *gin.Context) {\n    t := time.Now()\n\n    // Set example variable\n    c.Set(\"example\", \"12345\")\n\n    // before request\n\n    c.Next()\n\n    // after request\n    latency := time.Since(t)\n    log.Print(latency)\n\n    // access the status we are sending\n    status := c.Writer.Status()\n    log.Println(status)\n  }\n}\n\nfunc main() {\n  r := gin.New()\n  r.Use(Logger())\n\n  r.GET(\"/test\", func(c *gin.Context) {\n    example := c.MustGet(\"example\").(string)\n\n    // it would print: \"12345\"\n    log.Println(example)\n  })\n\n  // Listen and serve on 0.0.0.0:8080\n  r.Run(\":8080\")\n}\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Using BasicAuth() middleware\n\n```go\n// simulate some private data\nvar secrets = gin.H{\n  \"foo\":    gin.H{\"email\": \"foo@bar.com\", \"phone\": \"123433\"},\n  \"austin\": gin.H{\"email\": \"austin@example.com\", \"phone\": \"666\"},\n  \"lena\":   gin.H{\"email\": \"lena@guapa.com\", \"phone\": \"523443\"},\n}\n\nfunc main() {\n  r := gin.Default()\n\n  // Group using gin.BasicAuth() middleware\n  // gin.Accounts is a shortcut for map[string]string\n  authorized := r.Group(\"/admin\", gin.BasicAuth(gin.Accounts{\n    \"foo\":    \"bar\",\n    \"austin\": \"1234\",\n    \"lena\":   \"hello2\",\n    \"manu\":   \"4321\",\n  }))\n\n  // /admin/secrets endpoint\n  // hit \"localhost:8080/admin/secrets\n  authorized.GET(\"/secrets\", func(c *gin.Context) {\n    // get user, it was set by the BasicAuth middleware\n    user := c.MustGet(gin.AuthUserKey).(string)\n    if secret, ok := secrets[user]; ok {\n      c.JSON(http.StatusOK, gin.H{\"user\": user, \"secret\": secret})\n    } else {\n      c.JSON(http.StatusOK, gin.H{\"user\": user, \"secret\": \"NO SECRET :(\"})\n    }\n  })\n\n  // Listen and serve on 0.0.0.0:8080\n  r.Run(\":8080\")\n}\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Goroutines inside a middleware\n\nWhen starting new Goroutines inside a middleware or handler, you **SHOULD NOT** use the original context inside it, you have to use a read-only copy.\n\n```go\nfunc main() {\n  r := gin.Default()\n\n  r.GET(\"/long_async\", func(c *gin.Context) {\n    // create copy to be used inside the goroutine\n    cCp := c.Copy()\n    go func() {\n      // simulate a long task with time.Sleep(). 5 seconds\n      time.Sleep(5 * time.Second)\n\n      // note that you are using the copied context \"cCp\", IMPORTANT\n      log.Println(\"Done! in path \" + cCp.Request.URL.Path)\n    }()\n  })\n\n  r.GET(\"/long_sync\", func(c *gin.Context) {\n    // simulate a long task with time.Sleep(). 5 seconds\n    time.Sleep(5 * time.Second)\n\n    // since we are NOT using a goroutine, we do not have to copy the context\n    log.Println(\"Done! in path \" + c.Request.URL.Path)\n  })\n\n  // Listen and serve on 0.0.0.0:8080\n  r.Run(\":8080\")\n}\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Custom HTTP configuration\n\nUse `http.ListenAndServe()` directly, like this:\n\n```go\nfunc main() {\n  router := gin.Default()\n  http.ListenAndServe(\":8080\", router)\n}\n```\n\nor\n\n```go\nfunc main() {\n  router := gin.Default()\n\n  s := &http.Server{\n    Addr:           \":8080\",\n    Handler:        router,\n    ReadTimeout:    10 * time.Second,\n    WriteTimeout:   10 * time.Second,\n    MaxHeaderBytes: 1 << 20,\n  }\n  s.ListenAndServe()\n}\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Support Let's Encrypt\n\nexample for 1-line LetsEncrypt HTTPS servers.\n\n```go\npackage main\n\nimport (\n  \"log\"\n  \"net/http\"\n\n  \"github.com/gin-gonic/autotls\"\n  \"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n  r := gin.Default()\n\n  // Ping handler\n  r.GET(\"/ping\", func(c *gin.Context) {\n    c.String(http.StatusOK, \"pong\")\n  })\n\n  log.Fatal(autotls.Run(r, \"example1.com\", \"example2.com\"))\n}\n```\n\nexample for custom autocert manager.\n\n```go\npackage main\n\nimport (\n  \"log\"\n  \"net/http\"\n\n  \"github.com/gin-gonic/autotls\"\n  \"github.com/gin-gonic/gin\"\n  \"golang.org/x/crypto/acme/autocert\"\n)\n\nfunc main() {\n  r := gin.Default()\n\n  // Ping handler\n  r.GET(\"/ping\", func(c *gin.Context) {\n    c.String(http.StatusOK, \"pong\")\n  })\n\n  m := autocert.Manager{\n    Prompt:     autocert.AcceptTOS,\n    HostPolicy: autocert.HostWhitelist(\"example1.com\", \"example2.com\"),\n    Cache:      autocert.DirCache(\"/var/www/.cache\"),\n  }\n\n  log.Fatal(autotls.RunWithManager(r, &m))\n}\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Run multiple service using Gin\n\nSee the [question](https://github.com/gin-gonic/gin/issues/346) and try the following example:\n\n```go\npackage main\n\nimport (\n  \"log\"\n  \"net/http\"\n  \"time\"\n\n  \"github.com/gin-gonic/gin\"\n  \"golang.org/x/sync/errgroup\"\n)\n\nvar (\n  g errgroup.Group\n)\n\nfunc router01() http.Handler {\n  e := gin.New()\n  e.Use(gin.Recovery())\n  e.GET(\"/\", func(c *gin.Context) {\n    c.JSON(\n      http.StatusOK,\n      gin.H{\n        \"code\":  http.StatusOK,\n        \"error\": \"Welcome server 01\",\n      },\n    )\n  })\n\n  return e\n}\n\nfunc router02() http.Handler {\n  e := gin.New()\n  e.Use(gin.Recovery())\n  e.GET(\"/\", func(c *gin.Context) {\n    c.JSON(\n      http.StatusOK,\n      gin.H{\n        \"code\":  http.StatusOK,\n        \"error\": \"Welcome server 02\",\n      },\n    )\n  })\n\n  return e\n}\n\nfunc main() {\n  server01 := &http.Server{\n    Addr:         \":8080\",\n    Handler:      router01(),\n    ReadTimeout:  5 * time.Second,\n    WriteTimeout: 10 * time.Second,\n  }\n\n  server02 := &http.Server{\n    Addr:         \":8081\",\n    Handler:      router02(),\n    ReadTimeout:  5 * time.Second,\n    WriteTimeout: 10 * time.Second,\n  }\n\n  g.Go(func() error {\n    err := server01.ListenAndServe()\n    if err != nil && err != http.ErrServerClosed {\n      log.Fatal(err)\n    }\n    return err\n  })\n\n  g.Go(func() error {\n    err := server02.ListenAndServe()\n    if err != nil && err != http.ErrServerClosed {\n      log.Fatal(err)\n    }\n    return err\n  })\n\n  if err := g.Wait(); err != nil {\n    log.Fatal(err)\n  }\n}\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Graceful shutdown or restart\n\nThere are a few approaches you can use to perform a graceful shutdown or restart. You can make use of third-party packages specifically built for that, or you can manually do the same with the functions and methods from the built-in packages.\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "#### Third-party packages\n\nWe can use [fvbock/endless](https://github.com/fvbock/endless) to replace the default `ListenAndServe`. Refer to issue [#296](https://github.com/gin-gonic/gin/issues/296) for more details.\n\n```go\nrouter := gin.Default()\nrouter.GET(\"/\", handler)\n// [...]\nendless.ListenAndServe(\":4242\", router)\n```\n\nAlternatives:\n\n* [grace](https://github.com/facebookgo/grace): Graceful restart & zero downtime deploy for Go servers.\n* [graceful](https://github.com/tylerb/graceful): Graceful is a Go package enabling graceful shutdown of an http.Handler server.\n* [manners](https://github.com/braintree/manners): A polite Go HTTP server that shuts down gracefully.\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "#### Manually\n\nIn case you are using Go 1.8 or a later version, you may not need to use those libraries. Consider using `http.Server`'s built-in [Shutdown()](https://pkg.go.dev/net/http#Server.Shutdown) method for graceful shutdowns. The example below describes its usage, and we've got more examples using gin [here](https://github.com/gin-gonic/examples/tree/master/graceful-shutdown).\n\n```go\n// +build go1.8\n\npackage main\n\nimport (\n  \"context\"\n  \"log\"\n  \"net/http\"\n  \"os\"\n  \"os/signal\"\n  \"syscall\"\n  \"time\"\n\n  \"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n  router := gin.Default()\n  router.GET(\"/\", func(c *gin.Context) {\n    time.Sleep(5 * time.Second)\n    c.String(http.StatusOK, \"Welcome Gin Server\")\n  })\n\n  srv := &http.Server{\n    Addr:    \":8080\",\n    Handler: router,\n  }\n\n  // Initializing the server in a goroutine so that\n  // it won't block the graceful shutdown handling below\n  go func() {\n    if err := srv.ListenAndServe(); err != nil && !errors.Is(err, http.ErrServerClosed) {\n      log.Printf(\"listen: %s\\n\", err)\n    }\n  }()\n\n  // Wait for interrupt signal to gracefully shutdown the server with\n  // a timeout of 5 seconds.\n  quit := make(chan os.Signal)\n  // kill (no param) default send syscall.SIGTERM\n  // kill -2 is syscall.SIGINT\n  // kill -9 is syscall.SIGKILL but can't be caught, so don't need to add it\n  signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\n  <-quit\n  log.Println(\"Shutting down server...\")\n\n  // The context is used to inform the server it has 5 seconds to finish\n  // the request it is currently handling\n  ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n  defer cancel()\n\n  if err := srv.Shutdown(ctx); err != nil {\n    log.Fatal(\"Server forced to shutdown:\", err)\n  }\n\n  log.Println(\"Server exiting\")\n}\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Build a single binary with templates\n\nYou can build a server into a single binary containing templates by using the [embed](https://pkg.go.dev/embed) package.\n\n```go\npackage main\n\nimport (\n  \"embed\"\n  \"html/template\"\n  \"net/http\"\n\n  \"github.com/gin-gonic/gin\"\n)\n\n//go:embed assets/* templates/*\nvar f embed.FS\n\nfunc main() {\n  router := gin.Default()\n  templ := template.Must(template.New(\"\").ParseFS(f, \"templates/*.tmpl\", \"templates/foo/*.tmpl\"))\n  router.SetHTMLTemplate(templ)\n\n  // example: /public/assets/images/example.png\n  router.StaticFS(\"/public\", http.FS(f))\n\n  router.GET(\"/\", func(c *gin.Context) {\n    c.HTML(http.StatusOK, \"index.tmpl\", gin.H{\n      \"title\": \"Main website\",\n    })\n  })\n\n  router.GET(\"/foo\", func(c *gin.Context) {\n    c.HTML(http.StatusOK, \"bar.tmpl\", gin.H{\n      \"title\": \"Foo website\",\n    })\n  })\n\n  router.GET(\"favicon.ico\", func(c *gin.Context) {\n    file, _ := f.ReadFile(\"assets/favicon.ico\")\n    c.Data(\n      http.StatusOK,\n      \"image/x-icon\",\n      file,\n    )\n  })\n\n  router.Run(\":8080\")\n}\n```\n\nSee a complete example in the `https://github.com/gin-gonic/examples/tree/master/assets-in-binary/example02` directory.\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Bind form-data request with custom struct\n\nThe follow example using custom struct:\n\n```go\ntype StructA struct {\n    FieldA string `form:\"field_a\"`\n}\n\ntype StructB struct {\n    NestedStruct StructA\n    FieldB string `form:\"field_b\"`\n}\n\ntype StructC struct {\n    NestedStructPointer *StructA\n    FieldC string `form:\"field_c\"`\n}\n\ntype StructD struct {\n    NestedAnonyStruct struct {\n        FieldX string `form:\"field_x\"`\n    }\n    FieldD string `form:\"field_d\"`\n}\n\nfunc GetDataB(c *gin.Context) {\n    var b StructB\n    c.Bind(&b)\n    c.JSON(http.StatusOK, gin.H{\n        \"a\": b.NestedStruct,\n        \"b\": b.FieldB,\n    })\n}\n\nfunc GetDataC(c *gin.Context) {\n    var b StructC\n    c.Bind(&b)\n    c.JSON(http.StatusOK, gin.H{\n        \"a\": b.NestedStructPointer,\n        \"c\": b.FieldC,\n    })\n}\n\nfunc GetDataD(c *gin.Context) {\n    var b StructD\n    c.Bind(&b)\n    c.JSON(http.StatusOK, gin.H{\n        \"x\": b.NestedAnonyStruct,\n        \"d\": b.FieldD,\n    })\n}\n\nfunc main() {\n    r := gin.Default()\n    r.GET(\"/getb\", GetDataB)\n    r.GET(\"/getc\", GetDataC)\n    r.GET(\"/getd\", GetDataD)\n\n    r.Run()\n}\n```\n\nUsing the command `curl` command result:\n\n```sh\n$ curl \"http://localhost:8080/getb?field_a=hello&field_b=world\"\n{\"a\":{\"FieldA\":\"hello\"},\"b\":\"world\"}\n$ curl \"http://localhost:8080/getc?field_a=hello&field_c=world\"\n{\"a\":{\"FieldA\":\"hello\"},\"c\":\"world\"}\n$ curl \"http://localhost:8080/getd?field_x=hello&field_d=world\"\n{\"d\":\"world\",\"x\":{\"FieldX\":\"hello\"}}\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Try to bind body into different structs\n\nThe normal methods for binding request body consumes `c.Request.Body` and they\ncannot be called multiple times.\n\n```go\ntype formA struct {\n  Foo string `json:\"foo\" xml:\"foo\" binding:\"required\"`\n}\n\ntype formB struct {\n  Bar string `json:\"bar\" xml:\"bar\" binding:\"required\"`\n}\n\nfunc SomeHandler(c *gin.Context) {\n  objA := formA{}\n  objB := formB{}\n  // Calling c.ShouldBind consumes c.Request.Body and it cannot be reused.\n  if errA := c.ShouldBind(&objA); errA == nil {\n    c.String(http.StatusOK, `the body should be formA`)\n  // Always an error is occurred by this because c.Request.Body is EOF now.\n  } else if errB := c.ShouldBind(&objB); errB == nil {\n    c.String(http.StatusOK, `the body should be formB`)\n  } else {\n    ...\n  }\n}\n```\n\nFor this, you can use `c.ShouldBindBodyWith` or shortcuts.\n\n- `c.ShouldBindBodyWithJSON` is a shortcut for c.ShouldBindBodyWith(obj, binding.JSON).\n- `c.ShouldBindBodyWithXML` is a shortcut for c.ShouldBindBodyWith(obj, binding.XML).\n- `c.ShouldBindBodyWithYAML` is a shortcut for c.ShouldBindBodyWith(obj, binding.YAML).\n- `c.ShouldBindBodyWithTOML` is a shortcut for c.ShouldBindBodyWith(obj, binding.TOML).\n\n```go\nfunc SomeHandler(c *gin.Context) {\n  objA := formA{}\n  objB := formB{}\n  // This reads c.Request.Body and stores the result into the context.\n  if errA := c.ShouldBindBodyWith(&objA, binding.Form); errA == nil {\n    c.String(http.StatusOK, `the body should be formA`)\n  // At this time, it reuses body stored in the context.\n  } else if errB := c.ShouldBindBodyWith(&objB, binding.JSON); errB == nil {\n    c.String(http.StatusOK, `the body should be formB JSON`)\n  // And it can accepts other formats\n  } else if errB2 := c.ShouldBindBodyWithXML(&objB); errB2 == nil {\n    c.String(http.StatusOK, `the body should be formB XML`)\n  } else {\n    ...\n  }\n}\n```\n\n1. `c.ShouldBindBodyWith` stores body into the context before binding. This has\na slight impact to performance, so you should not use this method if you are\nenough to call binding at once.\n2. This feature is only needed for some formats -- `JSON`, `XML`, `MsgPack`,\n`ProtoBuf`. For other formats, `Query`, `Form`, `FormPost`, `FormMultipart`,\ncan be called by `c.ShouldBind()` multiple times without any damage to\nperformance (See [#1341](https://github.com/gin-gonic/gin/pull/1341)).\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Bind form-data request with custom struct and custom tag\n\n```go\nconst (\n  customerTag = \"url\"\n  defaultMemory = 32 << 20\n)\n\ntype customerBinding struct {}\n\nfunc (customerBinding) Name() string {\n  return \"form\"\n}\n\nfunc (customerBinding) Bind(req *http.Request, obj any) error {\n  if err := req.ParseForm(); err != nil {\n    return err\n  }\n  if err := req.ParseMultipartForm(defaultMemory); err != nil {\n    if err != http.ErrNotMultipart {\n      return err\n    }\n  }\n  if err := binding.MapFormWithTag(obj, req.Form, customerTag); err != nil {\n    return err\n  }\n  return validate(obj)\n}\n\nfunc validate(obj any) error {\n  if binding.Validator == nil {\n    return nil\n  }\n  return binding.Validator.ValidateStruct(obj)\n}\n\n// Now we can do this!!!\n// FormA is an external type that we can't modify it's tag\ntype FormA struct {\n  FieldA string `url:\"field_a\"`\n}\n\nfunc ListHandler(s *Service) func(ctx *gin.Context) {\n  return func(ctx *gin.Context) {\n    var urlBinding = customerBinding{}\n    var opt FormA\n    err := ctx.MustBindWith(&opt, urlBinding)\n    if err != nil {\n      ...\n    }\n    ...\n  }\n}\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### http2 server push\n\nhttp.Pusher is supported only **go1.8+**. See the [golang blog](https://go.dev/blog/h2push) for detail information.\n\n```go\npackage main\n\nimport (\n  \"html/template\"\n  \"log\"\n  \"net/http\"\n\n  \"github.com/gin-gonic/gin\"\n)\n\nvar html = template.Must(template.New(\"https\").Parse(`\n<html>\n<head>\n  <title>Https Test</title>\n  <script src=\"/assets/app.js\"></script>\n</head>\n<body>\n  <h1 style=\"color:red;\">Welcome, Ginner!</h1>\n</body>\n</html>\n`))\n\nfunc main() {\n  r := gin.Default()\n  r.Static(\"/assets\", \"./assets\")\n  r.SetHTMLTemplate(html)\n\n  r.GET(\"/\", func(c *gin.Context) {\n    if pusher := c.Writer.Pusher(); pusher != nil {\n      // use pusher.Push() to do server push\n      if err := pusher.Push(\"/assets/app.js\", nil); err != nil {\n        log.Printf(\"Failed to push: %v\", err)\n      }\n    }\n    c.HTML(http.StatusOK, \"https\", gin.H{\n      \"status\": \"success\",\n    })\n  })\n\n  // Listen and Server in https://127.0.0.1:8080\n  r.RunTLS(\":8080\", \"./testdata/server.pem\", \"./testdata/server.key\")\n}\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Define format for the log of routes\n\nThe default log of routes is:\n\n```sh\n[GIN-debug] POST   /foo                      --> main.main.func1 (3 handlers)\n[GIN-debug] GET    /bar                      --> main.main.func2 (3 handlers)\n[GIN-debug] GET    /status                   --> main.main.func3 (3 handlers)\n```\n\nIf you want to log this information in given format (e.g. JSON, key values or something else), then you can define this format with `gin.DebugPrintRouteFunc`.\nIn the example below, we log all routes with standard log package but you can use another log tools that suits of your needs.\n\n```go\nimport (\n  \"log\"\n  \"net/http\"\n\n  \"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n  r := gin.Default()\n  gin.DebugPrintRouteFunc = func(httpMethod, absolutePath, handlerName string, nuHandlers int) {\n    log.Printf(\"endpoint %v %v %v %v\\n\", httpMethod, absolutePath, handlerName, nuHandlers)\n  }\n\n  r.POST(\"/foo\", func(c *gin.Context) {\n    c.JSON(http.StatusOK, \"foo\")\n  })\n\n  r.GET(\"/bar\", func(c *gin.Context) {\n    c.JSON(http.StatusOK, \"bar\")\n  })\n\n  r.GET(\"/status\", func(c *gin.Context) {\n    c.JSON(http.StatusOK, \"ok\")\n  })\n\n  // Listen and Server in http://0.0.0.0:8080\n  r.Run()\n}\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Set and get a cookie\n\n```go\nimport (\n  \"fmt\"\n\n  \"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n  router := gin.Default()\n\n  router.GET(\"/cookie\", func(c *gin.Context) {\n    cookie, err := c.Cookie(\"gin_cookie\")\n\n    if err != nil {\n      cookie = \"NotSet\"\n      // Using http.Cookie struct for more control\n      c.SetCookieData(&http.Cookie{\n        Name:       \"gin_cookie\",\n        Value:      \"test\",\n        Path:       \"/\",\n        Domain:     \"localhost\",\n        MaxAge:     3600,\n        Secure:     false,\n        HttpOnly:   true,\n        // Additional fields available in http.Cookie\n        Expires:    time.Now().Add(24 * time.Hour),\n        // Partitioned: true, // Available in newer Go versions\n      })\n    }\n\n    fmt.Printf(\"Cookie value: %s \\n\", cookie)\n  })\n\n  router.Run()\n}\n```\n\nYou can also use the `SetCookieData` method, which accepts a `*http.Cookie` directly for more flexibility:\n\n```go\nimport (\n  \"fmt\"\n  \"net/http\"\n  \"time\"\n\n  \"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n  router := gin.Default()\n\n  router.GET(\"/cookie\", func(c *gin.Context) {\n      cookie, err := c.Cookie(\"gin_cookie\")\n\n      if err != nil {\n          cookie = \"NotSet\"\n          // Using http.Cookie struct for more control\n          c.SetCookieData(&http.Cookie{\n              Name:       \"gin_cookie\",\n              Value:      \"test\",\n              Path:       \"/\",\n              Domain:     \"localhost\",\n              MaxAge:     3600,\n              Secure:     false,\n              HttpOnly:   true,\n              // Additional fields available in http.Cookie\n              Expires:    time.Now().Add(24 * time.Hour),\n              // Partitioned: true, // Available in newer Go versions\n          })\n      }\n\n      fmt.Printf(\"Cookie value: %s \\n\", cookie)\n  })\n\n  router.Run()\n}\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "### Custom json codec at runtime\n\nGin support custom json serialization and deserialization logic without using compile tags.\n\n1. Define a custom struct implements the `json.Core` interface.\n\n2. Before your engine starts, assign values to `json.API` using the custom struct.\n\n```go\npackage main\n\nimport (\n  \"io\"\n\n  \"github.com/gin-gonic/gin\"\n  \"github.com/gin-gonic/gin/codec/json\"\n  jsoniter \"github.com/json-iterator/go\"\n)\n\nvar customConfig = jsoniter.Config{\n  EscapeHTML:             true,\n  SortMapKeys:            true,\n  ValidateJsonRawMessage: true,\n}.Froze()\n\n// implement api.JsonApi\ntype customJsonApi struct {\n}\n\nfunc (j customJsonApi) Marshal(v any) ([]byte, error) {\n  return customConfig.Marshal(v)\n}\n\nfunc (j customJsonApi) Unmarshal(data []byte, v any) error {\n  return customConfig.Unmarshal(data, v)\n}\n\nfunc (j customJsonApi) MarshalIndent(v any, prefix, indent string) ([]byte, error) {\n  return customConfig.MarshalIndent(v, prefix, indent)\n}\n\nfunc (j customJsonApi) NewEncoder(writer io.Writer) json.Encoder {\n  return customConfig.NewEncoder(writer)\n}\n\nfunc (j customJsonApi) NewDecoder(reader io.Reader) json.Decoder {\n  return customConfig.NewDecoder(reader)\n}\n\nfunc main() {\n  //Replace the default json api\n  json.API = customJsonApi{}\n\n  //Start your gin engine\n  router := gin.Default()\n  router.Run(\":8080\")\n}\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "## Don't trust all proxies\n\nGin lets you specify which headers to hold the real client IP (if any),\nas well as specifying which proxies (or direct clients) you trust to\nspecify one of these headers.\n\nUse function `SetTrustedProxies()` on your `gin.Engine` to specify network addresses\nor network CIDRs from where clients which their request headers related to client\nIP can be trusted. They can be IPv4 addresses, IPv4 CIDRs, IPv6 addresses or\nIPv6 CIDRs.\n\n**Attention:** Gin trusts all proxies by default if you don't specify a trusted\nproxy using the function above, **this is NOT safe**. At the same time, if you don't\nuse any proxy, you can disable this feature by using `Engine.SetTrustedProxies(nil)`,\nthen `Context.ClientIP()` will return the remote address directly to avoid some\nunnecessary computation.\n\n```go\nimport (\n  \"fmt\"\n\n  \"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n  router := gin.Default()\n  router.SetTrustedProxies([]string{\"192.168.1.2\"})\n\n  router.GET(\"/\", func(c *gin.Context) {\n    // If the client is 192.168.1.2, use the X-Forwarded-For\n    // header to deduce the original client IP from the trust-\n    // worthy parts of that header.\n    // Otherwise, simply return the direct client IP\n    fmt.Printf(\"ClientIP: %s\\n\", c.ClientIP())\n  })\n  router.Run()\n}\n```\n\n**Notice:** If you are using a CDN service, you can set the `Engine.TrustedPlatform`\nto skip TrustedProxies check, it has a higher priority than TrustedProxies.\nLook at the example below:\n\n```go\nimport (\n  \"fmt\"\n\n  \"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n  router := gin.Default()\n  // Use predefined header gin.PlatformXXX\n  // Google App Engine\n  router.TrustedPlatform = gin.PlatformGoogleAppEngine\n  // Cloudflare\n  router.TrustedPlatform = gin.PlatformCloudflare\n  // Fly.io\n  router.TrustedPlatform = gin.PlatformFlyIO\n  // Or, you can set your own trusted request header. But be sure your CDN\n  // prevents users from passing this header! For example, if your CDN puts\n  // the client IP in X-CDN-Client-IP:\n  router.TrustedPlatform = \"X-CDN-Client-IP\"\n\n  router.GET(\"/\", func(c *gin.Context) {\n    // If you set TrustedPlatform, ClientIP() will resolve the\n    // corresponding header and return IP directly\n    fmt.Printf(\"ClientIP: %s\\n\", c.ClientIP())\n  })\n  router.Run()\n}\n```\n",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "## Testing\n\nThe `net/http/httptest` package is preferable way for HTTP testing.\n\n```go\npackage main\n\nimport (\n  \"net/http\"\n\n  \"github.com/gin-gonic/gin\"\n)\n\nfunc setupRouter() *gin.Engine {\n  r := gin.Default()\n  r.GET(\"/ping\", func(c *gin.Context) {\n    c.String(http.StatusOK, \"pong\")\n  })\n  return r\n}\n\nfunc main() {\n  r := setupRouter()\n  r.Run(\":8080\")\n}\n```\n\nTest for code example above:\n\n```go\npackage main\n\nimport (\n  \"net/http\"\n  \"net/http/httptest\"\n  \"testing\"\n\n  \"github.com/stretchr/testify/assert\"\n)\n\nfunc TestPingRoute(t *testing.T) {\n  router := setupRouter()\n\n  w := httptest.NewRecorder()\n  req, _ := http.NewRequest(http.MethodGet, \"/ping\", nil)\n  router.ServeHTTP(w, req)\n\n  assert.Equal(t, http.StatusOK, w.Code)\n  assert.Equal(t, \"pong\", w.Body.String())\n}\n```",
    "source_file": "docs/doc.md",
    "chunk_type": "doc"
  },
  {
    "content": "// Copyright 2017 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage binding\n\nimport \"net/http\"\n\ntype queryBinding struct{}\n\nfunc (queryBinding) Name() string {\n\treturn \"query\"\n}\n\nfunc (queryBinding) Bind(req *http.Request, obj any) error {\n\tvalues := req.URL.Query()\n\tif err := mapForm(obj, values); err != nil {\n\t\treturn err\n\t}\n\treturn validate(obj)\n}\n",
    "source_file": "binding/query.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2022 Gin Core Team. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage binding\n\nimport (\n\t\"net/http\"\n\t\"net/textproto\"\n\t\"reflect\"\n)\n\ntype headerBinding struct{}\n\nfunc (headerBinding) Name() string {\n\treturn \"header\"\n}\n\nfunc (headerBinding) Bind(req *http.Request, obj any) error {\n\tif err := mapHeader(obj, req.Header); err != nil {\n\t\treturn err\n\t}\n\n\treturn validate(obj)\n}\n\nfunc mapHeader(ptr any, h map[string][]string) error {\n\treturn mappingByPtr(ptr, headerSource(h), \"header\")\n}\n\ntype headerSource map[string][]string\n\nvar _ setter = headerSource(nil)\n\nfunc (hs headerSource) TrySet(value reflect.Value, field reflect.StructField, tagValue string, opt setOptions) (bool, error) {\n\treturn setByForm(value, field, hs, textproto.CanonicalMIMEHeaderKey(tagValue), opt)\n}\n",
    "source_file": "binding/header.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2017 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\n//go:build !nomsgpack\n\npackage binding\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"net/http\"\n\n\t\"github.com/ugorji/go/codec\"\n)\n\ntype msgpackBinding struct{}\n\nfunc (msgpackBinding) Name() string {\n\treturn \"msgpack\"\n}\n\nfunc (msgpackBinding) Bind(req *http.Request, obj any) error {\n\treturn decodeMsgPack(req.Body, obj)\n}\n\nfunc (msgpackBinding) BindBody(body []byte, obj any) error {\n\treturn decodeMsgPack(bytes.NewReader(body), obj)\n}\n\nfunc decodeMsgPack(r io.Reader, obj any) error {\n\tcdc := new(codec.MsgpackHandle)\n\tif err := codec.NewDecoder(r, cdc).Decode(&obj); err != nil {\n\t\treturn err\n\t}\n\treturn validate(obj)\n}\n",
    "source_file": "binding/msgpack.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2020 Gin Core Team. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\n//go:build nomsgpack\n\npackage binding\n\nimport \"net/http\"\n\n// Content-Type MIME of the most common data formats.\nconst (\n\tMIMEJSON              = \"application/json\"\n\tMIMEHTML              = \"text/html\"\n\tMIMEXML               = \"application/xml\"\n\tMIMEXML2              = \"text/xml\"\n\tMIMEPlain             = \"text/plain\"\n\tMIMEPOSTForm          = \"application/x-www-form-urlencoded\"\n\tMIMEMultipartPOSTForm = \"multipart/form-data\"\n\tMIMEPROTOBUF          = \"application/x-protobuf\"\n\tMIMEYAML              = \"application/x-yaml\"\n\tMIMEYAML2             = \"application/yaml\"\n\tMIMETOML              = \"application/toml\"\n)\n\n// Binding describes the interface which needs to be implemented for binding the\n// data present in the request such as JSON request body, query parameters or\n// the form POST.\ntype Binding interface {\n\tName() string\n\tBind(*http.Request, any) error\n}\n\n// BindingBody adds BindBody method to Binding. BindBody is similar with Bind,\n// but it reads the body from supplied bytes instead of req.Body.\ntype BindingBody interface {\n\tBinding\n\tBindBody([]byte, any) error\n}\n\n// BindingUri adds BindUri method to Binding. BindUri is similar with Bind,\n// but it reads the Params.\ntype BindingUri interface {\n\tName() string\n\tBindUri(map[string][]string, any) error\n}\n\n// StructValidator is the minimal interface which needs to be implemented in\n// order for it to be used as the validator engine for ensuring the correctness\n// of the request. Gin provides a default implementation for this using\n// https://github.com/go-playground/validator/tree/v10.6.1.\ntype StructValidator interface {\n\t// ValidateStruct can receive any kind of type and it should never panic, even if the configuration is not right.\n\t// If the received type is not a struct, any validation should be skipped and nil must be returned.\n\t// If the received type is a struct or pointer to a struct, the validation should be performed.\n\t// If the struct is not valid or the validation itself fails, a descriptive error should be returned.\n\t// Otherwise nil must be returned.\n\tValidateStruct(any) error\n\n\t// Engine returns the underlying validator engine which powers the\n\t// StructValidator implementation.\n\tEngine() any\n}\n\n// Validator is the default validator which implements the StructValidator\n// interface. It uses https://github.com/go-playground/validator/tree/v10.6.1\n// under the hood.\nvar Validator StructValidator = &defaultValidator{}\n\n// These implement the Binding interface and can be used to bind the data\n// present in the request to struct instances.\nvar (\n\tJSON          = jsonBinding{}\n\tXML           = xmlBinding{}\n\tForm          = formBinding{}\n\tQuery         = queryBinding{}\n\tFormPost      = formPostBinding{}\n\tFormMultipart = formMultipartBinding{}\n\tProtoBuf      = protobufBinding{}\n\tYAML          = yamlBinding{}\n\tUri           = uriBinding{}\n\tHeader        = headerBinding{}\n\tTOML          = tomlBinding{}\n\tPlain         = plainBinding{}\n)\n\n// Default returns the appropriate Binding instance based on the HTTP method\n// and the content type.\nfunc Default(method, contentType string) Binding {\n\tif method == \"GET\" {\n\t\treturn Form\n\t}\n\n\tswitch contentType {\n\tcase MIMEJSON:\n\t\treturn JSON\n\tcase MIMEXML, MIMEXML2:\n\t\treturn XML\n\tcase MIMEPROTOBUF:\n\t\treturn ProtoBuf\n\tcase MIMEYAML, MIMEYAML2:\n\t\treturn YAML\n\tcase MIMEMultipartPOSTForm:\n\t\treturn FormMultipart\n\tcase MIMETOML:\n\t\treturn TOML\n\tdefault: // case MIMEPOSTForm:\n\t\treturn Form\n\t}\n}\n\nfunc validate(obj any) error {\n\tif Validator == nil {\n\t\treturn nil\n\t}\n\treturn Validator.ValidateStruct(obj)\n}\n",
    "source_file": "binding/binding_nomsgpack.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage binding\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"mime/multipart\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gin-gonic/gin/codec/json\"\n\t\"github.com/gin-gonic/gin/internal/bytesconv\"\n)\n\nvar (\n\terrUnknownType = errors.New(\"unknown type\")\n\n\t// ErrConvertMapStringSlice can not convert to map[string][]string\n\tErrConvertMapStringSlice = errors.New(\"can not convert to map slices of strings\")\n\n\t// ErrConvertToMapString can not convert to map[string]string\n\tErrConvertToMapString = errors.New(\"can not convert to map of strings\")\n)\n\nfunc mapURI(ptr any, m map[string][]string) error {\n\treturn mapFormByTag(ptr, m, \"uri\")\n}\n\nfunc mapForm(ptr any, form map[string][]string) error {\n\treturn mapFormByTag(ptr, form, \"form\")\n}\n\nfunc MapFormWithTag(ptr any, form map[string][]string, tag string) error {\n\treturn mapFormByTag(ptr, form, tag)\n}\n\nvar emptyField = reflect.StructField{}\n\nfunc mapFormByTag(ptr any, form map[string][]string, tag string) error {\n\t// Check if ptr is a map\n\tptrVal := reflect.ValueOf(ptr)\n\tvar pointed any\n\tif ptrVal.Kind() == reflect.Ptr {\n\t\tptrVal = ptrVal.Elem()\n\t\tpointed = ptrVal.Interface()\n\t}\n\tif ptrVal.Kind() == reflect.Map &&\n\t\tptrVal.Type().Key().Kind() == reflect.String {\n\t\tif pointed != nil {\n\t\t\tptr = pointed\n\t\t}\n\t\treturn setFormMap(ptr, form)\n\t}\n\n\treturn mappingByPtr(ptr, formSource(form), tag)\n}\n\n// setter tries to set value on a walking by fields of a struct\ntype setter interface {\n\tTrySet(value reflect.Value, field reflect.StructField, key string, opt setOptions) (isSet bool, err error)\n}\n\ntype formSource map[string][]string\n\nvar _ setter = formSource(nil)\n\n// TrySet tries to set a value by request's form source (like map[string][]string)\nfunc (form formSource) TrySet(value reflect.Value, field reflect.StructField, tagValue string, opt setOptions) (isSet bool, err error) {\n\treturn setByForm(value, field, form, tagValue, opt)\n}\n\nfunc mappingByPtr(ptr any, setter setter, tag string) error {\n\t_, err := mapping(reflect.ValueOf(ptr), emptyField, setter, tag)\n\treturn err\n}\n\nfunc mapping(value reflect.Value, field reflect.StructField, setter setter, tag string) (bool, error) {\n\tif field.Tag.Get(tag) == \"-\" { // just ignoring this field\n\t\treturn false, nil\n\t}\n\n\tvKind := value.Kind()\n\n\tif vKind == reflect.Ptr {\n\t\tvar isNew bool\n\t\tvPtr := value\n\t\tif value.IsNil() {\n\t\t\tisNew = true\n\t\t\tvPtr = reflect.New(value.Type().Elem())\n\t\t}\n\t\tisSet, err := mapping(vPtr.Elem(), field, setter, tag)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tif isNew && isSet {\n\t\t\tvalue.Set(vPtr)\n\t\t}\n\t\treturn isSet, nil\n\t}\n\n\tif vKind != reflect.Struct || !field.Anonymous {\n\t\tok, err := tryToSetValue(value, field, setter, tag)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tif ok {\n\t\t\treturn true, nil\n\t\t}\n\t}\n\n\tif vKind == reflect.Struct {\n\t\ttValue := value.Type()\n\n\t\tvar isSet bool\n\t\tfor i := 0; i < value.NumField(); i++ {\n\t\t\tsf := tValue.Field(i)\n\t\t\tif sf.PkgPath != \"\" && !sf.Anonymous { // unexported\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tok, err := mapping(value.Field(i), sf, setter, tag)\n\t\t\tif err != nil {\n\t\t\t\treturn false, err\n\t\t\t}\n\t\t\tisSet = isSet || ok\n\t\t}\n\t\treturn isSet, nil\n\t}\n\treturn false, nil\n}\n\ntype setOptions struct {\n\tisDefaultExists bool\n\tdefaultValue    string\n}\n\nfunc tryToSetValue(value reflect.Value, field reflect.StructField, setter setter, tag string) (bool, error) {\n\tvar tagValue string\n\tvar setOpt setOptions\n\n\ttagValue = field.Tag.Get(tag)\n\ttagValue, opts := head(tagValue, \",\")\n\n\tif tagValue == \"\" { // default value is FieldName\n\t\ttagValue = field.Name\n\t}\n\tif tagValue == \"\" { // when field is \"emptyField\" variable\n\t\treturn false, nil\n\t}\n\n\tvar opt string\n\tfor len(opts) > 0 {\n\t\topt, opts = head(opts, \",\")\n\n\t\tif k, v := head(opt, \"=\"); k == \"default\" {\n\t\t\tsetOpt.isDefaultExists = true\n\t\t\tsetOpt.defaultValue = v\n\n\t\t\t// convert semicolon-separated default values to csv-separated values for processing in setByForm\n\t\t\tif field.Type.Kind() == reflect.Slice || field.Type.Kind() == reflect.Array {\n\t\t\t\tcfTag := field.Tag.Get(\"collection_format\")\n\t\t\t\tif cfTag == \"\" || cfTag == \"multi\" || cfTag == \"csv\" {\n\t\t\t\t\tsetOpt.defaultValue = strings.ReplaceAll(v, \";\", \",\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn setter.TrySet(value, field, tagValue, setOpt)\n}\n\n// BindUnmarshaler is the interface used to wrap the UnmarshalParam method.\ntype BindUnmarshaler interface {\n\t// UnmarshalParam decodes and assigns a value from an form or query param.\n\tUnmarshalParam(param string) error\n}\n\n// trySetCustom tries to set a custom type value\n// If the value implements the BindUnmarshaler interface, it will be used to set the value, we will return `true`\n// to skip the default value setting.\nfunc trySetCustom(val string, value reflect.Value) (isSet bool, err error) {\n\tswitch v := value.Addr().Interface().(type) {\n\tcase BindUnmarshaler:\n\t\treturn true, v.UnmarshalParam(val)\n\t}\n\treturn false, nil\n}\n\nfunc trySplit(vs []string, field reflect.StructField) (newVs []string, err error) {\n\tcfTag := field.Tag.Get(\"collection_format\")\n\tif cfTag == \"\" || cfTag == \"multi\" {\n\t\treturn vs, nil\n\t}\n\n\tvar sep string\n\tswitch cfTag {\n\tcase \"csv\":\n\t\tsep = \",\"\n\tcase \"ssv\":\n\t\tsep = \" \"\n\tcase \"tsv\":\n\t\tsep = \"\\t\"\n\tcase \"pipes\":\n\t\tsep = \"|\"\n\tdefault:\n\t\treturn vs, fmt.Errorf(\"%s is not supported in the collection_format. (csv, ssv, pipes)\", cfTag)\n\t}\n\n\ttotalLength := 0\n\tfor _, v := range vs {\n\t\ttotalLength += strings.Count(v, sep) + 1\n\t}\n\tnewVs = make([]string, 0, totalLength)\n\tfor _, v := range vs {\n\t\tnewVs = append(newVs, strings.Split(v, sep)...)\n\t}\n\n\treturn newVs, nil\n}\n\nfunc setByForm(value reflect.Value, field reflect.StructField, form map[string][]string, tagValue string, opt setOptions) (isSet bool, err error) {\n\tvs, ok := form[tagValue]\n\tif !ok && !opt.isDefaultExists {\n\t\treturn false, nil\n\t}\n\n\tswitch value.Kind() {\n\tcase reflect.Slice:\n\t\tif !ok {\n\t\t\tvs = []string{opt.defaultValue}\n\n\t\t\t// pre-process the default value for multi if present\n\t\t\tcfTag := field.Tag.Get(\"collection_format\")\n\t\t\tif cfTag == \"\" || cfTag == \"multi\" {\n\t\t\t\tvs = strings.Split(opt.defaultValue, \",\")\n\t\t\t}\n\t\t}\n\n\t\tif ok, err = trySetCustom(vs[0], value); ok {\n\t\t\treturn ok, err\n\t\t}\n\n\t\tif vs, err = trySplit(vs, field); err != nil {\n\t\t\treturn false, err\n\t\t}\n\n\t\treturn true, setSlice(vs, value, field)\n\tcase reflect.Array:\n\t\tif !ok {\n\t\t\tvs = []string{opt.defaultValue}\n\n\t\t\t// pre-process the default value for multi if present\n\t\t\tcfTag := field.Tag.Get(\"collection_format\")\n\t\t\tif cfTag == \"\" || cfTag == \"multi\" {\n\t\t\t\tvs = strings.Split(opt.defaultValue, \",\")\n\t\t\t}\n\t\t}\n\n\t\tif ok, err = trySetCustom(vs[0], value); ok {\n\t\t\treturn ok, err\n\t\t}\n\n\t\tif vs, err = trySplit(vs, field); err != nil {\n\t\t\treturn false, err\n\t\t}\n\n\t\tif len(vs) != value.Len() {\n\t\t\treturn false, fmt.Errorf(\"%q is not valid value for %s\", vs, value.Type().String())\n\t\t}\n\n\t\treturn true, setArray(vs, value, field)\n\tdefault:\n\t\tvar val string\n\t\tif !ok {\n\t\t\tval = opt.defaultValue\n\t\t}\n\n\t\tif len(vs) > 0 {\n\t\t\tval = vs[0]\n\t\t\tif val == \"\" {\n\t\t\t\tval = opt.defaultValue\n\t\t\t}\n\t\t}\n\t\tif ok, err := trySetCustom(val, value); ok {\n\t\t\treturn ok, err\n\t\t}\n\t\treturn true, setWithProperType(val, value, field)\n\t}\n}\n\nfunc setWithProperType(val string, value reflect.Value, field reflect.StructField) error {\n\tswitch value.Kind() {\n\tcase reflect.Int:\n\t\treturn setIntField(val, 0, value)\n\tcase reflect.Int8:\n\t\treturn setIntField(val, 8, value)\n\tcase reflect.Int16:\n\t\treturn setIntField(val, 16, value)\n\tcase reflect.Int32:\n\t\treturn setIntField(val, 32, value)\n\tcase reflect.Int64:\n\t\tswitch value.Interface().(type) {\n\t\tcase time.Duration:\n\t\t\treturn setTimeDuration(val, value)\n\t\t}\n\t\treturn setIntField(val, 64, value)\n\tcase reflect.Uint:\n\t\treturn setUintField(val, 0, value)\n\tcase reflect.Uint8:\n\t\treturn setUintField(val, 8, value)\n\tcase reflect.Uint16:\n\t\treturn setUintField(val, 16, value)\n\tcase reflect.Uint32:\n\t\treturn setUintField(val, 32, value)\n\tcase reflect.Uint64:\n\t\treturn setUintField(val, 64, value)\n\tcase reflect.Bool:\n\t\treturn setBoolField(val, value)\n\tcase reflect.Float32:\n\t\treturn setFloatField(val, 32, value)\n\tcase reflect.Float64:\n\t\treturn setFloatField(val, 64, value)\n\tcase reflect.String:\n\t\tvalue.SetString(val)\n\tcase reflect.Struct:\n\t\tswitch value.Interface().(type) {\n\t\tcase time.Time:\n\t\t\treturn setTimeField(val, field, value)\n\t\tcase multipart.FileHeader:\n\t\t\treturn nil\n\t\t}\n\t\treturn json.API.Unmarshal(bytesconv.StringToBytes(val), value.Addr().Interface())\n\tcase reflect.Map:\n\t\treturn json.API.Unmarshal(bytesconv.StringToBytes(val), value.Addr().Interface())\n\tcase reflect.Ptr:\n\t\tif !value.Elem().IsValid() {\n\t\t\tvalue.Set(reflect.New(value.Type().Elem()))\n\t\t}\n\t\treturn setWithProperType(val, value.Elem(), field)\n\tdefault:\n\t\treturn errUnknownType\n\t}\n\treturn nil\n}\n\nfunc setIntField(val string, bitSize int, field reflect.Value) error {\n\tif val == \"\" {\n\t\tval = \"0\"\n\t}\n\tintVal, err := strconv.ParseInt(val, 10, bitSize)\n\tif err == nil {\n\t\tfield.SetInt(intVal)\n\t}\n\treturn err\n}\n\nfunc setUintField(val string, bitSize int, field reflect.Value) error {\n\tif val == \"\" {\n\t\tval = \"0\"\n\t}\n\tuintVal, err := strconv.ParseUint(val, 10, bitSize)\n\tif err == nil {\n\t\tfield.SetUint(uintVal)\n\t}\n\treturn err\n}\n\nfunc setBoolField(val string, field reflect.Value) error {\n\tif val == \"\" {\n\t\tval = \"false\"\n\t}\n\tboolVal, err := strconv.ParseBool(val)\n\tif err == nil {\n\t\tfield.SetBool(boolVal)\n\t}\n\treturn err\n}\n\nfunc setFloatField(val string, bitSize int, field reflect.Value) error {\n\tif val == \"\" {\n\t\tval = \"0.0\"\n\t}\n\tfloatVal, err := strconv.ParseFloat(val, bitSize)\n\tif err == nil {\n\t\tfield.SetFloat(floatVal)\n\t}\n\treturn err\n}\n\nfunc setTimeField(val string, structField reflect.StructField, value reflect.Value) error {\n\ttimeFormat := structField.Tag.Get(\"time_format\")\n\tif timeFormat == \"\" {\n\t\ttimeFormat = time.RFC3339\n\t}\n\n\tswitch tf := strings.ToLower(timeFormat); tf {\n\tcase \"unix\", \"unixmilli\", \"unixmicro\", \"unixnano\":\n\t\ttv, err := strconv.ParseInt(val, 10, 64)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tvar t time.Time\n\t\tswitch tf {\n\t\tcase \"unix\":\n\t\t\tt = time.Unix(tv, 0)\n\t\tcase \"unixmilli\":\n\t\t\tt = time.UnixMilli(tv)\n\t\tcase \"unixmicro\":\n\t\t\tt = time.UnixMicro(tv)\n\t\tdefault:\n\t\t\tt = time.Unix(0, tv)\n\t\t}\n\n\t\tvalue.Set(reflect.ValueOf(t))\n\t\treturn nil\n\t}\n\n\tif val == \"\" {\n\t\tvalue.Set(reflect.ValueOf(time.Time{}))\n\t\treturn nil\n\t}\n\n\tl := time.Local\n\tif isUTC, _ := strconv.ParseBool(structField.Tag.Get(\"time_utc\")); isUTC {\n\t\tl = time.UTC\n\t}\n\n\tif locTag := structField.Tag.Get(\"time_location\"); locTag != \"\" {\n\t\tloc, err := time.LoadLocation(locTag)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tl = loc\n\t}\n\n\tt, err := time.ParseInLocation(timeFormat, val, l)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvalue.Set(reflect.ValueOf(t))\n\treturn nil\n}\n\nfunc setArray(vals []string, value reflect.Value, field reflect.StructField) error {\n\tfor i, s := range vals {\n\t\terr := setWithProperType(s, value.Index(i), field)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc setSlice(vals []string, value reflect.Value, field reflect.StructField) error {\n\tslice := reflect.MakeSlice(value.Type(), len(vals), len(vals))\n\terr := setArray(vals, slice, field)\n\tif err != nil {\n\t\treturn err\n\t}\n\tvalue.Set(slice)\n\treturn nil\n}\n\nfunc setTimeDuration(val string, value reflect.Value) error {\n\td, err := time.ParseDuration(val)\n\tif err != nil {\n\t\treturn err\n\t}\n\tvalue.Set(reflect.ValueOf(d))\n\treturn nil\n}\n\nfunc head(str, sep string) (head string, tail string) {\n\thead, tail, _ = strings.Cut(str, sep)\n\treturn head, tail\n}\n\nfunc setFormMap(ptr any, form map[string][]string) error {\n\tel := reflect.TypeOf(ptr).Elem()\n\n\tif el.Kind() == reflect.Slice {\n\t\tptrMap, ok := ptr.(map[string][]string)\n\t\tif !ok {\n\t\t\treturn ErrConvertMapStringSlice\n\t\t}\n\t\tfor k, v := range form {\n\t\t\tptrMap[k] = v\n\t\t}\n\n\t\treturn nil\n\t}\n\n\tptrMap, ok := ptr.(map[string]string)\n\tif !ok {\n\t\treturn ErrConvertToMapString\n\t}\n\tfor k, v := range form {\n\t\tptrMap[k] = v[len(v)-1] // pick last\n\t}\n\n\treturn nil\n}\n",
    "source_file": "binding/form_mapping.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage binding\n\nimport (\n\t\"bytes\"\n\t\"encoding/xml\"\n\t\"io\"\n\t\"net/http\"\n)\n\ntype xmlBinding struct{}\n\nfunc (xmlBinding) Name() string {\n\treturn \"xml\"\n}\n\nfunc (xmlBinding) Bind(req *http.Request, obj any) error {\n\treturn decodeXML(req.Body, obj)\n}\n\nfunc (xmlBinding) BindBody(body []byte, obj any) error {\n\treturn decodeXML(bytes.NewReader(body), obj)\n}\n\nfunc decodeXML(r io.Reader, obj any) error {\n\tdecoder := xml.NewDecoder(r)\n\tif err := decoder.Decode(obj); err != nil {\n\t\treturn err\n\t}\n\treturn validate(obj)\n}\n",
    "source_file": "binding/xml.go",
    "chunk_type": "code"
  },
  {
    "content": "package binding\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"reflect\"\n\n\t\"github.com/gin-gonic/gin/internal/bytesconv\"\n)\n\ntype plainBinding struct{}\n\nfunc (plainBinding) Name() string {\n\treturn \"plain\"\n}\n\nfunc (plainBinding) Bind(req *http.Request, obj any) error {\n\tall, err := io.ReadAll(req.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn decodePlain(all, obj)\n}\n\nfunc (plainBinding) BindBody(body []byte, obj any) error {\n\treturn decodePlain(body, obj)\n}\n\nfunc decodePlain(data []byte, obj any) error {\n\tif obj == nil {\n\t\treturn nil\n\t}\n\n\tv := reflect.ValueOf(obj)\n\n\tfor v.Kind() == reflect.Ptr {\n\t\tif v.IsNil() {\n\t\t\treturn nil\n\t\t}\n\t\tv = v.Elem()\n\t}\n\n\tif v.Kind() == reflect.String {\n\t\tv.SetString(bytesconv.BytesToString(data))\n\t\treturn nil\n\t}\n\n\tif _, ok := v.Interface().([]byte); ok {\n\t\tv.SetBytes(data)\n\t\treturn nil\n\t}\n\n\treturn fmt.Errorf(\"type (%T) unknown type\", v)\n}\n",
    "source_file": "binding/plain.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2018 Gin Core Team. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage binding\n\ntype uriBinding struct{}\n\nfunc (uriBinding) Name() string {\n\treturn \"uri\"\n}\n\nfunc (uriBinding) BindUri(m map[string][]string, obj any) error {\n\tif err := mapURI(obj, m); err != nil {\n\t\treturn err\n\t}\n\treturn validate(obj)\n}\n",
    "source_file": "binding/uri.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage binding\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n)\n\nconst defaultMemory = 32 << 20\n\ntype (\n\tformBinding          struct{}\n\tformPostBinding      struct{}\n\tformMultipartBinding struct{}\n)\n\nfunc (formBinding) Name() string {\n\treturn \"form\"\n}\n\nfunc (formBinding) Bind(req *http.Request, obj any) error {\n\tif err := req.ParseForm(); err != nil {\n\t\treturn err\n\t}\n\tif err := req.ParseMultipartForm(defaultMemory); err != nil && !errors.Is(err, http.ErrNotMultipart) {\n\t\treturn err\n\t}\n\tif err := mapForm(obj, req.Form); err != nil {\n\t\treturn err\n\t}\n\treturn validate(obj)\n}\n\nfunc (formPostBinding) Name() string {\n\treturn \"form-urlencoded\"\n}\n\nfunc (formPostBinding) Bind(req *http.Request, obj any) error {\n\tif err := req.ParseForm(); err != nil {\n\t\treturn err\n\t}\n\tif err := mapForm(obj, req.PostForm); err != nil {\n\t\treturn err\n\t}\n\treturn validate(obj)\n}\n\nfunc (formMultipartBinding) Name() string {\n\treturn \"multipart/form-data\"\n}\n\nfunc (formMultipartBinding) Bind(req *http.Request, obj any) error {\n\tif err := req.ParseMultipartForm(defaultMemory); err != nil {\n\t\treturn err\n\t}\n\tif err := mappingByPtr(obj, (*multipartRequest)(req), \"form\"); err != nil {\n\t\treturn err\n\t}\n\n\treturn validate(obj)\n}\n",
    "source_file": "binding/form.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2018 Gin Core Team. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage binding\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"net/http\"\n\n\t\"github.com/goccy/go-yaml\"\n)\n\ntype yamlBinding struct{}\n\nfunc (yamlBinding) Name() string {\n\treturn \"yaml\"\n}\n\nfunc (yamlBinding) Bind(req *http.Request, obj any) error {\n\treturn decodeYAML(req.Body, obj)\n}\n\nfunc (yamlBinding) BindBody(body []byte, obj any) error {\n\treturn decodeYAML(bytes.NewReader(body), obj)\n}\n\nfunc decodeYAML(r io.Reader, obj any) error {\n\tdecoder := yaml.NewDecoder(r)\n\tif err := decoder.Decode(obj); err != nil {\n\t\treturn err\n\t}\n\treturn validate(obj)\n}\n",
    "source_file": "binding/yaml.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2022 Gin Core Team. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage binding\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"net/http\"\n\n\t\"github.com/pelletier/go-toml/v2\"\n)\n\ntype tomlBinding struct{}\n\nfunc (tomlBinding) Name() string {\n\treturn \"toml\"\n}\n\nfunc (tomlBinding) Bind(req *http.Request, obj any) error {\n\treturn decodeToml(req.Body, obj)\n}\n\nfunc (tomlBinding) BindBody(body []byte, obj any) error {\n\treturn decodeToml(bytes.NewReader(body), obj)\n}\n\nfunc decodeToml(r io.Reader, obj any) error {\n\tdecoder := toml.NewDecoder(r)\n\tif err := decoder.Decode(obj); err != nil {\n\t\treturn err\n\t}\n\treturn validate(obj)\n}\n",
    "source_file": "binding/toml.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage binding\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin/codec/json\"\n)\n\n// EnableDecoderUseNumber is used to call the UseNumber method on the JSON\n// Decoder instance. UseNumber causes the Decoder to unmarshal a number into an\n// any as a Number instead of as a float64.\nvar EnableDecoderUseNumber = false\n\n// EnableDecoderDisallowUnknownFields is used to call the DisallowUnknownFields method\n// on the JSON Decoder instance. DisallowUnknownFields causes the Decoder to\n// return an error when the destination is a struct and the input contains object\n// keys which do not match any non-ignored, exported fields in the destination.\nvar EnableDecoderDisallowUnknownFields = false\n\ntype jsonBinding struct{}\n\nfunc (jsonBinding) Name() string {\n\treturn \"json\"\n}\n\nfunc (jsonBinding) Bind(req *http.Request, obj any) error {\n\tif req == nil || req.Body == nil {\n\t\treturn errors.New(\"invalid request\")\n\t}\n\treturn decodeJSON(req.Body, obj)\n}\n\nfunc (jsonBinding) BindBody(body []byte, obj any) error {\n\treturn decodeJSON(bytes.NewReader(body), obj)\n}\n\nfunc decodeJSON(r io.Reader, obj any) error {\n\tdecoder := json.API.NewDecoder(r)\n\tif EnableDecoderUseNumber {\n\t\tdecoder.UseNumber()\n\t}\n\tif EnableDecoderDisallowUnknownFields {\n\t\tdecoder.DisallowUnknownFields()\n\t}\n\tif err := decoder.Decode(obj); err != nil {\n\t\treturn err\n\t}\n\treturn validate(obj)\n}\n",
    "source_file": "binding/json.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2019 Gin Core Team. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage binding\n\nimport (\n\t\"errors\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"reflect\"\n)\n\ntype multipartRequest http.Request\n\nvar _ setter = (*multipartRequest)(nil)\n\nvar (\n\t// ErrMultiFileHeader multipart.FileHeader invalid\n\tErrMultiFileHeader = errors.New(\"unsupported field type for multipart.FileHeader\")\n\n\t// ErrMultiFileHeaderLenInvalid array for []*multipart.FileHeader len invalid\n\tErrMultiFileHeaderLenInvalid = errors.New(\"unsupported len of array for []*multipart.FileHeader\")\n)\n\n// TrySet tries to set a value by the multipart request with the binding a form file\nfunc (r *multipartRequest) TrySet(value reflect.Value, field reflect.StructField, key string, opt setOptions) (bool, error) {\n\tif files := r.MultipartForm.File[key]; len(files) != 0 {\n\t\treturn setByMultipartFormFile(value, field, files)\n\t}\n\n\treturn setByForm(value, field, r.MultipartForm.Value, key, opt)\n}\n\nfunc setByMultipartFormFile(value reflect.Value, field reflect.StructField, files []*multipart.FileHeader) (isSet bool, err error) {\n\tswitch value.Kind() {\n\tcase reflect.Ptr:\n\t\tswitch value.Interface().(type) {\n\t\tcase *multipart.FileHeader:\n\t\t\tvalue.Set(reflect.ValueOf(files[0]))\n\t\t\treturn true, nil\n\t\t}\n\tcase reflect.Struct:\n\t\tswitch value.Interface().(type) {\n\t\tcase multipart.FileHeader:\n\t\t\tvalue.Set(reflect.ValueOf(*files[0]))\n\t\t\treturn true, nil\n\t\t}\n\tcase reflect.Slice:\n\t\tslice := reflect.MakeSlice(value.Type(), len(files), len(files))\n\t\tisSet, err = setArrayOfMultipartFormFiles(slice, field, files)\n\t\tif err != nil || !isSet {\n\t\t\treturn isSet, err\n\t\t}\n\t\tvalue.Set(slice)\n\t\treturn true, nil\n\tcase reflect.Array:\n\t\treturn setArrayOfMultipartFormFiles(value, field, files)\n\t}\n\treturn false, ErrMultiFileHeader\n}\n\nfunc setArrayOfMultipartFormFiles(value reflect.Value, field reflect.StructField, files []*multipart.FileHeader) (isSet bool, err error) {\n\tif value.Len() != len(files) {\n\t\treturn false, ErrMultiFileHeaderLenInvalid\n\t}\n\tfor i := range files {\n\t\tset, err := setByMultipartFormFile(value.Index(i), field, files[i:i+1])\n\t\tif err != nil || !set {\n\t\t\treturn set, err\n\t\t}\n\t}\n\treturn true, nil\n}\n",
    "source_file": "binding/multipart_form_mapping.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\n//go:build !nomsgpack\n\npackage binding\n\nimport \"net/http\"\n\n// Content-Type MIME of the most common data formats.\nconst (\n\tMIMEJSON              = \"application/json\"\n\tMIMEHTML              = \"text/html\"\n\tMIMEXML               = \"application/xml\"\n\tMIMEXML2              = \"text/xml\"\n\tMIMEPlain             = \"text/plain\"\n\tMIMEPOSTForm          = \"application/x-www-form-urlencoded\"\n\tMIMEMultipartPOSTForm = \"multipart/form-data\"\n\tMIMEPROTOBUF          = \"application/x-protobuf\"\n\tMIMEMSGPACK           = \"application/x-msgpack\"\n\tMIMEMSGPACK2          = \"application/msgpack\"\n\tMIMEYAML              = \"application/x-yaml\"\n\tMIMEYAML2             = \"application/yaml\"\n\tMIMETOML              = \"application/toml\"\n)\n\n// Binding describes the interface which needs to be implemented for binding the\n// data present in the request such as JSON request body, query parameters or\n// the form POST.\ntype Binding interface {\n\tName() string\n\tBind(*http.Request, any) error\n}\n\n// BindingBody adds BindBody method to Binding. BindBody is similar with Bind,\n// but it reads the body from supplied bytes instead of req.Body.\ntype BindingBody interface {\n\tBinding\n\tBindBody([]byte, any) error\n}\n\n// BindingUri adds BindUri method to Binding. BindUri is similar with Bind,\n// but it reads the Params.\ntype BindingUri interface {\n\tName() string\n\tBindUri(map[string][]string, any) error\n}\n\n// StructValidator is the minimal interface which needs to be implemented in\n// order for it to be used as the validator engine for ensuring the correctness\n// of the request. Gin provides a default implementation for this using\n// https://github.com/go-playground/validator/tree/v10.6.1.\ntype StructValidator interface {\n\t// ValidateStruct can receive any kind of type and it should never panic, even if the configuration is not right.\n\t// If the received type is a slice|array, the validation should be performed travel on every element.\n\t// If the received type is not a struct or slice|array, any validation should be skipped and nil must be returned.\n\t// If the received type is a struct or pointer to a struct, the validation should be performed.\n\t// If the struct is not valid or the validation itself fails, a descriptive error should be returned.\n\t// Otherwise nil must be returned.\n\tValidateStruct(any) error\n\n\t// Engine returns the underlying validator engine which powers the\n\t// StructValidator implementation.\n\tEngine() any\n}\n\n// Validator is the default validator which implements the StructValidator\n// interface. It uses https://github.com/go-playground/validator/tree/v10.6.1\n// under the hood.\nvar Validator StructValidator = &defaultValidator{}\n\n// These implement the Binding interface and can be used to bind the data\n// present in the request to struct instances.\nvar (\n\tJSON          BindingBody = jsonBinding{}\n\tXML           BindingBody = xmlBinding{}\n\tForm          Binding     = formBinding{}\n\tQuery         Binding     = queryBinding{}\n\tFormPost      Binding     = formPostBinding{}\n\tFormMultipart Binding     = formMultipartBinding{}\n\tProtoBuf      BindingBody = protobufBinding{}\n\tMsgPack       BindingBody = msgpackBinding{}\n\tYAML          BindingBody = yamlBinding{}\n\tUri           BindingUri  = uriBinding{}\n\tHeader        Binding     = headerBinding{}\n\tPlain         BindingBody = plainBinding{}\n\tTOML          BindingBody = tomlBinding{}\n)\n\n// Default returns the appropriate Binding instance based on the HTTP method\n// and the content type.\nfunc Default(method, contentType string) Binding {\n\tif method == http.MethodGet {\n\t\treturn Form\n\t}\n\n\tswitch contentType {\n\tcase MIMEJSON:\n\t\treturn JSON\n\tcase MIMEXML, MIMEXML2:\n\t\treturn XML\n\tcase MIMEPROTOBUF:\n\t\treturn ProtoBuf\n\tcase MIMEMSGPACK, MIMEMSGPACK2:\n\t\treturn MsgPack\n\tcase MIMEYAML, MIMEYAML2:\n\t\treturn YAML\n\tcase MIMETOML:\n\t\treturn TOML\n\tcase MIMEMultipartPOSTForm:\n\t\treturn FormMultipart\n\tdefault: // case MIMEPOSTForm:\n\t\treturn Form\n\t}\n}\n\nfunc validate(obj any) error {\n\tif Validator == nil {\n\t\treturn nil\n\t}\n\treturn Validator.ValidateStruct(obj)\n}\n",
    "source_file": "binding/binding.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage binding\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n\n\t\"google.golang.org/protobuf/proto\"\n)\n\ntype protobufBinding struct{}\n\nfunc (protobufBinding) Name() string {\n\treturn \"protobuf\"\n}\n\nfunc (b protobufBinding) Bind(req *http.Request, obj any) error {\n\tbuf, err := io.ReadAll(req.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn b.BindBody(buf, obj)\n}\n\nfunc (protobufBinding) BindBody(body []byte, obj any) error {\n\tmsg, ok := obj.(proto.Message)\n\tif !ok {\n\t\treturn errors.New(\"obj is not ProtoMessage\")\n\t}\n\tif err := proto.Unmarshal(body, msg); err != nil {\n\t\treturn err\n\t}\n\t// Here it's same to return validate(obj), but until now we can't add\n\t// `binding:\"\"` to the struct which automatically generate by gen-proto\n\treturn nil\n\t// return validate(obj)\n}\n",
    "source_file": "binding/protobuf.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2017 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage binding\n\nimport (\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/go-playground/validator/v10\"\n)\n\ntype defaultValidator struct {\n\tonce     sync.Once\n\tvalidate *validator.Validate\n}\n\ntype SliceValidationError []error\n\n// Error concatenates all error elements in SliceValidationError into a single string separated by \\n.\nfunc (err SliceValidationError) Error() string {\n\tif len(err) == 0 {\n\t\treturn \"\"\n\t}\n\n\tvar b strings.Builder\n\tfor i := 0; i < len(err); i++ {\n\t\tif err[i] != nil {\n\t\t\tif b.Len() > 0 {\n\t\t\t\tb.WriteString(\"\\n\")\n\t\t\t}\n\t\t\tb.WriteString(\"[\" + strconv.Itoa(i) + \"]: \" + err[i].Error())\n\t\t}\n\t}\n\treturn b.String()\n}\n\nvar _ StructValidator = (*defaultValidator)(nil)\n\n// ValidateStruct receives any kind of type, but only performed struct or pointer to struct type.\nfunc (v *defaultValidator) ValidateStruct(obj any) error {\n\tif obj == nil {\n\t\treturn nil\n\t}\n\n\tvalue := reflect.ValueOf(obj)\n\tswitch value.Kind() {\n\tcase reflect.Ptr:\n\t\tif value.Elem().Kind() != reflect.Struct {\n\t\t\treturn v.ValidateStruct(value.Elem().Interface())\n\t\t}\n\t\treturn v.validateStruct(obj)\n\tcase reflect.Struct:\n\t\treturn v.validateStruct(obj)\n\tcase reflect.Slice, reflect.Array:\n\t\tcount := value.Len()\n\t\tvalidateRet := make(SliceValidationError, 0)\n\t\tfor i := 0; i < count; i++ {\n\t\t\tif err := v.ValidateStruct(value.Index(i).Interface()); err != nil {\n\t\t\t\tvalidateRet = append(validateRet, err)\n\t\t\t}\n\t\t}\n\t\tif len(validateRet) == 0 {\n\t\t\treturn nil\n\t\t}\n\t\treturn validateRet\n\tdefault:\n\t\treturn nil\n\t}\n}\n\n// validateStruct receives struct type\nfunc (v *defaultValidator) validateStruct(obj any) error {\n\tv.lazyinit()\n\treturn v.validate.Struct(obj)\n}\n\n// Engine returns the underlying validator engine which powers the default\n// Validator instance. This is useful if you want to register custom validations\n// or struct level validations. See validator GoDoc for more info -\n// https://pkg.go.dev/github.com/go-playground/validator/v10\nfunc (v *defaultValidator) Engine() any {\n\tv.lazyinit()\n\treturn v.validate\n}\n\nfunc (v *defaultValidator) lazyinit() {\n\tv.once.Do(func() {\n\t\tv.validate = validator.New()\n\t\tv.validate.SetTagName(\"binding\")\n\t})\n}\n",
    "source_file": "binding/default_validator.go",
    "chunk_type": "code"
  },
  {
    "content": "# Gin Examples\n\n\u26a0\ufe0f  **NOTICE:** All gin examples have been moved as standalone repository to [here](https://github.com/gin-gonic/examples).",
    "source_file": "examples/README.md",
    "chunk_type": "doc"
  },
  {
    "content": "// Copyright 2023 Gin Core Team. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage bytesconv\n\nimport (\n\t\"unsafe\"\n)\n\n// StringToBytes converts string to byte slice without a memory allocation.\n// For more details, see https://github.com/golang/go/issues/53003#issuecomment-1140276077.\nfunc StringToBytes(s string) []byte {\n\treturn unsafe.Slice(unsafe.StringData(s), len(s))\n}\n\n// BytesToString converts byte slice to string without a memory allocation.\n// For more details, see https://github.com/golang/go/issues/53003#issuecomment-1140276077.\nfunc BytesToString(b []byte) string {\n\treturn unsafe.String(unsafe.SliceData(b), len(b))\n}\n",
    "source_file": "internal/bytesconv/bytesconv.go",
    "chunk_type": "code"
  },
  {
    "content": "package fs\n\nimport (\n\t\"io/fs\"\n\t\"net/http\"\n)\n\n// FileSystem implements an [fs.FS].\ntype FileSystem struct {\n\thttp.FileSystem\n}\n\n// Open passes `Open` to the upstream implementation and return an [fs.File].\nfunc (o FileSystem) Open(name string) (fs.File, error) {\n\tf, err := o.FileSystem.Open(name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn fs.File(f), nil\n}\n",
    "source_file": "internal/fs/fs.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2025 Gin Core Team. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\n//go:build sonic && (linux || windows || darwin)\n\npackage json\n\nimport (\n\t\"io\"\n\n\t\"github.com/bytedance/sonic\"\n)\n\n// Package indicates what library is being used for JSON encoding.\nconst Package = \"github.com/bytedance/sonic\"\n\nfunc init() {\n\tAPI = sonicApi{}\n}\n\nvar json = sonic.ConfigStd\n\ntype sonicApi struct{}\n\nfunc (j sonicApi) Marshal(v any) ([]byte, error) {\n\treturn json.Marshal(v)\n}\n\nfunc (j sonicApi) Unmarshal(data []byte, v any) error {\n\treturn json.Unmarshal(data, v)\n}\n\nfunc (j sonicApi) MarshalIndent(v any, prefix, indent string) ([]byte, error) {\n\treturn json.MarshalIndent(v, prefix, indent)\n}\n\nfunc (j sonicApi) NewEncoder(writer io.Writer) Encoder {\n\treturn json.NewEncoder(writer)\n}\n\nfunc (j sonicApi) NewDecoder(reader io.Reader) Decoder {\n\treturn json.NewDecoder(reader)\n}\n",
    "source_file": "codec/json/sonic.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2025 Gin Core Team. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\n//go:build jsoniter\n\npackage json\n\nimport (\n\t\"io\"\n\n\tjsoniter \"github.com/json-iterator/go\"\n)\n\n// Package indicates what library is being used for JSON encoding.\nconst Package = \"github.com/json-iterator/go\"\n\nfunc init() {\n\tAPI = jsoniterApi{}\n}\n\nvar json = jsoniter.ConfigCompatibleWithStandardLibrary\n\ntype jsoniterApi struct{}\n\nfunc (j jsoniterApi) Marshal(v any) ([]byte, error) {\n\treturn json.Marshal(v)\n}\n\nfunc (j jsoniterApi) Unmarshal(data []byte, v any) error {\n\treturn json.Unmarshal(data, v)\n}\n\nfunc (j jsoniterApi) MarshalIndent(v any, prefix, indent string) ([]byte, error) {\n\treturn json.MarshalIndent(v, prefix, indent)\n}\n\nfunc (j jsoniterApi) NewEncoder(writer io.Writer) Encoder {\n\treturn json.NewEncoder(writer)\n}\n\nfunc (j jsoniterApi) NewDecoder(reader io.Reader) Decoder {\n\treturn json.NewDecoder(reader)\n}\n",
    "source_file": "codec/json/jsoniter.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2025 Gin Core Team. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage json\n\nimport \"io\"\n\n// API the json codec in use.\nvar API Core\n\n// Core the api for json codec.\ntype Core interface {\n\tMarshal(v any) ([]byte, error)\n\tUnmarshal(data []byte, v any) error\n\tMarshalIndent(v any, prefix, indent string) ([]byte, error)\n\tNewEncoder(writer io.Writer) Encoder\n\tNewDecoder(reader io.Reader) Decoder\n}\n\n// Encoder an interface writes JSON values to an output stream.\ntype Encoder interface {\n\t// SetEscapeHTML specifies whether problematic HTML characters\n\t// should be escaped inside JSON quoted strings.\n\t// The default behavior is to escape &, <, and > to \\u0026, \\u003c, and \\u003e\n\t// to avoid certain safety problems that can arise when embedding JSON in HTML.\n\t//\n\t// In non-HTML settings where the escaping interferes with the readability\n\t// of the output, SetEscapeHTML(false) disables this behavior.\n\tSetEscapeHTML(on bool)\n\n\t// Encode writes the JSON encoding of v to the stream,\n\t// followed by a newline character.\n\t//\n\t// See the documentation for Marshal for details about the\n\t// conversion of Go values to JSON.\n\tEncode(v any) error\n}\n\n// Decoder an interface reads and decodes JSON values from an input stream.\ntype Decoder interface {\n\t// UseNumber causes the Decoder to unmarshal a number into an any as a\n\t// Number instead of as a float64.\n\tUseNumber()\n\n\t// DisallowUnknownFields causes the Decoder to return an error when the destination\n\t// is a struct and the input contains object keys which do not match any\n\t// non-ignored, exported fields in the destination.\n\tDisallowUnknownFields()\n\n\t// Decode reads the next JSON-encoded value from its\n\t// input and stores it in the value pointed to by v.\n\t//\n\t// See the documentation for Unmarshal for details about\n\t// the conversion of JSON into a Go value.\n\tDecode(v any) error\n}\n",
    "source_file": "codec/json/api.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2025 Gin Core Team. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\n//go:build go_json\n\npackage json\n\nimport (\n\t\"io\"\n\n\t\"github.com/goccy/go-json\"\n)\n\n// Package indicates what library is being used for JSON encoding.\nconst Package = \"github.com/goccy/go-json\"\n\nfunc init() {\n\tAPI = gojsonApi{}\n}\n\ntype gojsonApi struct{}\n\nfunc (j gojsonApi) Marshal(v any) ([]byte, error) {\n\treturn json.Marshal(v)\n}\n\nfunc (j gojsonApi) Unmarshal(data []byte, v any) error {\n\treturn json.Unmarshal(data, v)\n}\n\nfunc (j gojsonApi) MarshalIndent(v any, prefix, indent string) ([]byte, error) {\n\treturn json.MarshalIndent(v, prefix, indent)\n}\n\nfunc (j gojsonApi) NewEncoder(writer io.Writer) Encoder {\n\treturn json.NewEncoder(writer)\n}\n\nfunc (j gojsonApi) NewDecoder(reader io.Reader) Decoder {\n\treturn json.NewDecoder(reader)\n}\n",
    "source_file": "codec/json/go_json.go",
    "chunk_type": "code"
  },
  {
    "content": "// Copyright 2025 Gin Core Team. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\n//go:build !jsoniter && !go_json && !(sonic && (linux || windows || darwin))\n\npackage json\n\nimport (\n\t\"encoding/json\"\n\t\"io\"\n)\n\n// Package indicates what library is being used for JSON encoding.\nconst Package = \"encoding/json\"\n\nfunc init() {\n\tAPI = jsonApi{}\n}\n\ntype jsonApi struct{}\n\nfunc (j jsonApi) Marshal(v any) ([]byte, error) {\n\treturn json.Marshal(v)\n}\n\nfunc (j jsonApi) Unmarshal(data []byte, v any) error {\n\treturn json.Unmarshal(data, v)\n}\n\nfunc (j jsonApi) MarshalIndent(v any, prefix, indent string) ([]byte, error) {\n\treturn json.MarshalIndent(v, prefix, indent)\n}\n\nfunc (j jsonApi) NewEncoder(writer io.Writer) Encoder {\n\treturn json.NewEncoder(writer)\n}\n\nfunc (j jsonApi) NewDecoder(reader io.Reader) Decoder {\n\treturn json.NewDecoder(reader)\n}\n",
    "source_file": "codec/json/json.go",
    "chunk_type": "code"
  }
]