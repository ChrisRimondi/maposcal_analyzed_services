{
  "chunks": [
    {
      "content": "Copyright \u00a9 2017-present, [Encode OSS Ltd](https://www.encode.io/).\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n* Neither the name of the copyright holder nor the names of its\n  contributors may be used to endorse or promote products derived from\n  this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.",
      "source_file": "LICENSE.md",
      "chunk_type": "doc"
    },
    {
      "content": "-e .[standard]\n\n# Core dependencies\nh11==0.16.0\n\n# Explicit optionals\na2wsgi==1.10.8\nwsproto==1.2.0\nwebsockets==13.1\n\n# Packaging\nbuild==1.2.2.post1\ntwine==6.1.0\n\n# Testing\nruff==0.11.9\npytest==8.3.5\npytest-mock==3.14.0\npytest-xdist[psutil]==3.6.1\nmypy==1.15.0\ntypes-click==7.1.8\ntypes-pyyaml==6.0.12.20250402\ntrustme==1.2.1\ncryptography==44.0.3\ncoverage==7.8.0\ncoverage-conditional-plugin==0.9.0\ncoverage-enable-subprocess==1.0\nhttpx==0.28.1\n\n# Documentation\nmkdocs==1.6.1\nmkdocs-material==9.6.13\nmkdocstrings-python==1.16.12\nmkdocs-llmstxt==0.2.0\n",
      "source_file": "requirements.txt",
      "chunk_type": "doc"
    },
    {
      "content": "# This CITATION.cff file was generated with cffinit.\n# Visit https://bit.ly/cffinit to generate yours today!\n\ncff-version: 1.2.0\ntitle: Uvicorn\nmessage: >-\n  If you use this software, please cite it using the\n  metadata from this file.\ntype: software\nauthors:\n  - given-names: Marcelo\n    family-names: Trylesinski\n    email: marcelotryle@gmail.com\n  - given-names: Tom\n    family-names: Christie\n    email: tom@tomchristie.com\nrepository-code: 'https://github.com/encode/uvicorn'\nurl: 'https://www.uvicorn.org/'\nabstract: Uvicorn is an ASGI web server implementation for Python.\nkeywords:\n  - asgi\n  - server\nlicense: BSD-3-Clause\n",
      "source_file": "CITATION.cff",
      "chunk_type": "unknown"
    },
    {
      "content": "<p align=\"center\">\n  <img width=\"320\" height=\"320\" src=\"https://raw.githubusercontent.com/tomchristie/uvicorn/master/docs/uvicorn.png\" alt='uvicorn'>\n</p>\n\n<p align=\"center\">\n<em>An ASGI web server, for Python.</em>\n</p>\n\n---\n\n[![Build Status](https://github.com/encode/uvicorn/workflows/Test%20Suite/badge.svg)](https://github.com/encode/uvicorn/actions)\n[![Package version](https://badge.fury.io/py/uvicorn.svg)](https://pypi.python.org/pypi/uvicorn)\n[![Supported Python Version](https://img.shields.io/pypi/pyversions/uvicorn.svg?color=%2334D058)](https://pypi.org/project/uvicorn)\n\n**Documentation**: [https://www.uvicorn.org](https://www.uvicorn.org)\n\n---\n\nUvicorn is an ASGI web server implementation for Python.\n\nUntil recently Python has lacked a minimal low-level server/application interface for\nasync frameworks. The [ASGI specification][asgi] fills this gap, and means we're now able to\nstart building a common set of tooling usable across all async frameworks.\n\nUvicorn supports HTTP/1.1 and WebSockets.\n",
      "source_file": "README.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Quickstart\n\nInstall using `pip`:\n\n```shell\n$ pip install uvicorn\n```\n\nThis will install uvicorn with minimal (pure Python) dependencies.\n\n```shell\n$ pip install 'uvicorn[standard]'\n```\n\nThis will install uvicorn with \"Cython-based\" dependencies (where possible) and other \"optional extras\".\n\nIn this context, \"Cython-based\" means the following:\n\n- the event loop `uvloop` will be installed and used if possible.\n- the http protocol will be handled by `httptools` if possible.\n\nMoreover, \"optional extras\" means that:\n\n- the websocket protocol will be handled by `websockets` (should you want to use `wsproto` you'd need to install it manually) if possible.\n- the `--reload` flag in development mode will use `watchfiles`.\n- windows users will have `colorama` installed for the colored logs.\n- `python-dotenv` will be installed should you want to use the `--env-file` option.\n- `PyYAML` will be installed to allow you to provide a `.yaml` file to `--log-config`, if desired.\n\nCreate an application, in `example.py`:\n\n```python\nasync def app(scope, receive, send):\n    assert scope['type'] == 'http'\n\n    await send({\n        'type': 'http.response.start',\n        'status': 200,\n        'headers': [\n            (b'content-type', b'text/plain'),\n        ],\n    })\n    await send({\n        'type': 'http.response.body',\n        'body': b'Hello, world!',\n    })\n```\n\nRun the server:\n\n```shell\n$ uvicorn example:app\n```\n\n---\n",
      "source_file": "README.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Why ASGI?\n\nMost well established Python Web frameworks started out as WSGI-based frameworks.\n\nWSGI applications are a single, synchronous callable that takes a request and returns a response.\nThis doesn\u2019t allow for long-lived connections, like you get with long-poll HTTP or WebSocket connections,\nwhich WSGI doesn't support well.\n\nHaving an async concurrency model also allows for options such as lightweight background tasks,\nand can be less of a limiting factor for endpoints that have long periods being blocked on network\nI/O such as dealing with slow HTTP requests.\n\n---\n",
      "source_file": "README.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Alternative ASGI servers\n\nA strength of the ASGI protocol is that it decouples the server implementation\nfrom the application framework. This allows for an ecosystem of interoperating\nwebservers and application frameworks.\n",
      "source_file": "README.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Daphne\n\nThe first ASGI server implementation, originally developed to power Django Channels, is [the Daphne webserver][daphne].\n\nIt is run widely in production, and supports HTTP/1.1, HTTP/2, and WebSockets.\n\nAny of the example applications given here can equally well be run using `daphne` instead.\n\n```\n$ pip install daphne\n$ daphne app:App\n```\n",
      "source_file": "README.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Hypercorn\n\n[Hypercorn][hypercorn] was initially part of the Quart web framework, before\nbeing separated out into a standalone ASGI server.\n\nHypercorn supports HTTP/1.1, HTTP/2, and WebSockets.\n\nIt also supports [the excellent `trio` async framework][trio], as an alternative to `asyncio`.\n\n```\n$ pip install hypercorn\n$ hypercorn app:App\n```\n",
      "source_file": "README.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Mangum\n\n[Mangum][mangum] is an adapter for using ASGI applications with AWS Lambda & API Gateway.\n",
      "source_file": "README.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Granian\n\n[Granian][granian] is an ASGI compatible Rust HTTP server which supports HTTP/2, TLS and WebSockets.\n\n---\n\n<p align=\"center\"><i>Uvicorn is <a href=\"https://github.com/encode/uvicorn/blob/master/LICENSE.md\">BSD licensed</a> code.<br/>Designed & crafted with care.</i><br/>&mdash; \ud83e\udd84  &mdash;</p>\n\n[asgi]: https://asgi.readthedocs.io/en/latest/\n[daphne]: https://github.com/django/daphne\n[hypercorn]: https://github.com/pgjones/hypercorn\n[trio]: https://trio.readthedocs.io\n[mangum]: https://github.com/jordaneremieff/mangum\n[granian]: https://github.com/emmett-framework/granian",
      "source_file": "README.md",
      "chunk_type": "doc"
    },
    {
      "content": "# \u2728 Sponsor Starlette & Uvicorn \u2728\n\nThank you for your interest in sponsoring Starlette and Uvicorn! \u2764\ufe0f\n\nYour support *directly* contributes to the ongoing development, maintenance, and long-term sustainability of both projects.\n\n<div style=\"display: flex; justify-content: center; gap: 4rem; margin: 2rem 0; text-align: center;\">\n    <div style=\"padding: 1rem;\">\n        <h3 style=\"color: #6e5494; font-size: 2em; margin-bottom: 0.5rem;\">67M+</h3>\n        <p>Starlette Downloads/Month</p>\n    </div>\n    <div style=\"padding: 1rem;\">\n        <h3 style=\"color: #6e5494; font-size: 2em; margin-bottom: 0.5rem;\">57M+</h3>\n        <p>Uvicorn Downloads/Month</p>\n    </div>\n    <div style=\"padding: 1rem;\">\n        <h3 style=\"color: #6e5494; font-size: 2em; margin-bottom: 0.5rem;\">19K+</h3>\n        <p>Combined GitHub Stars</p>\n    </div>\n</div>\n",
      "source_file": "docs/sponsorship.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Why Sponsor?\n\nWhile Starlette and Uvicorn are part of the [Encode](https://github.com/encode) organization,\nthey have been primarily maintained by [**Marcelo Trylesinski (Kludex)**](https://github.com/Kludex)\nfor the past several years. His dedication and consistent work have been instrumental in keeping\nthese projects robust, secure, and up-to-date.\n\nThis sponsorship page was created to give the community an opportunity to support Marcelo's continued\nefforts in maintaining and improving both projects. Your sponsorship directly enables him to\ndedicate more time and resources to maintaining and improving these essential tools:\n\n- [x] **Active Development:** Developing new features, enhancing existing ones, and\n  keeping both projects aligned with the latest developments in the Python and ASGI ecosystems. \ud83d\udcbb\n- [x] **Community Support:** Providing better support, addressing user issues,\n  and cultivating a welcoming environment for contributors. \ud83e\udd1d\n- [x] **Long-Term Stability:** Ensuring the long-term viability of both projects through strategic\n  planning and addressing technical debt. \ud83c\udf33\n- [x] **Bug Fixes & Maintenance:** Providing prompt attention to bug reports and\n  general maintenance to keep the projects reliable. \ud83d\udd28\n- [x] **Security:** Ensuring robust security practices, conducting regular security audits, and\n  promptly addressing vulnerabilities to protect millions of production deployments. \ud83d\udd12\n- [x] **Documentation:** Creating comprehensive guides, tutorials, and examples to help users of all skill levels. \ud83d\udcd6\n",
      "source_file": "docs/sponsorship.md",
      "chunk_type": "doc"
    },
    {
      "content": "## How Sponsorship Works\n\nWe currently manage sponsorships *exclusively* through **GitHub Sponsors**. This platform integrates seamlessly with the GitHub ecosystem, making it easy for organizations to contribute.\n\n<div style=\"text-align: center; padding: 2rem; margin: 2rem 0; background: linear-gradient(135deg, #6e5494, #24292e); border-radius: 10px; color: white;\">\n    <h2 style=\"color: white; margin-bottom: 1rem;\">\ud83c\udf1f Become a Sponsor Today! \ud83c\udf1f</h2>\n    <p style=\"margin-bottom: 1.5rem; font-size: 1.1em;\">Your support helps keep Starlette and Uvicorn growing stronger!</p>\n    <a href=\"https://github.com/sponsors/Kludex\"\n       style=\"display: inline-block; padding: 1rem 2rem; background-color: #238636; color: white; text-decoration: none; border-radius: 6px; font-size: 1.2em; font-weight: bold; transition: all 0.3s ease-in-out;\"\n       onmouseover=\"this.style.backgroundColor='#2ea043';this.style.transform='translateY(-2px)'\"\n       onmouseout=\"this.style.backgroundColor='#238636';this.style.transform='translateY(0)'\">\n        \u2764\ufe0f Sponsor on GitHub\n    </a>\n</div>\n",
      "source_file": "docs/sponsorship.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Sponsorship Tiers \ud83c\udf81\n\n<div style=\"display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1.5rem; margin: 2rem 0;\">\n    <div style=\"padding: 1.5rem; border: 1px solid #e1e4e8; border-radius: 6px; background: #fff; display: flex; flex-direction: column;\">\n        <h3 style=\"color: #cd7f32;\">\ud83e\udd49 Bronze Sponsor</h3>\n        <div style=\"font-size: 1.5em; margin: 1rem 0;\">$100<span style=\"font-size: 0.6em;\">/month</span></div>\n        <ul style=\"list-style: none; padding: 0; margin-bottom: 1rem; min-height: 90px;\">\n            <li>\u2713 Company name on Sponsors page</li>\n            <li>\u2713 Small logo with link</li>\n            <li>\u2713 Our eternal gratitude</li>\n        </ul>\n        <div style=\"text-align: center; margin-top: auto;\">\n            <a href=\"https://github.com/sponsors/Kludex\" style=\"display: inline-block; padding: 0.5rem 1rem; background-color: #cd7f32; color: white; text-decoration: none; border-radius: 6px; font-weight: bold; transition: opacity 0.2s;\" onmouseover=\"this.style.opacity='0.8'\" onmouseout=\"this.style.opacity='1'\">\n                Become a Bronze Sponsor\n            </a>\n        </div>\n    </div>\n    <div style=\"padding: 1.5rem; border: 1px solid #e1e4e8; border-radius: 6px; background: #fff; display: flex; flex-direction: column;\">\n        <h3 style=\"color: #c0c0c0;\">\ud83e\udd48 Silver Sponsor</h3>\n        <div style=\"font-size: 1.5em; margin: 1rem 0;\">$250<span style=\"font-size: 0.6em;\">/month</span></div>\n        <ul style=\"list-style: none; padding: 0; margin-bottom: 1rem; min-height: 90px;\">\n            <li>\u2713 All Bronze benefits</li>\n            <li>\u2713 Medium-sized logo</li>\n            <li>\u2713 Release notes mention</li>\n        </ul>\n        <div style=\"text-align: center; margin-top: auto;\">\n            <a href=\"https://github.com/sponsors/Kludex\" style=\"display: inline-block; padding: 0.5rem 1rem; background-color: #c0c0c0; color: white; text-decoration: none; border-radius: 6px; font-weight: bold; transition: opacity 0.2s;\" onmouseover=\"this.style.opacity='0.8'\" onmouseout=\"this.style.opacity='1'\">\n                Become a Silver Sponsor\n            </a>\n        </div>\n    </div>\n    <div style=\"padding: 1.5rem; border: 1px solid #e1e4e8; border-radius: 6px; background: #fff; position: relative; overflow: hidden; display: flex; flex-direction: column;\">\n        <div style=\"position: absolute; top: 10px; right: -25px; background: #238636; color: white; padding: 5px 30px; transform: rotate(45deg);\">\n            Popular\n        </div>\n        <h3 style=\"color: #ffd700;\">\ud83e\udd47 Gold Sponsor</h3>\n        <div style=\"font-size: 1.5em; margin: 1rem 0;\">$500<span style=\"font-size: 0.6em;\">/month</span></div>\n        <ul style=\"list-style: none; padding: 0; margin-bottom: 1rem; min-height: 90px;\">\n            <li>\u2713 All Silver benefits</li>\n            <li>\u2713 Large logo on main pages</li>\n            <li>\u2713 Priority support</li>\n        </ul>\n        <div style=\"text-align: center; margin-top: auto;\">\n            <a href=\"https://github.com/sponsors/Kludex\" style=\"display: inline-block; padding: 0.5rem 1rem; background-color: #ffd700; color: black; text-decoration: none; border-radius: 6px; font-weight: bold; transition: opacity 0.2s;\" onmouseover=\"this.style.opacity='0.8'\" onmouseout=\"this.style.opacity='1'\">\n                Become a Gold Sponsor\n            </a>\n        </div>\n    </div>\n</div>\n\n<div style=\"text-align: center; margin: 2rem 0;\">\n    <h3>\ud83e\udd1d Custom Sponsor</h3>\n    <p>Looking for something different? <a href=\"mailto:marcelotryle@gmail.com\">Contact us</a> to discuss custom sponsorship options!</p>\n</div>\n",
      "source_file": "docs/sponsorship.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Current Sponsors\n\n**Thank you to our generous sponsors!** \ud83d\ude4f\n\n<div style=\"display: flex; flex-direction: column; gap: 3rem; margin: 2rem 0;\">\n    <div>\n        <h3 style=\"text-align: center; color: #ffd700; margin-bottom: 1.5rem;\">\ud83c\udfc6 Gold Sponsors</h3>\n        <div style=\"display: flex; flex-wrap: wrap; justify-content: center; gap: 2rem; align-items: center;\">\n            <a href=\"https://fastapi.tiangolo.com\" style=\"text-decoration: none;\">\n                <div style=\"width: 200px; background: #f6f8fa; border-radius: 8px; padding: 1rem; text-align: center;\">\n                    <div style=\"height: 100px; display: flex; align-items: center; justify-content: center; margin-bottom: 0.75rem;\">\n                        <img src=\"https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png\" alt=\"FastAPI\" style=\"max-width: 100%; max-height: 100%; object-fit: contain;\">\n                    </div>\n                    <p style=\"margin: 0; color: #57606a; font-size: 0.9em;\">Modern, fast web framework for building APIs with Python 3.8+</p>\n                </div>\n            </a>\n        </div>\n    </div>\n\n    <div>\n        <h3 style=\"text-align: center; color: #c0c0c0; margin-bottom: 1.5rem;\">\ud83e\udd48 Silver Sponsors</h3>\n        <div style=\"display: flex; flex-wrap: wrap; justify-content: center; gap: 2rem; align-items: center;\">\n            <!-- Add Silver Sponsors here -->\n        </div>\n    </div>\n\n    <div>\n        <h3 style=\"text-align: center; color: #cd7f32; margin-bottom: 1.5rem;\">\ud83e\udd49 Bronze Sponsors</h3>\n        <div style=\"display: flex; flex-wrap: wrap; justify-content: center; gap: 2rem; align-items: center;\">\n            <!-- Add Bronze Sponsors here -->\n        </div>\n    </div>\n</div>\n",
      "source_file": "docs/sponsorship.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Alternative Sponsorship Platforms\n\n<div style=\"background: #f6f8fa; padding: 1.5rem; border-radius: 8px; margin: 2rem 0;\">\n    <h3>\ud83d\udce2 We Want Your Input!</h3>\n    <p>We are currently evaluating whether to expand our sponsorship options beyond GitHub Sponsors. If your company would be interested in sponsoring Starlette and Uvicorn but prefers to use a different platform (e.g., Open Collective, direct invoicing), please let us know!</p>\n    <p>Your feedback is invaluable in helping us make sponsorship as accessible as possible. Share your thoughts by:</p>\n    <ul>\n        <li>Opening a discussion on our <a href=\"https://github.com/encode/starlette/discussions\">GitHub repository</a></li>\n        <li>Contacting us directly at <a href=\"mailto:marcelotryle@gmail.com\">marcelotryle@gmail.com</a></li>\n    </ul>\n</div>\n\n<a id=\"acknowledgments\"></a>\n",
      "source_file": "docs/sponsorship.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Community & Future Plans \ud83c\udf1f\n\nWe want to express our deepest gratitude to all the contributors who have helped shape Starlette and\nUvicorn over the years. These projects wouldn't be what they are today without the incredible work of\nevery single contributor.\n\nSpecial thanks to some of our most impactful contributors:\n\n- **Tom Christie** ([@tomchristie](https://github.com/tomchristie)) - The original creator of Starlette and Uvicorn.\n- **Adrian Garcia Badaracco** ([@adriangb](https://github.com/adriangb)) - Major contributor to Starlette.\n- **Thomas Grainger** ([@graingert](https://github.com/graingert)) - Major contributor to AnyIO, and significant contributions to Starlette and Uvicorn.\n- **Alex Gr\u00f6nholm** ([@agronholm](https://github.com/agronholm)) - Creator of AnyIO.\n- **Florimond Manca** ([@florimondmanca](https://github.com/florimondmanca)) - Important contributions to Starlette and Uvicorn.\n\nIf you want your name removed from the list above, or if I forgot a significant contributor, please let me know.\nYou can view all contributors on GitHub:\n[Starlette Contributors](https://github.com/encode/starlette/graphs/contributors) / [Uvicorn Contributors](https://github.com/encode/uvicorn/graphs/contributors).\n\nWhile the current sponsorship program directly supports Marcelo's maintenance work, we are exploring ways\nto distribute funding to other key contributors in the future. This initiative is still in early planning\nstages, as we want to ensure a fair and sustainable model that recognizes the valuable contributions of\nour community members.",
      "source_file": "docs/sponsorship.md",
      "chunk_type": "doc"
    },
    {
      "content": "# Settings\n\nUse the following options to configure Uvicorn, when running from the command line.\n",
      "source_file": "docs/settings.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Configuration Methods\n\nThere are three ways to configure Uvicorn:\n\n1. **Command Line**: Use command line options when running Uvicorn directly.\n   ```bash\n   uvicorn main:app --host 0.0.0.0 --port 8000\n   ```\n\n2. **Programmatic**: Use keyword arguments when running programmatically with `uvicorn.run()`.\n   ```python\n   uvicorn.run(\"main:app\", host=\"0.0.0.0\", port=8000)\n   ```\n\n    !!! note\n        When using `reload=True` or `workers=NUM`, you should put `uvicorn.run` into\n        an `if __name__ == '__main__'` clause in the main module.\n\n3. **Environment Variables**: Use environment variables with the prefix `UVICORN_`.\n   ```bash\n   export UVICORN_HOST=\"0.0.0.0\"\n   export UVICORN_PORT=\"8000\"\n   uvicorn main:app\n   ```\n\nCLI options and the arguments for `uvicorn.run()` take precedence over environment variables.\n\nAlso note that `UVICORN_*` prefixed settings cannot be used from within an environment\nconfiguration file. Using an environment configuration file with the `--env-file` flag is\nintended for configuring the ASGI application that uvicorn runs, rather than configuring\nuvicorn itself.\n",
      "source_file": "docs/settings.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Application\n\n* `APP` - The ASGI application to run, in the format `\"<module>:<attribute>\"`.\n* `--factory` - Treat `APP` as an application factory, i.e. a `() -> <ASGI app>` callable.\n* `--app-dir <path>` - Look for APP in the specified directory by adding it to the PYTHONPATH. **Default:** *Current working directory*.\n",
      "source_file": "docs/settings.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Socket Binding\n\n* `--host <str>` - Bind socket to this host. Use `--host 0.0.0.0` to make the application available on your local network. IPv6 addresses are supported, for example: `--host '::'`. **Default:** *'127.0.0.1'*.\n* `--port <int>` - Bind to a socket with this port. If set to 0, an available port will be picked. **Default:** *8000*.\n* `--uds <path>` - Bind to a UNIX domain socket, for example `--uds /tmp/uvicorn.sock`. Useful if you want to run Uvicorn behind a reverse proxy.\n* `--fd <int>` - Bind to socket from this file descriptor. Useful if you want to run Uvicorn within a process manager.\n",
      "source_file": "docs/settings.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Development\n\n* `--reload` - Enable auto-reload. Uvicorn supports two versions of auto-reloading behavior enabled by this option. **Default:** *False*.\n* `--reload-dir <path>` - Specify which directories to watch for python file changes. May be used multiple times. If unused, then by default the whole current directory will be watched. If you are running programmatically use `reload_dirs=[]` and pass a list of strings.\n* `--reload-delay <float>` - Delay between previous and next check if application needs to be reloaded. **Default:** *0.25*.\n",
      "source_file": "docs/settings.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Reloading without watchfiles\n\nIf Uvicorn _cannot_ load [watchfiles](https://pypi.org/project/watchfiles/) at runtime, it will periodically look for changes in modification times to all `*.py` files (and only `*.py` files) inside of its monitored directories. See the `--reload-dir` option. Specifying other file extensions is not supported unless watchfiles is installed. See the `--reload-include` and `--reload-exclude` options for details.\n",
      "source_file": "docs/settings.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Reloading with watchfiles\n\nFor more nuanced control over which file modifications trigger reloads, install `uvicorn[standard]`, which includes watchfiles as a dependency. Alternatively, install [watchfiles](https://pypi.org/project/watchfiles/) where Uvicorn can see it.\n\nUsing Uvicorn with watchfiles will enable the following options (which are otherwise ignored):\n\n* `--reload-include <glob-pattern>` - Specify a glob pattern to match files or directories which will be watched. May be used multiple times. By default the following patterns are included: `*.py`. These defaults can be overwritten by including them in `--reload-exclude`.\n* `--reload-exclude <glob-pattern>` - Specify a glob pattern to match files or directories which will excluded from watching. May be used multiple times. By default the following patterns are excluded: `.*, .py[cod], .sw.*, ~*`. These defaults can be overwritten by including them in `--reload-include`.\n\n!!! tip\n    When using Uvicorn through [WSL](https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux), you might\n    have to set the `WATCHFILES_FORCE_POLLING` environment variable, for file changes to trigger a reload.\n    See [watchfiles documentation](https://watchfiles.helpmanual.io/api/watch/) for further details.\n",
      "source_file": "docs/settings.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Production\n\n* `--workers <int>` - Number of worker processes. Defaults to the `$WEB_CONCURRENCY` environment variable if available, or 1. Not valid with `--reload`.\n* `--env-file <path>` - Environment configuration file for the ASGI application. **Default:** *None*.\n\n!!! note\n    The `--reload` and `--workers` arguments are mutually exclusive. You cannot use both at the same time.\n",
      "source_file": "docs/settings.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Logging\n\n* `--log-config <path>` - Logging configuration file. **Options:** *`dictConfig()` formats: .json, .yaml*. Any other format will be processed with `fileConfig()`. Set the `formatters.default.use_colors` and `formatters.access.use_colors` values to override the auto-detected behavior.\n    * If you wish to use a YAML file for your logging config, you will need to include PyYAML as a dependency for your project or install uvicorn with the `[standard]` optional extras.\n* `--log-level <str>` - Set the log level. **Options:** *'critical', 'error', 'warning', 'info', 'debug', 'trace'.* **Default:** *'info'*.\n* `--no-access-log` - Disable access log only, without changing log level.\n* `--use-colors / --no-use-colors` - Enable / disable colorized formatting of the log records. If not set, colors will be auto-detected. This option is ignored if the `--log-config` CLI option is used.\n",
      "source_file": "docs/settings.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Implementation\n\n* `--loop <str>` - Set the event loop implementation. The uvloop implementation provides greater performance, but is not compatible with Windows or PyPy. **Options:** *'auto', 'asyncio', 'uvloop'.* **Default:** *'auto'*.\n* `--http <str>` - Set the HTTP protocol implementation. The httptools implementation provides greater performance, but it not compatible with PyPy. **Options:** *'auto', 'h11', 'httptools'.* **Default:** *'auto'*.\n* `--ws <str>` - Set the WebSockets protocol implementation. Either of the `websockets` and `wsproto` packages are supported. There are two versions of `websockets` supported: `websockets` and `websockets-sansio`. Use `'none'` to ignore all websocket requests. **Options:** *'auto', 'none', 'websockets', 'websockets-sansio', 'wsproto'.* **Default:** *'auto'*.\n* `--ws-max-size <int>` - Set the WebSockets max message size, in bytes. Only available with the `websockets` protocol. **Default:** *16777216* (16 MB).\n* `--ws-max-queue <int>` - Set the maximum length of the WebSocket incoming message queue. Only available with the `websockets` protocol. **Default:** *32*.\n* `--ws-ping-interval <float>` - Set the WebSockets ping interval, in seconds. Only available with the `websockets` protocol. **Default:** *20.0*.\n* `--ws-ping-timeout <float>` - Set the WebSockets ping timeout, in seconds. Only available with the `websockets` protocol. **Default:** *20.0*.\n* `--ws-per-message-deflate <bool>` - Enable/disable WebSocket per-message-deflate compression. Only available with the `websockets` protocol. **Default:** *True*.\n* `--lifespan <str>` - Set the Lifespan protocol implementation. **Options:** *'auto', 'on', 'off'.* **Default:** *'auto'*.\n* `--h11-max-incomplete-event-size <int>` - Set the maximum number of bytes to buffer of an incomplete event. Only available for `h11` HTTP protocol implementation. **Default:** *16384* (16 KB).\n",
      "source_file": "docs/settings.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Application Interface\n\n* `--interface <str>` - Select ASGI3, ASGI2, or WSGI as the application interface.\nNote that WSGI mode always disables WebSocket support, as it is not supported by the WSGI interface.\n**Options:** *'auto', 'asgi3', 'asgi2', 'wsgi'.* **Default:** *'auto'*.\n\n!!! warning\n    Uvicorn's native WSGI implementation is deprecated, you should switch\n    to [a2wsgi](https://github.com/abersheeran/a2wsgi) (`pip install a2wsgi`).\n",
      "source_file": "docs/settings.md",
      "chunk_type": "doc"
    },
    {
      "content": "## HTTP\n\n* `--root-path <str>` - Set the ASGI `root_path` for applications submounted below a given URL path. **Default:** *\"\"*.\n* `--proxy-headers / --no-proxy-headers` - Enable/Disable X-Forwarded-Proto, X-Forwarded-For to populate remote address info. Defaults to enabled, but is restricted to only trusting connecting IPs in the `forwarded-allow-ips` configuration.\n* `--forwarded-allow-ips <comma-separated-list>` - Comma separated list of IP Addresses, IP Networks, or literals (e.g. UNIX Socket path) to trust with proxy headers. Defaults to the `$FORWARDED_ALLOW_IPS` environment variable if available, or '127.0.0.1'. The literal `'*'` means trust everything.\n* `--server-header / --no-server-header` - Enable/Disable default `Server` header. **Default:** *True*.\n* `--date-header / --no-date-header` - Enable/Disable default `Date` header. **Default:** *True*.\n* `--header <name:value>` - Specify custom default HTTP response headers as a Name:Value pair. May be used multiple times.\n\n!!! note\n    The `--no-date-header` flag doesn't have effect on the `websockets` implementation.\n",
      "source_file": "docs/settings.md",
      "chunk_type": "doc"
    },
    {
      "content": "## HTTPS\n\nThe [SSL context](https://docs.python.org/3/library/ssl.html#ssl.SSLContext) can be configured with the following options:\n\n* `--ssl-keyfile <path>` - The SSL key file.\n* `--ssl-keyfile-password <str>` - The password to decrypt the ssl key.\n* `--ssl-certfile <path>` - The SSL certificate file.\n* `--ssl-version <int>` - The SSL version to use. **Default:** *ssl.PROTOCOL_TLS_SERVER*.\n* `--ssl-cert-reqs <int>` - Whether client certificate is required. **Default:** *ssl.CERT_NONE*.\n* `--ssl-ca-certs <str>` - The CA certificates file.\n* `--ssl-ciphers <str>` - The ciphers to use. **Default:** *\"TLSv1\"*.\n\nTo understand more about the SSL context options, please refer to the [Python documentation](https://docs.python.org/3/library/ssl.html).\n",
      "source_file": "docs/settings.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Resource Limits\n\n* `--limit-concurrency <int>` - Maximum number of concurrent connections or tasks to allow, before issuing HTTP 503 responses. Useful for ensuring known memory usage patterns even under over-resourced loads.\n* `--limit-max-requests <int>` - Maximum number of requests to service before terminating the process. Useful when running together with a process manager, for preventing memory leaks from impacting long-running processes.\n* `--backlog <int>` - Maximum number of connections to hold in backlog. Relevant for heavy incoming traffic. **Default:** *2048*.\n",
      "source_file": "docs/settings.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Timeouts\n\n* `--timeout-keep-alive <int>` - Close Keep-Alive connections if no new data is received within this timeout. **Default:** *5*.\n* `--timeout-graceful-shutdown <int>` - Maximum number of seconds to wait for graceful shutdown. After this timeout, the server will start terminating requests.",
      "source_file": "docs/settings.md",
      "chunk_type": "doc"
    },
    {
      "content": "---\ntoc_depth: 2\n---\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.35.0 (June 28, 2025)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Added\n\n* Add `WebSocketsSansIOProtocol` (#2540)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Changed\n\n* Refine help message for option `--proxy-headers` (#2653)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.34.3 (June 1, 2025)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n* Don't include `cwd()` when non-empty `--reload-dirs` is passed (#2598)\n* Apply `get_client_addr` formatting to WebSocket logging (#2636)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.34.2 (April 19, 2025)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n* Flush stdout buffer on Windows to trigger reload (#2604)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.34.1 (April 13, 2025)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Deprecated\n\n* Deprecate `ServerState` in the main module (#2581)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.34.0 (December 15, 2024)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Added\n\n* Add `content-length` to 500 response in `wsproto` implementation (#2542)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Removed\n\n* Drop support for Python 3.8 (#2543)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.33.0 (December 14, 2024)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Removed\n\n* Remove `WatchGod` support for `--reload` (#2536)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.32.1 (November 20, 2024)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n* Drop ASGI spec version to 2.3 on HTTP scope (#2513)\n* Enable httptools lenient data on `httptools >= 0.6.3` (#2488)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.32.0 (October 15, 2024)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Added\n\n* Officially support Python 3.13 (#2482)\n* Warn when `max_request_limit` is exceeded (#2430)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.31.1 (October 9, 2024)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n* Support WebSockets 0.13.1 (#2471)\n* Restore support for `[*]` in trusted hosts (#2480)\n* Add `PathLike[str]` type hint for `ssl_keyfile` (#2481)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.31.0 (September 27, 2024)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Added\n\nImprove `ProxyHeadersMiddleware` (#2468) and (#2231):\n\n- Fix the host for requests from clients running on the proxy server itself.\n- Fallback to host that was already set for empty x-forwarded-for headers.\n- Also allow to specify IP Networks as trusted hosts. This greatly simplifies deployments\n  on docker swarm/kubernetes, where the reverse proxy might have a dynamic IP.\n    - This includes support for IPv6 Address/Networks.\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.30.6 (August 13, 2024)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n- Don't warn when upgrade is not WebSocket and depedencies are installed (#2360)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.30.5 (August 2, 2024)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n- Don't close connection before receiving body on H11 (#2408)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.30.4 (July 31, 2024)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n- Close connection when `h11` sets client state to `MUST_CLOSE` (#2375)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.30.3 (July 20, 2024)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n- Suppress `KeyboardInterrupt` from CLI and programmatic usage (#2384)\n- `ClientDisconnect` inherits from `OSError` instead of `IOError` (#2393)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.30.2 (July 20, 2024)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Added\n\n- Add `reason` support to [`websocket.disconnect`](https://asgi.readthedocs.io/en/latest/specs/www.html#disconnect-receive-event-ws) event (#2324)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n- Iterate subprocesses in-place on the process manager (#2373)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.30.1 (June 2, 2024)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n- Allow horizontal tabs `\\t` in response header values (#2345)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.30.0 (May 28, 2024)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Added\n\n- New multiprocess manager (#2183)\n- Allow `ConfigParser` or a `io.IO[Any]` on `log_config` (#1976)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n- Suppress side-effects of signal propagation (#2317)\n- Send `content-length` header on 5xx (#2304)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Deprecated\n\n- Deprecate the `uvicorn.workers` module (#2302)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.29.0 (March 19, 2024)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Added\n\n- Cooperative signal handling (#1600)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.28.1 (March 19, 2024)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n- Revert raise `ClientDisconnected` on HTTP (#2276)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.28.0 (March 9, 2024)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Added\n\n- Raise `ClientDisconnected` on `send()` when client disconnected (#2220)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n- Except `AttributeError` on `sys.stdin.fileno()` for Windows IIS10 (#1947)\n- Use `X-Forwarded-Proto` for WebSockets scheme when the proxy provides it (#2258)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.27.1 (February 10, 2024)\n\n- Fix spurious LocalProtocolError errors when processing pipelined requests (#2243)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.27.0.post1 (January 29, 2024)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n- Fix nav overrides for newer version of Mkdocs Material (#2233)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.27.0 (January 22, 2024)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Added\n\n- Raise `ClientDisconnect(IOError)` on `send()` when client disconnected (#2218)\n- Bump ASGI WebSocket spec version to 2.4 (#2221)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.26.0 (January 16, 2024)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Changed\n\n- Update `--root-path` to include the root path prefix in the full ASGI `path` as per the ASGI spec (#2213)\n- Use `__future__.annotations` on some internal modules (#2199)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.25.0 (December 17, 2023)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Added\n\n- Support the WebSocket Denial Response ASGI extension (#1916)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n- Allow explicit hidden file paths on `--reload-include` (#2176)\n- Properly annotate `uvicorn.run()` (#2158)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.24.0.post1 (November 6, 2023)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n- Revert mkdocs-material from 9.1.21 to 9.2.6 (#2148)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.24.0 (November 4, 2023)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Added\n\n- Support Python 3.12 (#2145)\n- Allow setting `app` via environment variable `UVICORN_APP` (#2106)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.23.2 (July 31, 2023)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n- Maintain the same behavior of `websockets` from 10.4 on 11.0 (#2061)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.23.1 (July 18, 2023)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n- Add `typing_extensions` for Python 3.10 and lower (#2053)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.23.0 (July 10, 2023)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Added\n\n- Add `--ws-max-queue` parameter WebSockets (#2033)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Removed\n\n- Drop support for Python 3.7 (#1996)\n- Remove `asgiref` as typing dependency (#1999)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n- Set `scope[\"scheme\"]` to `ws` or `wss` instead of `http` or `https` on `ProxyHeadersMiddleware` for WebSockets (#2043)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Changed\n\n- Raise `ImportError` on circular import (#2040)\n- Use `logger.getEffectiveLevel()` instead of `logger.level` to check if log level is `TRACE` (#1966)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.22.0 (April 28, 2023)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Added\n\n- Add `--timeout-graceful-shutdown` parameter (#1950)\n- Handle `SIGBREAK` on Windows (#1909)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n- Shutdown event is now being triggered on Windows when using hot reload (#1584)\n- `--reload-delay` is effectively used on the `watchfiles` reloader (#1930)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.21.1 (March 16, 2023)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n- Reset lifespan state on each request (#1903)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.21.0 (March 9, 2023)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Added\n\n- Introduce lifespan state (#1818)\n- Allow headers to be sent as iterables on H11 implementation (#1782)\n- Improve discoverability when --port=0 is used (#1890)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Changed\n\n- Avoid importing `h11` and `pyyaml` when not needed to improve import time (#1846)\n- Replace current native `WSGIMiddleware` implementation by `a2wsgi` (#1825)\n- Change default `--app-dir` from \".\" (dot) to \"\" (empty string) (#1835)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n- Send code 1012 on shutdown for WebSockets (#1816)\n- Use `surrogateescape` to encode headers on `websockets` implementation (#1005)\n- Fix warning message on reload failure (#1784)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.20.0 (November 20, 2022)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Added\n\n- Check if handshake is completed before sending frame on `wsproto` shutdown (#1737)\n- Add default headers to WebSockets implementations (#1606 & #1747)\n- Warn user when `reload` and `workers` flag are used together (#1731)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n- Use correct `WebSocket` error codes on `close` (#1753)\n- Send disconnect event on connection lost for `wsproto` (#996)\n- Add `SIGQUIT` handler to `UvicornWorker` (#1710)\n- Fix crash on exist with \"--uds\" if socket doesn't exist (#1725)\n- Annotate `CONFIG_KWARGS` in `UvicornWorker` class (#1746)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Removed\n\n- Remove conditional on `RemoteProtocolError.event_hint` on `wsproto` (#1486)\n- Remove unused `handle_no_connect` on `wsproto` implementation (#1759)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.19.0 (October 19, 2022)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Added\n\n- Support Python 3.11 (#1652)\n- Bump minimal `httptools` version to `0.5.0` (#1645)\n- Ignore HTTP/2 upgrade and optionally ignore WebSocket upgrade (#1661)\n- Add `py.typed` to comply with PEP 561 (#1687)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n- Set `propagate` to `False` on \"uvicorn\" logger (#1288)\n- USR1 signal is now handled correctly on `UvicornWorker`. (#1565)\n- Use path with query string on `WebSockets` logs (#1385)\n- Fix behavior on which \"Date\" headers were not updated on the same connection (#1706)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Removed\n\n- Remove the `--debug` flag (#1640)\n- Remove the `DebugMiddleware` (#1697)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.18.3 (August 24, 2022)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n- Remove cyclic references on HTTP implementations. (#1604)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Changed\n\n- `reload_delay` default changed from `None` to `0.25` on `uvicorn.run()` and `Config`. `None` is not an acceptable value anymore. (#1545)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.18.2 (June 27, 2022)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n- Add default `log_config` on `uvicorn.run()` (#1541)\n- Revert `logging` file name modification (#1543)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.18.1 (June 23, 2022)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n- Use `DEFAULT_MAX_INCOMPLETE_EVENT_SIZE` as default to `h11_max_incomplete_event_size` on the CLI (#1534)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.18.0 (June 23, 2022)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Added\n\n- The `reload` flag prioritizes `watchfiles` instead of the deprecated `watchgod` (#1437)\n- Annotate `uvicorn.run()` function (#1423)\n- Allow configuring `max_incomplete_event_size` for `h11` implementation (#1514)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Removed\n\n- Remove `asgiref` dependency (#1532)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n- Turn `raw_path` into bytes on both websockets implementations (#1487)\n- Revert log exception traceback in case of invalid HTTP request (#1518)\n- Set `asyncio.WindowsSelectorEventLoopPolicy()` when using multiple workers to avoid \"WinError 87\" (#1454)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.17.6 (March 11, 2022)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Changed\n\n- Change `httptools` range to `>=0.4.0` (#1400)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.17.5 (February 16, 2022)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n- Fix case where url is fragmented in httptools protocol (#1263)\n- Fix WSGI middleware not to explode quadratically in the case of a larger body (#1329)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Changed\n\n- Send HTTP 400 response for invalid request (#1352)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.17.4 (February 4, 2022)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n- Replace `create_server` by `create_unix_server` (#1362)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.17.3 (February 3, 2022)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n- Drop wsproto version checking. (#1359)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.17.2 (February 3, 2022)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n- Revert #1332. While trying to solve the memory leak, it introduced an issue (#1345) when the server receives big chunks of data using the `httptools` implementation. (#1354)\n- Revert stream interface changes. This was introduced on 0.14.0, and caused an issue (#1226), which caused a memory leak when sending TCP pings. (#1355)\n- Fix wsproto version check expression (#1342)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.17.1 (January 28, 2022)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n- Move all data handling logic to protocol and ensure connection is closed. (#1332)\n- Change `spec_version` field from \"2.1\" to \"2.3\", as Uvicorn is compliant with that version of the ASGI specifications. (#1337)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.17.0.post1 (January 24, 2022)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n- Add the `python_requires` version specifier (#1328)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.17.0 (January 14, 2022)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Added\n\n- Allow configurable websocket per-message-deflate setting (#1300)\n- Support extra_headers for WS accept message (#1293)\n- Add missing http version on websockets scope (#1309)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed/Removed\n\n- Drop Python 3.6 support (#1261)\n- Fix reload process behavior when exception is raised (#1313)\n- Remove `root_path` from logs (#1294)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.16.0 (December 8, 2021)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Added\n\n- Enable read of uvicorn settings from environment variables (#1279)\n- Bump `websockets` to 10.0. (#1180)\n- Ensure non-zero exit code when startup fails (#1278)\n- Increase `httptools` version range from \"==0.2.*\" to \">=0.2.0,<0.4.0\". (#1243)\n- Override default asyncio event loop with reload only on Windows (#1257)\n- Replace `HttpToolsProtocol.pipeline` type from `list` to `deque`. (#1213)\n- Replace `WSGIResponder.send_queue` type from `list` to `deque`. (#1214)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n- Main process exit after startup failure on reloader classes (#1177)\n- Fix the need of `httptools` on minimal installation (#1135)\n- Fix ping parameters annotation in Config class (#1127)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.15.0 (August 13, 2021)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Added\n\n- Change reload to be configurable with glob patterns. Currently only `.py` files are watched, which is different from the previous default behavior. (#820)\n- Add Python 3.10-rc.1 support. Now the server uses `asyncio.run` which will: start a fresh asyncio event loop, on shutdown cancel any background tasks rather than aborting them, `aexit` any remaining async generators, and shutdown the default `ThreadPoolExecutor`. (#1070)\n- Exit with status 3 when worker starts failed (#1077)\n- Add option to set websocket ping interval and timeout (#1048)\n- Adapt bind_socket to make it usable with multiple processes (#1009)\n- Add existence check to the reload directory(ies) (#1089)\n- Add missing trace log for websocket protocols (#1083)\n- Support disabling default Server and Date headers (#818)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Changed\n\n- Add PEP440 compliant version of click (#1099)\n- Bump asgiref to 3.4.0 (#1100)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n- When receiving a `SIGTERM` supervisors now terminate their processes before joining them (#1069)\n- Fix `httptools` range to `>=0.4.0` (#1400)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.14.0 (June 1, 2021)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Added\n\n- Defaults ws max_size on server to 16MB (#995)\n- Improve user feedback if no ws library installed (#926 and #1023)\n- Support 'reason' field in 'websocket.close' messages (#957)\n- Implemented lifespan.shutdown.failed (#755)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Changed\n\n- Upgraded websockets requirements (#1065)\n- Switch to asyncio streams API (#869)\n- Update httptools from 0.1.* to 0.2.* (#1024)\n- Allow Click 8.0, refs #1016 (#1042)\n- Add search for a trusted host in ProxyHeadersMiddleware (#591)\n- Up wsproto to 1.0.0 (#892)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n- Force reload_dirs to be a list (#978)\n- Fix gunicorn worker not running if extras not installed (#901)\n- Fix socket port 0 (#975)\n- Prevent garbage collection of main lifespan task (#972)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.13.4 (February 20, 2021)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n- Fixed wsgi middleware PATH_INFO encoding (#962)\n- Fixed uvloop dependency  (#952) then (#959)\n- Relax watchgod up bound (#946)\n- Return 'connection: close' header in response (#721)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Added\n\n- Docs: Nginx + websockets (#948)\n- Document the default value of 1 for workers (#940) (#943)\n- Enabled permessage-deflate extension in websockets (#764)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.13.3 (December 29, 2020)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n- Prevent swallowing of return codes from `subprocess` when running with Gunicorn by properly resetting signals. (#895)\n- Tweak detection of app factories to be more robust. A warning is now logged when passing a factory without the `--factory` flag. (#914)\n- Properly clean tasks when handshake is aborted when running with `--ws websockets`. (#921)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.13.2 (December 12, 2020)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n- Log full exception traceback in case of invalid HTTP request. (#886 and #888)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.13.1 (December 12, 2020)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n\n- Prevent exceptions when the ASGI application rejects a connection during the WebSocket handshake, when running on both `--ws wsproto` or `--ws websockets`. (#704 and #881)\n- Ensure connection `scope` doesn't leak in logs when using JSON log formatters. (#859 and #884)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.13.0 (December 8, 2020)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Added\n\n- Add `--factory` flag to support factory-style application imports. (#875)\n- Skip installation of signal handlers when not in the main thread. Allows using `Server` in multithreaded contexts without having to override `.install_signal_handlers()`. (#871)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.12.3 (November 21, 2020)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n- Fix race condition that leads Quart to hang with uvicorn (#848)\n- Use latin1 when decoding X-Forwarded-* headers (#701)\n- Rework IPv6 support (#837)\n- Cancel old keepalive-trigger before setting new one. (#832)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.12.2 (October 19, 2020)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Added\n- Adding ability to decrypt ssl key file (#808)\n- Support .yml log config files (#799)\n- Added python 3.9 support (#804)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n- Fixes watchgod with common prefixes (#817)\n- Fix reload with ipv6 host (#803)\n- Added cli support for headers containing colon (#813)\n- Sharing socket across workers on windows (#802)\n- Note the need to configure trusted \"ips\" when using unix sockets (#796)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.12.1 (September 30, 2020)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Changed\n- Pinning h11 and python-dotenv to min versions (#789)\n- Get docs/index.md in sync with README.md (#784)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n- Improve changelog by pointing out breaking changes (#792)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.12.0 (September 28, 2020)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Added\n- Make reload delay configurable (#774)\n- Upgrade maximum h11 dependency version to 0.10 (#772)\n- Allow .json or .yaml --log-config files (#665)\n- Add ASGI dict to the lifespan scope (#754)\n- Upgrade wsproto to 0.15.0 (#750)\n- Use optional package installs (#666)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Changed\n- Don't set log level for root logger (#767) 8/28/20 df81b168\n- Uvicorn no longer ships extra dependencies `uvloop`, `websockets` and `httptools` as default.\n  To install these dependencies use `uvicorn[standard]`.\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Fixed\n- Revert \"Improve shutdown robustness when using `--reload` or multiprocessing (#620)\" (#756)\n- Fix terminate error in windows (#744)\n- Fix bug where --log-config disables uvicorn loggers (#512)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.11.8 (July 30, 2020)\n\n* Fix a regression that caused Uvicorn to crash when using `--interface=wsgi`. (#730)\n* Fix a regression that caused Uvicorn to crash when using unix domain sockets. (#729)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.11.7 (July 28, 2020)\n\n* SECURITY FIX: Prevent sending invalid HTTP header names and values. (#725)\n* SECURITY FIX: Ensure path value is escaped before logging to the console. (#724)\n* Fix `--proxy-headers` client IP and host when using a Unix socket. (#636)\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.11.6 (July 17, 2020)\n\n* Fix overriding the root logger.\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.11.5 (April 29, 2020)\n\n* Revert \"Watch all files, not just .py\" due to unexpected side effects.\n* Revert \"Pass through gunicorn timeout config.\" due to unexpected side effects.\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.11.4 (April 28, 2020)\n\n* Use `watchgod`, if installed, for watching code changes.\n* Watch all files, not just .py.\n* Pass through gunicorn timeout config.\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.11.3 (February 17, 2020)\n\n* Update dependencies.\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.11.2 (January 20, 2020)\n\n* Don't open socket until after application startup.\n* Support `--backlog`.\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.11.1 (December 20, 2019)\n\n* Use a more liberal `h11` dependency. Either `0.8.*` or `0.9.*``.\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.11.0 (December 20, 2019)\n\n* Fix reload/multiprocessing on Windows with Python 3.8.\n* Drop IOCP support. (Required for fix above.)\n* Add `uvicorn --version` flag.\n* Add `--use-colors` and `--no-use-colors` flags.\n* Display port correctly, when auto port selection isused with `--port=0`.\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.10.8 (November 12, 2019)\n\n* Fix reload/multiprocessing error.\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.10.7 (November 12, 2019)\n\n* Use resource_sharer.DupSocket to resolve socket sharing on Windows.\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.10.6 (November 12, 2019)\n\n* Exit if `workers` or `reload` are use without an app import string style.\n* Reorganise supervisor processes to properly hand over sockets on windows.\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.10.5 (November 12, 2019)\n\n* Update uvloop dependency to 0.14+\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.10.4 (November 9, 2019)\n\n* Error clearly when `workers=<NUM>` is used with app instance, instead of an app import string.\n* Switch `--reload-dir` to current working directory by default.\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.10.3 (November 1, 2019)\n\n* Add ``--log-level trace`\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.10.2 (October 31, 2019)\n\n* Enable --proxy-headers by default.\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.10.1 (October 31, 2019)\n\n* Resolve issues with logging when using `--reload` or `--workers`.\n* Setup up root logger to capture output for all logger instances, not just `uvicorn.error` and `uvicorn.access`.\n",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "## 0.10.0 (October 29, 2019)\n\n* Support for Python 3.8\n* Separated out `uvicorn.error` and `uvicorn.access` logs.\n* Coloured log output when connected to a terminal.\n* Dropped `logger=` config setting.\n* Added `--log-config [FILE]` and `log_config=[str|dict]`. May either be a Python logging config dictionary or the file name of a logging configuration.\n* Added `--forwarded_allow_ips` and `forwarded_allow_ips`. Defaults to the value of the `$FORWARDED_ALLOW_IPS` environment variable or \"127.0.0.1\". The `--proxy-headers` flag now defaults to `True`, but only trusted IPs are used to populate forwarding info.\n* The `--workers` setting now defaults to the value of the `$WEB_CONCURRENCY` environment variable.\n* Added support for `--env-file`. Requires `python-dotenv`.",
      "source_file": "docs/release-notes.md",
      "chunk_type": "doc"
    },
    {
      "content": "www.uvicorn.org\n",
      "source_file": "docs/CNAME",
      "chunk_type": "unknown"
    },
    {
      "content": "<style>\n  .md-typeset h1,\n  .md-content__button {\n    display: none;\n  }\n</style>\n\n<p align=\"center\">\n  <img width=\"320\" height=\"320\" src=\"../../uvicorn.png\" alt='uvicorn'>\n</p>\n\n<p align=\"center\">\n<em>An ASGI web server, for Python.</em>\n</p>\n\n<p align=\"center\">\n<a href=\"https://github.com/encode/uvicorn/actions\">\n    <img src=\"https://github.com/encode/uvicorn/workflows/Test%20Suite/badge.svg\" alt=\"Test Suite\">\n</a>\n<a href=\"https://pypi.org/project/uvicorn/\">\n    <img src=\"https://badge.fury.io/py/uvicorn.svg\" alt=\"Package version\">\n</a>\n<a href=\"https://pypi.org/project/uvicorn\" target=\"_blank\">\n    <img src=\"https://img.shields.io/pypi/pyversions/uvicorn.svg?color=%2334D058\" alt=\"Supported Python versions\">\n</a>\n<a href=\"https://discord.gg/RxKUF5JuHs\">\n    <img src=\"https://img.shields.io/discord/1051468649518616576?logo=discord&logoColor=ffffff&color=7389D8&labelColor=6A7EC2\" alt=\"Discord\">\n</a>\n</p>\n\n---\n\n**Documentation**: [https://www.uvicorn.org](https://www.uvicorn.org)<br>\n**Source Code**: [https://www.github.com/encode/uvicorn](https://www.github.com/encode/uvicorn)\n\n---\n\n**Uvicorn** is an [ASGI](concepts/asgi.md) web server implementation for Python.\n\nUntil recently Python has lacked a minimal low-level server/application interface for\nasync frameworks. The [ASGI specification](https://asgi.readthedocs.io/en/latest/) fills this gap,\nand means we're now able to start building a common set of tooling usable across all async frameworks.\n\nUvicorn currently supports **HTTP/1.1** and **WebSockets**.\n",
      "source_file": "docs/index.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Quickstart\n\n**Uvicorn** is available on [PyPI](https://pypi.org/project/uvicorn/) so installation is as simple as:\n\n=== \"pip\"\n    ```bash\n    pip install uvicorn\n    ```\n\n=== \"uv\"\n    ```bash\n    uv add uvicorn\n    ```\n\nSee the [installation documentation](installation.md) for more information.\n\n---\n\nLet's create a simple ASGI application to run with Uvicorn:\n\n```python title=\"main.py\"\nasync def app(scope, receive, send):\n    assert scope['type'] == 'http'\n\n    await send({\n        'type': 'http.response.start',\n        'status': 200,\n        'headers': [\n            (b'content-type', b'text/plain'),\n            (b'content-length', b'13'),\n        ],\n    })\n    await send({\n        'type': 'http.response.body',\n        'body': b'Hello, world!',\n    })\n```\n\nThen we can run it with Uvicorn:\n\n```shell\nuvicorn main:app\n```\n\n---\n",
      "source_file": "docs/index.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Usage\n\nThe uvicorn command line tool is the easiest way to run your application.\n",
      "source_file": "docs/index.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Command line options\n\n```bash\n{{ uvicorn_help }}\n```\n\nFor more information, see the [settings documentation](settings.md).\n",
      "source_file": "docs/index.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Running programmatically\n\nThere are several ways to run uvicorn directly from your application.\n",
      "source_file": "docs/index.md",
      "chunk_type": "doc"
    },
    {
      "content": "#### `uvicorn.run`\n\nIf you're looking for a programmatic equivalent of the `uvicorn` command line interface, use `uvicorn.run()`:\n\n```py title=\"main.py\"\nimport uvicorn\n\nasync def app(scope, receive, send):\n    ...\n\nif __name__ == \"__main__\":\n    uvicorn.run(\"main:app\", port=5000, log_level=\"info\")\n```\n",
      "source_file": "docs/index.md",
      "chunk_type": "doc"
    },
    {
      "content": "#### `Config` and `Server` instances\n\nFor more control over configuration and server lifecycle, use `uvicorn.Config` and `uvicorn.Server`:\n\n```py title=\"main.py\"\nimport uvicorn\n\nasync def app(scope, receive, send):\n    ...\n\nif __name__ == \"__main__\":\n    config = uvicorn.Config(\"main:app\", port=5000, log_level=\"info\")\n    server = uvicorn.Server(config)\n    server.run()\n```\n\nIf you'd like to run Uvicorn from an already running async environment, use `uvicorn.Server.serve()` instead:\n\n```py title=\"main.py\"\nimport asyncio\nimport uvicorn\n\nasync def app(scope, receive, send):\n    ...\n\nasync def main():\n    config = uvicorn.Config(\"main:app\", port=5000, log_level=\"info\")\n    server = uvicorn.Server(config)\n    await server.serve()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n",
      "source_file": "docs/index.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Running with Gunicorn\n\n!!! warning\n    The `uvicorn.workers` module is deprecated and will be removed in a future release.\n\n    You should use the [`uvicorn-worker`](https://github.com/Kludex/uvicorn-worker) package instead.\n\n    ```bash\n    python -m pip install uvicorn-worker\n    ```\n\n[Gunicorn](https://gunicorn.org/) is a mature, fully featured server and process manager.\n\nUvicorn includes a Gunicorn worker class allowing you to run ASGI applications,\nwith all of Uvicorn's performance benefits, while also giving you Gunicorn's\nfully-featured process management.\n\nThis allows you to increase or decrease the number of worker processes on the\nfly, restart worker processes gracefully, or perform server upgrades without downtime.\n\nFor production deployments we recommend using gunicorn with the uvicorn worker class.\n\n```\ngunicorn example:app -w 4 -k uvicorn.workers.UvicornWorker\n```\n\nFor a [PyPy](https://pypy.org/) compatible configuration use `uvicorn.workers.UvicornH11Worker`.\n\nFor more information, see the [deployment documentation](deployment/index.md).\n",
      "source_file": "docs/index.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Application factories\n\nThe `--factory` flag allows loading the application from a factory function, rather than an application instance directly. The factory will be called with no arguments and should return an ASGI application.\n\n```py title=\"main.py\"\ndef create_app():\n    app = ...\n    return app\n```\n\n```shell\nuvicorn --factory main:create_app\n```",
      "source_file": "docs/index.md",
      "chunk_type": "doc"
    },
    {
      "content": "# Contributing\n\nThank you for being interested in contributing to Uvicorn.\nThere are many ways you can contribute to the project:\n\n- Using Uvicorn on your stack and [reporting bugs/issues you find](https://github.com/encode/uvicorn/issues/new)\n- [Implementing new features and fixing bugs](https://github.com/encode/uvicorn/issues?q=is%3Aissue+is%3Aopen+label%3A%22help+wanted%22)\n- [Review Pull Requests of others](https://github.com/encode/uvicorn/pulls)\n- Write documentation\n- Participate in discussions\n",
      "source_file": "docs/contributing.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Reporting Bugs, Issues or Feature Requests\n\nFound something that Uvicorn should support?\nStumbled upon some unexpected behaviour?\nNeed a missing functionality?\n\nContributions should generally start out from a previous discussion.\nYou can reach out someone at the [community chat](https://discord.com/invite/SWU73HffbV)\nor at the [github discussions tab](https://github.com/encode/uvicorn/discussions).\n\nWhen creating a new topic in the discussions tab, possible bugs may be raised\nas a \"Potential Issue\" discussion, feature requests may be raised as an\n\"Ideas\" discussion. We can then determine if the discussion needs\nto be escalated into an \"Issue\" or not, or if we'd consider a pull request.\n\nTry to be more descriptive as you can and in case of a bug report,\nprovide as much information as possible like:\n\n- OS platform\n- Python version\n- Installed dependencies and versions (`python -m pip freeze`)\n- Code snippet\n- Error traceback\n\nYou should always try to reduce any examples to the *simplest possible case*\nthat demonstrates the issue.\n\nSome possibly useful tips for narrowing down potential issues...\n\n- Does the issue exist with a specific supervisor like `Multiprocess` or more than one?\n- Does the issue exist on asgi, or wsgi, or both?\n- Are you running Uvicorn in conjunction with Gunicorn, others, or standalone?\n",
      "source_file": "docs/contributing.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Development\n\nTo start developing Uvicorn create a **fork** of the\n[Uvicorn repository](https://github.com/encode/uvicorn) on GitHub.\n\nThen clone your fork with the following command replacing `YOUR-USERNAME` with\nyour GitHub username:\n\n```shell\n$ git clone https://github.com/YOUR-USERNAME/uvicorn\n```\n\nYou can now install the project and its dependencies using:\n\n```shell\n$ cd uvicorn\n$ scripts/install\n```\n",
      "source_file": "docs/contributing.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Testing and Linting\n\nWe use custom shell scripts to automate testing, linting,\nand documentation building workflow.\n\nTo run the tests, use:\n\n```shell\n$ scripts/test\n```\n\nAny additional arguments will be passed to `pytest`. See the [pytest documentation](https://docs.pytest.org/en/latest/how-to/usage.html) for more information.\n\nFor example, to run a single test script:\n\n```shell\n$ scripts/test tests/test_cli.py\n```\n\nTo run the code auto-formatting:\n\n```shell\n$ scripts/lint\n```\n\nLastly, to run code checks separately (they are also run as part of `scripts/test`), run:\n\n```shell\n$ scripts/check\n```\n",
      "source_file": "docs/contributing.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Documenting\n\nDocumentation pages are located under the `docs/` folder.\n\nTo run the documentation site locally (useful for previewing changes), use:\n\n```shell\n$ scripts/docs serve\n```\n",
      "source_file": "docs/contributing.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Resolving Build / CI Failures\n\nOnce you've submitted your pull request, the test suite will\nautomatically run, and the results will show up in GitHub.\nIf the test suite fails, you'll want to click through to the\n\"Details\" link, and try to identify why the test suite failed.\n\n<p align=\"center\" style=\"margin: 0 0 10px\">\n  <img src=\"https://raw.githubusercontent.com/encode/uvicorn/master/docs/img/gh-actions-fail.png\" alt='Failing PR commit status'>\n</p>\n\nHere are some common ways the test suite can fail:\n",
      "source_file": "docs/contributing.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Check Job Failed\n\n<p align=\"center\" style=\"margin: 0 0 10px\">\n  <img src=\"https://raw.githubusercontent.com/encode/uvicorn/master/docs/img/gh-actions-fail-check.png\" alt='Failing GitHub action lint job'>\n</p>\n\nThis job failing means there is either a code formatting issue or type-annotation issue.\nYou can look at the job output to figure out why it's failed or within a shell run:\n\n```shell\n$ scripts/check\n```\n\nIt may be worth it to run `$ scripts/lint` to attempt auto-formatting the code\nand if that job succeeds commit the changes.\n",
      "source_file": "docs/contributing.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Docs Job Failed\n\nThis job failing means the documentation failed to build. This can happen for\na variety of reasons like invalid markdown or missing configuration within `mkdocs.yml`.\n",
      "source_file": "docs/contributing.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Python 3.X Job Failed\n\nThis job failing means the unit tests failed or not all code paths are covered by unit tests.\n\nIf tests are failing you will see this message under the coverage report:\n\n`=== 1 failed, 354 passed, 1 skipped, 1 xfailed in 37.08s ===`\n\nIf tests succeed but coverage doesn't reach 100%, you will see this\nmessage under the coverage report:\n\n`Coverage failure: total of 98 is less than fail-under=100`\n",
      "source_file": "docs/contributing.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Releasing\n\n*This section is targeted at Uvicorn maintainers.*\n\nBefore releasing a new version, create a pull request that includes:\n\n- **An update to the changelog**:\n    - We follow the format from [keepachangelog](https://keepachangelog.com/en/1.0.0/).\n    - [Compare](https://github.com/encode/uvicorn/compare/) `master` with the tag of the latest release, and list all entries that are of interest to our users:\n        - Things that **must** go in the changelog: added, changed, deprecated or removed features, and bug fixes.\n        - Things that **should not** go in the changelog: changes to documentation, tests or tooling.\n        - Try sorting entries in descending order of impact / importance.\n        - Keep it concise and to-the-point. \ud83c\udfaf\n- **A version bump**: see `__init__.py`.\n\nFor an example, see [#1006](https://github.com/encode/uvicorn/pull/1107).\n\nOnce the release PR is merged, create a\n[new release](https://github.com/encode/uvicorn/releases/new) including:\n\n- Tag version like `0.13.3`.\n- Release title `Version 0.13.3`\n- Description copied from the changelog.\n\nOnce created this release will be automatically uploaded to PyPI.\n\nIf something goes wrong with the PyPI job the release can be published using the\n`scripts/publish` script.",
      "source_file": "docs/contributing.md",
      "chunk_type": "doc"
    },
    {
      "content": "# Server Behavior\n\nUvicorn is designed with particular attention to connection and resource management, in order to provide a robust server implementation. It aims to ensure graceful behavior to either server or client errors, and resilience to poor client behavior or denial of service attacks.\n",
      "source_file": "docs/server-behavior.md",
      "chunk_type": "doc"
    },
    {
      "content": "## HTTP Headers\n\nThe `Server` and `Date` headers are added to all outgoing requests.\n\nIf a `Connection: Close` header is included then Uvicorn will close the connection after the response. Otherwise connections will stay open, pending the keep-alive timeout.\n\nIf a `Content-Length` header is included then Uvicorn will ensure that the content length of the response body matches the value in the header, and raise an error otherwise.\n\nIf no `Content-Length` header is included then Uvicorn will use chunked encoding for the response body, and will set a `Transfer-Encoding` header if required.\n\nIf a `Transfer-Encoding` header is included then any `Content-Length` header will be ignored.\n\nHTTP headers are mandated to be case-insensitive. Uvicorn will always send response headers strictly in lowercase.\n\n---\n",
      "source_file": "docs/server-behavior.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Flow Control\n\nProper flow control ensures that large amounts of data do not become buffered on the transport when either side of a connection is sending data faster than its counterpart is able to handle.\n",
      "source_file": "docs/server-behavior.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Write flow control\n\nIf the write buffer passes a high water mark, then Uvicorn ensures the ASGI `send` messages will only return once the write buffer has been drained below the low water mark.\n",
      "source_file": "docs/server-behavior.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Read flow control\n\nUvicorn will pause reading from a transport once the buffered request body hits a high water mark, and will only resume once `receive` has been called, or once the response has been sent.\n\n---\n",
      "source_file": "docs/server-behavior.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Request and Response bodies\n",
      "source_file": "docs/server-behavior.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Response completion\n\nOnce a response has been sent, Uvicorn will no longer buffer any remaining request body. Any later calls to `receive` will return an `http.disconnect` message.\n\nTogether with the read flow control, this behavior ensures that responses that return without reading the request body will not stream any substantial amounts of data into memory.\n",
      "source_file": "docs/server-behavior.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Expect: 100-Continue\n\nThe `Expect: 100-Continue` header may be sent by clients to require a confirmation from the server before uploading the request body. This can be used to ensure that large request bodies are only sent once the client has confirmation that the server is willing to accept the request.\n\nUvicorn ensures that any required `100 Continue` confirmations are only sent if the ASGI application calls `receive` to read the request body.\n\nNote that proxy configurations may not necessarily forward on `Expect: 100-Continue` headers. In particular, Nginx defaults to buffering request bodies, and automatically sends `100 Continues` rather than passing the header on to the upstream server.\n",
      "source_file": "docs/server-behavior.md",
      "chunk_type": "doc"
    },
    {
      "content": "### HEAD requests\n\nUvicorn will strip any response body from HTTP requests with the `HEAD` method.\n\nApplications should generally treat `HEAD` requests in the same manner as `GET` requests, in order to ensure that identical headers are sent in both cases, and that any ASGI middleware that modifies the headers will operate identically in either case.\n\nOne exception to this might be if your application serves large file downloads, in which case you might wish to only generate the response headers.\n\n---\n",
      "source_file": "docs/server-behavior.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Timeouts\n\nUvicorn provides the following timeouts:\n\n* Keep-Alive. Defaults to 5 seconds. Between requests, connections must receive new data within this period or be disconnected.\n\n---\n",
      "source_file": "docs/server-behavior.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Resource Limits\n\nUvicorn provides the following resource limiting:\n\n* Concurrency. Defaults to `None`. If set, this provides a maximum number of concurrent tasks *or* open connections that should be allowed. Any new requests or connections that occur once this limit has been reached will result in a \"503 Service Unavailable\" response. Setting this value to a limit that you know your servers are able to support will help ensure reliable resource usage, even against significantly over-resourced servers.\n* Max requests. Defaults to `None`. If set, this provides a maximum number of HTTP requests that will be serviced before terminating a process. Together with a process manager this can be used to prevent memory leaks from impacting long running processes.\n\n---\n",
      "source_file": "docs/server-behavior.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Server Errors\n\nServer errors will be logged at the `error` log level. All logging defaults to being written to `stdout`.\n",
      "source_file": "docs/server-behavior.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Exceptions\n\nIf an exception is raised by an ASGI application, and a response has not yet been sent on the connection, then a `500 Server Error` HTTP response will be sent.\n\nUvicorn sends the headers and the status code as soon as it receives from the ASGI application. This means that if the application sends a [Response Start](https://asgi.readthedocs.io/en/latest/specs/www.html#response-start-send-event)\nmessage with a status code of `200 OK`, and then an exception is raised, the response will still be sent with a status code of `200 OK`.\n",
      "source_file": "docs/server-behavior.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Invalid responses\n\nUvicorn will ensure that ASGI applications send the correct sequence of messages, and will raise errors otherwise. This includes checking for no response sent, partial response sent, or invalid message sequences being sent.\n\n---\n",
      "source_file": "docs/server-behavior.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Graceful Process Shutdown\n\nGraceful process shutdowns are particularly important during a restart period. During this period you want to:\n\n* Start a number of new server processes to handle incoming requests, listening on the existing socket.\n* Stop the previous server processes from listening on the existing socket.\n* Close any connections that are not currently waiting on an HTTP response, and wait for any other connections to finalize their HTTP responses.\n* Wait for any background tasks to run to completion, such as occurs when the ASGI application has sent the HTTP response, but the asyncio task has not yet run to completion.\n\nUvicorn handles process shutdown gracefully, ensuring that connections are properly finalized, and all tasks have run to completion. During a shutdown period Uvicorn will ensure that responses and tasks must still complete within the configured timeout periods.\n\n---\n",
      "source_file": "docs/server-behavior.md",
      "chunk_type": "doc"
    },
    {
      "content": "## HTTP Pipelining\n\nHTTP/1.1 provides support for sending multiple requests on a single connection, before having received each corresponding response. Servers are required to support HTTP pipelining, but it is now generally accepted to lead to implementation issues. It is not enabled on browsers, and may not necessarily be enabled on any proxies that the HTTP request passes through.\n\nUvicorn supports pipelining pragmatically. It will queue up any pipelined HTTP requests, and pause reading from the underlying transport. It will not start processing pipelined requests until each response has been dealt with in turn.",
      "source_file": "docs/server-behavior.md",
      "chunk_type": "doc"
    },
    {
      "content": "**Uvicorn** is available on [PyPI](https://pypi.org/project/uvicorn/) so installation is as simple as:\n\n=== \"pip\"\n\n    ```bash\n    pip install uvicorn\n    ```\n\n=== \"uv\"\n\n    ```bash\n    uv add uvicorn\n    ```\n\nThe above will install Uvicorn with the minimal set of dependencies:\n\n- [`h11`](https://github.com/python-hyper/h11) \u2014 Pure Python sans-io HTTP/1.1 implementation.\n- [`click`](https://github.com/pallets/click) \u2014 Command line interface library.\n\nIf you are running on Python 3.10 or early versions,\n[`typing_extensions`](https://github.com/python/typing_extensions) will also be installed.\n",
      "source_file": "docs/installation.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Optional Dependencies\n\nThere are many optional dependencies that can be installed to add support for various features.\n\nIf you just want to install all of them at once, you can use the `standard` extra:\n\n=== \"pip\"\n    ```bash\n    pip install 'uvicorn[standard]'\n    ```\n\n=== \"uv\"\n    ```bash\n    uv add 'uvicorn[standard]'\n    ```\n\nThe `standard` extra installs the following dependencies:\n\n- **[`uvloop`](https://github.com/MagicStack/uvloop) \u2014 Fast, drop-in replacement of the built-in asyncio event loop.**\n\n    When `uvloop` is installed, Uvicorn will use it by default.\n\n- **[`httptools`](https://github.com/MagicStack/httptools) \u2014 Python binding for the Node.js HTTP parser.**\n\n    When `httptools` is installed, Uvicorn will use it by default for HTTP/1.1 parsing.\n\n    You can read this issue to understand how it compares with `h11`: [h11/issues/9](https://github.com/python-hyper/h11/issues/9).\n\n- **[`websockets`](https://websockets.readthedocs.io/en/stable/) \u2014 WebSocket library for Python.**\n\n    When `websockets` is installed, Uvicorn will use it by default for WebSocket handling.\n\n    You can alternatively install **[`wsproto`](https://github.com/python-hyper/wsproto)** and set the `--ws`\n    option to `wsproto` to use it instead.\n\n- **[`watchfiles`](https://github.com/samuelcolvin/watchfiles) \u2014 Simple, modern and high performance file\n    watching and code reload in python.**\n\n    When `watchfiles` is installed, Uvicorn will use it by default for the `--reload` option.\n\n- **[`colorama`](https://github.com/tartley/colorama) \u2014 Cross-platform support for ANSI terminal\n    colors.**\n\n    This is installed only on Windows, to provide colored logs.\n\n- **[`python-dotenv`](https://github.com/theskumar/python-dotenv) \u2014 Reads key-value pairs from a `.env` file\n    and adds them to the environment.**\n\n    This is installed to allow you to use the `--env-file` option.\n\n- **[`PyYAML`](https://github.com/yaml/pyyaml) \u2014 YAML parser and emitter for Python.**\n\n    This is installed to allow you to provide a `.yaml` file to the `--log-config` option.",
      "source_file": "docs/installation.md",
      "chunk_type": "doc"
    },
    {
      "content": "#!/bin/sh -e\n\nexport PREFIX=\"\"\nif [ -d 'venv' ] ; then\n    export PREFIX=\"venv/bin/\"\n    export PATH=${PREFIX}:${PATH}\nfi\nexport SOURCE_FILES=\"uvicorn tests\"\n\nset -x\n\n${PREFIX}ruff format $SOURCE_FILES\n${PREFIX}ruff check --fix $SOURCE_FILES\n",
      "source_file": "scripts/lint",
      "chunk_type": "unknown"
    },
    {
      "content": "#!/bin/sh -e\n\n# Use the Python executable provided from the `-p` option, or a default.\n[ \"$1\" = \"-p\" ] && PYTHON=$2 || PYTHON=\"python3\"\n\nREQUIREMENTS=\"requirements.txt\"\nVENV=\"venv\"\n\nset -x\n\nif [ -z \"$GITHUB_ACTIONS\" ]; then\n    \"$PYTHON\" -m venv \"$VENV\"\n    PIP=\"$VENV/bin/pip\"\nelse\n    PIP=\"$PYTHON -m pip\"\nfi\n\n${PIP} install -U pip\n${PIP} install -r \"$REQUIREMENTS\"\n",
      "source_file": "scripts/install",
      "chunk_type": "unknown"
    },
    {
      "content": "#!/bin/sh -e\n\nPREFIX=\"\"\nif [ -d \"venv\" ] ; then\n    PREFIX=\"venv/bin/\"\nfi\n\nset -x\n\n${PREFIX}mkdocs \"$@\"\n",
      "source_file": "scripts/docs",
      "chunk_type": "unknown"
    },
    {
      "content": "#!/bin/sh -e\n\nVERSION_FILE=\"uvicorn/__init__.py\"\n\nif [ -d 'venv' ] ; then\n    PREFIX=\"venv/bin/\"\nelse\n    PREFIX=\"\"\nfi\n\nif [ ! -z \"$GITHUB_ACTIONS\" ]; then\n  git config --local user.email \"41898282+github-actions[bot]@users.noreply.github.com\"\n  git config --local user.name \"GitHub Action\"\n\n  VERSION=`grep __version__ ${VERSION_FILE} | grep -o '[0-9][^\"]*'`\n\n  if [ \"refs/tags/${VERSION}\" != \"${GITHUB_REF}\" ] ; then\n    echo \"GitHub Ref '${GITHUB_REF}' did not match package version '${VERSION}'\"\n    exit 1\n  fi\nfi\n\nset -x\n\n${PREFIX}twine upload dist/*\n${PREFIX}mkdocs gh-deploy --force\n",
      "source_file": "scripts/publish",
      "chunk_type": "unknown"
    },
    {
      "content": "#!/bin/sh -e\n\nexport PREFIX=\"\"\nif [ -d 'venv' ] ; then\n    export PREFIX=\"venv/bin/\"\n    export PATH=${PREFIX}:${PATH}\nfi\nexport SOURCE_FILES=\"uvicorn tests\"\n\nset -x\n\n./scripts/sync-version\n${PREFIX}ruff format --check --diff $SOURCE_FILES\n${PREFIX}mypy $SOURCE_FILES\n${PREFIX}ruff check $SOURCE_FILES\n",
      "source_file": "scripts/check",
      "chunk_type": "unknown"
    },
    {
      "content": "#!/bin/sh -e\n\nSEMVER_REGEX=\"([0-9]+)\\.([0-9]+)\\.([0-9]+)(?:-([0-9A-Za-z-]+(?:\\.[0-9A-Za-z-]+)*))?(?:\\+[0-9A-Za-z-]+)?\"\nCHANGELOG_VERSION=$(grep -o -E $SEMVER_REGEX docs/release-notes.md | head -1)\nVERSION=$(grep -o -E $SEMVER_REGEX uvicorn/__init__.py | head -1)\nif [ \"$CHANGELOG_VERSION\" != \"$VERSION\" ]; then\n    echo \"Version in changelog does not match version in uvicorn/__init__.py!\"\n    exit 1\nfi\n",
      "source_file": "scripts/sync-version",
      "chunk_type": "unknown"
    },
    {
      "content": "\"\"\"\nCopyright (c) Django Software Foundation and individual contributors.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n    1. Redistributions of source code must retain the above copyright notice,\n       this list of conditions and the following disclaimer.\n\n    2. Redistributions in binary form must reproduce the above copyright\n       notice, this list of conditions and the following disclaimer in the\n       documentation and/or other materials provided with the distribution.\n\n    3. Neither the name of Django nor the names of its contributors may be used\n       to endorse or promote products derived from this software without\n       specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport sys\nimport types\nfrom collections.abc import Awaitable, Iterable, MutableMapping\nfrom typing import Any, Callable, Literal, Optional, Protocol, TypedDict, Union\n\nif sys.version_info >= (3, 11):  # pragma: py-lt-311\n    from typing import NotRequired\nelse:  # pragma: py-gte-311\n    from typing_extensions import NotRequired\n\n# WSGI\nEnviron = MutableMapping[str, Any]\nExcInfo = tuple[type[BaseException], BaseException, Optional[types.TracebackType]]\nStartResponse = Callable[[str, Iterable[tuple[str, str]], Optional[ExcInfo]], None]\nWSGIApp = Callable[[Environ, StartResponse], Union[Iterable[bytes], BaseException]]\n\n\n# ASGI",
      "start_line": 0,
      "end_line": 50,
      "source_file": "uvicorn/_types.py",
      "chunk_type": "code"
    },
    {
      "content": "class ASGIVersions(TypedDict):\n    spec_version: str\n    version: Literal[\"2.0\"] | Literal[\"3.0\"]\n\n",
      "start_line": 50,
      "end_line": 55,
      "source_file": "uvicorn/_types.py",
      "chunk_type": "code"
    },
    {
      "content": "class HTTPScope(TypedDict):\n    type: Literal[\"http\"]\n    asgi: ASGIVersions\n    http_version: str\n    method: str\n    scheme: str\n    path: str\n    raw_path: bytes\n    query_string: bytes\n    root_path: str\n    headers: Iterable[tuple[bytes, bytes]]\n    client: tuple[str, int] | None\n    server: tuple[str, int | None] | None\n    state: NotRequired[dict[str, Any]]\n    extensions: NotRequired[dict[str, dict[object, object]]]\n\n",
      "start_line": 55,
      "end_line": 72,
      "source_file": "uvicorn/_types.py",
      "chunk_type": "code"
    },
    {
      "content": "class WebSocketScope(TypedDict):\n    type: Literal[\"websocket\"]\n    asgi: ASGIVersions\n    http_version: str\n    scheme: str\n    path: str\n    raw_path: bytes\n    query_string: bytes\n    root_path: str\n    headers: Iterable[tuple[bytes, bytes]]\n    client: tuple[str, int] | None\n    server: tuple[str, int | None] | None\n    subprotocols: Iterable[str]\n    state: NotRequired[dict[str, Any]]\n    extensions: NotRequired[dict[str, dict[object, object]]]\n\n",
      "start_line": 72,
      "end_line": 89,
      "source_file": "uvicorn/_types.py",
      "chunk_type": "code"
    },
    {
      "content": "class LifespanScope(TypedDict):\n    type: Literal[\"lifespan\"]\n    asgi: ASGIVersions\n    state: NotRequired[dict[str, Any]]\n\n\nWWWScope = Union[HTTPScope, WebSocketScope]\nScope = Union[HTTPScope, WebSocketScope, LifespanScope]\n\n",
      "start_line": 89,
      "end_line": 99,
      "source_file": "uvicorn/_types.py",
      "chunk_type": "code"
    },
    {
      "content": "class HTTPRequestEvent(TypedDict):\n    type: Literal[\"http.request\"]\n    body: bytes\n    more_body: bool\n\n",
      "start_line": 99,
      "end_line": 105,
      "source_file": "uvicorn/_types.py",
      "chunk_type": "code"
    },
    {
      "content": "class HTTPResponseDebugEvent(TypedDict):\n    type: Literal[\"http.response.debug\"]\n    info: dict[str, object]\n\n",
      "start_line": 105,
      "end_line": 110,
      "source_file": "uvicorn/_types.py",
      "chunk_type": "code"
    },
    {
      "content": "class HTTPResponseStartEvent(TypedDict):\n    type: Literal[\"http.response.start\"]\n    status: int\n    headers: NotRequired[Iterable[tuple[bytes, bytes]]]\n    trailers: NotRequired[bool]\n\n",
      "start_line": 110,
      "end_line": 117,
      "source_file": "uvicorn/_types.py",
      "chunk_type": "code"
    },
    {
      "content": "class HTTPResponseBodyEvent(TypedDict):\n    type: Literal[\"http.response.body\"]\n    body: bytes\n    more_body: NotRequired[bool]\n\n",
      "start_line": 117,
      "end_line": 123,
      "source_file": "uvicorn/_types.py",
      "chunk_type": "code"
    },
    {
      "content": "class HTTPResponseTrailersEvent(TypedDict):\n    type: Literal[\"http.response.trailers\"]\n    headers: Iterable[tuple[bytes, bytes]]\n    more_trailers: bool\n\n",
      "start_line": 123,
      "end_line": 129,
      "source_file": "uvicorn/_types.py",
      "chunk_type": "code"
    },
    {
      "content": "class HTTPServerPushEvent(TypedDict):\n    type: Literal[\"http.response.push\"]\n    path: str\n    headers: Iterable[tuple[bytes, bytes]]\n\n",
      "start_line": 129,
      "end_line": 135,
      "source_file": "uvicorn/_types.py",
      "chunk_type": "code"
    },
    {
      "content": "class HTTPDisconnectEvent(TypedDict):\n    type: Literal[\"http.disconnect\"]\n\n",
      "start_line": 135,
      "end_line": 139,
      "source_file": "uvicorn/_types.py",
      "chunk_type": "code"
    },
    {
      "content": "class WebSocketConnectEvent(TypedDict):\n    type: Literal[\"websocket.connect\"]\n\n",
      "start_line": 139,
      "end_line": 143,
      "source_file": "uvicorn/_types.py",
      "chunk_type": "code"
    },
    {
      "content": "class WebSocketAcceptEvent(TypedDict):\n    type: Literal[\"websocket.accept\"]\n    subprotocol: NotRequired[str | None]\n    headers: NotRequired[Iterable[tuple[bytes, bytes]]]\n\n",
      "start_line": 143,
      "end_line": 149,
      "source_file": "uvicorn/_types.py",
      "chunk_type": "code"
    },
    {
      "content": "class _WebSocketReceiveEventBytes(TypedDict):\n    type: Literal[\"websocket.receive\"]\n    bytes: bytes\n    text: NotRequired[None]\n\n",
      "start_line": 149,
      "end_line": 155,
      "source_file": "uvicorn/_types.py",
      "chunk_type": "code"
    },
    {
      "content": "class _WebSocketReceiveEventText(TypedDict):\n    type: Literal[\"websocket.receive\"]\n    bytes: NotRequired[None]\n    text: str\n\n\nWebSocketReceiveEvent = Union[_WebSocketReceiveEventBytes, _WebSocketReceiveEventText]\n\n",
      "start_line": 155,
      "end_line": 164,
      "source_file": "uvicorn/_types.py",
      "chunk_type": "code"
    },
    {
      "content": "class _WebSocketSendEventBytes(TypedDict):\n    type: Literal[\"websocket.send\"]\n    bytes: bytes\n    text: NotRequired[None]\n\n",
      "start_line": 164,
      "end_line": 170,
      "source_file": "uvicorn/_types.py",
      "chunk_type": "code"
    },
    {
      "content": "class _WebSocketSendEventText(TypedDict):\n    type: Literal[\"websocket.send\"]\n    bytes: NotRequired[None]\n    text: str\n\n\nWebSocketSendEvent = Union[_WebSocketSendEventBytes, _WebSocketSendEventText]\n\n",
      "start_line": 170,
      "end_line": 179,
      "source_file": "uvicorn/_types.py",
      "chunk_type": "code"
    },
    {
      "content": "class WebSocketResponseStartEvent(TypedDict):\n    type: Literal[\"websocket.http.response.start\"]\n    status: int\n    headers: Iterable[tuple[bytes, bytes]]\n\n",
      "start_line": 179,
      "end_line": 185,
      "source_file": "uvicorn/_types.py",
      "chunk_type": "code"
    },
    {
      "content": "class WebSocketResponseBodyEvent(TypedDict):\n    type: Literal[\"websocket.http.response.body\"]\n    body: bytes\n    more_body: NotRequired[bool]\n\n",
      "start_line": 185,
      "end_line": 191,
      "source_file": "uvicorn/_types.py",
      "chunk_type": "code"
    },
    {
      "content": "class WebSocketDisconnectEvent(TypedDict):\n    type: Literal[\"websocket.disconnect\"]\n    code: int\n    reason: NotRequired[str | None]\n\n",
      "start_line": 191,
      "end_line": 197,
      "source_file": "uvicorn/_types.py",
      "chunk_type": "code"
    },
    {
      "content": "class WebSocketCloseEvent(TypedDict):\n    type: Literal[\"websocket.close\"]\n    code: NotRequired[int]\n    reason: NotRequired[str | None]\n\n",
      "start_line": 197,
      "end_line": 203,
      "source_file": "uvicorn/_types.py",
      "chunk_type": "code"
    },
    {
      "content": "class LifespanStartupEvent(TypedDict):\n    type: Literal[\"lifespan.startup\"]\n\n",
      "start_line": 203,
      "end_line": 207,
      "source_file": "uvicorn/_types.py",
      "chunk_type": "code"
    },
    {
      "content": "class LifespanShutdownEvent(TypedDict):\n    type: Literal[\"lifespan.shutdown\"]\n\n",
      "start_line": 207,
      "end_line": 211,
      "source_file": "uvicorn/_types.py",
      "chunk_type": "code"
    },
    {
      "content": "class LifespanStartupCompleteEvent(TypedDict):\n    type: Literal[\"lifespan.startup.complete\"]\n\n",
      "start_line": 211,
      "end_line": 215,
      "source_file": "uvicorn/_types.py",
      "chunk_type": "code"
    },
    {
      "content": "class LifespanStartupFailedEvent(TypedDict):\n    type: Literal[\"lifespan.startup.failed\"]\n    message: str\n\n",
      "start_line": 215,
      "end_line": 220,
      "source_file": "uvicorn/_types.py",
      "chunk_type": "code"
    },
    {
      "content": "class LifespanShutdownCompleteEvent(TypedDict):\n    type: Literal[\"lifespan.shutdown.complete\"]\n\n",
      "start_line": 220,
      "end_line": 224,
      "source_file": "uvicorn/_types.py",
      "chunk_type": "code"
    },
    {
      "content": "class LifespanShutdownFailedEvent(TypedDict):\n    type: Literal[\"lifespan.shutdown.failed\"]\n    message: str\n\n\nWebSocketEvent = Union[WebSocketReceiveEvent, WebSocketDisconnectEvent, WebSocketConnectEvent]\n\n\nASGIReceiveEvent = Union[\n    HTTPRequestEvent,\n    HTTPDisconnectEvent,\n    WebSocketConnectEvent,\n    WebSocketReceiveEvent,\n    WebSocketDisconnectEvent,\n    LifespanStartupEvent,\n    LifespanShutdownEvent,\n]\n\n\nASGISendEvent = Union[\n    HTTPResponseStartEvent,\n    HTTPResponseBodyEvent,\n    HTTPResponseTrailersEvent,\n    HTTPServerPushEvent,\n    HTTPDisconnectEvent,\n    WebSocketAcceptEvent,\n    WebSocketSendEvent,\n    WebSocketResponseStartEvent,\n    WebSocketResponseBodyEvent,\n    WebSocketCloseEvent,\n    LifespanStartupCompleteEvent,\n    LifespanStartupFailedEvent,\n    LifespanShutdownCompleteEvent,\n    LifespanShutdownFailedEvent,\n]\n\n\nASGIReceiveCallable = Callable[[], Awaitable[ASGIReceiveEvent]]\nASGISendCallable = Callable[[ASGISendEvent], Awaitable[None]]\n\n",
      "start_line": 224,
      "end_line": 265,
      "source_file": "uvicorn/_types.py",
      "chunk_type": "code"
    },
    {
      "content": "class ASGI2Protocol(Protocol):",
      "start_line": 265,
      "end_line": 266,
      "source_file": "uvicorn/_types.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, scope: Scope) -> None: ...  # pragma: no cover\n\n    async def __call__(self, receive: ASGIReceiveCallable, send: ASGISendCallable) -> None: ...  # pragma: no cover\n\n\nASGI2Application = type[ASGI2Protocol]\nASGI3Application = Callable[\n    [\n        Scope,\n        ASGIReceiveCallable,\n        ASGISendCallable,\n    ],\n    Awaitable[None],\n]\nASGIApplication = Union[ASGI2Application, ASGI3Application]",
      "start_line": 266,
      "end_line": 281,
      "source_file": "uvicorn/_types.py",
      "chunk_type": "code"
    },
    {
      "content": "from __future__ import annotations\n\nimport asyncio\nimport contextlib\nimport logging\nimport os\nimport platform\nimport signal\nimport socket\nimport sys\nimport threading\nimport time\nfrom collections.abc import Generator, Sequence\nfrom email.utils import formatdate\nfrom types import FrameType\nfrom typing import TYPE_CHECKING, Union\n\nimport click\n\nfrom uvicorn._compat import asyncio_run\nfrom uvicorn.config import Config\n\nif TYPE_CHECKING:\n    from uvicorn.protocols.http.h11_impl import H11Protocol\n    from uvicorn.protocols.http.httptools_impl import HttpToolsProtocol\n    from uvicorn.protocols.websockets.websockets_impl import WebSocketProtocol\n    from uvicorn.protocols.websockets.websockets_sansio_impl import WebSocketsSansIOProtocol\n    from uvicorn.protocols.websockets.wsproto_impl import WSProtocol\n\n    Protocols = Union[H11Protocol, HttpToolsProtocol, WSProtocol, WebSocketProtocol, WebSocketsSansIOProtocol]\n\nHANDLED_SIGNALS = (\n    signal.SIGINT,  # Unix signal 2. Sent by Ctrl+C.\n    signal.SIGTERM,  # Unix signal 15. Sent by `kill <pid>`.\n)\nif sys.platform == \"win32\":  # pragma: py-not-win32\n    HANDLED_SIGNALS += (signal.SIGBREAK,)  # Windows signal 21. Sent by Ctrl+Break.\n\nlogger = logging.getLogger(\"uvicorn.error\")\n\n",
      "start_line": 0,
      "end_line": 41,
      "source_file": "uvicorn/server.py",
      "chunk_type": "code"
    },
    {
      "content": "class ServerState:\n    \"\"\"\n    Shared servers state that is available between all protocol instances.\n    \"\"\"\n",
      "start_line": 41,
      "end_line": 46,
      "source_file": "uvicorn/server.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self) -> None:\n        self.total_requests = 0\n        self.connections: set[Protocols] = set()\n        self.tasks: set[asyncio.Task[None]] = set()\n        self.default_headers: list[tuple[bytes, bytes]] = []\n\n",
      "start_line": 46,
      "end_line": 53,
      "source_file": "uvicorn/server.py",
      "chunk_type": "code"
    },
    {
      "content": "class Server:",
      "start_line": 53,
      "end_line": 54,
      "source_file": "uvicorn/server.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, config: Config) -> None:\n        self.config = config\n        self.server_state = ServerState()\n\n        self.started = False\n        self.should_exit = False\n        self.force_exit = False\n        self.last_notified = 0.0\n\n        self._captured_signals: list[int] = []\n",
      "start_line": 54,
      "end_line": 65,
      "source_file": "uvicorn/server.py",
      "chunk_type": "code"
    },
    {
      "content": "    def run(self, sockets: list[socket.socket] | None = None) -> None:\n        return asyncio_run(self.serve(sockets=sockets), loop_factory=self.config.get_loop_factory())\n\n    async def serve(self, sockets: list[socket.socket] | None = None) -> None:\n        with self.capture_signals():\n            await self._serve(sockets)\n\n    async def _serve(self, sockets: list[socket.socket] | None = None) -> None:\n        process_id = os.getpid()\n\n        config = self.config\n        if not config.loaded:\n            config.load()\n\n        self.lifespan = config.lifespan_class(config)\n\n        message = \"Started server process [%d]\"\n        color_message = \"Started server process [\" + click.style(\"%d\", fg=\"cyan\") + \"]\"\n        logger.info(message, process_id, extra={\"color_message\": color_message})\n\n        await self.startup(sockets=sockets)\n        if self.should_exit:\n            return\n        await self.main_loop()\n        await self.shutdown(sockets=sockets)\n\n        message = \"Finished server process [%d]\"\n        color_message = \"Finished server process [\" + click.style(\"%d\", fg=\"cyan\") + \"]\"\n        logger.info(message, process_id, extra={\"color_message\": color_message})\n\n    async def startup(self, sockets: list[socket.socket] | None = None) -> None:\n        await self.lifespan.startup()\n        if self.lifespan.should_exit:\n            self.should_exit = True\n            return\n\n        config = self.config\n",
      "start_line": 65,
      "end_line": 103,
      "source_file": "uvicorn/server.py",
      "chunk_type": "code"
    },
    {
      "content": "        def create_protocol(\n            _loop: asyncio.AbstractEventLoop | None = None,\n        ) -> asyncio.Protocol:\n            return config.http_protocol_class(  # type: ignore[call-arg]\n                config=config,\n                server_state=self.server_state,\n                app_state=self.lifespan.state,\n                _loop=_loop,\n            )\n\n        loop = asyncio.get_running_loop()\n\n        listeners: Sequence[socket.SocketType]\n        if sockets is not None:  # pragma: full coverage\n            # Explicitly passed a list of open sockets.\n            # We use this when the server is run from a Gunicorn worker.\n",
      "start_line": 103,
      "end_line": 120,
      "source_file": "uvicorn/server.py",
      "chunk_type": "code"
    },
    {
      "content": "            def _share_socket(\n                sock: socket.SocketType,\n            ) -> socket.SocketType:  # pragma py-not-win32\n                # Windows requires the socket be explicitly shared across\n                # multiple workers (processes).\n                from socket import fromshare  # type: ignore[attr-defined]\n\n                sock_data = sock.share(os.getpid())  # type: ignore[attr-defined]\n                return fromshare(sock_data)\n\n            self.servers: list[asyncio.base_events.Server] = []\n            for sock in sockets:\n                is_windows = platform.system() == \"Windows\"\n                if config.workers > 1 and is_windows:  # pragma: py-not-win32\n                    sock = _share_socket(sock)  # type: ignore[assignment]\n                server = await loop.create_server(create_protocol, sock=sock, ssl=config.ssl, backlog=config.backlog)\n                self.servers.append(server)\n            listeners = sockets\n\n        elif config.fd is not None:  # pragma: py-win32\n            # Use an existing socket, from a file descriptor.\n            sock = socket.fromfd(config.fd, socket.AF_UNIX, socket.SOCK_STREAM)\n            server = await loop.create_server(create_protocol, sock=sock, ssl=config.ssl, backlog=config.backlog)\n            assert server.sockets is not None  # mypy\n            listeners = server.sockets\n            self.servers = [server]\n\n        elif config.uds is not None:  # pragma: py-win32\n            # Create a socket using UNIX domain socket.\n            uds_perms = 0o666\n            if os.path.exists(config.uds):\n                uds_perms = os.stat(config.uds).st_mode  # pragma: full coverage\n            server = await loop.create_unix_server(\n                create_protocol, path=config.uds, ssl=config.ssl, backlog=config.backlog\n            )\n            os.chmod(config.uds, uds_perms)\n            assert server.sockets is not None  # mypy\n            listeners = server.sockets\n            self.servers = [server]\n\n        else:\n            # Standard case. Create a socket from a host/port pair.\n            try:\n                server = await loop.create_server(\n                    create_protocol,\n                    host=config.host,\n                    port=config.port,\n                    ssl=config.ssl,\n                    backlog=config.backlog,\n                )\n            except OSError as exc:\n                logger.error(exc)\n                await self.lifespan.shutdown()\n                sys.exit(1)\n\n            assert server.sockets is not None\n            listeners = server.sockets\n            self.servers = [server]\n\n        if sockets is None:\n            self._log_started_message(listeners)\n        else:\n            # We're most likely running multiple workers, so a message has already been\n            # logged by `config.bind_socket()`.\n            pass  # pragma: full coverage\n\n        self.started = True\n",
      "start_line": 120,
      "end_line": 188,
      "source_file": "uvicorn/server.py",
      "chunk_type": "code"
    },
    {
      "content": "    def _log_started_message(self, listeners: Sequence[socket.SocketType]) -> None:\n        config = self.config\n\n        if config.fd is not None:  # pragma: py-win32\n            sock = listeners[0]\n            logger.info(\n                \"Uvicorn running on socket %s (Press CTRL+C to quit)\",\n                sock.getsockname(),\n            )\n\n        elif config.uds is not None:  # pragma: py-win32\n            logger.info(\"Uvicorn running on unix socket %s (Press CTRL+C to quit)\", config.uds)\n\n        else:\n            addr_format = \"%s://%s:%d\"\n            host = \"0.0.0.0\" if config.host is None else config.host\n            if \":\" in host:\n                # It's an IPv6 address.\n                addr_format = \"%s://[%s]:%d\"\n\n            port = config.port\n            if port == 0:\n                port = listeners[0].getsockname()[1]\n\n            protocol_name = \"https\" if config.ssl else \"http\"\n            message = f\"Uvicorn running on {addr_format} (Press CTRL+C to quit)\"\n            color_message = \"Uvicorn running on \" + click.style(addr_format, bold=True) + \" (Press CTRL+C to quit)\"\n            logger.info(\n                message,\n                protocol_name,\n                host,\n                port,\n                extra={\"color_message\": color_message},\n            )\n\n    async def main_loop(self) -> None:\n        counter = 0\n        should_exit = await self.on_tick(counter)\n        while not should_exit:\n            counter += 1\n            counter = counter % 864000\n            await asyncio.sleep(0.1)\n            should_exit = await self.on_tick(counter)\n\n    async def on_tick(self, counter: int) -> bool:\n        # Update the default headers, once per second.\n        if counter % 10 == 0:\n            current_time = time.time()\n            current_date = formatdate(current_time, usegmt=True).encode()\n\n            if self.config.date_header:\n                date_header = [(b\"date\", current_date)]\n            else:\n                date_header = []\n\n            self.server_state.default_headers = date_header + self.config.encoded_headers\n\n            # Callback to `callback_notify` once every `timeout_notify` seconds.\n            if self.config.callback_notify is not None:\n                if current_time - self.last_notified > self.config.timeout_notify:  # pragma: full coverage\n                    self.last_notified = current_time\n                    await self.config.callback_notify()\n\n        # Determine if we should exit.\n        if self.should_exit:\n            return True\n\n        max_requests = self.config.limit_max_requests\n        if max_requests is not None and self.server_state.total_requests >= max_requests:\n            logger.warning(f\"Maximum request limit of {max_requests} exceeded. Terminating process.\")\n            return True\n\n        return False\n\n    async def shutdown(self, sockets: list[socket.socket] | None = None) -> None:\n        logger.info(\"Shutting down\")\n\n        # Stop accepting new connections.\n        for server in self.servers:\n            server.close()\n        for sock in sockets or []:\n            sock.close()  # pragma: full coverage\n\n        # Request shutdown on all existing connections.\n        for connection in list(self.server_state.connections):\n            connection.shutdown()\n        await asyncio.sleep(0.1)\n\n        # When 3.10 is not supported anymore, use `async with asyncio.timeout(...):`.\n        try:\n            await asyncio.wait_for(\n                self._wait_tasks_to_complete(),\n                timeout=self.config.timeout_graceful_shutdown,\n            )\n        except asyncio.TimeoutError:\n            logger.error(\n                \"Cancel %s running task(s), timeout graceful shutdown exceeded\",\n                len(self.server_state.tasks),\n            )\n            for t in self.server_state.tasks:\n                t.cancel(msg=\"Task cancelled, timeout graceful shutdown exceeded\")\n\n        # Send the lifespan shutdown event, and wait for application shutdown.\n        if not self.force_exit:\n            await self.lifespan.shutdown()\n\n    async def _wait_tasks_to_complete(self) -> None:\n        # Wait for existing connections to finish sending responses.\n        if self.server_state.connections and not self.force_exit:\n            msg = \"Waiting for connections to close. (CTRL+C to force quit)\"\n            logger.info(msg)\n            while self.server_state.connections and not self.force_exit:\n                await asyncio.sleep(0.1)\n\n        # Wait for existing tasks to complete.\n        if self.server_state.tasks and not self.force_exit:\n            msg = \"Waiting for background tasks to complete. (CTRL+C to force quit)\"\n            logger.info(msg)\n            while self.server_state.tasks and not self.force_exit:\n                await asyncio.sleep(0.1)\n\n        for server in self.servers:\n            await server.wait_closed()\n\n    @contextlib.contextmanager",
      "start_line": 188,
      "end_line": 313,
      "source_file": "uvicorn/server.py",
      "chunk_type": "code"
    },
    {
      "content": "    def capture_signals(self) -> Generator[None, None, None]:\n        # Signals can only be listened to from the main thread.\n        if threading.current_thread() is not threading.main_thread():\n            yield\n            return\n        # always use signal.signal, even if loop.add_signal_handler is available\n        # this allows to restore previous signal handlers later on\n        original_handlers = {sig: signal.signal(sig, self.handle_exit) for sig in HANDLED_SIGNALS}\n        try:\n            yield\n        finally:\n            for sig, handler in original_handlers.items():\n                signal.signal(sig, handler)\n        # If we did gracefully shut down due to a signal, try to\n        # trigger the expected behaviour now; multiple signals would be\n        # done LIFO, see https://stackoverflow.com/questions/48434964\n        for captured_signal in reversed(self._captured_signals):\n            signal.raise_signal(captured_signal)\n",
      "start_line": 313,
      "end_line": 332,
      "source_file": "uvicorn/server.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_exit(self, sig: int, frame: FrameType | None) -> None:\n        self._captured_signals.append(sig)\n        if self.should_exit and sig == signal.SIGINT:\n            self.force_exit = True  # pragma: full coverage\n        else:\n            self.should_exit = True",
      "start_line": 332,
      "end_line": 338,
      "source_file": "uvicorn/server.py",
      "chunk_type": "code"
    },
    {
      "content": "from __future__ import annotations\n\nimport asyncio\nimport inspect\nimport json\nimport logging\nimport logging.config\nimport os\nimport socket\nimport ssl\nimport sys\nfrom collections.abc import Awaitable\nfrom configparser import RawConfigParser\nfrom pathlib import Path\nfrom typing import IO, Any, Callable, Literal\n\nimport click\n\nfrom uvicorn._types import ASGIApplication\nfrom uvicorn.importer import ImportFromStringError, import_from_string\nfrom uvicorn.logging import TRACE_LOG_LEVEL\nfrom uvicorn.middleware.asgi2 import ASGI2Middleware\nfrom uvicorn.middleware.message_logger import MessageLoggerMiddleware\nfrom uvicorn.middleware.proxy_headers import ProxyHeadersMiddleware\nfrom uvicorn.middleware.wsgi import WSGIMiddleware\n\nHTTPProtocolType = Literal[\"auto\", \"h11\", \"httptools\"]\nWSProtocolType = Literal[\"auto\", \"none\", \"websockets\", \"websockets-sansio\", \"wsproto\"]\nLifespanType = Literal[\"auto\", \"on\", \"off\"]\nLoopFactoryType = Literal[\"none\", \"auto\", \"asyncio\", \"uvloop\"]\nInterfaceType = Literal[\"auto\", \"asgi3\", \"asgi2\", \"wsgi\"]\n\nLOG_LEVELS: dict[str, int] = {\n    \"critical\": logging.CRITICAL,\n    \"error\": logging.ERROR,\n    \"warning\": logging.WARNING,\n    \"info\": logging.INFO,\n    \"debug\": logging.DEBUG,\n    \"trace\": TRACE_LOG_LEVEL,\n}\nHTTP_PROTOCOLS: dict[str, str] = {\n    \"auto\": \"uvicorn.protocols.http.auto:AutoHTTPProtocol\",\n    \"h11\": \"uvicorn.protocols.http.h11_impl:H11Protocol\",\n    \"httptools\": \"uvicorn.protocols.http.httptools_impl:HttpToolsProtocol\",\n}\nWS_PROTOCOLS: dict[str, str | None] = {\n    \"auto\": \"uvicorn.protocols.websockets.auto:AutoWebSocketsProtocol\",\n    \"none\": None,\n    \"websockets\": \"uvicorn.protocols.websockets.websockets_impl:WebSocketProtocol\",\n    \"websockets-sansio\": \"uvicorn.protocols.websockets.websockets_sansio_impl:WebSocketsSansIOProtocol\",\n    \"wsproto\": \"uvicorn.protocols.websockets.wsproto_impl:WSProtocol\",\n}\nLIFESPAN: dict[str, str] = {\n    \"auto\": \"uvicorn.lifespan.on:LifespanOn\",\n    \"on\": \"uvicorn.lifespan.on:LifespanOn\",\n    \"off\": \"uvicorn.lifespan.off:LifespanOff\",\n}\nLOOP_FACTORIES: dict[str, str | None] = {\n    \"none\": None,\n    \"auto\": \"uvicorn.loops.auto:auto_loop_factory\",\n    \"asyncio\": \"uvicorn.loops.asyncio:asyncio_loop_factory\",\n    \"uvloop\": \"uvicorn.loops.uvloop:uvloop_loop_factory\",\n}\nINTERFACES: list[InterfaceType] = [\"auto\", \"asgi3\", \"asgi2\", \"wsgi\"]\n\nSSL_PROTOCOL_VERSION: int = ssl.PROTOCOL_TLS_SERVER\n\nLOGGING_CONFIG: dict[str, Any] = {\n    \"version\": 1,\n    \"disable_existing_loggers\": False,\n    \"formatters\": {\n        \"default\": {\n            \"()\": \"uvicorn.logging.DefaultFormatter\",\n            \"fmt\": \"%(levelprefix)s %(message)s\",\n            \"use_colors\": None,\n        },\n        \"access\": {\n            \"()\": \"uvicorn.logging.AccessFormatter\",\n            \"fmt\": '%(levelprefix)s %(client_addr)s - \"%(request_line)s\" %(status_code)s',  # noqa: E501\n        },\n    },\n    \"handlers\": {\n        \"default\": {\n            \"formatter\": \"default\",\n            \"class\": \"logging.StreamHandler\",\n            \"stream\": \"ext://sys.stderr\",\n        },\n        \"access\": {\n            \"formatter\": \"access\",\n            \"class\": \"logging.StreamHandler\",\n            \"stream\": \"ext://sys.stdout\",\n        },\n    },\n    \"loggers\": {\n        \"uvicorn\": {\"handlers\": [\"default\"], \"level\": \"INFO\", \"propagate\": False},\n        \"uvicorn.error\": {\"level\": \"INFO\"},\n        \"uvicorn.access\": {\"handlers\": [\"access\"], \"level\": \"INFO\", \"propagate\": False},\n    },\n}\n\nlogger = logging.getLogger(\"uvicorn.error\")\n\n",
      "start_line": 0,
      "end_line": 103,
      "source_file": "uvicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "def create_ssl_context(\n    certfile: str | os.PathLike[str],\n    keyfile: str | os.PathLike[str] | None,\n    password: str | None,\n    ssl_version: int,\n    cert_reqs: int,\n    ca_certs: str | os.PathLike[str] | None,\n    ciphers: str | None,\n) -> ssl.SSLContext:\n    ctx = ssl.SSLContext(ssl_version)\n    get_password = (lambda: password) if password else None\n    ctx.load_cert_chain(certfile, keyfile, get_password)\n    ctx.verify_mode = ssl.VerifyMode(cert_reqs)\n    if ca_certs:\n        ctx.load_verify_locations(ca_certs)\n    if ciphers:\n        ctx.set_ciphers(ciphers)\n    return ctx\n\n",
      "start_line": 103,
      "end_line": 123,
      "source_file": "uvicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "def is_dir(path: Path) -> bool:\n    try:\n        if not path.is_absolute():\n            path = path.resolve()\n        return path.is_dir()\n    except OSError:  # pragma: full coverage\n        return False\n\n",
      "start_line": 123,
      "end_line": 132,
      "source_file": "uvicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "def resolve_reload_patterns(patterns_list: list[str], directories_list: list[str]) -> tuple[list[str], list[Path]]:\n    directories: list[Path] = list(set(map(Path, directories_list.copy())))\n    patterns: list[str] = patterns_list.copy()\n\n    current_working_directory = Path.cwd()\n    for pattern in patterns_list:\n        # Special case for the .* pattern, otherwise this would only match\n        # hidden directories which is probably undesired\n        if pattern == \".*\":\n            continue  # pragma: py-not-linux\n        patterns.append(pattern)\n        if is_dir(Path(pattern)):\n            directories.append(Path(pattern))\n        else:\n            for match in current_working_directory.glob(pattern):\n                if is_dir(match):\n                    directories.append(match)\n\n    directories = list(set(directories))\n    directories = list(map(Path, directories))\n    directories = list(map(lambda x: x.resolve(), directories))\n    directories = list({reload_path for reload_path in directories if is_dir(reload_path)})\n\n    children = []\n    for j in range(len(directories)):\n        for k in range(j + 1, len(directories)):  # pragma: full coverage\n            if directories[j] in directories[k].parents:\n                children.append(directories[k])\n            elif directories[k] in directories[j].parents:\n                children.append(directories[j])\n\n    directories = list(set(directories).difference(set(children)))\n\n    return list(set(patterns)), directories\n\n",
      "start_line": 132,
      "end_line": 168,
      "source_file": "uvicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "def _normalize_dirs(dirs: list[str] | str | None) -> list[str]:\n    if dirs is None:\n        return []\n    if isinstance(dirs, str):\n        return [dirs]\n    return list(set(dirs))\n\n",
      "start_line": 168,
      "end_line": 176,
      "source_file": "uvicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class Config:",
      "start_line": 176,
      "end_line": 177,
      "source_file": "uvicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(\n        self,\n        app: ASGIApplication | Callable[..., Any] | str,\n        host: str = \"127.0.0.1\",\n        port: int = 8000,\n        uds: str | None = None,\n        fd: int | None = None,\n        loop: LoopFactoryType | str = \"auto\",\n        http: type[asyncio.Protocol] | HTTPProtocolType | str = \"auto\",\n        ws: type[asyncio.Protocol] | WSProtocolType | str = \"auto\",\n        ws_max_size: int = 16 * 1024 * 1024,\n        ws_max_queue: int = 32,\n        ws_ping_interval: float | None = 20.0,\n        ws_ping_timeout: float | None = 20.0,\n        ws_per_message_deflate: bool = True,\n        lifespan: LifespanType = \"auto\",\n        env_file: str | os.PathLike[str] | None = None,\n        log_config: dict[str, Any] | str | RawConfigParser | IO[Any] | None = LOGGING_CONFIG,\n        log_level: str | int | None = None,\n        access_log: bool = True,\n        use_colors: bool | None = None,\n        interface: InterfaceType = \"auto\",\n        reload: bool = False,\n        reload_dirs: list[str] | str | None = None,\n        reload_delay: float = 0.25,\n        reload_includes: list[str] | str | None = None,\n        reload_excludes: list[str] | str | None = None,\n        workers: int | None = None,\n        proxy_headers: bool = True,\n        server_header: bool = True,\n        date_header: bool = True,\n        forwarded_allow_ips: list[str] | str | None = None,\n        root_path: str = \"\",\n        limit_concurrency: int | None = None,\n        limit_max_requests: int | None = None,\n        backlog: int = 2048,\n        timeout_keep_alive: int = 5,\n        timeout_notify: int = 30,\n        timeout_graceful_shutdown: int | None = None,\n        callback_notify: Callable[..., Awaitable[None]] | None = None,\n        ssl_keyfile: str | os.PathLike[str] | None = None,\n        ssl_certfile: str | os.PathLike[str] | None = None,\n        ssl_keyfile_password: str | None = None,\n        ssl_version: int = SSL_PROTOCOL_VERSION,\n        ssl_cert_reqs: int = ssl.CERT_NONE,\n        ssl_ca_certs: str | None = None,\n        ssl_ciphers: str = \"TLSv1\",\n        headers: list[tuple[str, str]] | None = None,\n        factory: bool = False,\n        h11_max_incomplete_event_size: int | None = None,\n    ):\n        self.app = app\n        self.host = host\n        self.port = port\n        self.uds = uds\n        self.fd = fd\n        self.loop = loop\n        self.http = http\n        self.ws = ws\n        self.ws_max_size = ws_max_size\n        self.ws_max_queue = ws_max_queue\n        self.ws_ping_interval = ws_ping_interval\n        self.ws_ping_timeout = ws_ping_timeout\n        self.ws_per_message_deflate = ws_per_message_deflate\n        self.lifespan = lifespan\n        self.log_config = log_config\n        self.log_level = log_level\n        self.access_log = access_log\n        self.use_colors = use_colors\n        self.interface = interface\n        self.reload = reload\n        self.reload_delay = reload_delay\n        self.workers = workers or 1\n        self.proxy_headers = proxy_headers\n        self.server_header = server_header\n        self.date_header = date_header\n        self.root_path = root_path\n        self.limit_concurrency = limit_concurrency\n        self.limit_max_requests = limit_max_requests\n        self.backlog = backlog\n        self.timeout_keep_alive = timeout_keep_alive\n        self.timeout_notify = timeout_notify\n        self.timeout_graceful_shutdown = timeout_graceful_shutdown\n        self.callback_notify = callback_notify\n        self.ssl_keyfile = ssl_keyfile\n        self.ssl_certfile = ssl_certfile\n        self.ssl_keyfile_password = ssl_keyfile_password\n        self.ssl_version = ssl_version\n        self.ssl_cert_reqs = ssl_cert_reqs\n        self.ssl_ca_certs = ssl_ca_certs\n        self.ssl_ciphers = ssl_ciphers\n        self.headers: list[tuple[str, str]] = headers or []\n        self.encoded_headers: list[tuple[bytes, bytes]] = []\n        self.factory = factory\n        self.h11_max_incomplete_event_size = h11_max_incomplete_event_size\n\n        self.loaded = False\n        self.configure_logging()\n\n        self.reload_dirs: list[Path] = []\n        self.reload_dirs_excludes: list[Path] = []\n        self.reload_includes: list[str] = []\n        self.reload_excludes: list[str] = []\n\n        if (reload_dirs or reload_includes or reload_excludes) and not self.should_reload:\n            logger.warning(\n                \"Current configuration will not reload as not all conditions are met, please refer to documentation.\"\n            )\n\n        if self.should_reload:\n            reload_dirs = _normalize_dirs(reload_dirs)\n            reload_includes = _normalize_dirs(reload_includes)\n            reload_excludes = _normalize_dirs(reload_excludes)\n\n            self.reload_includes, self.reload_dirs = resolve_reload_patterns(reload_includes, reload_dirs)\n\n            self.reload_excludes, self.reload_dirs_excludes = resolve_reload_patterns(reload_excludes, [])\n\n            reload_dirs_tmp = self.reload_dirs.copy()\n\n            for directory in self.reload_dirs_excludes:\n                for reload_directory in reload_dirs_tmp:\n                    if directory == reload_directory or directory in reload_directory.parents:\n                        try:\n                            self.reload_dirs.remove(reload_directory)\n                        except ValueError:  # pragma: full coverage\n                            pass\n\n            for pattern in self.reload_excludes:\n                if pattern in self.reload_includes:\n                    self.reload_includes.remove(pattern)  # pragma: full coverage\n\n            if not self.reload_dirs:\n                if reload_dirs:\n                    logger.warning(\n                        \"Provided reload directories %s did not contain valid \"\n                        + \"directories, watching current working directory.\",\n                        reload_dirs,\n                    )\n                self.reload_dirs = [Path.cwd()]\n\n            logger.info(\n                \"Will watch for changes in these directories: %s\",\n                sorted(list(map(str, self.reload_dirs))),\n            )\n\n        if env_file is not None:\n            from dotenv import load_dotenv\n\n            logger.info(\"Loading environment from '%s'\", env_file)\n            load_dotenv(dotenv_path=env_file)\n\n        if workers is None and \"WEB_CONCURRENCY\" in os.environ:\n            self.workers = int(os.environ[\"WEB_CONCURRENCY\"])\n\n        self.forwarded_allow_ips: list[str] | str\n        if forwarded_allow_ips is None:\n            self.forwarded_allow_ips = os.environ.get(\"FORWARDED_ALLOW_IPS\", \"127.0.0.1\")\n        else:\n            self.forwarded_allow_ips = forwarded_allow_ips  # pragma: full coverage\n\n        if self.reload and self.workers > 1:\n            logger.warning('\"workers\" flag is ignored when reloading is enabled.')\n\n    @property",
      "start_line": 177,
      "end_line": 342,
      "source_file": "uvicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def asgi_version(self) -> Literal[\"2.0\", \"3.0\"]:\n        mapping: dict[str, Literal[\"2.0\", \"3.0\"]] = {\n            \"asgi2\": \"2.0\",\n            \"asgi3\": \"3.0\",\n            \"wsgi\": \"3.0\",\n        }\n        return mapping[self.interface]\n\n    @property",
      "start_line": 342,
      "end_line": 351,
      "source_file": "uvicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def is_ssl(self) -> bool:\n        return bool(self.ssl_keyfile or self.ssl_certfile)\n\n    @property",
      "start_line": 351,
      "end_line": 355,
      "source_file": "uvicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def use_subprocess(self) -> bool:\n        return bool(self.reload or self.workers > 1)\n",
      "start_line": 355,
      "end_line": 358,
      "source_file": "uvicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def configure_logging(self) -> None:\n        logging.addLevelName(TRACE_LOG_LEVEL, \"TRACE\")\n\n        if self.log_config is not None:\n            if isinstance(self.log_config, dict):\n                if self.use_colors in (True, False):\n                    self.log_config[\"formatters\"][\"default\"][\"use_colors\"] = self.use_colors\n                    self.log_config[\"formatters\"][\"access\"][\"use_colors\"] = self.use_colors\n                logging.config.dictConfig(self.log_config)\n            elif isinstance(self.log_config, str) and self.log_config.endswith(\".json\"):\n                with open(self.log_config) as file:\n                    loaded_config = json.load(file)\n                    logging.config.dictConfig(loaded_config)\n            elif isinstance(self.log_config, str) and self.log_config.endswith((\".yaml\", \".yml\")):\n                # Install the PyYAML package or the uvicorn[standard] optional\n                # dependencies to enable this functionality.\n                import yaml\n\n                with open(self.log_config) as file:\n                    loaded_config = yaml.safe_load(file)\n                    logging.config.dictConfig(loaded_config)\n            else:\n                # See the note about fileConfig() here:\n                # https://docs.python.org/3/library/logging.config.html#configuration-file-format\n                logging.config.fileConfig(self.log_config, disable_existing_loggers=False)\n\n        if self.log_level is not None:\n            if isinstance(self.log_level, str):\n                log_level = LOG_LEVELS[self.log_level]\n            else:\n                log_level = self.log_level\n            logging.getLogger(\"uvicorn.error\").setLevel(log_level)\n            logging.getLogger(\"uvicorn.access\").setLevel(log_level)\n            logging.getLogger(\"uvicorn.asgi\").setLevel(log_level)\n        if self.access_log is False:\n            logging.getLogger(\"uvicorn.access\").handlers = []\n            logging.getLogger(\"uvicorn.access\").propagate = False\n",
      "start_line": 358,
      "end_line": 396,
      "source_file": "uvicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def load(self) -> None:\n        assert not self.loaded\n\n        if self.is_ssl:\n            assert self.ssl_certfile\n            self.ssl: ssl.SSLContext | None = create_ssl_context(\n                keyfile=self.ssl_keyfile,\n                certfile=self.ssl_certfile,\n                password=self.ssl_keyfile_password,\n                ssl_version=self.ssl_version,\n                cert_reqs=self.ssl_cert_reqs,\n                ca_certs=self.ssl_ca_certs,\n                ciphers=self.ssl_ciphers,\n            )\n        else:\n            self.ssl = None\n\n        encoded_headers = [(key.lower().encode(\"latin1\"), value.encode(\"latin1\")) for key, value in self.headers]\n        self.encoded_headers = (\n            [(b\"server\", b\"uvicorn\")] + encoded_headers\n            if b\"server\" not in dict(encoded_headers) and self.server_header\n            else encoded_headers\n        )\n\n        if isinstance(self.http, str):\n            http_protocol_class = import_from_string(HTTP_PROTOCOLS.get(self.http, self.http))\n            self.http_protocol_class: type[asyncio.Protocol] = http_protocol_class\n        else:\n            self.http_protocol_class = self.http\n\n        if isinstance(self.ws, str):\n            ws_protocol_class = import_from_string(WS_PROTOCOLS.get(self.ws, self.ws))\n            self.ws_protocol_class: type[asyncio.Protocol] | None = ws_protocol_class\n        else:\n            self.ws_protocol_class = self.ws\n\n        self.lifespan_class = import_from_string(LIFESPAN[self.lifespan])\n\n        try:\n            self.loaded_app = import_from_string(self.app)\n        except ImportFromStringError as exc:\n            logger.error(\"Error loading ASGI app. %s\" % exc)\n            sys.exit(1)\n\n        try:\n            self.loaded_app = self.loaded_app()\n        except TypeError as exc:\n            if self.factory:\n                logger.error(\"Error loading ASGI app factory: %s\", exc)\n                sys.exit(1)\n        else:\n            if not self.factory:\n                logger.warning(\n                    \"ASGI app factory detected. Using it, but please consider setting the --factory flag explicitly.\"\n                )\n\n        if self.interface == \"auto\":\n            if inspect.isclass(self.loaded_app):\n                use_asgi_3 = hasattr(self.loaded_app, \"__await__\")\n            elif inspect.isfunction(self.loaded_app):\n                use_asgi_3 = inspect.iscoroutinefunction(self.loaded_app)\n            else:\n                call = getattr(self.loaded_app, \"__call__\", None)\n                use_asgi_3 = inspect.iscoroutinefunction(call)\n            self.interface = \"asgi3\" if use_asgi_3 else \"asgi2\"\n\n        if self.interface == \"wsgi\":\n            self.loaded_app = WSGIMiddleware(self.loaded_app)\n            self.ws_protocol_class = None\n        elif self.interface == \"asgi2\":\n            self.loaded_app = ASGI2Middleware(self.loaded_app)\n\n        if logger.getEffectiveLevel() <= TRACE_LOG_LEVEL:\n            self.loaded_app = MessageLoggerMiddleware(self.loaded_app)\n        if self.proxy_headers:\n            self.loaded_app = ProxyHeadersMiddleware(self.loaded_app, trusted_hosts=self.forwarded_allow_ips)\n\n        self.loaded = True\n",
      "start_line": 396,
      "end_line": 475,
      "source_file": "uvicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def get_loop_factory(self) -> Callable[[], asyncio.AbstractEventLoop] | None:\n        if self.loop in LOOP_FACTORIES:\n            loop_factory: Callable | None = import_from_string(LOOP_FACTORIES[self.loop])\n        else:\n            try:\n                return import_from_string(self.loop)\n            except ImportFromStringError as exc:\n                logger.error(\"Error loading custom loop setup function. %s\" % exc)\n                sys.exit(1)\n        if loop_factory is None:\n            return None\n        return loop_factory(use_subprocess=self.use_subprocess)\n",
      "start_line": 475,
      "end_line": 488,
      "source_file": "uvicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def bind_socket(self) -> socket.socket:\n        logger_args: list[str | int]\n        if self.uds:  # pragma: py-win32\n            path = self.uds\n            sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n            try:\n                sock.bind(path)\n                uds_perms = 0o666\n                os.chmod(self.uds, uds_perms)\n            except OSError as exc:  # pragma: full coverage\n                logger.error(exc)\n                sys.exit(1)\n\n            message = \"Uvicorn running on unix socket %s (Press CTRL+C to quit)\"\n            sock_name_format = \"%s\"\n            color_message = \"Uvicorn running on \" + click.style(sock_name_format, bold=True) + \" (Press CTRL+C to quit)\"\n            logger_args = [self.uds]\n        elif self.fd:  # pragma: py-win32\n            sock = socket.fromfd(self.fd, socket.AF_UNIX, socket.SOCK_STREAM)\n            message = \"Uvicorn running on socket %s (Press CTRL+C to quit)\"\n            fd_name_format = \"%s\"\n            color_message = \"Uvicorn running on \" + click.style(fd_name_format, bold=True) + \" (Press CTRL+C to quit)\"\n            logger_args = [sock.getsockname()]\n        else:\n            family = socket.AF_INET\n            addr_format = \"%s://%s:%d\"\n\n            if self.host and \":\" in self.host:  # pragma: full coverage\n                # It's an IPv6 address.\n                family = socket.AF_INET6\n                addr_format = \"%s://[%s]:%d\"\n\n            sock = socket.socket(family=family)\n            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n            try:\n                sock.bind((self.host, self.port))\n            except OSError as exc:  # pragma: full coverage\n                logger.error(exc)\n                sys.exit(1)\n\n            message = f\"Uvicorn running on {addr_format} (Press CTRL+C to quit)\"\n            color_message = \"Uvicorn running on \" + click.style(addr_format, bold=True) + \" (Press CTRL+C to quit)\"\n            protocol_name = \"https\" if self.is_ssl else \"http\"\n            logger_args = [protocol_name, self.host, sock.getsockname()[1]]\n        logger.info(message, *logger_args, extra={\"color_message\": color_message})\n        sock.set_inheritable(True)\n        return sock\n\n    @property",
      "start_line": 488,
      "end_line": 537,
      "source_file": "uvicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def should_reload(self) -> bool:\n        return isinstance(self.app, str) and self.reload",
      "start_line": 537,
      "end_line": 539,
      "source_file": "uvicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "import importlib\nfrom typing import Any\n\n",
      "start_line": 0,
      "end_line": 4,
      "source_file": "uvicorn/importer.py",
      "chunk_type": "code"
    },
    {
      "content": "class ImportFromStringError(Exception):\n    pass\n\n",
      "start_line": 4,
      "end_line": 8,
      "source_file": "uvicorn/importer.py",
      "chunk_type": "code"
    },
    {
      "content": "def import_from_string(import_str: Any) -> Any:\n    if not isinstance(import_str, str):\n        return import_str\n\n    module_str, _, attrs_str = import_str.partition(\":\")\n    if not module_str or not attrs_str:\n        message = 'Import string \"{import_str}\" must be in format \"<module>:<attribute>\".'\n        raise ImportFromStringError(message.format(import_str=import_str))\n\n    try:\n        module = importlib.import_module(module_str)\n    except ModuleNotFoundError as exc:\n        if exc.name != module_str:\n            raise exc from None\n        message = 'Could not import module \"{module_str}\".'\n        raise ImportFromStringError(message.format(module_str=module_str))\n\n    instance = module\n    try:\n        for attr_str in attrs_str.split(\".\"):\n            instance = getattr(instance, attr_str)\n    except AttributeError:\n        message = 'Attribute \"{attrs_str}\" not found in module \"{module_str}\".'\n        raise ImportFromStringError(message.format(attrs_str=attrs_str, module_str=module_str))\n\n    return instance",
      "start_line": 8,
      "end_line": 34,
      "source_file": "uvicorn/importer.py",
      "chunk_type": "code"
    },
    {
      "content": "\"\"\"\nSome light wrappers around Python's multiprocessing, to deal with cleanly\nstarting child processes.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport multiprocessing\nimport os\nimport sys\nfrom multiprocessing.context import SpawnProcess\nfrom socket import socket\nfrom typing import Callable\n\nfrom uvicorn.config import Config\n\nmultiprocessing.allow_connection_pickling()\nspawn = multiprocessing.get_context(\"spawn\")\n\n",
      "start_line": 0,
      "end_line": 20,
      "source_file": "uvicorn/_subprocess.py",
      "chunk_type": "code"
    },
    {
      "content": "def get_subprocess(\n    config: Config,\n    target: Callable[..., None],\n    sockets: list[socket],\n) -> SpawnProcess:\n    \"\"\"\n    Called in the parent process, to instantiate a new child process instance.\n    The child is not yet started at this point.\n\n    * config - The Uvicorn configuration instance.\n    * target - A callable that accepts a list of sockets. In practice this will\n               be the `Server.run()` method.\n    * sockets - A list of sockets to pass to the server. Sockets are bound once\n                by the parent process, and then passed to the child processes.\n    \"\"\"\n    # We pass across the stdin fileno, and reopen it in the child process.\n    # This is required for some debugging environments.\n    try:\n        stdin_fileno = sys.stdin.fileno()\n    # The `sys.stdin` can be `None`, see https://docs.python.org/3/library/sys.html#sys.__stdin__.\n    except (AttributeError, OSError):\n        stdin_fileno = None\n\n    kwargs = {\n        \"config\": config,\n        \"target\": target,\n        \"sockets\": sockets,\n        \"stdin_fileno\": stdin_fileno,\n    }\n\n    return spawn.Process(target=subprocess_started, kwargs=kwargs)\n\n",
      "start_line": 20,
      "end_line": 53,
      "source_file": "uvicorn/_subprocess.py",
      "chunk_type": "code"
    },
    {
      "content": "def subprocess_started(\n    config: Config,\n    target: Callable[..., None],\n    sockets: list[socket],\n    stdin_fileno: int | None,\n) -> None:\n    \"\"\"\n    Called when the child process starts.\n\n    * config - The Uvicorn configuration instance.\n    * target - A callable that accepts a list of sockets. In practice this will\n               be the `Server.run()` method.\n    * sockets - A list of sockets to pass to the server. Sockets are bound once\n                by the parent process, and then passed to the child processes.\n    * stdin_fileno - The file number of sys.stdin, so that it can be reattached\n                     to the child process.\n    \"\"\"\n    # Re-open stdin.\n    if stdin_fileno is not None:\n        sys.stdin = os.fdopen(stdin_fileno)  # pragma: full coverage\n\n    # Logging needs to be setup again for each child.\n    config.configure_logging()\n\n    try:\n        # Now we can call into `Server.run(sockets=sockets)`\n        target(sockets=sockets)\n    except KeyboardInterrupt:  # pragma: no cover\n        # supress the exception to avoid a traceback from subprocess.Popen\n        # the parent already expects us to end, so no vital information is lost\n        pass",
      "start_line": 53,
      "end_line": 84,
      "source_file": "uvicorn/_subprocess.py",
      "chunk_type": "code"
    },
    {
      "content": "from uvicorn.config import Config\nfrom uvicorn.main import Server, main, run\n\n__version__ = \"0.35.0\"\n__all__ = [\"main\", \"run\", \"Config\", \"Server\"]",
      "start_line": 0,
      "end_line": 5,
      "source_file": "uvicorn/__init__.py",
      "chunk_type": "code"
    },
    {
      "content": "\n",
      "source_file": "uvicorn/py.typed",
      "chunk_type": "unknown"
    },
    {
      "content": "from __future__ import annotations\n\nimport asyncio\nimport logging\nimport signal\nimport sys\nimport warnings\nfrom typing import Any\n\nfrom gunicorn.arbiter import Arbiter\nfrom gunicorn.workers.base import Worker\n\nfrom uvicorn._compat import asyncio_run\nfrom uvicorn.config import Config\nfrom uvicorn.server import Server\n\nwarnings.warn(\n    \"The `uvicorn.workers` module is deprecated. Please use `uvicorn-worker` package instead.\\n\"\n    \"For more details, see https://github.com/Kludex/uvicorn-worker.\",\n    DeprecationWarning,\n)\n\n",
      "start_line": 0,
      "end_line": 23,
      "source_file": "uvicorn/workers.py",
      "chunk_type": "code"
    },
    {
      "content": "class UvicornWorker(Worker):\n    \"\"\"\n    A worker class for Gunicorn that interfaces with an ASGI consumer callable,\n    rather than a WSGI callable.\n    \"\"\"\n\n    CONFIG_KWARGS: dict[str, Any] = {\"loop\": \"auto\", \"http\": \"auto\"}\n",
      "start_line": 23,
      "end_line": 31,
      "source_file": "uvicorn/workers.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        super().__init__(*args, **kwargs)\n\n        logger = logging.getLogger(\"uvicorn.error\")\n        logger.handlers = self.log.error_log.handlers\n        logger.setLevel(self.log.error_log.level)\n        logger.propagate = False\n\n        logger = logging.getLogger(\"uvicorn.access\")\n        logger.handlers = self.log.access_log.handlers\n        logger.setLevel(self.log.access_log.level)\n        logger.propagate = False\n\n        config_kwargs: dict = {\n            \"app\": None,\n            \"log_config\": None,\n            \"timeout_keep_alive\": self.cfg.keepalive,\n            \"timeout_notify\": self.timeout,\n            \"callback_notify\": self.callback_notify,\n            \"limit_max_requests\": self.max_requests,\n            \"forwarded_allow_ips\": self.cfg.forwarded_allow_ips,\n        }\n\n        if self.cfg.is_ssl:\n            ssl_kwargs = {\n                \"ssl_keyfile\": self.cfg.ssl_options.get(\"keyfile\"),\n                \"ssl_certfile\": self.cfg.ssl_options.get(\"certfile\"),\n                \"ssl_keyfile_password\": self.cfg.ssl_options.get(\"password\"),\n                \"ssl_version\": self.cfg.ssl_options.get(\"ssl_version\"),\n                \"ssl_cert_reqs\": self.cfg.ssl_options.get(\"cert_reqs\"),\n                \"ssl_ca_certs\": self.cfg.ssl_options.get(\"ca_certs\"),\n                \"ssl_ciphers\": self.cfg.ssl_options.get(\"ciphers\"),\n            }\n            config_kwargs.update(ssl_kwargs)\n\n        if self.cfg.settings[\"backlog\"].value:\n            config_kwargs[\"backlog\"] = self.cfg.settings[\"backlog\"].value\n\n        config_kwargs.update(self.CONFIG_KWARGS)\n\n        self.config = Config(**config_kwargs)\n",
      "start_line": 31,
      "end_line": 73,
      "source_file": "uvicorn/workers.py",
      "chunk_type": "code"
    },
    {
      "content": "    def init_signals(self) -> None:\n        # Reset signals so Gunicorn doesn't swallow subprocess return codes\n        # other signals are set up by Server.install_signal_handlers()\n        # See: https://github.com/encode/uvicorn/issues/894\n        for s in self.SIGNALS:\n            signal.signal(s, signal.SIG_DFL)\n\n        signal.signal(signal.SIGUSR1, self.handle_usr1)\n        # Don't let SIGUSR1 disturb active requests by interrupting system calls\n        signal.siginterrupt(signal.SIGUSR1, False)\n",
      "start_line": 73,
      "end_line": 84,
      "source_file": "uvicorn/workers.py",
      "chunk_type": "code"
    },
    {
      "content": "    def _install_sigquit_handler(self) -> None:\n        \"\"\"Install a SIGQUIT handler on workers.\n\n        - https://github.com/encode/uvicorn/issues/1116\n        - https://github.com/benoitc/gunicorn/issues/2604\n        \"\"\"\n\n        loop = asyncio.get_running_loop()\n        loop.add_signal_handler(signal.SIGQUIT, self.handle_exit, signal.SIGQUIT, None)\n\n    async def _serve(self) -> None:\n        self.config.app = self.wsgi\n        server = Server(config=self.config)\n        self._install_sigquit_handler()\n        await server.serve(sockets=self.sockets)\n        if not server.started:\n            sys.exit(Arbiter.WORKER_BOOT_ERROR)\n",
      "start_line": 84,
      "end_line": 102,
      "source_file": "uvicorn/workers.py",
      "chunk_type": "code"
    },
    {
      "content": "    def run(self) -> None:\n        return asyncio_run(self._serve(), loop_factory=self.config.get_loop_factory())\n\n    async def callback_notify(self) -> None:\n        self.notify()\n\n",
      "start_line": 102,
      "end_line": 109,
      "source_file": "uvicorn/workers.py",
      "chunk_type": "code"
    },
    {
      "content": "class UvicornH11Worker(UvicornWorker):\n    CONFIG_KWARGS = {\"loop\": \"asyncio\", \"http\": \"h11\"}",
      "start_line": 109,
      "end_line": 111,
      "source_file": "uvicorn/workers.py",
      "chunk_type": "code"
    },
    {
      "content": "from __future__ import annotations\n\nimport asyncio\nimport sys\nfrom collections.abc import Callable, Coroutine\nfrom typing import Any, TypeVar\n\n_T = TypeVar(\"_T\")\n\nif sys.version_info >= (3, 12):\n    asyncio_run = asyncio.run\nelif sys.version_info >= (3, 11):\n",
      "start_line": 0,
      "end_line": 13,
      "source_file": "uvicorn/_compat.py",
      "chunk_type": "code"
    },
    {
      "content": "    def asyncio_run(\n        main: Coroutine[Any, Any, _T],\n        *,\n        debug: bool = False,\n        loop_factory: Callable[[], asyncio.AbstractEventLoop] | None = None,\n    ) -> _T:\n        # asyncio.run from Python 3.12\n        # https://docs.python.org/3/license.html#psf-license\n        with asyncio.Runner(debug=debug, loop_factory=loop_factory) as runner:\n            return runner.run(main)\n\nelse:\n    # modified version of asyncio.run from Python 3.10 to add loop_factory kwarg\n    # https://docs.python.org/3/license.html#psf-license",
      "start_line": 13,
      "end_line": 27,
      "source_file": "uvicorn/_compat.py",
      "chunk_type": "code"
    },
    {
      "content": "    def asyncio_run(\n        main: Coroutine[Any, Any, _T],\n        *,\n        debug: bool = False,\n        loop_factory: Callable[[], asyncio.AbstractEventLoop] | None = None,\n    ) -> _T:\n        try:\n            asyncio.get_running_loop()\n        except RuntimeError:\n            pass\n        else:\n            raise RuntimeError(\"asyncio.run() cannot be called from a running event loop\")\n\n        if not asyncio.iscoroutine(main):\n            raise ValueError(f\"a coroutine was expected, got {main!r}\")\n\n        if loop_factory is None:\n            loop = asyncio.new_event_loop()\n        else:\n            loop = loop_factory()\n        try:\n            if loop_factory is None:\n                asyncio.set_event_loop(loop)\n            if debug is not None:\n                loop.set_debug(debug)\n            return loop.run_until_complete(main)\n        finally:\n            try:\n                _cancel_all_tasks(loop)\n                loop.run_until_complete(loop.shutdown_asyncgens())\n                loop.run_until_complete(loop.shutdown_default_executor())\n            finally:\n                if loop_factory is None:\n                    asyncio.set_event_loop(None)\n                loop.close()\n",
      "start_line": 27,
      "end_line": 63,
      "source_file": "uvicorn/_compat.py",
      "chunk_type": "code"
    },
    {
      "content": "    def _cancel_all_tasks(loop: asyncio.AbstractEventLoop) -> None:\n        to_cancel = asyncio.all_tasks(loop)\n        if not to_cancel:\n            return\n\n        for task in to_cancel:\n            task.cancel()\n\n        loop.run_until_complete(asyncio.gather(*to_cancel, return_exceptions=True))\n\n        for task in to_cancel:\n            if task.cancelled():\n                continue\n            if task.exception() is not None:\n                loop.call_exception_handler(\n                    {\n                        \"message\": \"unhandled exception during asyncio.run() shutdown\",\n                        \"exception\": task.exception(),\n                        \"task\": task,\n                    }\n                )",
      "start_line": 63,
      "end_line": 84,
      "source_file": "uvicorn/_compat.py",
      "chunk_type": "code"
    },
    {
      "content": "from __future__ import annotations\n\nimport asyncio\nimport logging\nimport os\nimport platform\nimport ssl\nimport sys\nimport warnings\nfrom configparser import RawConfigParser\nfrom typing import IO, Any, Callable, get_args\n\nimport click\n\nimport uvicorn\nfrom uvicorn._types import ASGIApplication\nfrom uvicorn.config import (\n    INTERFACES,\n    LIFESPAN,\n    LOG_LEVELS,\n    LOGGING_CONFIG,\n    SSL_PROTOCOL_VERSION,\n    Config,\n    HTTPProtocolType,\n    InterfaceType,\n    LifespanType,\n    LoopFactoryType,\n    WSProtocolType,\n)\nfrom uvicorn.server import Server\nfrom uvicorn.supervisors import ChangeReload, Multiprocess\n\nLEVEL_CHOICES = click.Choice(list(LOG_LEVELS.keys()))\nLIFESPAN_CHOICES = click.Choice(list(LIFESPAN.keys()))\nINTERFACE_CHOICES = click.Choice(INTERFACES)\n\n",
      "start_line": 0,
      "end_line": 37,
      "source_file": "uvicorn/main.py",
      "chunk_type": "code"
    },
    {
      "content": "def _metavar_from_type(_type: Any) -> str:\n    return f\"[{'|'.join(key for key in get_args(_type) if key != 'none')}]\"\n\n\nSTARTUP_FAILURE = 3\n\nlogger = logging.getLogger(\"uvicorn.error\")\n\n",
      "start_line": 37,
      "end_line": 46,
      "source_file": "uvicorn/main.py",
      "chunk_type": "code"
    },
    {
      "content": "def print_version(ctx: click.Context, param: click.Parameter, value: bool) -> None:\n    if not value or ctx.resilient_parsing:\n        return\n    click.echo(\n        \"Running uvicorn {version} with {py_implementation} {py_version} on {system}\".format(  # noqa: UP032\n            version=uvicorn.__version__,\n            py_implementation=platform.python_implementation(),\n            py_version=platform.python_version(),\n            system=platform.system(),\n        )\n    )\n    ctx.exit()\n\n\n@click.command(context_settings={\"auto_envvar_prefix\": \"UVICORN\"})\n@click.argument(\"app\", envvar=\"UVICORN_APP\")\n@click.option(\n    \"--host\",\n    type=str,\n    default=\"127.0.0.1\",\n    help=\"Bind socket to this host.\",\n    show_default=True,\n)\n@click.option(\n    \"--port\",\n    type=int,\n    default=8000,\n    help=\"Bind socket to this port. If 0, an available port will be picked.\",\n    show_default=True,\n)\n@click.option(\"--uds\", type=str, default=None, help=\"Bind to a UNIX domain socket.\")\n@click.option(\"--fd\", type=int, default=None, help=\"Bind to socket from this file descriptor.\")\n@click.option(\"--reload\", is_flag=True, default=False, help=\"Enable auto-reload.\")\n@click.option(\n    \"--reload-dir\",\n    \"reload_dirs\",\n    multiple=True,\n    help=\"Set reload directories explicitly, instead of using the current working directory.\",\n    type=click.Path(exists=True),\n)\n@click.option(\n    \"--reload-include\",\n    \"reload_includes\",\n    multiple=True,\n    help=\"Set glob patterns to include while watching for files. Includes '*.py' \"\n    \"by default; these defaults can be overridden with `--reload-exclude`. \"\n    \"This option has no effect unless watchfiles is installed.\",\n)\n@click.option(\n    \"--reload-exclude\",\n    \"reload_excludes\",\n    multiple=True,\n    help=\"Set glob patterns to exclude while watching for files. Includes \"\n    \"'.*, .py[cod], .sw.*, ~*' by default; these defaults can be overridden \"\n    \"with `--reload-include`. This option has no effect unless watchfiles is \"\n    \"installed.\",\n)\n@click.option(\n    \"--reload-delay\",\n    type=float,\n    default=0.25,\n    show_default=True,\n    help=\"Delay between previous and next check if application needs to be. Defaults to 0.25s.\",\n)\n@click.option(\n    \"--workers\",\n    default=None,\n    type=int,\n    help=\"Number of worker processes. Defaults to the $WEB_CONCURRENCY environment\"\n    \" variable if available, or 1. Not valid with --reload.\",\n)\n@click.option(\n    \"--loop\",\n    type=str,\n    metavar=_metavar_from_type(LoopFactoryType),\n    default=\"auto\",\n    help=\"Event loop factory implementation.\",\n    show_default=True,\n)\n@click.option(\n    \"--http\",\n    type=str,\n    metavar=_metavar_from_type(HTTPProtocolType),\n    default=\"auto\",\n    help=\"HTTP protocol implementation.\",\n    show_default=True,\n)\n@click.option(\n    \"--ws\",\n    type=str,\n    metavar=_metavar_from_type(WSProtocolType),\n    default=\"auto\",\n    help=\"WebSocket protocol implementation.\",\n    show_default=True,\n)\n@click.option(\n    \"--ws-max-size\",\n    type=int,\n    default=16777216,\n    help=\"WebSocket max size message in bytes\",\n    show_default=True,\n)\n@click.option(\n    \"--ws-max-queue\",\n    type=int,\n    default=32,\n    help=\"The maximum length of the WebSocket message queue.\",\n    show_default=True,\n)\n@click.option(\n    \"--ws-ping-interval\",\n    type=float,\n    default=20.0,\n    help=\"WebSocket ping interval in seconds.\",\n    show_default=True,\n)\n@click.option(\n    \"--ws-ping-timeout\",\n    type=float,\n    default=20.0,\n    help=\"WebSocket ping timeout in seconds.\",\n    show_default=True,\n)\n@click.option(\n    \"--ws-per-message-deflate\",\n    type=bool,\n    default=True,\n    help=\"WebSocket per-message-deflate compression\",\n    show_default=True,\n)\n@click.option(\n    \"--lifespan\",\n    type=LIFESPAN_CHOICES,\n    default=\"auto\",\n    help=\"Lifespan implementation.\",\n    show_default=True,\n)\n@click.option(\n    \"--interface\",\n    type=INTERFACE_CHOICES,\n    default=\"auto\",\n    help=\"Select ASGI3, ASGI2, or WSGI as the application interface.\",\n    show_default=True,\n)\n@click.option(\n    \"--env-file\",\n    type=click.Path(exists=True),\n    default=None,\n    help=\"Environment configuration file.\",\n    show_default=True,\n)\n@click.option(\n    \"--log-config\",\n    type=click.Path(exists=True),\n    default=None,\n    help=\"Logging configuration file. Supported formats: .ini, .json, .yaml.\",\n    show_default=True,\n)\n@click.option(\n    \"--log-level\",\n    type=LEVEL_CHOICES,\n    default=None,\n    help=\"Log level. [default: info]\",\n    show_default=True,\n)\n@click.option(\n    \"--access-log/--no-access-log\",\n    is_flag=True,\n    default=True,\n    help=\"Enable/Disable access log.\",\n)\n@click.option(\n    \"--use-colors/--no-use-colors\",\n    is_flag=True,\n    default=None,\n    help=\"Enable/Disable colorized logging.\",\n)\n@click.option(\n    \"--proxy-headers/--no-proxy-headers\",\n    is_flag=True,\n    default=True,\n    help=\"Enable/Disable X-Forwarded-Proto, X-Forwarded-For to populate url scheme and remote address info.\",\n)\n@click.option(\n    \"--server-header/--no-server-header\",\n    is_flag=True,\n    default=True,\n    help=\"Enable/Disable default Server header.\",\n)\n@click.option(\n    \"--date-header/--no-date-header\",\n    is_flag=True,\n    default=True,\n    help=\"Enable/Disable default Date header.\",\n)\n@click.option(\n    \"--forwarded-allow-ips\",\n    type=str,\n    default=None,\n    help=\"Comma separated list of IP Addresses, IP Networks, or literals \"\n    \"(e.g. UNIX Socket path) to trust with proxy headers. Defaults to the \"\n    \"$FORWARDED_ALLOW_IPS environment variable if available, or '127.0.0.1'. \"\n    \"The literal '*' means trust everything.\",\n)\n@click.option(\n    \"--root-path\",\n    type=str,\n    default=\"\",\n    help=\"Set the ASGI 'root_path' for applications submounted below a given URL path.\",\n)\n@click.option(\n    \"--limit-concurrency\",\n    type=int,\n    default=None,\n    help=\"Maximum number of concurrent connections or tasks to allow, before issuing HTTP 503 responses.\",\n)\n@click.option(\n    \"--backlog\",\n    type=int,\n    default=2048,\n    help=\"Maximum number of connections to hold in backlog\",\n)\n@click.option(\n    \"--limit-max-requests\",\n    type=int,\n    default=None,\n    help=\"Maximum number of requests to service before terminating the process.\",\n)\n@click.option(\n    \"--timeout-keep-alive\",\n    type=int,\n    default=5,\n    help=\"Close Keep-Alive connections if no new data is received within this timeout.\",\n    show_default=True,\n)\n@click.option(\n    \"--timeout-graceful-shutdown\",\n    type=int,\n    default=None,\n    help=\"Maximum number of seconds to wait for graceful shutdown.\",\n)\n@click.option(\"--ssl-keyfile\", type=str, default=None, help=\"SSL key file\", show_default=True)\n@click.option(\n    \"--ssl-certfile\",\n    type=str,\n    default=None,\n    help=\"SSL certificate file\",\n    show_default=True,\n)\n@click.option(\n    \"--ssl-keyfile-password\",\n    type=str,\n    default=None,\n    help=\"SSL keyfile password\",\n    show_default=True,\n)\n@click.option(\n    \"--ssl-version\",\n    type=int,\n    default=int(SSL_PROTOCOL_VERSION),\n    help=\"SSL version to use (see stdlib ssl module's)\",\n    show_default=True,\n)\n@click.option(\n    \"--ssl-cert-reqs\",\n    type=int,\n    default=int(ssl.CERT_NONE),\n    help=\"Whether client certificate is required (see stdlib ssl module's)\",\n    show_default=True,\n)\n@click.option(\n    \"--ssl-ca-certs\",\n    type=str,\n    default=None,\n    help=\"CA certificates file\",\n    show_default=True,\n)\n@click.option(\n    \"--ssl-ciphers\",\n    type=str,\n    default=\"TLSv1\",\n    help=\"Ciphers to use (see stdlib ssl module's)\",\n    show_default=True,\n)\n@click.option(\n    \"--header\",\n    \"headers\",\n    multiple=True,\n    help=\"Specify custom default HTTP response headers as a Name:Value pair\",\n)\n@click.option(\n    \"--version\",\n    is_flag=True,\n    callback=print_version,\n    expose_value=False,\n    is_eager=True,\n    help=\"Display the uvicorn version and exit.\",\n)\n@click.option(\n    \"--app-dir\",\n    default=\"\",\n    show_default=True,\n    help=\"Look for APP in the specified directory, by adding this to the PYTHONPATH.\"\n    \" Defaults to the current working directory.\",\n)\n@click.option(\n    \"--h11-max-incomplete-event-size\",\n    \"h11_max_incomplete_event_size\",\n    type=int,\n    default=None,\n    help=\"For h11, the maximum number of bytes to buffer of an incomplete event.\",\n)\n@click.option(\n    \"--factory\",\n    is_flag=True,\n    default=False,\n    help=\"Treat APP as an application factory, i.e. a () -> <ASGI app> callable.\",\n    show_default=True,\n)",
      "start_line": 46,
      "end_line": 365,
      "source_file": "uvicorn/main.py",
      "chunk_type": "code"
    },
    {
      "content": "def main(\n    app: str,\n    host: str,\n    port: int,\n    uds: str,\n    fd: int,\n    loop: LoopFactoryType | str,\n    http: HTTPProtocolType | str,\n    ws: WSProtocolType | str,\n    ws_max_size: int,\n    ws_max_queue: int,\n    ws_ping_interval: float,\n    ws_ping_timeout: float,\n    ws_per_message_deflate: bool,\n    lifespan: LifespanType,\n    interface: InterfaceType,\n    reload: bool,\n    reload_dirs: list[str],\n    reload_includes: list[str],\n    reload_excludes: list[str],\n    reload_delay: float,\n    workers: int,\n    env_file: str,\n    log_config: str,\n    log_level: str,\n    access_log: bool,\n    proxy_headers: bool,\n    server_header: bool,\n    date_header: bool,\n    forwarded_allow_ips: str,\n    root_path: str,\n    limit_concurrency: int,\n    backlog: int,\n    limit_max_requests: int,\n    timeout_keep_alive: int,\n    timeout_graceful_shutdown: int | None,\n    ssl_keyfile: str,\n    ssl_certfile: str,\n    ssl_keyfile_password: str,\n    ssl_version: int,\n    ssl_cert_reqs: int,\n    ssl_ca_certs: str,\n    ssl_ciphers: str,\n    headers: list[str],\n    use_colors: bool,\n    app_dir: str,\n    h11_max_incomplete_event_size: int | None,\n    factory: bool,\n) -> None:\n    run(\n        app,\n        host=host,\n        port=port,\n        uds=uds,\n        fd=fd,\n        loop=loop,\n        http=http,\n        ws=ws,\n        ws_max_size=ws_max_size,\n        ws_max_queue=ws_max_queue,\n        ws_ping_interval=ws_ping_interval,\n        ws_ping_timeout=ws_ping_timeout,\n        ws_per_message_deflate=ws_per_message_deflate,\n        lifespan=lifespan,\n        env_file=env_file,\n        log_config=LOGGING_CONFIG if log_config is None else log_config,\n        log_level=log_level,\n        access_log=access_log,\n        interface=interface,\n        reload=reload,\n        reload_dirs=reload_dirs or None,\n        reload_includes=reload_includes or None,\n        reload_excludes=reload_excludes or None,\n        reload_delay=reload_delay,\n        workers=workers,\n        proxy_headers=proxy_headers,\n        server_header=server_header,\n        date_header=date_header,\n        forwarded_allow_ips=forwarded_allow_ips,\n        root_path=root_path,\n        limit_concurrency=limit_concurrency,\n        backlog=backlog,\n        limit_max_requests=limit_max_requests,\n        timeout_keep_alive=timeout_keep_alive,\n        timeout_graceful_shutdown=timeout_graceful_shutdown,\n        ssl_keyfile=ssl_keyfile,\n        ssl_certfile=ssl_certfile,\n        ssl_keyfile_password=ssl_keyfile_password,\n        ssl_version=ssl_version,\n        ssl_cert_reqs=ssl_cert_reqs,\n        ssl_ca_certs=ssl_ca_certs,\n        ssl_ciphers=ssl_ciphers,\n        headers=[header.split(\":\", 1) for header in headers],  # type: ignore[misc]\n        use_colors=use_colors,\n        factory=factory,\n        app_dir=app_dir,\n        h11_max_incomplete_event_size=h11_max_incomplete_event_size,\n    )\n\n",
      "start_line": 365,
      "end_line": 465,
      "source_file": "uvicorn/main.py",
      "chunk_type": "code"
    },
    {
      "content": "def run(\n    app: ASGIApplication | Callable[..., Any] | str,\n    *,\n    host: str = \"127.0.0.1\",\n    port: int = 8000,\n    uds: str | None = None,\n    fd: int | None = None,\n    loop: LoopFactoryType | str = \"auto\",\n    http: type[asyncio.Protocol] | HTTPProtocolType | str = \"auto\",\n    ws: type[asyncio.Protocol] | WSProtocolType | str = \"auto\",\n    ws_max_size: int = 16777216,\n    ws_max_queue: int = 32,\n    ws_ping_interval: float | None = 20.0,\n    ws_ping_timeout: float | None = 20.0,\n    ws_per_message_deflate: bool = True,\n    lifespan: LifespanType = \"auto\",\n    interface: InterfaceType = \"auto\",\n    reload: bool = False,\n    reload_dirs: list[str] | str | None = None,\n    reload_includes: list[str] | str | None = None,\n    reload_excludes: list[str] | str | None = None,\n    reload_delay: float = 0.25,\n    workers: int | None = None,\n    env_file: str | os.PathLike[str] | None = None,\n    log_config: dict[str, Any] | str | RawConfigParser | IO[Any] | None = LOGGING_CONFIG,\n    log_level: str | int | None = None,\n    access_log: bool = True,\n    proxy_headers: bool = True,\n    server_header: bool = True,\n    date_header: bool = True,\n    forwarded_allow_ips: list[str] | str | None = None,\n    root_path: str = \"\",\n    limit_concurrency: int | None = None,\n    backlog: int = 2048,\n    limit_max_requests: int | None = None,\n    timeout_keep_alive: int = 5,\n    timeout_graceful_shutdown: int | None = None,\n    ssl_keyfile: str | os.PathLike[str] | None = None,\n    ssl_certfile: str | os.PathLike[str] | None = None,\n    ssl_keyfile_password: str | None = None,\n    ssl_version: int = SSL_PROTOCOL_VERSION,\n    ssl_cert_reqs: int = ssl.CERT_NONE,\n    ssl_ca_certs: str | None = None,\n    ssl_ciphers: str = \"TLSv1\",\n    headers: list[tuple[str, str]] | None = None,\n    use_colors: bool | None = None,\n    app_dir: str | None = None,\n    factory: bool = False,\n    h11_max_incomplete_event_size: int | None = None,\n) -> None:\n    if app_dir is not None:\n        sys.path.insert(0, app_dir)\n\n    config = Config(\n        app,\n        host=host,\n        port=port,\n        uds=uds,\n        fd=fd,\n        loop=loop,\n        http=http,\n        ws=ws,\n        ws_max_size=ws_max_size,\n        ws_max_queue=ws_max_queue,\n        ws_ping_interval=ws_ping_interval,\n        ws_ping_timeout=ws_ping_timeout,\n        ws_per_message_deflate=ws_per_message_deflate,\n        lifespan=lifespan,\n        interface=interface,\n        reload=reload,\n        reload_dirs=reload_dirs,\n        reload_includes=reload_includes,\n        reload_excludes=reload_excludes,\n        reload_delay=reload_delay,\n        workers=workers,\n        env_file=env_file,\n        log_config=log_config,\n        log_level=log_level,\n        access_log=access_log,\n        proxy_headers=proxy_headers,\n        server_header=server_header,\n        date_header=date_header,\n        forwarded_allow_ips=forwarded_allow_ips,\n        root_path=root_path,\n        limit_concurrency=limit_concurrency,\n        backlog=backlog,\n        limit_max_requests=limit_max_requests,\n        timeout_keep_alive=timeout_keep_alive,\n        timeout_graceful_shutdown=timeout_graceful_shutdown,\n        ssl_keyfile=ssl_keyfile,\n        ssl_certfile=ssl_certfile,\n        ssl_keyfile_password=ssl_keyfile_password,\n        ssl_version=ssl_version,\n        ssl_cert_reqs=ssl_cert_reqs,\n        ssl_ca_certs=ssl_ca_certs,\n        ssl_ciphers=ssl_ciphers,\n        headers=headers,\n        use_colors=use_colors,\n        factory=factory,\n        h11_max_incomplete_event_size=h11_max_incomplete_event_size,\n    )\n    server = Server(config=config)\n\n    if (config.reload or config.workers > 1) and not isinstance(app, str):\n        logger = logging.getLogger(\"uvicorn.error\")\n        logger.warning(\"You must pass the application as an import string to enable 'reload' or 'workers'.\")\n        sys.exit(1)\n\n    try:\n        if config.should_reload:\n            sock = config.bind_socket()\n            ChangeReload(config, target=server.run, sockets=[sock]).run()\n        elif config.workers > 1:\n            sock = config.bind_socket()\n            Multiprocess(config, target=server.run, sockets=[sock]).run()\n        else:\n            server.run()\n    except KeyboardInterrupt:\n        pass  # pragma: full coverage\n    finally:\n        if config.uds and os.path.exists(config.uds):\n            os.remove(config.uds)  # pragma: py-win32\n\n    if not server.started and not config.should_reload and config.workers == 1:\n        sys.exit(STARTUP_FAILURE)\n\n",
      "start_line": 465,
      "end_line": 592,
      "source_file": "uvicorn/main.py",
      "chunk_type": "code"
    },
    {
      "content": "def __getattr__(name: str) -> Any:\n    if name == \"ServerState\":\n        warnings.warn(\n            \"uvicorn.main.ServerState is deprecated, use uvicorn.server.ServerState instead.\",\n            DeprecationWarning,\n        )\n        from uvicorn.server import ServerState\n\n        return ServerState\n    raise AttributeError(f\"module {__name__} has no attribute {name}\")\n\n\nif __name__ == \"__main__\":\n    main()  # pragma: no cover",
      "start_line": 592,
      "end_line": 606,
      "source_file": "uvicorn/main.py",
      "chunk_type": "code"
    },
    {
      "content": "import uvicorn\n\nif __name__ == \"__main__\":\n    uvicorn.main()",
      "start_line": 0,
      "end_line": 4,
      "source_file": "uvicorn/__main__.py",
      "chunk_type": "code"
    },
    {
      "content": "from uvicorn._types import (\n    ASGI2Application,\n    ASGIReceiveCallable,\n    ASGISendCallable,\n    Scope,\n)\n\n",
      "start_line": 0,
      "end_line": 8,
      "source_file": "uvicorn/middleware/asgi2.py",
      "chunk_type": "code"
    },
    {
      "content": "class ASGI2Middleware:",
      "start_line": 8,
      "end_line": 9,
      "source_file": "uvicorn/middleware/asgi2.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, app: \"ASGI2Application\"):\n        self.app = app\n\n    async def __call__(self, scope: \"Scope\", receive: \"ASGIReceiveCallable\", send: \"ASGISendCallable\") -> None:\n        instance = self.app(scope)\n        await instance(receive, send)",
      "start_line": 9,
      "end_line": 15,
      "source_file": "uvicorn/middleware/asgi2.py",
      "chunk_type": "code"
    },
    {
      "content": "from __future__ import annotations\n\nimport ipaddress\n\nfrom uvicorn._types import ASGI3Application, ASGIReceiveCallable, ASGISendCallable, Scope\n\n",
      "start_line": 0,
      "end_line": 7,
      "source_file": "uvicorn/middleware/proxy_headers.py",
      "chunk_type": "code"
    },
    {
      "content": "class ProxyHeadersMiddleware:\n    \"\"\"Middleware for handling known proxy headers\n\n    This middleware can be used when a known proxy is fronting the application,\n    and is trusted to be properly setting the `X-Forwarded-Proto` and\n    `X-Forwarded-For` headers with the connecting client information.\n\n    Modifies the `client` and `scheme` information so that they reference\n    the connecting client, rather that the connecting proxy.\n\n    References:\n    - <https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#Proxies>\n    - <https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For>\n    \"\"\"\n",
      "start_line": 7,
      "end_line": 22,
      "source_file": "uvicorn/middleware/proxy_headers.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, app: ASGI3Application, trusted_hosts: list[str] | str = \"127.0.0.1\") -> None:\n        self.app = app\n        self.trusted_hosts = _TrustedHosts(trusted_hosts)\n\n    async def __call__(self, scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable) -> None:\n        if scope[\"type\"] == \"lifespan\":\n            return await self.app(scope, receive, send)\n\n        client_addr = scope.get(\"client\")\n        client_host = client_addr[0] if client_addr else None\n\n        if client_host in self.trusted_hosts:\n            headers = dict(scope[\"headers\"])\n\n            if b\"x-forwarded-proto\" in headers:\n                x_forwarded_proto = headers[b\"x-forwarded-proto\"].decode(\"latin1\").strip()\n\n                if x_forwarded_proto in {\"http\", \"https\", \"ws\", \"wss\"}:\n                    if scope[\"type\"] == \"websocket\":\n                        scope[\"scheme\"] = x_forwarded_proto.replace(\"http\", \"ws\")\n                    else:\n                        scope[\"scheme\"] = x_forwarded_proto\n\n            if b\"x-forwarded-for\" in headers:\n                x_forwarded_for = headers[b\"x-forwarded-for\"].decode(\"latin1\")\n                host = self.trusted_hosts.get_trusted_client_host(x_forwarded_for)\n\n                if host:\n                    # If the x-forwarded-for header is empty then host is an empty string.\n                    # Only set the client if we actually got something usable.\n                    # See: https://github.com/encode/uvicorn/issues/1068\n\n                    # We've lost the connecting client's port information by now,\n                    # so only include the host.\n                    port = 0\n                    scope[\"client\"] = (host, port)\n\n        return await self.app(scope, receive, send)\n\n",
      "start_line": 22,
      "end_line": 62,
      "source_file": "uvicorn/middleware/proxy_headers.py",
      "chunk_type": "code"
    },
    {
      "content": "def _parse_raw_hosts(value: str) -> list[str]:\n    return [item.strip() for item in value.split(\",\")]\n\n",
      "start_line": 62,
      "end_line": 66,
      "source_file": "uvicorn/middleware/proxy_headers.py",
      "chunk_type": "code"
    },
    {
      "content": "class _TrustedHosts:\n    \"\"\"Container for trusted hosts and networks\"\"\"\n",
      "start_line": 66,
      "end_line": 69,
      "source_file": "uvicorn/middleware/proxy_headers.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, trusted_hosts: list[str] | str) -> None:\n        self.always_trust: bool = trusted_hosts in (\"*\", [\"*\"])\n\n        self.trusted_literals: set[str] = set()\n        self.trusted_hosts: set[ipaddress.IPv4Address | ipaddress.IPv6Address] = set()\n        self.trusted_networks: set[ipaddress.IPv4Network | ipaddress.IPv6Network] = set()\n\n        # Notes:\n        # - We separate hosts from literals as there are many ways to write\n        #   an IPv6 Address so we need to compare by object.\n        # - We don't convert IP Address to single host networks (e.g. /32 / 128) as\n        #   it more efficient to do an address lookup in a set than check for\n        #   membership in each network.\n        # - We still allow literals as it might be possible that we receive a\n        #   something that isn't an IP Address e.g. a unix socket.\n\n        if not self.always_trust:\n            if isinstance(trusted_hosts, str):\n                trusted_hosts = _parse_raw_hosts(trusted_hosts)\n\n            for host in trusted_hosts:\n                # Note: because we always convert invalid IP types to literals it\n                # is not possible for the user to know they provided a malformed IP\n                # type - this may lead to unexpected / difficult to debug behaviour.\n\n                if \"/\" in host:\n                    # Looks like a network\n                    try:\n                        self.trusted_networks.add(ipaddress.ip_network(host))\n                    except ValueError:\n                        # Was not a valid IP Network\n                        self.trusted_literals.add(host)\n                else:\n                    try:\n                        self.trusted_hosts.add(ipaddress.ip_address(host))\n                    except ValueError:\n                        # Was not a valid IP Address\n                        self.trusted_literals.add(host)\n",
      "start_line": 69,
      "end_line": 108,
      "source_file": "uvicorn/middleware/proxy_headers.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __contains__(self, host: str | None) -> bool:\n        if self.always_trust:\n            return True\n\n        if not host:\n            return False\n\n        try:\n            ip = ipaddress.ip_address(host)\n            if ip in self.trusted_hosts:\n                return True\n            return any(ip in net for net in self.trusted_networks)\n\n        except ValueError:\n            return host in self.trusted_literals\n",
      "start_line": 108,
      "end_line": 124,
      "source_file": "uvicorn/middleware/proxy_headers.py",
      "chunk_type": "code"
    },
    {
      "content": "    def get_trusted_client_host(self, x_forwarded_for: str) -> str:\n        \"\"\"Extract the client host from x_forwarded_for header\n\n        In general this is the first \"untrusted\" host in the forwarded for list.\n        \"\"\"\n        x_forwarded_for_hosts = _parse_raw_hosts(x_forwarded_for)\n\n        if self.always_trust:\n            return x_forwarded_for_hosts[0]\n\n        # Note: each proxy appends to the header list so check it in reverse order\n        for host in reversed(x_forwarded_for_hosts):\n            if host not in self:\n                return host\n\n        # All hosts are trusted meaning that the client was also a trusted proxy\n        # See https://github.com/encode/uvicorn/issues/1068#issuecomment-855371576\n        return x_forwarded_for_hosts[0]",
      "start_line": 124,
      "end_line": 142,
      "source_file": "uvicorn/middleware/proxy_headers.py",
      "chunk_type": "code"
    },
    {
      "content": "from __future__ import annotations\n\nimport asyncio\nimport concurrent.futures\nimport io\nimport sys\nimport warnings\nfrom collections import deque\nfrom collections.abc import Iterable\n\nfrom uvicorn._types import (\n    ASGIReceiveCallable,\n    ASGIReceiveEvent,\n    ASGISendCallable,\n    ASGISendEvent,\n    Environ,\n    ExcInfo,\n    HTTPRequestEvent,\n    HTTPResponseBodyEvent,\n    HTTPResponseStartEvent,\n    HTTPScope,\n    StartResponse,\n    WSGIApp,\n)\n\n",
      "start_line": 0,
      "end_line": 26,
      "source_file": "uvicorn/middleware/wsgi.py",
      "chunk_type": "code"
    },
    {
      "content": "def build_environ(scope: HTTPScope, message: ASGIReceiveEvent, body: io.BytesIO) -> Environ:\n    \"\"\"\n    Builds a scope and request message into a WSGI environ object.\n    \"\"\"\n    script_name = scope.get(\"root_path\", \"\").encode(\"utf8\").decode(\"latin1\")\n    path_info = scope[\"path\"].encode(\"utf8\").decode(\"latin1\")\n    if path_info.startswith(script_name):\n        path_info = path_info[len(script_name) :]\n    environ = {\n        \"REQUEST_METHOD\": scope[\"method\"],\n        \"SCRIPT_NAME\": script_name,\n        \"PATH_INFO\": path_info,\n        \"QUERY_STRING\": scope[\"query_string\"].decode(\"ascii\"),\n        \"SERVER_PROTOCOL\": \"HTTP/%s\" % scope[\"http_version\"],\n        \"wsgi.version\": (1, 0),\n        \"wsgi.url_scheme\": scope.get(\"scheme\", \"http\"),\n        \"wsgi.input\": body,\n        \"wsgi.errors\": sys.stdout,\n        \"wsgi.multithread\": True,\n        \"wsgi.multiprocess\": True,\n        \"wsgi.run_once\": False,\n    }\n\n    # Get server name and port - required in WSGI, not in ASGI\n    server = scope.get(\"server\")\n    if server is None:\n        server = (\"localhost\", 80)\n    environ[\"SERVER_NAME\"] = server[0]\n    environ[\"SERVER_PORT\"] = server[1]\n\n    # Get client IP address\n    client = scope.get(\"client\")\n    if client is not None:\n        environ[\"REMOTE_ADDR\"] = client[0]\n\n    # Go through headers and make them into environ entries\n    for name, value in scope.get(\"headers\", []):\n        name_str: str = name.decode(\"latin1\")\n        if name_str == \"content-length\":\n            corrected_name = \"CONTENT_LENGTH\"\n        elif name_str == \"content-type\":\n            corrected_name = \"CONTENT_TYPE\"\n        else:\n            corrected_name = \"HTTP_%s\" % name_str.upper().replace(\"-\", \"_\")\n        # HTTPbis say only ASCII chars are allowed in headers, but we latin1\n        # just in case\n        value_str: str = value.decode(\"latin1\")\n        if corrected_name in environ:\n            corrected_name_environ = environ[corrected_name]\n            assert isinstance(corrected_name_environ, str)\n            value_str = corrected_name_environ + \",\" + value_str\n        environ[corrected_name] = value_str\n    return environ\n\n",
      "start_line": 26,
      "end_line": 81,
      "source_file": "uvicorn/middleware/wsgi.py",
      "chunk_type": "code"
    },
    {
      "content": "class _WSGIMiddleware:",
      "start_line": 81,
      "end_line": 82,
      "source_file": "uvicorn/middleware/wsgi.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, app: WSGIApp, workers: int = 10):\n        warnings.warn(\n            \"Uvicorn's native WSGI implementation is deprecated, you should switch to a2wsgi (`pip install a2wsgi`).\",\n            DeprecationWarning,\n        )\n        self.app = app\n        self.executor = concurrent.futures.ThreadPoolExecutor(max_workers=workers)\n\n    async def __call__(\n        self,\n        scope: HTTPScope,\n        receive: ASGIReceiveCallable,\n        send: ASGISendCallable,\n    ) -> None:\n        assert scope[\"type\"] == \"http\"\n        instance = WSGIResponder(self.app, self.executor, scope)\n        await instance(receive, send)\n\n",
      "start_line": 82,
      "end_line": 101,
      "source_file": "uvicorn/middleware/wsgi.py",
      "chunk_type": "code"
    },
    {
      "content": "class WSGIResponder:",
      "start_line": 101,
      "end_line": 102,
      "source_file": "uvicorn/middleware/wsgi.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(\n        self,\n        app: WSGIApp,\n        executor: concurrent.futures.ThreadPoolExecutor,\n        scope: HTTPScope,\n    ):\n        self.app = app\n        self.executor = executor\n        self.scope = scope\n        self.status = None\n        self.response_headers = None\n        self.send_event = asyncio.Event()\n        self.send_queue: deque[ASGISendEvent | None] = deque()\n        self.loop: asyncio.AbstractEventLoop = asyncio.get_event_loop()\n        self.response_started = False\n        self.exc_info: ExcInfo | None = None\n\n    async def __call__(self, receive: ASGIReceiveCallable, send: ASGISendCallable) -> None:\n        message: HTTPRequestEvent = await receive()  # type: ignore[assignment]\n        body = io.BytesIO(message.get(\"body\", b\"\"))\n        more_body = message.get(\"more_body\", False)\n        if more_body:\n            body.seek(0, io.SEEK_END)\n            while more_body:\n                body_message: HTTPRequestEvent = (\n                    await receive()  # type: ignore[assignment]\n                )\n                body.write(body_message.get(\"body\", b\"\"))\n                more_body = body_message.get(\"more_body\", False)\n            body.seek(0)\n        environ = build_environ(self.scope, message, body)\n        self.loop = asyncio.get_event_loop()\n        wsgi = self.loop.run_in_executor(self.executor, self.wsgi, environ, self.start_response)\n        sender = self.loop.create_task(self.sender(send))\n        try:\n            await asyncio.wait_for(wsgi, None)\n        finally:\n            self.send_queue.append(None)\n            self.send_event.set()\n            await asyncio.wait_for(sender, None)\n        if self.exc_info is not None:\n            raise self.exc_info[0].with_traceback(self.exc_info[1], self.exc_info[2])\n\n    async def sender(self, send: ASGISendCallable) -> None:\n        while True:\n            if self.send_queue:\n                message = self.send_queue.popleft()\n                if message is None:\n                    return\n                await send(message)\n            else:\n                await self.send_event.wait()\n                self.send_event.clear()\n",
      "start_line": 102,
      "end_line": 156,
      "source_file": "uvicorn/middleware/wsgi.py",
      "chunk_type": "code"
    },
    {
      "content": "    def start_response(\n        self,\n        status: str,\n        response_headers: Iterable[tuple[str, str]],\n        exc_info: ExcInfo | None = None,\n    ) -> None:\n        self.exc_info = exc_info\n        if not self.response_started:\n            self.response_started = True\n            status_code_str, _ = status.split(\" \", 1)\n            status_code = int(status_code_str)\n            headers = [(name.encode(\"ascii\"), value.encode(\"ascii\")) for name, value in response_headers]\n            http_response_start_event: HTTPResponseStartEvent = {\n                \"type\": \"http.response.start\",\n                \"status\": status_code,\n                \"headers\": headers,\n            }\n            self.send_queue.append(http_response_start_event)\n            self.loop.call_soon_threadsafe(self.send_event.set)\n",
      "start_line": 156,
      "end_line": 176,
      "source_file": "uvicorn/middleware/wsgi.py",
      "chunk_type": "code"
    },
    {
      "content": "    def wsgi(self, environ: Environ, start_response: StartResponse) -> None:\n        for chunk in self.app(environ, start_response):  # type: ignore\n            response_body: HTTPResponseBodyEvent = {\n                \"type\": \"http.response.body\",\n                \"body\": chunk,\n                \"more_body\": True,\n            }\n            self.send_queue.append(response_body)\n            self.loop.call_soon_threadsafe(self.send_event.set)\n\n        empty_body: HTTPResponseBodyEvent = {\n            \"type\": \"http.response.body\",\n            \"body\": b\"\",\n            \"more_body\": False,\n        }\n        self.send_queue.append(empty_body)\n        self.loop.call_soon_threadsafe(self.send_event.set)\n\n\ntry:\n    from a2wsgi import WSGIMiddleware\nexcept ModuleNotFoundError:  # pragma: no cover\n    WSGIMiddleware = _WSGIMiddleware  # type: ignore[misc, assignment]",
      "start_line": 176,
      "end_line": 199,
      "source_file": "uvicorn/middleware/wsgi.py",
      "chunk_type": "code"
    },
    {
      "content": "from __future__ import annotations\n\nimport logging\nfrom collections.abc import Iterator\nfrom pathlib import Path\nfrom socket import socket\nfrom typing import Callable\n\nfrom uvicorn.config import Config\nfrom uvicorn.supervisors.basereload import BaseReload\n\nlogger = logging.getLogger(\"uvicorn.error\")\n\n",
      "start_line": 0,
      "end_line": 14,
      "source_file": "uvicorn/supervisors/statreload.py",
      "chunk_type": "code"
    },
    {
      "content": "class StatReload(BaseReload):",
      "start_line": 14,
      "end_line": 15,
      "source_file": "uvicorn/supervisors/statreload.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(\n        self,\n        config: Config,\n        target: Callable[[list[socket] | None], None],\n        sockets: list[socket],\n    ) -> None:\n        super().__init__(config, target, sockets)\n        self.reloader_name = \"StatReload\"\n        self.mtimes: dict[Path, float] = {}\n\n        if config.reload_excludes or config.reload_includes:\n            logger.warning(\"--reload-include and --reload-exclude have no effect unless watchfiles is installed.\")\n",
      "start_line": 15,
      "end_line": 28,
      "source_file": "uvicorn/supervisors/statreload.py",
      "chunk_type": "code"
    },
    {
      "content": "    def should_restart(self) -> list[Path] | None:\n        self.pause()\n\n        for file in self.iter_py_files():\n            try:\n                mtime = file.stat().st_mtime\n            except OSError:  # pragma: nocover\n                continue\n\n            old_time = self.mtimes.get(file)\n            if old_time is None:\n                self.mtimes[file] = mtime\n                continue\n            elif mtime > old_time:\n                return [file]\n        return None\n",
      "start_line": 28,
      "end_line": 45,
      "source_file": "uvicorn/supervisors/statreload.py",
      "chunk_type": "code"
    },
    {
      "content": "    def restart(self) -> None:\n        self.mtimes = {}\n        return super().restart()\n",
      "start_line": 45,
      "end_line": 49,
      "source_file": "uvicorn/supervisors/statreload.py",
      "chunk_type": "code"
    },
    {
      "content": "    def iter_py_files(self) -> Iterator[Path]:\n        for reload_dir in self.config.reload_dirs:\n            for path in list(reload_dir.rglob(\"*.py\")):\n                yield path.resolve()",
      "start_line": 49,
      "end_line": 53,
      "source_file": "uvicorn/supervisors/statreload.py",
      "chunk_type": "code"
    },
    {
      "content": "from __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom uvicorn.supervisors.basereload import BaseReload\nfrom uvicorn.supervisors.multiprocess import Multiprocess\n\nif TYPE_CHECKING:\n    ChangeReload: type[BaseReload]\nelse:\n    try:\n        from uvicorn.supervisors.watchfilesreload import WatchFilesReload as ChangeReload\n    except ImportError:  # pragma: no cover\n        from uvicorn.supervisors.statreload import StatReload as ChangeReload\n\n__all__ = [\"Multiprocess\", \"ChangeReload\"]",
      "start_line": 0,
      "end_line": 16,
      "source_file": "uvicorn/supervisors/__init__.py",
      "chunk_type": "code"
    },
    {
      "content": "from __future__ import annotations\n\nfrom pathlib import Path\nfrom socket import socket\nfrom typing import Callable\n\nfrom watchfiles import watch\n\nfrom uvicorn.config import Config\nfrom uvicorn.supervisors.basereload import BaseReload\n\n",
      "start_line": 0,
      "end_line": 12,
      "source_file": "uvicorn/supervisors/watchfilesreload.py",
      "chunk_type": "code"
    },
    {
      "content": "class FileFilter:",
      "start_line": 12,
      "end_line": 13,
      "source_file": "uvicorn/supervisors/watchfilesreload.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, config: Config):\n        default_includes = [\"*.py\"]\n        self.includes = [default for default in default_includes if default not in config.reload_excludes]\n        self.includes.extend(config.reload_includes)\n        self.includes = list(set(self.includes))\n\n        default_excludes = [\".*\", \".py[cod]\", \".sw.*\", \"~*\"]\n        self.excludes = [default for default in default_excludes if default not in config.reload_includes]\n        self.exclude_dirs = []\n        for e in config.reload_excludes:\n            p = Path(e)\n            try:\n                is_dir = p.is_dir()\n            except OSError:  # pragma: no cover\n                # gets raised on Windows for values like \"*.py\"\n                is_dir = False\n\n            if is_dir:\n                self.exclude_dirs.append(p)\n            else:\n                self.excludes.append(e)  # pragma: full coverage\n        self.excludes = list(set(self.excludes))\n",
      "start_line": 13,
      "end_line": 36,
      "source_file": "uvicorn/supervisors/watchfilesreload.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __call__(self, path: Path) -> bool:\n        for include_pattern in self.includes:\n            if path.match(include_pattern):\n                if str(path).endswith(include_pattern):\n                    return True  # pragma: full coverage\n\n                for exclude_dir in self.exclude_dirs:\n                    if exclude_dir in path.parents:\n                        return False\n\n                for exclude_pattern in self.excludes:\n                    if path.match(exclude_pattern):\n                        return False  # pragma: full coverage\n\n                return True\n        return False\n\n",
      "start_line": 36,
      "end_line": 54,
      "source_file": "uvicorn/supervisors/watchfilesreload.py",
      "chunk_type": "code"
    },
    {
      "content": "class WatchFilesReload(BaseReload):",
      "start_line": 54,
      "end_line": 55,
      "source_file": "uvicorn/supervisors/watchfilesreload.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(\n        self,\n        config: Config,\n        target: Callable[[list[socket] | None], None],\n        sockets: list[socket],\n    ) -> None:\n        super().__init__(config, target, sockets)\n        self.reloader_name = \"WatchFiles\"\n        self.reload_dirs = []\n        for directory in config.reload_dirs:\n            self.reload_dirs.append(directory)\n\n        self.watch_filter = FileFilter(config)\n        self.watcher = watch(\n            *self.reload_dirs,\n            watch_filter=None,\n            stop_event=self.should_exit,\n            # using yield_on_timeout here mostly to make sure tests don't\n            # hang forever, won't affect the class's behavior\n            yield_on_timeout=True,\n        )\n",
      "start_line": 55,
      "end_line": 77,
      "source_file": "uvicorn/supervisors/watchfilesreload.py",
      "chunk_type": "code"
    },
    {
      "content": "    def should_restart(self) -> list[Path] | None:\n        self.pause()\n\n        changes = next(self.watcher)\n        if changes:\n            unique_paths = {Path(c[1]) for c in changes}\n            return [p for p in unique_paths if self.watch_filter(p)]\n        return None",
      "start_line": 77,
      "end_line": 85,
      "source_file": "uvicorn/supervisors/watchfilesreload.py",
      "chunk_type": "code"
    },
    {
      "content": "from __future__ import annotations\n\nimport logging\nimport os\nimport signal\nimport sys\nimport threading\nfrom collections.abc import Iterator\nfrom pathlib import Path\nfrom socket import socket\nfrom types import FrameType\nfrom typing import Callable\n\nimport click\n\nfrom uvicorn._subprocess import get_subprocess\nfrom uvicorn.config import Config\n\nHANDLED_SIGNALS = (\n    signal.SIGINT,  # Unix signal 2. Sent by Ctrl+C.\n    signal.SIGTERM,  # Unix signal 15. Sent by `kill <pid>`.\n)\n\nlogger = logging.getLogger(\"uvicorn.error\")\n\n",
      "start_line": 0,
      "end_line": 26,
      "source_file": "uvicorn/supervisors/basereload.py",
      "chunk_type": "code"
    },
    {
      "content": "class BaseReload:",
      "start_line": 26,
      "end_line": 27,
      "source_file": "uvicorn/supervisors/basereload.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(\n        self,\n        config: Config,\n        target: Callable[[list[socket] | None], None],\n        sockets: list[socket],\n    ) -> None:\n        self.config = config\n        self.target = target\n        self.sockets = sockets\n        self.should_exit = threading.Event()\n        self.pid = os.getpid()\n        self.is_restarting = False\n        self.reloader_name: str | None = None\n",
      "start_line": 27,
      "end_line": 41,
      "source_file": "uvicorn/supervisors/basereload.py",
      "chunk_type": "code"
    },
    {
      "content": "    def signal_handler(self, sig: int, frame: FrameType | None) -> None:  # pragma: full coverage\n        \"\"\"\n        A signal handler that is registered with the parent process.\n        \"\"\"\n        if sys.platform == \"win32\" and self.is_restarting:\n            self.is_restarting = False\n        else:\n            self.should_exit.set()\n",
      "start_line": 41,
      "end_line": 50,
      "source_file": "uvicorn/supervisors/basereload.py",
      "chunk_type": "code"
    },
    {
      "content": "    def run(self) -> None:\n        self.startup()\n        for changes in self:\n            if changes:\n                logger.warning(\n                    \"%s detected changes in %s. Reloading...\",\n                    self.reloader_name,\n                    \", \".join(map(_display_path, changes)),\n                )\n                self.restart()\n\n        self.shutdown()\n",
      "start_line": 50,
      "end_line": 63,
      "source_file": "uvicorn/supervisors/basereload.py",
      "chunk_type": "code"
    },
    {
      "content": "    def pause(self) -> None:\n        if self.should_exit.wait(self.config.reload_delay):\n            raise StopIteration()\n",
      "start_line": 63,
      "end_line": 67,
      "source_file": "uvicorn/supervisors/basereload.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __iter__(self) -> Iterator[list[Path] | None]:\n        return self\n",
      "start_line": 67,
      "end_line": 70,
      "source_file": "uvicorn/supervisors/basereload.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __next__(self) -> list[Path] | None:\n        return self.should_restart()\n",
      "start_line": 70,
      "end_line": 73,
      "source_file": "uvicorn/supervisors/basereload.py",
      "chunk_type": "code"
    },
    {
      "content": "    def startup(self) -> None:\n        message = f\"Started reloader process [{self.pid}] using {self.reloader_name}\"\n        color_message = \"Started reloader process [{}] using {}\".format(\n            click.style(str(self.pid), fg=\"cyan\", bold=True),\n            click.style(str(self.reloader_name), fg=\"cyan\", bold=True),\n        )\n        logger.info(message, extra={\"color_message\": color_message})\n\n        for sig in HANDLED_SIGNALS:\n            signal.signal(sig, self.signal_handler)\n\n        self.process = get_subprocess(config=self.config, target=self.target, sockets=self.sockets)\n        self.process.start()\n",
      "start_line": 73,
      "end_line": 87,
      "source_file": "uvicorn/supervisors/basereload.py",
      "chunk_type": "code"
    },
    {
      "content": "    def restart(self) -> None:\n        if sys.platform == \"win32\":  # pragma: py-not-win32\n            self.is_restarting = True\n            assert self.process.pid is not None\n            os.kill(self.process.pid, signal.CTRL_C_EVENT)\n\n            # This is a workaround to ensure the Ctrl+C event is processed\n            sys.stdout.write(\" \")  # This has to be a non-empty string\n            sys.stdout.flush()\n        else:  # pragma: py-win32\n            self.process.terminate()\n        self.process.join()\n\n        self.process = get_subprocess(config=self.config, target=self.target, sockets=self.sockets)\n        self.process.start()\n",
      "start_line": 87,
      "end_line": 103,
      "source_file": "uvicorn/supervisors/basereload.py",
      "chunk_type": "code"
    },
    {
      "content": "    def shutdown(self) -> None:\n        if sys.platform == \"win32\":\n            self.should_exit.set()  # pragma: py-not-win32\n        else:\n            self.process.terminate()  # pragma: py-win32\n        self.process.join()\n\n        for sock in self.sockets:\n            sock.close()\n\n        message = f\"Stopping reloader process [{str(self.pid)}]\"\n        color_message = \"Stopping reloader process [{}]\".format(click.style(str(self.pid), fg=\"cyan\", bold=True))\n        logger.info(message, extra={\"color_message\": color_message})\n",
      "start_line": 103,
      "end_line": 117,
      "source_file": "uvicorn/supervisors/basereload.py",
      "chunk_type": "code"
    },
    {
      "content": "    def should_restart(self) -> list[Path] | None:\n        raise NotImplementedError(\"Reload strategies should override should_restart()\")\n\n",
      "start_line": 117,
      "end_line": 121,
      "source_file": "uvicorn/supervisors/basereload.py",
      "chunk_type": "code"
    },
    {
      "content": "def _display_path(path: Path) -> str:\n    try:\n        return f\"'{path.relative_to(Path.cwd())}'\"\n    except ValueError:\n        return f\"'{path}'\"",
      "start_line": 121,
      "end_line": 126,
      "source_file": "uvicorn/supervisors/basereload.py",
      "chunk_type": "code"
    },
    {
      "content": "from __future__ import annotations\n\nimport logging\nimport os\nimport signal\nimport threading\nfrom multiprocessing import Pipe\nfrom socket import socket\nfrom typing import Any, Callable\n\nimport click\n\nfrom uvicorn._subprocess import get_subprocess\nfrom uvicorn.config import Config\n\nSIGNALS = {\n    getattr(signal, f\"SIG{x}\"): x\n    for x in \"INT TERM BREAK HUP QUIT TTIN TTOU USR1 USR2 WINCH\".split()\n    if hasattr(signal, f\"SIG{x}\")\n}\n\nlogger = logging.getLogger(\"uvicorn.error\")\n\n",
      "start_line": 0,
      "end_line": 24,
      "source_file": "uvicorn/supervisors/multiprocess.py",
      "chunk_type": "code"
    },
    {
      "content": "class Process:",
      "start_line": 24,
      "end_line": 25,
      "source_file": "uvicorn/supervisors/multiprocess.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(\n        self,\n        config: Config,\n        target: Callable[[list[socket] | None], None],\n        sockets: list[socket],\n    ) -> None:\n        self.real_target = target\n\n        self.parent_conn, self.child_conn = Pipe()\n        self.process = get_subprocess(config, self.target, sockets)\n",
      "start_line": 25,
      "end_line": 36,
      "source_file": "uvicorn/supervisors/multiprocess.py",
      "chunk_type": "code"
    },
    {
      "content": "    def ping(self, timeout: float = 5) -> bool:\n        self.parent_conn.send(b\"ping\")\n        if self.parent_conn.poll(timeout):\n            self.parent_conn.recv()\n            return True\n        return False\n",
      "start_line": 36,
      "end_line": 43,
      "source_file": "uvicorn/supervisors/multiprocess.py",
      "chunk_type": "code"
    },
    {
      "content": "    def pong(self) -> None:\n        self.child_conn.recv()\n        self.child_conn.send(b\"pong\")\n",
      "start_line": 43,
      "end_line": 47,
      "source_file": "uvicorn/supervisors/multiprocess.py",
      "chunk_type": "code"
    },
    {
      "content": "    def always_pong(self) -> None:\n        while True:\n            self.pong()\n",
      "start_line": 47,
      "end_line": 51,
      "source_file": "uvicorn/supervisors/multiprocess.py",
      "chunk_type": "code"
    },
    {
      "content": "    def target(self, sockets: list[socket] | None = None) -> Any:  # pragma: no cover\n        if os.name == \"nt\":  # pragma: py-not-win32\n            # Windows doesn't support SIGTERM, so we use SIGBREAK instead.\n            # And then we raise SIGTERM when SIGBREAK is received.\n            # https://learn.microsoft.com/zh-cn/cpp/c-runtime-library/reference/signal?view=msvc-170\n            signal.signal(\n                signal.SIGBREAK,  # type: ignore[attr-defined]\n                lambda sig, frame: signal.raise_signal(signal.SIGTERM),\n            )\n\n        threading.Thread(target=self.always_pong, daemon=True).start()\n        return self.real_target(sockets)\n",
      "start_line": 51,
      "end_line": 64,
      "source_file": "uvicorn/supervisors/multiprocess.py",
      "chunk_type": "code"
    },
    {
      "content": "    def is_alive(self, timeout: float = 5) -> bool:\n        if not self.process.is_alive():\n            return False  # pragma: full coverage\n\n        return self.ping(timeout)\n",
      "start_line": 64,
      "end_line": 70,
      "source_file": "uvicorn/supervisors/multiprocess.py",
      "chunk_type": "code"
    },
    {
      "content": "    def start(self) -> None:\n        self.process.start()\n",
      "start_line": 70,
      "end_line": 73,
      "source_file": "uvicorn/supervisors/multiprocess.py",
      "chunk_type": "code"
    },
    {
      "content": "    def terminate(self) -> None:\n        if self.process.exitcode is None:  # Process is still running\n            assert self.process.pid is not None\n            if os.name == \"nt\":  # pragma: py-not-win32\n                # Windows doesn't support SIGTERM.\n                # So send SIGBREAK, and then in process raise SIGTERM.\n                os.kill(self.process.pid, signal.CTRL_BREAK_EVENT)  # type: ignore[attr-defined]\n            else:\n                os.kill(self.process.pid, signal.SIGTERM)\n            logger.info(f\"Terminated child process [{self.process.pid}]\")\n\n            self.parent_conn.close()\n            self.child_conn.close()\n",
      "start_line": 73,
      "end_line": 87,
      "source_file": "uvicorn/supervisors/multiprocess.py",
      "chunk_type": "code"
    },
    {
      "content": "    def kill(self) -> None:\n        # In Windows, the method will call `TerminateProcess` to kill the process.\n        # In Unix, the method will send SIGKILL to the process.\n        self.process.kill()\n",
      "start_line": 87,
      "end_line": 92,
      "source_file": "uvicorn/supervisors/multiprocess.py",
      "chunk_type": "code"
    },
    {
      "content": "    def join(self) -> None:\n        logger.info(f\"Waiting for child process [{self.process.pid}]\")\n        self.process.join()\n\n    @property",
      "start_line": 92,
      "end_line": 97,
      "source_file": "uvicorn/supervisors/multiprocess.py",
      "chunk_type": "code"
    },
    {
      "content": "    def pid(self) -> int | None:\n        return self.process.pid\n\n",
      "start_line": 97,
      "end_line": 101,
      "source_file": "uvicorn/supervisors/multiprocess.py",
      "chunk_type": "code"
    },
    {
      "content": "class Multiprocess:",
      "start_line": 101,
      "end_line": 102,
      "source_file": "uvicorn/supervisors/multiprocess.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(\n        self,\n        config: Config,\n        target: Callable[[list[socket] | None], None],\n        sockets: list[socket],\n    ) -> None:\n        self.config = config\n        self.target = target\n        self.sockets = sockets\n\n        self.processes_num = config.workers\n        self.processes: list[Process] = []\n\n        self.should_exit = threading.Event()\n\n        self.signal_queue: list[int] = []\n        for sig in SIGNALS:\n            signal.signal(sig, lambda sig, frame: self.signal_queue.append(sig))\n",
      "start_line": 102,
      "end_line": 121,
      "source_file": "uvicorn/supervisors/multiprocess.py",
      "chunk_type": "code"
    },
    {
      "content": "    def init_processes(self) -> None:\n        for _ in range(self.processes_num):\n            process = Process(self.config, self.target, self.sockets)\n            process.start()\n            self.processes.append(process)\n",
      "start_line": 121,
      "end_line": 127,
      "source_file": "uvicorn/supervisors/multiprocess.py",
      "chunk_type": "code"
    },
    {
      "content": "    def terminate_all(self) -> None:\n        for process in self.processes:\n            process.terminate()\n",
      "start_line": 127,
      "end_line": 131,
      "source_file": "uvicorn/supervisors/multiprocess.py",
      "chunk_type": "code"
    },
    {
      "content": "    def join_all(self) -> None:\n        for process in self.processes:\n            process.join()\n",
      "start_line": 131,
      "end_line": 135,
      "source_file": "uvicorn/supervisors/multiprocess.py",
      "chunk_type": "code"
    },
    {
      "content": "    def restart_all(self) -> None:\n        for idx, process in enumerate(self.processes):\n            process.terminate()\n            process.join()\n            new_process = Process(self.config, self.target, self.sockets)\n            new_process.start()\n            self.processes[idx] = new_process\n",
      "start_line": 135,
      "end_line": 143,
      "source_file": "uvicorn/supervisors/multiprocess.py",
      "chunk_type": "code"
    },
    {
      "content": "    def run(self) -> None:\n        message = f\"Started parent process [{os.getpid()}]\"\n        color_message = \"Started parent process [{}]\".format(click.style(str(os.getpid()), fg=\"cyan\", bold=True))\n        logger.info(message, extra={\"color_message\": color_message})\n\n        self.init_processes()\n\n        while not self.should_exit.wait(0.5):\n            self.handle_signals()\n            self.keep_subprocess_alive()\n\n        self.terminate_all()\n        self.join_all()\n\n        message = f\"Stopping parent process [{os.getpid()}]\"\n        color_message = \"Stopping parent process [{}]\".format(click.style(str(os.getpid()), fg=\"cyan\", bold=True))\n        logger.info(message, extra={\"color_message\": color_message})\n",
      "start_line": 143,
      "end_line": 161,
      "source_file": "uvicorn/supervisors/multiprocess.py",
      "chunk_type": "code"
    },
    {
      "content": "    def keep_subprocess_alive(self) -> None:\n        if self.should_exit.is_set():\n            return  # parent process is exiting, no need to keep subprocess alive\n\n        for idx, process in enumerate(self.processes):\n            if process.is_alive():\n                continue\n\n            process.kill()  # process is hung, kill it\n            process.join()\n\n            if self.should_exit.is_set():\n                return  # pragma: full coverage\n\n            logger.info(f\"Child process [{process.pid}] died\")\n            process = Process(self.config, self.target, self.sockets)\n            process.start()\n            self.processes[idx] = process\n",
      "start_line": 161,
      "end_line": 180,
      "source_file": "uvicorn/supervisors/multiprocess.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_signals(self) -> None:\n        for sig in tuple(self.signal_queue):\n            self.signal_queue.remove(sig)\n            sig_name = SIGNALS[sig]\n            sig_handler = getattr(self, f\"handle_{sig_name.lower()}\", None)\n            if sig_handler is not None:\n                sig_handler()\n            else:  # pragma: no cover\n                logger.debug(f\"Received signal {sig_name}, but no handler is defined for it.\")\n",
      "start_line": 180,
      "end_line": 190,
      "source_file": "uvicorn/supervisors/multiprocess.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_int(self) -> None:\n        logger.info(\"Received SIGINT, exiting.\")\n        self.should_exit.set()\n",
      "start_line": 190,
      "end_line": 194,
      "source_file": "uvicorn/supervisors/multiprocess.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_term(self) -> None:\n        logger.info(\"Received SIGTERM, exiting.\")\n        self.should_exit.set()\n",
      "start_line": 194,
      "end_line": 198,
      "source_file": "uvicorn/supervisors/multiprocess.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_break(self) -> None:  # pragma: py-not-win32\n        logger.info(\"Received SIGBREAK, exiting.\")\n        self.should_exit.set()\n",
      "start_line": 198,
      "end_line": 202,
      "source_file": "uvicorn/supervisors/multiprocess.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_hup(self) -> None:  # pragma: py-win32\n        logger.info(\"Received SIGHUP, restarting processes.\")\n        self.restart_all()\n",
      "start_line": 202,
      "end_line": 206,
      "source_file": "uvicorn/supervisors/multiprocess.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_ttin(self) -> None:  # pragma: py-win32\n        logger.info(\"Received SIGTTIN, increasing the number of processes.\")\n        self.processes_num += 1\n        process = Process(self.config, self.target, self.sockets)\n        process.start()\n        self.processes.append(process)\n",
      "start_line": 206,
      "end_line": 213,
      "source_file": "uvicorn/supervisors/multiprocess.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_ttou(self) -> None:  # pragma: py-win32\n        logger.info(\"Received SIGTTOU, decreasing number of processes.\")\n        if self.processes_num <= 1:\n            logger.info(\"Already reached one process, cannot decrease the number of processes anymore.\")\n            return\n        self.processes_num -= 1\n        process = self.processes.pop()\n        process.terminate()\n        process.join()",
      "start_line": 213,
      "end_line": 222,
      "source_file": "uvicorn/supervisors/multiprocess.py",
      "chunk_type": "code"
    },
    {
      "content": "from __future__ import annotations\n\nfrom typing import Any\n\nfrom uvicorn import Config\n\n",
      "start_line": 0,
      "end_line": 7,
      "source_file": "uvicorn/lifespan/off.py",
      "chunk_type": "code"
    },
    {
      "content": "class LifespanOff:",
      "start_line": 7,
      "end_line": 8,
      "source_file": "uvicorn/lifespan/off.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, config: Config) -> None:\n        self.should_exit = False\n        self.state: dict[str, Any] = {}\n\n    async def startup(self) -> None:\n        pass\n\n    async def shutdown(self) -> None:\n        pass",
      "start_line": 8,
      "end_line": 17,
      "source_file": "uvicorn/lifespan/off.py",
      "chunk_type": "code"
    },
    {
      "content": "from __future__ import annotations\n\nimport asyncio\nimport logging\nfrom asyncio import Queue\nfrom typing import Any, Union\n\nfrom uvicorn import Config\nfrom uvicorn._types import (\n    LifespanScope,\n    LifespanShutdownCompleteEvent,\n    LifespanShutdownEvent,\n    LifespanShutdownFailedEvent,\n    LifespanStartupCompleteEvent,\n    LifespanStartupEvent,\n    LifespanStartupFailedEvent,\n)\n\nLifespanReceiveMessage = Union[LifespanStartupEvent, LifespanShutdownEvent]\nLifespanSendMessage = Union[\n    LifespanStartupFailedEvent,\n    LifespanShutdownFailedEvent,\n    LifespanStartupCompleteEvent,\n    LifespanShutdownCompleteEvent,\n]\n\n\nSTATE_TRANSITION_ERROR = \"Got invalid state transition on lifespan protocol.\"\n\n",
      "start_line": 0,
      "end_line": 30,
      "source_file": "uvicorn/lifespan/on.py",
      "chunk_type": "code"
    },
    {
      "content": "class LifespanOn:",
      "start_line": 30,
      "end_line": 31,
      "source_file": "uvicorn/lifespan/on.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, config: Config) -> None:\n        if not config.loaded:\n            config.load()\n\n        self.config = config\n        self.logger = logging.getLogger(\"uvicorn.error\")\n        self.startup_event = asyncio.Event()\n        self.shutdown_event = asyncio.Event()\n        self.receive_queue: Queue[LifespanReceiveMessage] = asyncio.Queue()\n        self.error_occured = False\n        self.startup_failed = False\n        self.shutdown_failed = False\n        self.should_exit = False\n        self.state: dict[str, Any] = {}\n\n    async def startup(self) -> None:\n        self.logger.info(\"Waiting for application startup.\")\n\n        loop = asyncio.get_event_loop()\n        main_lifespan_task = loop.create_task(self.main())  # noqa: F841\n        # Keep a hard reference to prevent garbage collection\n        # See https://github.com/encode/uvicorn/pull/972\n        startup_event: LifespanStartupEvent = {\"type\": \"lifespan.startup\"}\n        await self.receive_queue.put(startup_event)\n        await self.startup_event.wait()\n\n        if self.startup_failed or (self.error_occured and self.config.lifespan == \"on\"):\n            self.logger.error(\"Application startup failed. Exiting.\")\n            self.should_exit = True\n        else:\n            self.logger.info(\"Application startup complete.\")\n\n    async def shutdown(self) -> None:\n        if self.error_occured:\n            return\n        self.logger.info(\"Waiting for application shutdown.\")\n        shutdown_event: LifespanShutdownEvent = {\"type\": \"lifespan.shutdown\"}\n        await self.receive_queue.put(shutdown_event)\n        await self.shutdown_event.wait()\n\n        if self.shutdown_failed or (self.error_occured and self.config.lifespan == \"on\"):\n            self.logger.error(\"Application shutdown failed. Exiting.\")\n            self.should_exit = True\n        else:\n            self.logger.info(\"Application shutdown complete.\")\n\n    async def main(self) -> None:\n        try:\n            app = self.config.loaded_app\n            scope: LifespanScope = {\n                \"type\": \"lifespan\",\n                \"asgi\": {\"version\": self.config.asgi_version, \"spec_version\": \"2.0\"},\n                \"state\": self.state,\n            }\n            await app(scope, self.receive, self.send)\n        except BaseException as exc:\n            self.asgi = None\n            self.error_occured = True\n            if self.startup_failed or self.shutdown_failed:\n                return\n            if self.config.lifespan == \"auto\":\n                msg = \"ASGI 'lifespan' protocol appears unsupported.\"\n                self.logger.info(msg)\n            else:\n                msg = \"Exception in 'lifespan' protocol\\n\"\n                self.logger.error(msg, exc_info=exc)\n        finally:\n            self.startup_event.set()\n            self.shutdown_event.set()\n\n    async def send(self, message: LifespanSendMessage) -> None:\n        assert message[\"type\"] in (\n            \"lifespan.startup.complete\",\n            \"lifespan.startup.failed\",\n            \"lifespan.shutdown.complete\",\n            \"lifespan.shutdown.failed\",\n        )\n\n        if message[\"type\"] == \"lifespan.startup.complete\":\n            assert not self.startup_event.is_set(), STATE_TRANSITION_ERROR\n            assert not self.shutdown_event.is_set(), STATE_TRANSITION_ERROR\n            self.startup_event.set()\n\n        elif message[\"type\"] == \"lifespan.startup.failed\":\n            assert not self.startup_event.is_set(), STATE_TRANSITION_ERROR\n            assert not self.shutdown_event.is_set(), STATE_TRANSITION_ERROR\n            self.startup_event.set()\n            self.startup_failed = True\n            if message.get(\"message\"):\n                self.logger.error(message[\"message\"])\n\n        elif message[\"type\"] == \"lifespan.shutdown.complete\":\n            assert self.startup_event.is_set(), STATE_TRANSITION_ERROR\n            assert not self.shutdown_event.is_set(), STATE_TRANSITION_ERROR\n            self.shutdown_event.set()\n\n        elif message[\"type\"] == \"lifespan.shutdown.failed\":\n            assert self.startup_event.is_set(), STATE_TRANSITION_ERROR\n            assert not self.shutdown_event.is_set(), STATE_TRANSITION_ERROR\n            self.shutdown_event.set()\n            self.shutdown_failed = True\n            if message.get(\"message\"):\n                self.logger.error(message[\"message\"])\n\n    async def receive(self) -> LifespanReceiveMessage:\n        return await self.receive_queue.get()",
      "start_line": 31,
      "end_line": 137,
      "source_file": "uvicorn/lifespan/on.py",
      "chunk_type": "code"
    },
    {
      "content": "from __future__ import annotations\n\nimport asyncio\nfrom collections.abc import Callable\n\nimport uvloop\n\n",
      "start_line": 0,
      "end_line": 8,
      "source_file": "uvicorn/loops/uvloop.py",
      "chunk_type": "code"
    },
    {
      "content": "def uvloop_loop_factory(use_subprocess: bool = False) -> Callable[[], asyncio.AbstractEventLoop]:\n    return uvloop.new_event_loop",
      "start_line": 8,
      "end_line": 10,
      "source_file": "uvicorn/loops/uvloop.py",
      "chunk_type": "code"
    },
    {
      "content": "from __future__ import annotations\n\nimport asyncio\nimport sys\nfrom collections.abc import Callable\n\n",
      "start_line": 0,
      "end_line": 7,
      "source_file": "uvicorn/loops/asyncio.py",
      "chunk_type": "code"
    },
    {
      "content": "def asyncio_loop_factory(use_subprocess: bool = False) -> Callable[[], asyncio.AbstractEventLoop]:\n    if sys.platform == \"win32\" and not use_subprocess:\n        return asyncio.ProactorEventLoop\n    return asyncio.SelectorEventLoop",
      "start_line": 7,
      "end_line": 11,
      "source_file": "uvicorn/loops/asyncio.py",
      "chunk_type": "code"
    },
    {
      "content": "from __future__ import annotations\n\nimport asyncio\nfrom collections.abc import Callable\n\n",
      "start_line": 0,
      "end_line": 6,
      "source_file": "uvicorn/loops/auto.py",
      "chunk_type": "code"
    },
    {
      "content": "def auto_loop_factory(use_subprocess: bool = False) -> Callable[[], asyncio.AbstractEventLoop]:\n    try:\n        import uvloop  # noqa\n    except ImportError:  # pragma: no cover\n        from uvicorn.loops.asyncio import asyncio_loop_factory as loop_factory\n\n        return loop_factory(use_subprocess=use_subprocess)\n    else:  # pragma: no cover\n        from uvicorn.loops.uvloop import uvloop_loop_factory\n\n        return uvloop_loop_factory(use_subprocess=use_subprocess)",
      "start_line": 6,
      "end_line": 17,
      "source_file": "uvicorn/loops/auto.py",
      "chunk_type": "code"
    },
    {
      "content": "from __future__ import annotations\n\nimport asyncio\nimport urllib.parse\n\nfrom uvicorn._types import WWWScope\n\n",
      "start_line": 0,
      "end_line": 8,
      "source_file": "uvicorn/protocols/utils.py",
      "chunk_type": "code"
    },
    {
      "content": "class ClientDisconnected(OSError): ...\n\n",
      "start_line": 8,
      "end_line": 11,
      "source_file": "uvicorn/protocols/utils.py",
      "chunk_type": "code"
    },
    {
      "content": "def get_remote_addr(transport: asyncio.Transport) -> tuple[str, int] | None:\n    socket_info = transport.get_extra_info(\"socket\")\n    if socket_info is not None:\n        try:\n            info = socket_info.getpeername()\n            return (str(info[0]), int(info[1])) if isinstance(info, tuple) else None\n        except OSError:  # pragma: no cover\n            # This case appears to inconsistently occur with uvloop\n            # bound to a unix domain socket.\n            return None\n\n    info = transport.get_extra_info(\"peername\")\n    if info is not None and isinstance(info, (list, tuple)) and len(info) == 2:\n        return (str(info[0]), int(info[1]))\n    return None\n\n",
      "start_line": 11,
      "end_line": 28,
      "source_file": "uvicorn/protocols/utils.py",
      "chunk_type": "code"
    },
    {
      "content": "def get_local_addr(transport: asyncio.Transport) -> tuple[str, int] | None:\n    socket_info = transport.get_extra_info(\"socket\")\n    if socket_info is not None:\n        info = socket_info.getsockname()\n\n        return (str(info[0]), int(info[1])) if isinstance(info, tuple) else None\n    info = transport.get_extra_info(\"sockname\")\n    if info is not None and isinstance(info, (list, tuple)) and len(info) == 2:\n        return (str(info[0]), int(info[1]))\n    return None\n\n",
      "start_line": 28,
      "end_line": 40,
      "source_file": "uvicorn/protocols/utils.py",
      "chunk_type": "code"
    },
    {
      "content": "def is_ssl(transport: asyncio.Transport) -> bool:\n    return bool(transport.get_extra_info(\"sslcontext\"))\n\n",
      "start_line": 40,
      "end_line": 44,
      "source_file": "uvicorn/protocols/utils.py",
      "chunk_type": "code"
    },
    {
      "content": "def get_client_addr(scope: WWWScope) -> str:\n    client = scope.get(\"client\")\n    if not client:\n        return \"\"\n    return \"%s:%d\" % client\n\n",
      "start_line": 44,
      "end_line": 51,
      "source_file": "uvicorn/protocols/utils.py",
      "chunk_type": "code"
    },
    {
      "content": "def get_path_with_query_string(scope: WWWScope) -> str:\n    path_with_query_string = urllib.parse.quote(scope[\"path\"])\n    if scope[\"query_string\"]:\n        path_with_query_string = \"{}?{}\".format(path_with_query_string, scope[\"query_string\"].decode(\"ascii\"))\n    return path_with_query_string",
      "start_line": 51,
      "end_line": 56,
      "source_file": "uvicorn/protocols/utils.py",
      "chunk_type": "code"
    },
    {
      "content": "from __future__ import annotations\n\nimport asyncio\nimport logging\nimport sys\nfrom asyncio.transports import BaseTransport, Transport\nfrom http import HTTPStatus\nfrom typing import Any, Literal, cast\nfrom urllib.parse import unquote\n\nfrom websockets.exceptions import InvalidState\nfrom websockets.extensions.permessage_deflate import ServerPerMessageDeflateFactory\nfrom websockets.frames import Frame, Opcode\nfrom websockets.http11 import Request\nfrom websockets.server import ServerProtocol\n\nfrom uvicorn._types import (\n    ASGIReceiveEvent,\n    ASGISendEvent,\n    WebSocketAcceptEvent,\n    WebSocketCloseEvent,\n    WebSocketResponseBodyEvent,\n    WebSocketResponseStartEvent,\n    WebSocketScope,\n    WebSocketSendEvent,\n)\nfrom uvicorn.config import Config\nfrom uvicorn.logging import TRACE_LOG_LEVEL\nfrom uvicorn.protocols.utils import (\n    ClientDisconnected,\n    get_local_addr,\n    get_path_with_query_string,\n    get_remote_addr,\n    is_ssl,\n)\nfrom uvicorn.server import ServerState\n\nif sys.version_info >= (3, 11):  # pragma: no cover\n    from typing import assert_never\nelse:  # pragma: no cover\n    from typing_extensions import assert_never\n\n",
      "start_line": 0,
      "end_line": 43,
      "source_file": "uvicorn/protocols/websockets/websockets_sansio_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "class WebSocketsSansIOProtocol(asyncio.Protocol):",
      "start_line": 43,
      "end_line": 44,
      "source_file": "uvicorn/protocols/websockets/websockets_sansio_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(\n        self,\n        config: Config,\n        server_state: ServerState,\n        app_state: dict[str, Any],\n        _loop: asyncio.AbstractEventLoop | None = None,\n    ) -> None:\n        if not config.loaded:\n            config.load()  # pragma: no cover\n\n        self.config = config\n        self.app = config.loaded_app\n        self.loop = _loop or asyncio.get_event_loop()\n        self.logger = logging.getLogger(\"uvicorn.error\")\n        self.root_path = config.root_path\n        self.app_state = app_state\n\n        # Shared server state\n        self.connections = server_state.connections\n        self.tasks = server_state.tasks\n        self.default_headers = server_state.default_headers\n\n        # Connection state\n        self.transport: asyncio.Transport = None  # type: ignore[assignment]\n        self.server: tuple[str, int] | None = None\n        self.client: tuple[str, int] | None = None\n        self.scheme: Literal[\"wss\", \"ws\"] = None  # type: ignore[assignment]\n\n        # WebSocket state\n        self.queue: asyncio.Queue[ASGIReceiveEvent] = asyncio.Queue()\n        self.handshake_initiated = False\n        self.handshake_complete = False\n        self.close_sent = False\n        self.initial_response: tuple[int, list[tuple[str, str]], bytes] | None = None\n\n        extensions = []\n        if self.config.ws_per_message_deflate:\n            extensions = [\n                ServerPerMessageDeflateFactory(\n                    server_max_window_bits=12,\n                    client_max_window_bits=12,\n                    compress_settings={\"memLevel\": 5},\n                )\n            ]\n        self.conn = ServerProtocol(\n            extensions=extensions,\n            max_size=self.config.ws_max_size,\n            logger=logging.getLogger(\"uvicorn.error\"),\n        )\n\n        self.read_paused = False\n        self.writable = asyncio.Event()\n        self.writable.set()\n\n        # Buffers\n        self.bytes = b\"\"\n",
      "start_line": 44,
      "end_line": 101,
      "source_file": "uvicorn/protocols/websockets/websockets_sansio_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def connection_made(self, transport: BaseTransport) -> None:\n        \"\"\"Called when a connection is made.\"\"\"\n        transport = cast(Transport, transport)\n        self.connections.add(self)\n        self.transport = transport\n        self.server = get_local_addr(transport)\n        self.client = get_remote_addr(transport)\n        self.scheme = \"wss\" if is_ssl(transport) else \"ws\"\n\n        if self.logger.level <= TRACE_LOG_LEVEL:\n            prefix = \"%s:%d - \" % self.client if self.client else \"\"\n            self.logger.log(TRACE_LOG_LEVEL, \"%sWebSocket connection made\", prefix)\n",
      "start_line": 101,
      "end_line": 114,
      "source_file": "uvicorn/protocols/websockets/websockets_sansio_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def connection_lost(self, exc: Exception | None) -> None:\n        code = 1005 if self.handshake_complete else 1006\n        self.queue.put_nowait({\"type\": \"websocket.disconnect\", \"code\": code})\n        self.connections.remove(self)\n\n        if self.logger.level <= TRACE_LOG_LEVEL:\n            prefix = \"%s:%d - \" % self.client if self.client else \"\"\n            self.logger.log(TRACE_LOG_LEVEL, \"%sWebSocket connection lost\", prefix)\n\n        self.handshake_complete = True\n        if exc is None:\n            self.transport.close()\n",
      "start_line": 114,
      "end_line": 127,
      "source_file": "uvicorn/protocols/websockets/websockets_sansio_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def eof_received(self) -> None:\n        pass\n",
      "start_line": 127,
      "end_line": 130,
      "source_file": "uvicorn/protocols/websockets/websockets_sansio_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def shutdown(self) -> None:\n        if self.handshake_complete:\n            self.queue.put_nowait({\"type\": \"websocket.disconnect\", \"code\": 1012})\n            self.conn.send_close(1012)\n            output = self.conn.data_to_send()\n            self.transport.write(b\"\".join(output))\n        else:\n            self.send_500_response()\n        self.transport.close()\n",
      "start_line": 130,
      "end_line": 140,
      "source_file": "uvicorn/protocols/websockets/websockets_sansio_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def data_received(self, data: bytes) -> None:\n        self.conn.receive_data(data)\n        if self.conn.parser_exc is not None:  # pragma: no cover\n            self.handle_parser_exception()\n            return\n        self.handle_events()\n",
      "start_line": 140,
      "end_line": 147,
      "source_file": "uvicorn/protocols/websockets/websockets_sansio_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_events(self) -> None:\n        for event in self.conn.events_received():\n            if isinstance(event, Request):\n                self.handle_connect(event)\n            if isinstance(event, Frame):\n                if event.opcode == Opcode.CONT:\n                    self.handle_cont(event)  # pragma: no cover\n                elif event.opcode == Opcode.TEXT:\n                    self.handle_text(event)\n                elif event.opcode == Opcode.BINARY:\n                    self.handle_bytes(event)\n                elif event.opcode == Opcode.PING:\n                    self.handle_ping()\n                elif event.opcode == Opcode.PONG:\n                    pass  # pragma: no cover\n                elif event.opcode == Opcode.CLOSE:\n                    self.handle_close(event)\n                else:\n                    assert_never(event.opcode)  # pragma: no cover\n\n    # Event handlers\n",
      "start_line": 147,
      "end_line": 169,
      "source_file": "uvicorn/protocols/websockets/websockets_sansio_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_connect(self, event: Request) -> None:\n        self.request = event\n        self.response = self.conn.accept(event)\n        self.handshake_initiated = True\n        if self.response.status_code != 101:\n            self.handshake_complete = True\n            self.close_sent = True\n            self.conn.send_response(self.response)\n            output = self.conn.data_to_send()\n            self.transport.write(b\"\".join(output))\n            self.transport.close()\n            return\n\n        headers = [\n            (key.encode(\"ascii\"), value.encode(\"ascii\", errors=\"surrogateescape\"))\n            for key, value in event.headers.raw_items()\n        ]\n        raw_path, _, query_string = event.path.partition(\"?\")\n        self.scope: WebSocketScope = {\n            \"type\": \"websocket\",\n            \"asgi\": {\"version\": self.config.asgi_version, \"spec_version\": \"2.3\"},\n            \"http_version\": \"1.1\",\n            \"scheme\": self.scheme,\n            \"server\": self.server,\n            \"client\": self.client,\n            \"root_path\": self.root_path,\n            \"path\": unquote(raw_path),\n            \"raw_path\": raw_path.encode(\"ascii\"),\n            \"query_string\": query_string.encode(\"ascii\"),\n            \"headers\": headers,\n            \"subprotocols\": event.headers.get_all(\"Sec-WebSocket-Protocol\"),\n            \"state\": self.app_state.copy(),\n            \"extensions\": {\"websocket.http.response\": {}},\n        }\n        self.queue.put_nowait({\"type\": \"websocket.connect\"})\n        task = self.loop.create_task(self.run_asgi())\n        task.add_done_callback(self.on_task_complete)\n        self.tasks.add(task)\n",
      "start_line": 169,
      "end_line": 208,
      "source_file": "uvicorn/protocols/websockets/websockets_sansio_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_cont(self, event: Frame) -> None:  # pragma: no cover\n        self.bytes += event.data\n        if event.fin:\n            self.send_receive_event_to_app()\n",
      "start_line": 208,
      "end_line": 213,
      "source_file": "uvicorn/protocols/websockets/websockets_sansio_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_text(self, event: Frame) -> None:\n        self.bytes = event.data\n        self.curr_msg_data_type: Literal[\"text\", \"bytes\"] = \"text\"\n        if event.fin:\n            self.send_receive_event_to_app()\n",
      "start_line": 213,
      "end_line": 219,
      "source_file": "uvicorn/protocols/websockets/websockets_sansio_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_bytes(self, event: Frame) -> None:\n        self.bytes = event.data\n        self.curr_msg_data_type = \"bytes\"\n        if event.fin:\n            self.send_receive_event_to_app()\n",
      "start_line": 219,
      "end_line": 225,
      "source_file": "uvicorn/protocols/websockets/websockets_sansio_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def send_receive_event_to_app(self) -> None:\n        if self.curr_msg_data_type == \"text\":\n            try:\n                self.queue.put_nowait({\"type\": \"websocket.receive\", \"text\": self.bytes.decode()})\n            except UnicodeDecodeError:  # pragma: no cover\n                self.logger.exception(\"Invalid UTF-8 sequence received from client.\")\n                self.conn.send_close(1007)\n                self.handle_parser_exception()\n                return\n        else:\n            self.queue.put_nowait({\"type\": \"websocket.receive\", \"bytes\": self.bytes})\n        if not self.read_paused:\n            self.read_paused = True\n            self.transport.pause_reading()\n",
      "start_line": 225,
      "end_line": 240,
      "source_file": "uvicorn/protocols/websockets/websockets_sansio_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_ping(self) -> None:\n        output = self.conn.data_to_send()\n        self.transport.write(b\"\".join(output))\n",
      "start_line": 240,
      "end_line": 244,
      "source_file": "uvicorn/protocols/websockets/websockets_sansio_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_close(self, event: Frame) -> None:\n        if not self.close_sent and not self.transport.is_closing():\n            assert self.conn.close_rcvd is not None\n            code = self.conn.close_rcvd.code\n            reason = self.conn.close_rcvd.reason\n            self.queue.put_nowait({\"type\": \"websocket.disconnect\", \"code\": code, \"reason\": reason})\n\n            output = self.conn.data_to_send()\n            self.transport.write(b\"\".join(output))\n            self.transport.close()\n",
      "start_line": 244,
      "end_line": 255,
      "source_file": "uvicorn/protocols/websockets/websockets_sansio_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_parser_exception(self) -> None:  # pragma: no cover\n        assert self.conn.close_sent is not None\n        code = self.conn.close_sent.code\n        reason = self.conn.close_sent.reason\n        self.queue.put_nowait({\"type\": \"websocket.disconnect\", \"code\": code, \"reason\": reason})\n\n        output = self.conn.data_to_send()\n        self.transport.write(b\"\".join(output))\n        self.close_sent = True\n        self.transport.close()\n",
      "start_line": 255,
      "end_line": 266,
      "source_file": "uvicorn/protocols/websockets/websockets_sansio_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def on_task_complete(self, task: asyncio.Task[None]) -> None:\n        self.tasks.discard(task)\n\n    async def run_asgi(self) -> None:\n        try:\n            result = await self.app(self.scope, self.receive, self.send)\n        except ClientDisconnected:\n            self.transport.close()  # pragma: no cover\n        except BaseException:\n            self.logger.exception(\"Exception in ASGI application\\n\")\n            self.send_500_response()\n            self.transport.close()\n        else:\n            if not self.handshake_complete:\n                self.logger.error(\"ASGI callable returned without completing handshake.\")\n                self.send_500_response()\n                self.transport.close()\n            elif result is not None:\n                self.logger.error(\"ASGI callable should return None, but returned '%s'.\", result)\n                self.transport.close()\n",
      "start_line": 266,
      "end_line": 287,
      "source_file": "uvicorn/protocols/websockets/websockets_sansio_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def send_500_response(self) -> None:\n        if self.initial_response or self.handshake_complete:\n            return\n        response = self.conn.reject(500, \"Internal Server Error\")\n        self.conn.send_response(response)\n        output = self.conn.data_to_send()\n        self.transport.write(b\"\".join(output))\n\n    async def send(self, message: ASGISendEvent) -> None:\n        await self.writable.wait()\n\n        message_type = message[\"type\"]\n\n        if not self.handshake_complete and self.initial_response is None:\n            if message_type == \"websocket.accept\":\n                message = cast(WebSocketAcceptEvent, message)\n                self.logger.info(\n                    '%s - \"WebSocket %s\" [accepted]',\n                    self.scope[\"client\"],\n                    get_path_with_query_string(self.scope),\n                )\n                headers = [\n                    (name.decode(\"latin-1\").lower(), value.decode(\"latin-1\").lower())\n                    for name, value in (self.default_headers + list(message.get(\"headers\", [])))\n                ]\n                accepted_subprotocol = message.get(\"subprotocol\")\n                if accepted_subprotocol:\n                    headers.append((\"Sec-WebSocket-Protocol\", accepted_subprotocol))\n                self.response.headers.update(headers)\n\n                if not self.transport.is_closing():\n                    self.handshake_complete = True\n                    self.conn.send_response(self.response)\n                    output = self.conn.data_to_send()\n                    self.transport.write(b\"\".join(output))\n\n            elif message_type == \"websocket.close\":\n                message = cast(WebSocketCloseEvent, message)\n                self.queue.put_nowait({\"type\": \"websocket.disconnect\", \"code\": 1006})\n                self.logger.info(\n                    '%s - \"WebSocket %s\" 403',\n                    self.scope[\"client\"],\n                    get_path_with_query_string(self.scope),\n                )\n                response = self.conn.reject(HTTPStatus.FORBIDDEN, \"\")\n                self.conn.send_response(response)\n                output = self.conn.data_to_send()\n                self.close_sent = True\n                self.handshake_complete = True\n                self.transport.write(b\"\".join(output))\n                self.transport.close()\n            elif message_type == \"websocket.http.response.start\" and self.initial_response is None:\n                message = cast(WebSocketResponseStartEvent, message)\n                if not (100 <= message[\"status\"] < 600):\n                    raise RuntimeError(\"Invalid HTTP status code '%d' in response.\" % message[\"status\"])\n                self.logger.info(\n                    '%s - \"WebSocket %s\" %d',\n                    self.scope[\"client\"],\n                    get_path_with_query_string(self.scope),\n                    message[\"status\"],\n                )\n                headers = [\n                    (name.decode(\"latin-1\"), value.decode(\"latin-1\"))\n                    for name, value in list(message.get(\"headers\", []))\n                ]\n                self.initial_response = (message[\"status\"], headers, b\"\")\n            else:\n                msg = (\n                    \"Expected ASGI message 'websocket.accept', 'websocket.close' \"\n                    \"or 'websocket.http.response.start' \"\n                    \"but got '%s'.\"\n                )\n                raise RuntimeError(msg % message_type)\n\n        elif not self.close_sent and self.initial_response is None:\n            try:\n                if message_type == \"websocket.send\":\n                    message = cast(WebSocketSendEvent, message)\n                    bytes_data = message.get(\"bytes\")\n                    text_data = message.get(\"text\")\n                    if text_data:\n                        self.conn.send_text(text_data.encode())\n                    elif bytes_data:\n                        self.conn.send_binary(bytes_data)\n                    output = self.conn.data_to_send()\n                    self.transport.write(b\"\".join(output))\n\n                elif message_type == \"websocket.close\" and not self.transport.is_closing():\n                    message = cast(WebSocketCloseEvent, message)\n                    code = message.get(\"code\", 1000)\n                    reason = message.get(\"reason\", \"\") or \"\"\n                    self.queue.put_nowait({\"type\": \"websocket.disconnect\", \"code\": code, \"reason\": reason})\n                    self.conn.send_close(code, reason)\n                    output = self.conn.data_to_send()\n                    self.transport.write(b\"\".join(output))\n                    self.close_sent = True\n                    self.transport.close()\n                else:\n                    msg = \"Expected ASGI message 'websocket.send' or 'websocket.close', but got '%s'.\"\n                    raise RuntimeError(msg % message_type)\n            except InvalidState:\n                raise ClientDisconnected()\n        elif self.initial_response is not None:\n            if message_type == \"websocket.http.response.body\":\n                message = cast(WebSocketResponseBodyEvent, message)\n                body = self.initial_response[2] + message[\"body\"]\n                self.initial_response = self.initial_response[:2] + (body,)\n                if not message.get(\"more_body\", False):\n                    response = self.conn.reject(self.initial_response[0], body.decode())\n                    response.headers.update(self.initial_response[1])\n                    self.queue.put_nowait({\"type\": \"websocket.disconnect\", \"code\": 1006})\n                    self.conn.send_response(response)\n                    output = self.conn.data_to_send()\n                    self.close_sent = True\n                    self.transport.write(b\"\".join(output))\n                    self.transport.close()\n            else:  # pragma: no cover\n                msg = \"Expected ASGI message 'websocket.http.response.body' but got '%s'.\"\n                raise RuntimeError(msg % message_type)\n\n        else:\n            msg = \"Unexpected ASGI message '%s', after sending 'websocket.close'.\"\n            raise RuntimeError(msg % message_type)\n\n    async def receive(self) -> ASGIReceiveEvent:\n        message = await self.queue.get()\n        if self.read_paused and self.queue.empty():\n            self.read_paused = False\n            self.transport.resume_reading()\n        return message",
      "start_line": 287,
      "end_line": 417,
      "source_file": "uvicorn/protocols/websockets/websockets_sansio_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "from __future__ import annotations\n\nimport asyncio\nimport http\nimport logging\nfrom collections.abc import Sequence\nfrom typing import Any, Literal, Optional, cast\nfrom urllib.parse import unquote\n\nimport websockets\nimport websockets.legacy.handshake\nfrom websockets.datastructures import Headers\nfrom websockets.exceptions import ConnectionClosed\nfrom websockets.extensions.base import ServerExtensionFactory\nfrom websockets.extensions.permessage_deflate import ServerPerMessageDeflateFactory\nfrom websockets.legacy.server import HTTPResponse\nfrom websockets.server import WebSocketServerProtocol\nfrom websockets.typing import Subprotocol\n\nfrom uvicorn._types import (\n    ASGI3Application,\n    ASGISendEvent,\n    WebSocketAcceptEvent,\n    WebSocketCloseEvent,\n    WebSocketConnectEvent,\n    WebSocketDisconnectEvent,\n    WebSocketReceiveEvent,\n    WebSocketResponseBodyEvent,\n    WebSocketResponseStartEvent,\n    WebSocketScope,\n    WebSocketSendEvent,\n)\nfrom uvicorn.config import Config\nfrom uvicorn.logging import TRACE_LOG_LEVEL\nfrom uvicorn.protocols.utils import (\n    ClientDisconnected,\n    get_client_addr,\n    get_local_addr,\n    get_path_with_query_string,\n    get_remote_addr,\n    is_ssl,\n)\nfrom uvicorn.server import ServerState\n\n",
      "start_line": 0,
      "end_line": 45,
      "source_file": "uvicorn/protocols/websockets/websockets_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "class Server:\n    closing = False\n",
      "start_line": 45,
      "end_line": 48,
      "source_file": "uvicorn/protocols/websockets/websockets_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def register(self, ws: WebSocketServerProtocol) -> None:\n        pass\n",
      "start_line": 48,
      "end_line": 51,
      "source_file": "uvicorn/protocols/websockets/websockets_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def unregister(self, ws: WebSocketServerProtocol) -> None:\n        pass\n",
      "start_line": 51,
      "end_line": 54,
      "source_file": "uvicorn/protocols/websockets/websockets_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def is_serving(self) -> bool:\n        return not self.closing\n\n",
      "start_line": 54,
      "end_line": 58,
      "source_file": "uvicorn/protocols/websockets/websockets_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "class WebSocketProtocol(WebSocketServerProtocol):\n    extra_headers: list[tuple[str, str]]\n    logger: logging.Logger | logging.LoggerAdapter[Any]\n",
      "start_line": 58,
      "end_line": 62,
      "source_file": "uvicorn/protocols/websockets/websockets_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(\n        self,\n        config: Config,\n        server_state: ServerState,\n        app_state: dict[str, Any],\n        _loop: asyncio.AbstractEventLoop | None = None,\n    ):\n        if not config.loaded:\n            config.load()\n\n        self.config = config\n        self.app = cast(ASGI3Application, config.loaded_app)\n        self.loop = _loop or asyncio.get_event_loop()\n        self.root_path = config.root_path\n        self.app_state = app_state\n\n        # Shared server state\n        self.connections = server_state.connections\n        self.tasks = server_state.tasks\n\n        # Connection state\n        self.transport: asyncio.Transport = None  # type: ignore[assignment]\n        self.server: tuple[str, int] | None = None\n        self.client: tuple[str, int] | None = None\n        self.scheme: Literal[\"wss\", \"ws\"] = None  # type: ignore[assignment]\n\n        # Connection events\n        self.scope: WebSocketScope\n        self.handshake_started_event = asyncio.Event()\n        self.handshake_completed_event = asyncio.Event()\n        self.closed_event = asyncio.Event()\n        self.initial_response: HTTPResponse | None = None\n        self.connect_sent = False\n        self.lost_connection_before_handshake = False\n        self.accepted_subprotocol: Subprotocol | None = None\n\n        self.ws_server: Server = Server()  # type: ignore[assignment]\n\n        extensions: list[ServerExtensionFactory] = []\n        if self.config.ws_per_message_deflate:\n            extensions.append(ServerPerMessageDeflateFactory())\n\n        super().__init__(\n            ws_handler=self.ws_handler,\n            ws_server=self.ws_server,  # type: ignore[arg-type]\n            max_size=self.config.ws_max_size,\n            max_queue=self.config.ws_max_queue,\n            ping_interval=self.config.ws_ping_interval,\n            ping_timeout=self.config.ws_ping_timeout,\n            extensions=extensions,\n            logger=logging.getLogger(\"uvicorn.error\"),\n        )\n        self.server_header = None\n        self.extra_headers = [\n            (name.decode(\"latin-1\"), value.decode(\"latin-1\")) for name, value in server_state.default_headers\n        ]\n",
      "start_line": 62,
      "end_line": 119,
      "source_file": "uvicorn/protocols/websockets/websockets_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def connection_made(  # type: ignore[override]\n        self, transport: asyncio.Transport\n    ) -> None:\n        self.connections.add(self)\n        self.transport = transport\n        self.server = get_local_addr(transport)\n        self.client = get_remote_addr(transport)\n        self.scheme = \"wss\" if is_ssl(transport) else \"ws\"\n\n        if self.logger.isEnabledFor(TRACE_LOG_LEVEL):\n            prefix = \"%s:%d - \" % self.client if self.client else \"\"\n            self.logger.log(TRACE_LOG_LEVEL, \"%sWebSocket connection made\", prefix)\n\n        super().connection_made(transport)\n",
      "start_line": 119,
      "end_line": 134,
      "source_file": "uvicorn/protocols/websockets/websockets_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def connection_lost(self, exc: Exception | None) -> None:\n        self.connections.remove(self)\n\n        if self.logger.isEnabledFor(TRACE_LOG_LEVEL):\n            prefix = \"%s:%d - \" % self.client if self.client else \"\"\n            self.logger.log(TRACE_LOG_LEVEL, \"%sWebSocket connection lost\", prefix)\n\n        self.lost_connection_before_handshake = not self.handshake_completed_event.is_set()\n        self.handshake_completed_event.set()\n        super().connection_lost(exc)\n        if exc is None:\n            self.transport.close()\n",
      "start_line": 134,
      "end_line": 147,
      "source_file": "uvicorn/protocols/websockets/websockets_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def shutdown(self) -> None:\n        self.ws_server.closing = True\n        if self.handshake_completed_event.is_set():\n            self.fail_connection(1012)\n        else:\n            self.send_500_response()\n        self.transport.close()\n",
      "start_line": 147,
      "end_line": 155,
      "source_file": "uvicorn/protocols/websockets/websockets_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def on_task_complete(self, task: asyncio.Task[None]) -> None:\n        self.tasks.discard(task)\n\n    async def process_request(self, path: str, request_headers: Headers) -> HTTPResponse | None:\n        \"\"\"\n        This hook is called to determine if the websocket should return\n        an HTTP response and close.\n\n        Our behavior here is to start the ASGI application, and then wait\n        for either `accept` or `close` in order to determine if we should\n        close the connection.\n        \"\"\"\n        path_portion, _, query_string = path.partition(\"?\")\n\n        websockets.legacy.handshake.check_request(request_headers)\n\n        subprotocols: list[str] = []\n        for header in request_headers.get_all(\"Sec-WebSocket-Protocol\"):\n            subprotocols.extend([token.strip() for token in header.split(\",\")])\n\n        asgi_headers = [\n            (name.encode(\"ascii\"), value.encode(\"ascii\", errors=\"surrogateescape\"))\n            for name, value in request_headers.raw_items()\n        ]\n        path = unquote(path_portion)\n        full_path = self.root_path + path\n        full_raw_path = self.root_path.encode(\"ascii\") + path_portion.encode(\"ascii\")\n\n        self.scope = {\n            \"type\": \"websocket\",\n            \"asgi\": {\"version\": self.config.asgi_version, \"spec_version\": \"2.4\"},\n            \"http_version\": \"1.1\",\n            \"scheme\": self.scheme,\n            \"server\": self.server,\n            \"client\": self.client,\n            \"root_path\": self.root_path,\n            \"path\": full_path,\n            \"raw_path\": full_raw_path,\n            \"query_string\": query_string.encode(\"ascii\"),\n            \"headers\": asgi_headers,\n            \"subprotocols\": subprotocols,\n            \"state\": self.app_state.copy(),\n            \"extensions\": {\"websocket.http.response\": {}},\n        }\n        task = self.loop.create_task(self.run_asgi())\n        task.add_done_callback(self.on_task_complete)\n        self.tasks.add(task)\n        await self.handshake_started_event.wait()\n        return self.initial_response\n",
      "start_line": 155,
      "end_line": 205,
      "source_file": "uvicorn/protocols/websockets/websockets_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def process_subprotocol(\n        self, headers: Headers, available_subprotocols: Sequence[Subprotocol] | None\n    ) -> Subprotocol | None:\n        \"\"\"\n        We override the standard 'process_subprotocol' behavior here so that\n        we return whatever subprotocol is sent in the 'accept' message.\n        \"\"\"\n        return self.accepted_subprotocol\n",
      "start_line": 205,
      "end_line": 214,
      "source_file": "uvicorn/protocols/websockets/websockets_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def send_500_response(self) -> None:\n        msg = b\"Internal Server Error\"\n        content = [\n            b\"HTTP/1.1 500 Internal Server Error\\r\\ncontent-type: text/plain; charset=utf-8\\r\\n\",\n            b\"content-length: \" + str(len(msg)).encode(\"ascii\") + b\"\\r\\n\",\n            b\"connection: close\\r\\n\",\n            b\"\\r\\n\",\n            msg,\n        ]\n        self.transport.write(b\"\".join(content))\n        # Allow handler task to terminate cleanly, as websockets doesn't cancel it by\n        # itself (see https://github.com/encode/uvicorn/issues/920)\n        self.handshake_started_event.set()\n\n    async def ws_handler(self, protocol: WebSocketServerProtocol, path: str) -> Any:  # type: ignore[override]\n        \"\"\"\n        This is the main handler function for the 'websockets' implementation\n        to call into. We just wait for close then return, and instead allow\n        'send' and 'receive' events to drive the flow.\n        \"\"\"\n        self.handshake_completed_event.set()\n        await self.wait_closed()\n\n    async def run_asgi(self) -> None:\n        \"\"\"\n        Wrapper around the ASGI callable, handling exceptions and unexpected\n        termination states.\n        \"\"\"\n        try:\n            result = await self.app(self.scope, self.asgi_receive, self.asgi_send)  # type: ignore[func-returns-value]\n        except ClientDisconnected:  # pragma: full coverage\n            self.closed_event.set()\n            self.transport.close()\n        except BaseException:\n            self.closed_event.set()\n            self.logger.exception(\"Exception in ASGI application\\n\")\n            if not self.handshake_started_event.is_set():\n                self.send_500_response()\n            else:\n                await self.handshake_completed_event.wait()\n            self.transport.close()\n        else:\n            self.closed_event.set()\n            if not self.handshake_started_event.is_set():\n                self.logger.error(\"ASGI callable returned without sending handshake.\")\n                self.send_500_response()\n                self.transport.close()\n            elif result is not None:\n                self.logger.error(\"ASGI callable should return None, but returned '%s'.\", result)\n                await self.handshake_completed_event.wait()\n                self.transport.close()\n\n    async def asgi_send(self, message: ASGISendEvent) -> None:\n        message_type = message[\"type\"]\n\n        if not self.handshake_started_event.is_set():\n            if message_type == \"websocket.accept\":\n                message = cast(\"WebSocketAcceptEvent\", message)\n                self.logger.info(\n                    '%s - \"WebSocket %s\" [accepted]',\n                    get_client_addr(self.scope),\n                    get_path_with_query_string(self.scope),\n                )\n                self.initial_response = None\n                self.accepted_subprotocol = cast(Optional[Subprotocol], message.get(\"subprotocol\"))\n                if \"headers\" in message:\n                    self.extra_headers.extend(\n                        # ASGI spec requires bytes\n                        # But for compatibility we need to convert it to strings\n                        (name.decode(\"latin-1\"), value.decode(\"latin-1\"))\n                        for name, value in message[\"headers\"]\n                    )\n                self.handshake_started_event.set()\n\n            elif message_type == \"websocket.close\":\n                message = cast(\"WebSocketCloseEvent\", message)\n                self.logger.info(\n                    '%s - \"WebSocket %s\" 403',\n                    get_client_addr(self.scope),\n                    get_path_with_query_string(self.scope),\n                )\n                self.initial_response = (http.HTTPStatus.FORBIDDEN, [], b\"\")\n                self.handshake_started_event.set()\n                self.closed_event.set()\n\n            elif message_type == \"websocket.http.response.start\":\n                message = cast(\"WebSocketResponseStartEvent\", message)\n                self.logger.info(\n                    '%s - \"WebSocket %s\" %d',\n                    get_client_addr(self.scope),\n                    get_path_with_query_string(self.scope),\n                    message[\"status\"],\n                )\n                # websockets requires the status to be an enum. look it up.\n                status = http.HTTPStatus(message[\"status\"])\n                headers = [\n                    (name.decode(\"latin-1\"), value.decode(\"latin-1\")) for name, value in message.get(\"headers\", [])\n                ]\n                self.initial_response = (status, headers, b\"\")\n                self.handshake_started_event.set()\n\n            else:\n                msg = (\n                    \"Expected ASGI message 'websocket.accept', 'websocket.close', \"\n                    \"or 'websocket.http.response.start' but got '%s'.\"\n                )\n                raise RuntimeError(msg % message_type)\n\n        elif not self.closed_event.is_set() and self.initial_response is None:\n            await self.handshake_completed_event.wait()\n\n            try:\n                if message_type == \"websocket.send\":\n                    message = cast(\"WebSocketSendEvent\", message)\n                    bytes_data = message.get(\"bytes\")\n                    text_data = message.get(\"text\")\n                    data = text_data if bytes_data is None else bytes_data\n                    await self.send(data)  # type: ignore[arg-type]\n\n                elif message_type == \"websocket.close\":\n                    message = cast(\"WebSocketCloseEvent\", message)\n                    code = message.get(\"code\", 1000)\n                    reason = message.get(\"reason\", \"\") or \"\"\n                    await self.close(code, reason)\n                    self.closed_event.set()\n\n                else:\n                    msg = \"Expected ASGI message 'websocket.send' or 'websocket.close', but got '%s'.\"\n                    raise RuntimeError(msg % message_type)\n            except ConnectionClosed as exc:\n                raise ClientDisconnected from exc\n\n        elif self.initial_response is not None:\n            if message_type == \"websocket.http.response.body\":\n                message = cast(\"WebSocketResponseBodyEvent\", message)\n                body = self.initial_response[2] + message[\"body\"]\n                self.initial_response = self.initial_response[:2] + (body,)\n                if not message.get(\"more_body\", False):\n                    self.closed_event.set()\n            else:\n                msg = \"Expected ASGI message 'websocket.http.response.body' but got '%s'.\"\n                raise RuntimeError(msg % message_type)\n\n        else:\n            msg = \"Unexpected ASGI message '%s', after sending 'websocket.close' or response already completed.\"\n            raise RuntimeError(msg % message_type)\n\n    async def asgi_receive(self) -> WebSocketDisconnectEvent | WebSocketConnectEvent | WebSocketReceiveEvent:\n        if not self.connect_sent:\n            self.connect_sent = True\n            return {\"type\": \"websocket.connect\"}\n\n        await self.handshake_completed_event.wait()\n\n        if self.lost_connection_before_handshake:\n            # If the handshake failed or the app closed before handshake completion,\n            # use 1006 Abnormal Closure.\n            return {\"type\": \"websocket.disconnect\", \"code\": 1006}\n\n        if self.closed_event.is_set():\n            return {\"type\": \"websocket.disconnect\", \"code\": 1005}\n\n        try:\n            data = await self.recv()\n        except ConnectionClosed:\n            self.closed_event.set()\n            if self.ws_server.closing:\n                return {\"type\": \"websocket.disconnect\", \"code\": 1012}\n            return {\"type\": \"websocket.disconnect\", \"code\": self.close_code or 1005, \"reason\": self.close_reason}\n\n        if isinstance(data, str):\n            return {\"type\": \"websocket.receive\", \"text\": data}\n        return {\"type\": \"websocket.receive\", \"bytes\": data}",
      "start_line": 214,
      "end_line": 387,
      "source_file": "uvicorn/protocols/websockets/websockets_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "from __future__ import annotations\n\nimport asyncio\nimport logging\nfrom typing import Any, Literal, cast\nfrom urllib.parse import unquote\n\nimport wsproto\nfrom wsproto import ConnectionType, events\nfrom wsproto.connection import ConnectionState\nfrom wsproto.extensions import Extension, PerMessageDeflate\nfrom wsproto.utilities import LocalProtocolError, RemoteProtocolError\n\nfrom uvicorn._types import (\n    ASGI3Application,\n    ASGISendEvent,\n    WebSocketAcceptEvent,\n    WebSocketCloseEvent,\n    WebSocketEvent,\n    WebSocketResponseBodyEvent,\n    WebSocketResponseStartEvent,\n    WebSocketScope,\n    WebSocketSendEvent,\n)\nfrom uvicorn.config import Config\nfrom uvicorn.logging import TRACE_LOG_LEVEL\nfrom uvicorn.protocols.utils import (\n    ClientDisconnected,\n    get_client_addr,\n    get_local_addr,\n    get_path_with_query_string,\n    get_remote_addr,\n    is_ssl,\n)\nfrom uvicorn.server import ServerState\n\n",
      "start_line": 0,
      "end_line": 37,
      "source_file": "uvicorn/protocols/websockets/wsproto_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "class WSProtocol(asyncio.Protocol):",
      "start_line": 37,
      "end_line": 38,
      "source_file": "uvicorn/protocols/websockets/wsproto_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(\n        self,\n        config: Config,\n        server_state: ServerState,\n        app_state: dict[str, Any],\n        _loop: asyncio.AbstractEventLoop | None = None,\n    ) -> None:\n        if not config.loaded:\n            config.load()  # pragma: full coverage\n\n        self.config = config\n        self.app = cast(ASGI3Application, config.loaded_app)\n        self.loop = _loop or asyncio.get_event_loop()\n        self.logger = logging.getLogger(\"uvicorn.error\")\n        self.root_path = config.root_path\n        self.app_state = app_state\n\n        # Shared server state\n        self.connections = server_state.connections\n        self.tasks = server_state.tasks\n        self.default_headers = server_state.default_headers\n\n        # Connection state\n        self.transport: asyncio.Transport = None  # type: ignore[assignment]\n        self.server: tuple[str, int] | None = None\n        self.client: tuple[str, int] | None = None\n        self.scheme: Literal[\"wss\", \"ws\"] = None  # type: ignore[assignment]\n\n        # WebSocket state\n        self.queue: asyncio.Queue[WebSocketEvent] = asyncio.Queue()\n        self.handshake_complete = False\n        self.close_sent = False\n\n        # Rejection state\n        self.response_started = False\n\n        self.conn = wsproto.WSConnection(connection_type=ConnectionType.SERVER)\n\n        self.read_paused = False\n        self.writable = asyncio.Event()\n        self.writable.set()\n\n        # Buffers\n        self.bytes = b\"\"\n        self.text = \"\"\n\n    # Protocol interface\n",
      "start_line": 38,
      "end_line": 86,
      "source_file": "uvicorn/protocols/websockets/wsproto_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def connection_made(  # type: ignore[override]\n        self, transport: asyncio.Transport\n    ) -> None:\n        self.connections.add(self)\n        self.transport = transport\n        self.server = get_local_addr(transport)\n        self.client = get_remote_addr(transport)\n        self.scheme = \"wss\" if is_ssl(transport) else \"ws\"\n\n        if self.logger.level <= TRACE_LOG_LEVEL:\n            prefix = \"%s:%d - \" % self.client if self.client else \"\"\n            self.logger.log(TRACE_LOG_LEVEL, \"%sWebSocket connection made\", prefix)\n",
      "start_line": 86,
      "end_line": 99,
      "source_file": "uvicorn/protocols/websockets/wsproto_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def connection_lost(self, exc: Exception | None) -> None:\n        code = 1005 if self.handshake_complete else 1006\n        self.queue.put_nowait({\"type\": \"websocket.disconnect\", \"code\": code})\n        self.connections.remove(self)\n\n        if self.logger.level <= TRACE_LOG_LEVEL:\n            prefix = \"%s:%d - \" % self.client if self.client else \"\"\n            self.logger.log(TRACE_LOG_LEVEL, \"%sWebSocket connection lost\", prefix)\n\n        self.handshake_complete = True\n        if exc is None:\n            self.transport.close()\n",
      "start_line": 99,
      "end_line": 112,
      "source_file": "uvicorn/protocols/websockets/wsproto_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def eof_received(self) -> None:\n        pass\n",
      "start_line": 112,
      "end_line": 115,
      "source_file": "uvicorn/protocols/websockets/wsproto_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def data_received(self, data: bytes) -> None:\n        try:\n            self.conn.receive_data(data)\n        except RemoteProtocolError as err:\n            # TODO: Remove `type: ignore` when wsproto fixes the type annotation.\n            self.transport.write(self.conn.send(err.event_hint))  # type: ignore[arg-type]  # noqa: E501\n            self.transport.close()\n        else:\n            self.handle_events()\n",
      "start_line": 115,
      "end_line": 125,
      "source_file": "uvicorn/protocols/websockets/wsproto_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_events(self) -> None:\n        for event in self.conn.events():\n            if isinstance(event, events.Request):\n                self.handle_connect(event)\n            elif isinstance(event, events.TextMessage):\n                self.handle_text(event)\n            elif isinstance(event, events.BytesMessage):\n                self.handle_bytes(event)\n            elif isinstance(event, events.CloseConnection):\n                self.handle_close(event)\n            elif isinstance(event, events.Ping):\n                self.handle_ping(event)\n",
      "start_line": 125,
      "end_line": 138,
      "source_file": "uvicorn/protocols/websockets/wsproto_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def pause_writing(self) -> None:\n        \"\"\"\n        Called by the transport when the write buffer exceeds the high water mark.\n        \"\"\"\n        self.writable.clear()  # pragma: full coverage\n",
      "start_line": 138,
      "end_line": 144,
      "source_file": "uvicorn/protocols/websockets/wsproto_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def resume_writing(self) -> None:\n        \"\"\"\n        Called by the transport when the write buffer drops below the low water mark.\n        \"\"\"\n        self.writable.set()  # pragma: full coverage\n",
      "start_line": 144,
      "end_line": 150,
      "source_file": "uvicorn/protocols/websockets/wsproto_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def shutdown(self) -> None:\n        if self.handshake_complete:\n            self.queue.put_nowait({\"type\": \"websocket.disconnect\", \"code\": 1012})\n            output = self.conn.send(wsproto.events.CloseConnection(code=1012))\n            self.transport.write(output)\n        else:\n            self.send_500_response()\n        self.transport.close()\n",
      "start_line": 150,
      "end_line": 159,
      "source_file": "uvicorn/protocols/websockets/wsproto_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def on_task_complete(self, task: asyncio.Task[None]) -> None:\n        self.tasks.discard(task)\n\n    # Event handlers\n",
      "start_line": 159,
      "end_line": 164,
      "source_file": "uvicorn/protocols/websockets/wsproto_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_connect(self, event: events.Request) -> None:\n        headers = [(b\"host\", event.host.encode())]\n        headers += [(key.lower(), value) for key, value in event.extra_headers]\n        raw_path, _, query_string = event.target.partition(\"?\")\n        path = unquote(raw_path)\n        full_path = self.root_path + path\n        full_raw_path = self.root_path.encode(\"ascii\") + raw_path.encode(\"ascii\")\n        self.scope: WebSocketScope = {\n            \"type\": \"websocket\",\n            \"asgi\": {\"version\": self.config.asgi_version, \"spec_version\": \"2.4\"},\n            \"http_version\": \"1.1\",\n            \"scheme\": self.scheme,\n            \"server\": self.server,\n            \"client\": self.client,\n            \"root_path\": self.root_path,\n            \"path\": full_path,\n            \"raw_path\": full_raw_path,\n            \"query_string\": query_string.encode(\"ascii\"),\n            \"headers\": headers,\n            \"subprotocols\": event.subprotocols,\n            \"state\": self.app_state.copy(),\n            \"extensions\": {\"websocket.http.response\": {}},\n        }\n        self.queue.put_nowait({\"type\": \"websocket.connect\"})\n        task = self.loop.create_task(self.run_asgi())\n        task.add_done_callback(self.on_task_complete)\n        self.tasks.add(task)\n",
      "start_line": 164,
      "end_line": 192,
      "source_file": "uvicorn/protocols/websockets/wsproto_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_text(self, event: events.TextMessage) -> None:\n        self.text += event.data\n        if event.message_finished:\n            self.queue.put_nowait({\"type\": \"websocket.receive\", \"text\": self.text})\n            self.text = \"\"\n            if not self.read_paused:\n                self.read_paused = True\n                self.transport.pause_reading()\n",
      "start_line": 192,
      "end_line": 201,
      "source_file": "uvicorn/protocols/websockets/wsproto_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_bytes(self, event: events.BytesMessage) -> None:\n        self.bytes += event.data\n        # todo: we may want to guard the size of self.bytes and self.text\n        if event.message_finished:\n            self.queue.put_nowait({\"type\": \"websocket.receive\", \"bytes\": self.bytes})\n            self.bytes = b\"\"\n            if not self.read_paused:\n                self.read_paused = True\n                self.transport.pause_reading()\n",
      "start_line": 201,
      "end_line": 211,
      "source_file": "uvicorn/protocols/websockets/wsproto_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_close(self, event: events.CloseConnection) -> None:\n        if self.conn.state == ConnectionState.REMOTE_CLOSING:\n            self.transport.write(self.conn.send(event.response()))\n        self.queue.put_nowait({\"type\": \"websocket.disconnect\", \"code\": event.code, \"reason\": event.reason})\n        self.transport.close()\n",
      "start_line": 211,
      "end_line": 217,
      "source_file": "uvicorn/protocols/websockets/wsproto_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_ping(self, event: events.Ping) -> None:\n        self.transport.write(self.conn.send(event.response()))\n",
      "start_line": 217,
      "end_line": 220,
      "source_file": "uvicorn/protocols/websockets/wsproto_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def send_500_response(self) -> None:\n        if self.response_started or self.handshake_complete:\n            return  # we cannot send responses anymore\n        headers: list[tuple[bytes, bytes]] = [\n            (b\"content-type\", b\"text/plain; charset=utf-8\"),\n            (b\"connection\", b\"close\"),\n            (b\"content-length\", b\"21\"),\n        ]\n        output = self.conn.send(wsproto.events.RejectConnection(status_code=500, headers=headers, has_body=True))\n        output += self.conn.send(wsproto.events.RejectData(data=b\"Internal Server Error\"))\n        self.transport.write(output)\n\n    async def run_asgi(self) -> None:\n        try:\n            result = await self.app(self.scope, self.receive, self.send)  # type: ignore[func-returns-value]\n        except ClientDisconnected:\n            self.transport.close()  # pragma: full coverage\n        except BaseException:\n            self.logger.exception(\"Exception in ASGI application\\n\")\n            self.send_500_response()\n            self.transport.close()\n        else:\n            if not self.handshake_complete:\n                self.logger.error(\"ASGI callable returned without completing handshake.\")\n                self.send_500_response()\n                self.transport.close()\n            elif result is not None:\n                self.logger.error(\"ASGI callable should return None, but returned '%s'.\", result)\n                self.transport.close()\n\n    async def send(self, message: ASGISendEvent) -> None:\n        await self.writable.wait()\n\n        message_type = message[\"type\"]\n\n        if not self.handshake_complete:\n            if message_type == \"websocket.accept\":\n                message = cast(WebSocketAcceptEvent, message)\n                self.logger.info(\n                    '%s - \"WebSocket %s\" [accepted]',\n                    get_client_addr(self.scope),\n                    get_path_with_query_string(self.scope),\n                )\n                subprotocol = message.get(\"subprotocol\")\n                extra_headers = self.default_headers + list(message.get(\"headers\", []))\n                extensions: list[Extension] = []\n                if self.config.ws_per_message_deflate:\n                    extensions.append(PerMessageDeflate())\n                if not self.transport.is_closing():\n                    self.handshake_complete = True\n                    output = self.conn.send(\n                        wsproto.events.AcceptConnection(\n                            subprotocol=subprotocol,\n                            extensions=extensions,\n                            extra_headers=extra_headers,\n                        )\n                    )\n                    self.transport.write(output)\n\n            elif message_type == \"websocket.close\":\n                self.queue.put_nowait({\"type\": \"websocket.disconnect\", \"code\": 1006})\n                self.logger.info(\n                    '%s - \"WebSocket %s\" 403',\n                    get_client_addr(self.scope),\n                    get_path_with_query_string(self.scope),\n                )\n                self.handshake_complete = True\n                self.close_sent = True\n                event = events.RejectConnection(status_code=403, headers=[])\n                output = self.conn.send(event)\n                self.transport.write(output)\n                self.transport.close()\n\n            elif message_type == \"websocket.http.response.start\":\n                message = cast(WebSocketResponseStartEvent, message)\n                # ensure status code is in the valid range\n                if not (100 <= message[\"status\"] < 600):\n                    msg = \"Invalid HTTP status code '%d' in response.\"\n                    raise RuntimeError(msg % message[\"status\"])\n                self.logger.info(\n                    '%s - \"WebSocket %s\" %d',\n                    get_client_addr(self.scope),\n                    get_path_with_query_string(self.scope),\n                    message[\"status\"],\n                )\n                self.handshake_complete = True\n                event = events.RejectConnection(\n                    status_code=message[\"status\"],\n                    headers=list(message[\"headers\"]),\n                    has_body=True,\n                )\n                output = self.conn.send(event)\n                self.transport.write(output)\n                self.response_started = True\n\n            else:\n                msg = (\n                    \"Expected ASGI message 'websocket.accept', 'websocket.close' \"\n                    \"or 'websocket.http.response.start' \"\n                    \"but got '%s'.\"\n                )\n                raise RuntimeError(msg % message_type)\n\n        elif not self.close_sent and not self.response_started:\n            try:\n                if message_type == \"websocket.send\":\n                    message = cast(WebSocketSendEvent, message)\n                    bytes_data = message.get(\"bytes\")\n                    text_data = message.get(\"text\")\n                    data = text_data if bytes_data is None else bytes_data\n                    output = self.conn.send(wsproto.events.Message(data=data))  # type: ignore\n                    if not self.transport.is_closing():\n                        self.transport.write(output)\n\n                elif message_type == \"websocket.close\":\n                    message = cast(WebSocketCloseEvent, message)\n                    self.close_sent = True\n                    code = message.get(\"code\", 1000)\n                    reason = message.get(\"reason\", \"\") or \"\"\n                    self.queue.put_nowait({\"type\": \"websocket.disconnect\", \"code\": code, \"reason\": reason})\n                    output = self.conn.send(wsproto.events.CloseConnection(code=code, reason=reason))\n                    if not self.transport.is_closing():\n                        self.transport.write(output)\n                        self.transport.close()\n\n                else:\n                    msg = \"Expected ASGI message 'websocket.send' or 'websocket.close', but got '%s'.\"\n                    raise RuntimeError(msg % message_type)\n            except LocalProtocolError as exc:\n                raise ClientDisconnected from exc\n        elif self.response_started:\n            if message_type == \"websocket.http.response.body\":\n                message = cast(\"WebSocketResponseBodyEvent\", message)\n                body_finished = not message.get(\"more_body\", False)\n                reject_data = events.RejectData(data=message[\"body\"], body_finished=body_finished)\n                output = self.conn.send(reject_data)\n                self.transport.write(output)\n\n                if body_finished:\n                    self.queue.put_nowait({\"type\": \"websocket.disconnect\", \"code\": 1006})\n                    self.close_sent = True\n                    self.transport.close()\n\n            else:\n                msg = \"Expected ASGI message 'websocket.http.response.body' but got '%s'.\"\n                raise RuntimeError(msg % message_type)\n\n        else:\n            msg = \"Unexpected ASGI message '%s', after sending 'websocket.close'.\"\n            raise RuntimeError(msg % message_type)\n\n    async def receive(self) -> WebSocketEvent:\n        message = await self.queue.get()\n        if self.read_paused and self.queue.empty():\n            self.read_paused = False\n            self.transport.resume_reading()\n        return message",
      "start_line": 220,
      "end_line": 377,
      "source_file": "uvicorn/protocols/websockets/wsproto_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "from __future__ import annotations\n\nimport asyncio\nfrom typing import Callable\n\nAutoWebSocketsProtocol: Callable[..., asyncio.Protocol] | None\ntry:\n    import websockets  # noqa\nexcept ImportError:  # pragma: no cover\n    try:\n        import wsproto  # noqa\n    except ImportError:\n        AutoWebSocketsProtocol = None\n    else:\n        from uvicorn.protocols.websockets.wsproto_impl import WSProtocol\n\n        AutoWebSocketsProtocol = WSProtocol\nelse:\n    from uvicorn.protocols.websockets.websockets_impl import WebSocketProtocol\n\n    AutoWebSocketsProtocol = WebSocketProtocol",
      "start_line": 0,
      "end_line": 21,
      "source_file": "uvicorn/protocols/websockets/auto.py",
      "chunk_type": "code"
    },
    {
      "content": "import asyncio\n\nfrom uvicorn._types import ASGIReceiveCallable, ASGISendCallable, Scope\n\nCLOSE_HEADER = (b\"connection\", b\"close\")\n\nHIGH_WATER_LIMIT = 65536\n\n",
      "start_line": 0,
      "end_line": 9,
      "source_file": "uvicorn/protocols/http/flow_control.py",
      "chunk_type": "code"
    },
    {
      "content": "class FlowControl:",
      "start_line": 9,
      "end_line": 10,
      "source_file": "uvicorn/protocols/http/flow_control.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, transport: asyncio.Transport) -> None:\n        self._transport = transport\n        self.read_paused = False\n        self.write_paused = False\n        self._is_writable_event = asyncio.Event()\n        self._is_writable_event.set()\n\n    async def drain(self) -> None:\n        await self._is_writable_event.wait()  # pragma: full coverage\n",
      "start_line": 10,
      "end_line": 20,
      "source_file": "uvicorn/protocols/http/flow_control.py",
      "chunk_type": "code"
    },
    {
      "content": "    def pause_reading(self) -> None:\n        if not self.read_paused:\n            self.read_paused = True\n            self._transport.pause_reading()\n",
      "start_line": 20,
      "end_line": 25,
      "source_file": "uvicorn/protocols/http/flow_control.py",
      "chunk_type": "code"
    },
    {
      "content": "    def resume_reading(self) -> None:\n        if self.read_paused:\n            self.read_paused = False\n            self._transport.resume_reading()\n",
      "start_line": 25,
      "end_line": 30,
      "source_file": "uvicorn/protocols/http/flow_control.py",
      "chunk_type": "code"
    },
    {
      "content": "    def pause_writing(self) -> None:\n        if not self.write_paused:  # pragma: full coverage\n            self.write_paused = True\n            self._is_writable_event.clear()\n",
      "start_line": 30,
      "end_line": 35,
      "source_file": "uvicorn/protocols/http/flow_control.py",
      "chunk_type": "code"
    },
    {
      "content": "    def resume_writing(self) -> None:\n        if self.write_paused:  # pragma: full coverage\n            self.write_paused = False\n            self._is_writable_event.set()\n\n\nasync def service_unavailable(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable) -> None:\n    await send(\n        {\n            \"type\": \"http.response.start\",\n            \"status\": 503,\n            \"headers\": [\n                (b\"content-type\", b\"text/plain; charset=utf-8\"),\n                (b\"content-length\", b\"19\"),\n                (b\"connection\", b\"close\"),\n            ],\n        }\n    )\n    await send({\"type\": \"http.response.body\", \"body\": b\"Service Unavailable\", \"more_body\": False})",
      "start_line": 35,
      "end_line": 54,
      "source_file": "uvicorn/protocols/http/flow_control.py",
      "chunk_type": "code"
    },
    {
      "content": "from __future__ import annotations\n\nimport asyncio\nimport http\nimport logging\nfrom typing import Any, Callable, Literal, cast\nfrom urllib.parse import unquote\n\nimport h11\nfrom h11._connection import DEFAULT_MAX_INCOMPLETE_EVENT_SIZE\n\nfrom uvicorn._types import (\n    ASGI3Application,\n    ASGIReceiveEvent,\n    ASGISendEvent,\n    HTTPRequestEvent,\n    HTTPResponseBodyEvent,\n    HTTPResponseStartEvent,\n    HTTPScope,\n)\nfrom uvicorn.config import Config\nfrom uvicorn.logging import TRACE_LOG_LEVEL\nfrom uvicorn.protocols.http.flow_control import CLOSE_HEADER, HIGH_WATER_LIMIT, FlowControl, service_unavailable\nfrom uvicorn.protocols.utils import get_client_addr, get_local_addr, get_path_with_query_string, get_remote_addr, is_ssl\nfrom uvicorn.server import ServerState\n\n",
      "start_line": 0,
      "end_line": 27,
      "source_file": "uvicorn/protocols/http/h11_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "def _get_status_phrase(status_code: int) -> bytes:\n    try:\n        return http.HTTPStatus(status_code).phrase.encode()\n    except ValueError:\n        return b\"\"\n\n\nSTATUS_PHRASES = {status_code: _get_status_phrase(status_code) for status_code in range(100, 600)}\n\n",
      "start_line": 27,
      "end_line": 37,
      "source_file": "uvicorn/protocols/http/h11_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "class H11Protocol(asyncio.Protocol):",
      "start_line": 37,
      "end_line": 38,
      "source_file": "uvicorn/protocols/http/h11_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(\n        self,\n        config: Config,\n        server_state: ServerState,\n        app_state: dict[str, Any],\n        _loop: asyncio.AbstractEventLoop | None = None,\n    ) -> None:\n        if not config.loaded:\n            config.load()\n\n        self.config = config\n        self.app = config.loaded_app\n        self.loop = _loop or asyncio.get_event_loop()\n        self.logger = logging.getLogger(\"uvicorn.error\")\n        self.access_logger = logging.getLogger(\"uvicorn.access\")\n        self.access_log = self.access_logger.hasHandlers()\n        self.conn = h11.Connection(\n            h11.SERVER,\n            config.h11_max_incomplete_event_size\n            if config.h11_max_incomplete_event_size is not None\n            else DEFAULT_MAX_INCOMPLETE_EVENT_SIZE,\n        )\n        self.ws_protocol_class = config.ws_protocol_class\n        self.root_path = config.root_path\n        self.limit_concurrency = config.limit_concurrency\n        self.app_state = app_state\n\n        # Timeouts\n        self.timeout_keep_alive_task: asyncio.TimerHandle | None = None\n        self.timeout_keep_alive = config.timeout_keep_alive\n\n        # Shared server state\n        self.server_state = server_state\n        self.connections = server_state.connections\n        self.tasks = server_state.tasks\n\n        # Per-connection state\n        self.transport: asyncio.Transport = None  # type: ignore[assignment]\n        self.flow: FlowControl = None  # type: ignore[assignment]\n        self.server: tuple[str, int] | None = None\n        self.client: tuple[str, int] | None = None\n        self.scheme: Literal[\"http\", \"https\"] | None = None\n\n        # Per-request state\n        self.scope: HTTPScope = None  # type: ignore[assignment]\n        self.headers: list[tuple[bytes, bytes]] = None  # type: ignore[assignment]\n        self.cycle: RequestResponseCycle = None  # type: ignore[assignment]\n\n    # Protocol interface",
      "start_line": 38,
      "end_line": 87,
      "source_file": "uvicorn/protocols/http/h11_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def connection_made(  # type: ignore[override]\n        self, transport: asyncio.Transport\n    ) -> None:\n        self.connections.add(self)\n\n        self.transport = transport\n        self.flow = FlowControl(transport)\n        self.server = get_local_addr(transport)\n        self.client = get_remote_addr(transport)\n        self.scheme = \"https\" if is_ssl(transport) else \"http\"\n\n        if self.logger.level <= TRACE_LOG_LEVEL:\n            prefix = \"%s:%d - \" % self.client if self.client else \"\"\n            self.logger.log(TRACE_LOG_LEVEL, \"%sHTTP connection made\", prefix)\n",
      "start_line": 87,
      "end_line": 102,
      "source_file": "uvicorn/protocols/http/h11_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def connection_lost(self, exc: Exception | None) -> None:\n        self.connections.discard(self)\n\n        if self.logger.level <= TRACE_LOG_LEVEL:\n            prefix = \"%s:%d - \" % self.client if self.client else \"\"\n            self.logger.log(TRACE_LOG_LEVEL, \"%sHTTP connection lost\", prefix)\n\n        if self.cycle and not self.cycle.response_complete:\n            self.cycle.disconnected = True\n        if self.conn.our_state != h11.ERROR:\n            event = h11.ConnectionClosed()\n            try:\n                self.conn.send(event)\n            except h11.LocalProtocolError:\n                # Premature client disconnect\n                pass\n\n        if self.cycle is not None:\n            self.cycle.message_event.set()\n        if self.flow is not None:\n            self.flow.resume_writing()\n        if exc is None:\n            self.transport.close()\n            self._unset_keepalive_if_required()\n",
      "start_line": 102,
      "end_line": 127,
      "source_file": "uvicorn/protocols/http/h11_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def eof_received(self) -> None:\n        pass\n",
      "start_line": 127,
      "end_line": 130,
      "source_file": "uvicorn/protocols/http/h11_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def _unset_keepalive_if_required(self) -> None:\n        if self.timeout_keep_alive_task is not None:\n            self.timeout_keep_alive_task.cancel()\n            self.timeout_keep_alive_task = None\n",
      "start_line": 130,
      "end_line": 135,
      "source_file": "uvicorn/protocols/http/h11_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def _get_upgrade(self) -> bytes | None:\n        connection = []\n        upgrade = None\n        for name, value in self.headers:\n            if name == b\"connection\":\n                connection = [token.lower().strip() for token in value.split(b\",\")]\n            if name == b\"upgrade\":\n                upgrade = value.lower()\n        if b\"upgrade\" in connection:\n            return upgrade\n        return None\n",
      "start_line": 135,
      "end_line": 147,
      "source_file": "uvicorn/protocols/http/h11_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def _should_upgrade_to_ws(self) -> bool:\n        if self.ws_protocol_class is None:\n            return False\n        return True\n",
      "start_line": 147,
      "end_line": 152,
      "source_file": "uvicorn/protocols/http/h11_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def _unsupported_upgrade_warning(self) -> None:\n        msg = \"Unsupported upgrade request.\"\n        self.logger.warning(msg)\n        if not self._should_upgrade_to_ws():\n            msg = \"No supported WebSocket library detected. Please use \\\"pip install 'uvicorn[standard]'\\\", or install 'websockets' or 'wsproto' manually.\"  # noqa: E501\n            self.logger.warning(msg)\n",
      "start_line": 152,
      "end_line": 159,
      "source_file": "uvicorn/protocols/http/h11_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def _should_upgrade(self) -> bool:\n        upgrade = self._get_upgrade()\n        if upgrade == b\"websocket\" and self._should_upgrade_to_ws():\n            return True\n        if upgrade is not None:\n            self._unsupported_upgrade_warning()\n        return False\n",
      "start_line": 159,
      "end_line": 167,
      "source_file": "uvicorn/protocols/http/h11_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def data_received(self, data: bytes) -> None:\n        self._unset_keepalive_if_required()\n\n        self.conn.receive_data(data)\n        self.handle_events()\n",
      "start_line": 167,
      "end_line": 173,
      "source_file": "uvicorn/protocols/http/h11_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_events(self) -> None:\n        while True:\n            try:\n                event = self.conn.next_event()\n            except h11.RemoteProtocolError:\n                msg = \"Invalid HTTP request received.\"\n                self.logger.warning(msg)\n                self.send_400_response(msg)\n                return\n\n            if event is h11.NEED_DATA:\n                break\n\n            elif event is h11.PAUSED:\n                # This case can occur in HTTP pipelining, so we need to\n                # stop reading any more data, and ensure that at the end\n                # of the active request/response cycle we handle any\n                # events that have been buffered up.\n                self.flow.pause_reading()\n                break\n\n            elif isinstance(event, h11.Request):\n                self.headers = [(key.lower(), value) for key, value in event.headers]\n                raw_path, _, query_string = event.target.partition(b\"?\")\n                path = unquote(raw_path.decode(\"ascii\"))\n                full_path = self.root_path + path\n                full_raw_path = self.root_path.encode(\"ascii\") + raw_path\n                self.scope = {\n                    \"type\": \"http\",\n                    \"asgi\": {\"version\": self.config.asgi_version, \"spec_version\": \"2.3\"},\n                    \"http_version\": event.http_version.decode(\"ascii\"),\n                    \"server\": self.server,\n                    \"client\": self.client,\n                    \"scheme\": self.scheme,  # type: ignore[typeddict-item]\n                    \"method\": event.method.decode(\"ascii\"),\n                    \"root_path\": self.root_path,\n                    \"path\": full_path,\n                    \"raw_path\": full_raw_path,\n                    \"query_string\": query_string,\n                    \"headers\": self.headers,\n                    \"state\": self.app_state.copy(),\n                }\n                if self._should_upgrade():\n                    self.handle_websocket_upgrade(event)\n                    return\n\n                # Handle 503 responses when 'limit_concurrency' is exceeded.\n                if self.limit_concurrency is not None and (\n                    len(self.connections) >= self.limit_concurrency or len(self.tasks) >= self.limit_concurrency\n                ):\n                    app = service_unavailable\n                    message = \"Exceeded concurrency limit.\"\n                    self.logger.warning(message)\n                else:\n                    app = self.app\n\n                # When starting to process a request, disable the keep-alive\n                # timeout. Normally we disable this when receiving data from\n                # client and set back when finishing processing its request.\n                # However, for pipelined requests processing finishes after\n                # already receiving the next request and thus the timer may\n                # be set here, which we don't want.\n                self._unset_keepalive_if_required()\n\n                self.cycle = RequestResponseCycle(\n                    scope=self.scope,\n                    conn=self.conn,\n                    transport=self.transport,\n                    flow=self.flow,\n                    logger=self.logger,\n                    access_logger=self.access_logger,\n                    access_log=self.access_log,\n                    default_headers=self.server_state.default_headers,\n                    message_event=asyncio.Event(),\n                    on_response=self.on_response_complete,\n                )\n                task = self.loop.create_task(self.cycle.run_asgi(app))\n                task.add_done_callback(self.tasks.discard)\n                self.tasks.add(task)\n\n            elif isinstance(event, h11.Data):\n                if self.conn.our_state is h11.DONE:\n                    continue\n                self.cycle.body += event.data\n                if len(self.cycle.body) > HIGH_WATER_LIMIT:\n                    self.flow.pause_reading()\n                self.cycle.message_event.set()\n\n            elif isinstance(event, h11.EndOfMessage):\n                if self.conn.our_state is h11.DONE:\n                    self.transport.resume_reading()\n                    self.conn.start_next_cycle()\n                    continue\n                self.cycle.more_body = False\n                self.cycle.message_event.set()\n                if self.conn.their_state == h11.MUST_CLOSE:\n                    break\n",
      "start_line": 173,
      "end_line": 271,
      "source_file": "uvicorn/protocols/http/h11_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_websocket_upgrade(self, event: h11.Request) -> None:\n        if self.logger.level <= TRACE_LOG_LEVEL:  # pragma: full coverage\n            prefix = \"%s:%d - \" % self.client if self.client else \"\"\n            self.logger.log(TRACE_LOG_LEVEL, \"%sUpgrading to WebSocket\", prefix)\n\n        self.connections.discard(self)\n        output = [event.method, b\" \", event.target, b\" HTTP/1.1\\r\\n\"]\n        for name, value in self.headers:\n            output += [name, b\": \", value, b\"\\r\\n\"]\n        output.append(b\"\\r\\n\")\n        protocol = self.ws_protocol_class(  # type: ignore[call-arg, misc]\n            config=self.config,\n            server_state=self.server_state,\n            app_state=self.app_state,\n        )\n        protocol.connection_made(self.transport)\n        protocol.data_received(b\"\".join(output))\n        self.transport.set_protocol(protocol)\n",
      "start_line": 271,
      "end_line": 290,
      "source_file": "uvicorn/protocols/http/h11_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def send_400_response(self, msg: str) -> None:\n        reason = STATUS_PHRASES[400]\n        headers: list[tuple[bytes, bytes]] = [\n            (b\"content-type\", b\"text/plain; charset=utf-8\"),\n            (b\"connection\", b\"close\"),\n        ]\n        event = h11.Response(status_code=400, headers=headers, reason=reason)\n        output = self.conn.send(event)\n        self.transport.write(output)\n\n        output = self.conn.send(event=h11.Data(data=msg.encode(\"ascii\")))\n        self.transport.write(output)\n\n        output = self.conn.send(event=h11.EndOfMessage())\n        self.transport.write(output)\n\n        self.transport.close()\n",
      "start_line": 290,
      "end_line": 308,
      "source_file": "uvicorn/protocols/http/h11_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def on_response_complete(self) -> None:\n        self.server_state.total_requests += 1\n\n        if self.transport.is_closing():\n            return\n\n        # Set a short Keep-Alive timeout.\n        self._unset_keepalive_if_required()\n\n        self.timeout_keep_alive_task = self.loop.call_later(self.timeout_keep_alive, self.timeout_keep_alive_handler)\n\n        # Unpause data reads if needed.\n        self.flow.resume_reading()\n\n        # Unblock any pipelined events.\n        if self.conn.our_state is h11.DONE and self.conn.their_state is h11.DONE:\n            self.conn.start_next_cycle()\n            self.handle_events()\n",
      "start_line": 308,
      "end_line": 327,
      "source_file": "uvicorn/protocols/http/h11_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def shutdown(self) -> None:\n        \"\"\"\n        Called by the server to commence a graceful shutdown.\n        \"\"\"\n        if self.cycle is None or self.cycle.response_complete:\n            event = h11.ConnectionClosed()\n            self.conn.send(event)\n            self.transport.close()\n        else:\n            self.cycle.keep_alive = False\n",
      "start_line": 327,
      "end_line": 338,
      "source_file": "uvicorn/protocols/http/h11_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def pause_writing(self) -> None:\n        \"\"\"\n        Called by the transport when the write buffer exceeds the high water mark.\n        \"\"\"\n        self.flow.pause_writing()  # pragma: full coverage\n",
      "start_line": 338,
      "end_line": 344,
      "source_file": "uvicorn/protocols/http/h11_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def resume_writing(self) -> None:\n        \"\"\"\n        Called by the transport when the write buffer drops below the low water mark.\n        \"\"\"\n        self.flow.resume_writing()  # pragma: full coverage\n",
      "start_line": 344,
      "end_line": 350,
      "source_file": "uvicorn/protocols/http/h11_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def timeout_keep_alive_handler(self) -> None:\n        \"\"\"\n        Called on a keep-alive connection if no new data is received after a short\n        delay.\n        \"\"\"\n        if not self.transport.is_closing():\n            event = h11.ConnectionClosed()\n            self.conn.send(event)\n            self.transport.close()\n\n",
      "start_line": 350,
      "end_line": 361,
      "source_file": "uvicorn/protocols/http/h11_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "class RequestResponseCycle:",
      "start_line": 361,
      "end_line": 362,
      "source_file": "uvicorn/protocols/http/h11_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(\n        self,\n        scope: HTTPScope,\n        conn: h11.Connection,\n        transport: asyncio.Transport,\n        flow: FlowControl,\n        logger: logging.Logger,\n        access_logger: logging.Logger,\n        access_log: bool,\n        default_headers: list[tuple[bytes, bytes]],\n        message_event: asyncio.Event,\n        on_response: Callable[..., None],\n    ) -> None:\n        self.scope = scope\n        self.conn = conn\n        self.transport = transport\n        self.flow = flow\n        self.logger = logger\n        self.access_logger = access_logger\n        self.access_log = access_log\n        self.default_headers = default_headers\n        self.message_event = message_event\n        self.on_response = on_response\n\n        # Connection state\n        self.disconnected = False\n        self.keep_alive = True\n        self.waiting_for_100_continue = conn.they_are_waiting_for_100_continue\n\n        # Request state\n        self.body = b\"\"\n        self.more_body = True\n\n        # Response state\n        self.response_started = False\n        self.response_complete = False\n\n    # ASGI exception wrapper\n    async def run_asgi(self, app: ASGI3Application) -> None:\n        try:\n            result = await app(  # type: ignore[func-returns-value]\n                self.scope, self.receive, self.send\n            )\n        except BaseException as exc:\n            msg = \"Exception in ASGI application\\n\"\n            self.logger.error(msg, exc_info=exc)\n            if not self.response_started:\n                await self.send_500_response()\n            else:\n                self.transport.close()\n        else:\n            if result is not None:\n                msg = \"ASGI callable should return None, but returned '%s'.\"\n                self.logger.error(msg, result)\n                self.transport.close()\n            elif not self.response_started and not self.disconnected:\n                msg = \"ASGI callable returned without starting response.\"\n                self.logger.error(msg)\n                await self.send_500_response()\n            elif not self.response_complete and not self.disconnected:\n                msg = \"ASGI callable returned without completing response.\"\n                self.logger.error(msg)\n                self.transport.close()\n        finally:\n            self.on_response = lambda: None\n\n    async def send_500_response(self) -> None:\n        response_start_event: HTTPResponseStartEvent = {\n            \"type\": \"http.response.start\",\n            \"status\": 500,\n            \"headers\": [\n                (b\"content-type\", b\"text/plain; charset=utf-8\"),\n                (b\"connection\", b\"close\"),\n            ],\n        }\n        await self.send(response_start_event)\n        response_body_event: HTTPResponseBodyEvent = {\n            \"type\": \"http.response.body\",\n            \"body\": b\"Internal Server Error\",\n            \"more_body\": False,\n        }\n        await self.send(response_body_event)\n\n    # ASGI interface\n    async def send(self, message: ASGISendEvent) -> None:\n        message_type = message[\"type\"]\n\n        if self.flow.write_paused and not self.disconnected:\n            await self.flow.drain()  # pragma: full coverage\n\n        if self.disconnected:\n            return  # pragma: full coverage\n\n        if not self.response_started:\n            # Sending response status line and headers\n            if message_type != \"http.response.start\":\n                msg = \"Expected ASGI message 'http.response.start', but got '%s'.\"\n                raise RuntimeError(msg % message_type)\n            message = cast(\"HTTPResponseStartEvent\", message)\n\n            self.response_started = True\n            self.waiting_for_100_continue = False\n\n            status = message[\"status\"]\n            headers = self.default_headers + list(message.get(\"headers\", []))\n\n            if CLOSE_HEADER in self.scope[\"headers\"] and CLOSE_HEADER not in headers:\n                headers = headers + [CLOSE_HEADER]\n\n            if self.access_log:\n                self.access_logger.info(\n                    '%s - \"%s %s HTTP/%s\" %d',\n                    get_client_addr(self.scope),\n                    self.scope[\"method\"],\n                    get_path_with_query_string(self.scope),\n                    self.scope[\"http_version\"],\n                    status,\n                )\n\n            # Write response status line and headers\n            reason = STATUS_PHRASES[status]\n            response = h11.Response(status_code=status, headers=headers, reason=reason)\n            output = self.conn.send(event=response)\n            self.transport.write(output)\n\n        elif not self.response_complete:\n            # Sending response body\n            if message_type != \"http.response.body\":\n                msg = \"Expected ASGI message 'http.response.body', but got '%s'.\"\n                raise RuntimeError(msg % message_type)\n            message = cast(\"HTTPResponseBodyEvent\", message)\n\n            body = message.get(\"body\", b\"\")\n            more_body = message.get(\"more_body\", False)\n\n            # Write response body\n            data = b\"\" if self.scope[\"method\"] == \"HEAD\" else body\n            output = self.conn.send(event=h11.Data(data=data))\n            self.transport.write(output)\n\n            # Handle response completion\n            if not more_body:\n                self.response_complete = True\n                self.message_event.set()\n                output = self.conn.send(event=h11.EndOfMessage())\n                self.transport.write(output)\n\n        else:\n            # Response already sent\n            msg = \"Unexpected ASGI message '%s' sent, after response already completed.\"\n            raise RuntimeError(msg % message_type)\n\n        if self.response_complete:\n            if self.conn.our_state is h11.MUST_CLOSE or not self.keep_alive:\n                self.conn.send(event=h11.ConnectionClosed())\n                self.transport.close()\n            self.on_response()\n\n    async def receive(self) -> ASGIReceiveEvent:\n        if self.waiting_for_100_continue and not self.transport.is_closing():\n            headers: list[tuple[str, str]] = []\n            event = h11.InformationalResponse(status_code=100, headers=headers, reason=\"Continue\")\n            output = self.conn.send(event=event)\n            self.transport.write(output)\n            self.waiting_for_100_continue = False\n\n        if not self.disconnected and not self.response_complete:\n            self.flow.resume_reading()\n            await self.message_event.wait()\n            self.message_event.clear()\n\n        if self.disconnected or self.response_complete:\n            return {\"type\": \"http.disconnect\"}\n\n        message: HTTPRequestEvent = {\n            \"type\": \"http.request\",\n            \"body\": self.body,\n            \"more_body\": self.more_body,\n        }\n        self.body = b\"\"\n        return message",
      "start_line": 362,
      "end_line": 543,
      "source_file": "uvicorn/protocols/http/h11_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "from __future__ import annotations\n\nimport asyncio\n\nAutoHTTPProtocol: type[asyncio.Protocol]\ntry:\n    import httptools  # noqa\nexcept ImportError:  # pragma: no cover\n    from uvicorn.protocols.http.h11_impl import H11Protocol\n\n    AutoHTTPProtocol = H11Protocol\nelse:  # pragma: no cover\n    from uvicorn.protocols.http.httptools_impl import HttpToolsProtocol\n\n    AutoHTTPProtocol = HttpToolsProtocol",
      "start_line": 0,
      "end_line": 15,
      "source_file": "uvicorn/protocols/http/auto.py",
      "chunk_type": "code"
    },
    {
      "content": "from __future__ import annotations\n\nimport asyncio\nimport http\nimport logging\nimport re\nimport urllib\nfrom asyncio.events import TimerHandle\nfrom collections import deque\nfrom typing import Any, Callable, Literal, cast\n\nimport httptools\n\nfrom uvicorn._types import (\n    ASGI3Application,\n    ASGIReceiveEvent,\n    ASGISendEvent,\n    HTTPRequestEvent,\n    HTTPResponseStartEvent,\n    HTTPScope,\n)\nfrom uvicorn.config import Config\nfrom uvicorn.logging import TRACE_LOG_LEVEL\nfrom uvicorn.protocols.http.flow_control import CLOSE_HEADER, HIGH_WATER_LIMIT, FlowControl, service_unavailable\nfrom uvicorn.protocols.utils import get_client_addr, get_local_addr, get_path_with_query_string, get_remote_addr, is_ssl\nfrom uvicorn.server import ServerState\n\nHEADER_RE = re.compile(b'[\\x00-\\x1f\\x7f()<>@,;:[]={} \\t\\\\\"]')\nHEADER_VALUE_RE = re.compile(b\"[\\x00-\\x08\\x0a-\\x1f\\x7f]\")\n\n",
      "start_line": 0,
      "end_line": 31,
      "source_file": "uvicorn/protocols/http/httptools_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "def _get_status_line(status_code: int) -> bytes:\n    try:\n        phrase = http.HTTPStatus(status_code).phrase.encode()\n    except ValueError:\n        phrase = b\"\"\n    return b\"\".join([b\"HTTP/1.1 \", str(status_code).encode(), b\" \", phrase, b\"\\r\\n\"])\n\n\nSTATUS_LINE = {status_code: _get_status_line(status_code) for status_code in range(100, 600)}\n\n",
      "start_line": 31,
      "end_line": 42,
      "source_file": "uvicorn/protocols/http/httptools_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "class HttpToolsProtocol(asyncio.Protocol):",
      "start_line": 42,
      "end_line": 43,
      "source_file": "uvicorn/protocols/http/httptools_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(\n        self,\n        config: Config,\n        server_state: ServerState,\n        app_state: dict[str, Any],\n        _loop: asyncio.AbstractEventLoop | None = None,\n    ) -> None:\n        if not config.loaded:\n            config.load()\n\n        self.config = config\n        self.app = config.loaded_app\n        self.loop = _loop or asyncio.get_event_loop()\n        self.logger = logging.getLogger(\"uvicorn.error\")\n        self.access_logger = logging.getLogger(\"uvicorn.access\")\n        self.access_log = self.access_logger.hasHandlers()\n        self.parser = httptools.HttpRequestParser(self)\n\n        try:\n            # Enable dangerous leniencies to allow server to a response on the first request from a pipelined request.\n            self.parser.set_dangerous_leniencies(lenient_data_after_close=True)\n        except AttributeError:  # pragma: no cover\n            # httptools < 0.6.3\n            pass\n\n        self.ws_protocol_class = config.ws_protocol_class\n        self.root_path = config.root_path\n        self.limit_concurrency = config.limit_concurrency\n        self.app_state = app_state\n\n        # Timeouts\n        self.timeout_keep_alive_task: TimerHandle | None = None\n        self.timeout_keep_alive = config.timeout_keep_alive\n\n        # Global state\n        self.server_state = server_state\n        self.connections = server_state.connections\n        self.tasks = server_state.tasks\n\n        # Per-connection state\n        self.transport: asyncio.Transport = None  # type: ignore[assignment]\n        self.flow: FlowControl = None  # type: ignore[assignment]\n        self.server: tuple[str, int] | None = None\n        self.client: tuple[str, int] | None = None\n        self.scheme: Literal[\"http\", \"https\"] | None = None\n        self.pipeline: deque[tuple[RequestResponseCycle, ASGI3Application]] = deque()\n\n        # Per-request state\n        self.scope: HTTPScope = None  # type: ignore[assignment]\n        self.headers: list[tuple[bytes, bytes]] = None  # type: ignore[assignment]\n        self.expect_100_continue = False\n        self.cycle: RequestResponseCycle = None  # type: ignore[assignment]\n\n    # Protocol interface",
      "start_line": 43,
      "end_line": 97,
      "source_file": "uvicorn/protocols/http/httptools_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def connection_made(  # type: ignore[override]\n        self, transport: asyncio.Transport\n    ) -> None:\n        self.connections.add(self)\n\n        self.transport = transport\n        self.flow = FlowControl(transport)\n        self.server = get_local_addr(transport)\n        self.client = get_remote_addr(transport)\n        self.scheme = \"https\" if is_ssl(transport) else \"http\"\n\n        if self.logger.level <= TRACE_LOG_LEVEL:\n            prefix = \"%s:%d - \" % self.client if self.client else \"\"\n            self.logger.log(TRACE_LOG_LEVEL, \"%sHTTP connection made\", prefix)\n",
      "start_line": 97,
      "end_line": 112,
      "source_file": "uvicorn/protocols/http/httptools_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def connection_lost(self, exc: Exception | None) -> None:\n        self.connections.discard(self)\n\n        if self.logger.level <= TRACE_LOG_LEVEL:\n            prefix = \"%s:%d - \" % self.client if self.client else \"\"\n            self.logger.log(TRACE_LOG_LEVEL, \"%sHTTP connection lost\", prefix)\n\n        if self.cycle and not self.cycle.response_complete:\n            self.cycle.disconnected = True\n        if self.cycle is not None:\n            self.cycle.message_event.set()\n        if self.flow is not None:\n            self.flow.resume_writing()\n        if exc is None:\n            self.transport.close()\n            self._unset_keepalive_if_required()\n\n        self.parser = None\n",
      "start_line": 112,
      "end_line": 131,
      "source_file": "uvicorn/protocols/http/httptools_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def eof_received(self) -> None:\n        pass\n",
      "start_line": 131,
      "end_line": 134,
      "source_file": "uvicorn/protocols/http/httptools_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def _unset_keepalive_if_required(self) -> None:\n        if self.timeout_keep_alive_task is not None:\n            self.timeout_keep_alive_task.cancel()\n            self.timeout_keep_alive_task = None\n",
      "start_line": 134,
      "end_line": 139,
      "source_file": "uvicorn/protocols/http/httptools_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def _get_upgrade(self) -> bytes | None:\n        connection = []\n        upgrade = None\n        for name, value in self.headers:\n            if name == b\"connection\":\n                connection = [token.lower().strip() for token in value.split(b\",\")]\n            if name == b\"upgrade\":\n                upgrade = value.lower()\n        if b\"upgrade\" in connection:\n            return upgrade\n        return None  # pragma: full coverage\n",
      "start_line": 139,
      "end_line": 151,
      "source_file": "uvicorn/protocols/http/httptools_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def _should_upgrade_to_ws(self) -> bool:\n        if self.ws_protocol_class is None:\n            return False\n        return True\n",
      "start_line": 151,
      "end_line": 156,
      "source_file": "uvicorn/protocols/http/httptools_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def _unsupported_upgrade_warning(self) -> None:\n        self.logger.warning(\"Unsupported upgrade request.\")\n        if not self._should_upgrade_to_ws():\n            msg = \"No supported WebSocket library detected. Please use \\\"pip install 'uvicorn[standard]'\\\", or install 'websockets' or 'wsproto' manually.\"  # noqa: E501\n            self.logger.warning(msg)\n",
      "start_line": 156,
      "end_line": 162,
      "source_file": "uvicorn/protocols/http/httptools_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def _should_upgrade(self) -> bool:\n        upgrade = self._get_upgrade()\n        return upgrade == b\"websocket\" and self._should_upgrade_to_ws()\n",
      "start_line": 162,
      "end_line": 166,
      "source_file": "uvicorn/protocols/http/httptools_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def data_received(self, data: bytes) -> None:\n        self._unset_keepalive_if_required()\n\n        try:\n            self.parser.feed_data(data)\n        except httptools.HttpParserError:\n            msg = \"Invalid HTTP request received.\"\n            self.logger.warning(msg)\n            self.send_400_response(msg)\n            return\n        except httptools.HttpParserUpgrade:\n            if self._should_upgrade():\n                self.handle_websocket_upgrade()\n            else:\n                self._unsupported_upgrade_warning()\n",
      "start_line": 166,
      "end_line": 182,
      "source_file": "uvicorn/protocols/http/httptools_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_websocket_upgrade(self) -> None:\n        if self.logger.level <= TRACE_LOG_LEVEL:\n            prefix = \"%s:%d - \" % self.client if self.client else \"\"\n            self.logger.log(TRACE_LOG_LEVEL, \"%sUpgrading to WebSocket\", prefix)\n\n        self.connections.discard(self)\n        method = self.scope[\"method\"].encode()\n        output = [method, b\" \", self.url, b\" HTTP/1.1\\r\\n\"]\n        for name, value in self.scope[\"headers\"]:\n            output += [name, b\": \", value, b\"\\r\\n\"]\n        output.append(b\"\\r\\n\")\n        protocol = self.ws_protocol_class(  # type: ignore[call-arg, misc]\n            config=self.config,\n            server_state=self.server_state,\n            app_state=self.app_state,\n        )\n        protocol.connection_made(self.transport)\n        protocol.data_received(b\"\".join(output))\n        self.transport.set_protocol(protocol)\n",
      "start_line": 182,
      "end_line": 202,
      "source_file": "uvicorn/protocols/http/httptools_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def send_400_response(self, msg: str) -> None:\n        content = [STATUS_LINE[400]]\n        for name, value in self.server_state.default_headers:\n            content.extend([name, b\": \", value, b\"\\r\\n\"])  # pragma: full coverage\n        content.extend(\n            [\n                b\"content-type: text/plain; charset=utf-8\\r\\n\",\n                b\"content-length: \" + str(len(msg)).encode(\"ascii\") + b\"\\r\\n\",\n                b\"connection: close\\r\\n\",\n                b\"\\r\\n\",\n                msg.encode(\"ascii\"),\n            ]\n        )\n        self.transport.write(b\"\".join(content))\n        self.transport.close()\n",
      "start_line": 202,
      "end_line": 218,
      "source_file": "uvicorn/protocols/http/httptools_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def on_message_begin(self) -> None:\n        self.url = b\"\"\n        self.expect_100_continue = False\n        self.headers = []\n        self.scope = {  # type: ignore[typeddict-item]\n            \"type\": \"http\",\n            \"asgi\": {\"version\": self.config.asgi_version, \"spec_version\": \"2.3\"},\n            \"http_version\": \"1.1\",\n            \"server\": self.server,\n            \"client\": self.client,\n            \"scheme\": self.scheme,  # type: ignore[typeddict-item]\n            \"root_path\": self.root_path,\n            \"headers\": self.headers,\n            \"state\": self.app_state.copy(),\n        }\n\n    # Parser callbacks",
      "start_line": 218,
      "end_line": 235,
      "source_file": "uvicorn/protocols/http/httptools_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def on_url(self, url: bytes) -> None:\n        self.url += url\n",
      "start_line": 235,
      "end_line": 238,
      "source_file": "uvicorn/protocols/http/httptools_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def on_header(self, name: bytes, value: bytes) -> None:\n        name = name.lower()\n        if name == b\"expect\" and value.lower() == b\"100-continue\":\n            self.expect_100_continue = True\n        self.headers.append((name, value))\n",
      "start_line": 238,
      "end_line": 244,
      "source_file": "uvicorn/protocols/http/httptools_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def on_headers_complete(self) -> None:\n        http_version = self.parser.get_http_version()\n        method = self.parser.get_method()\n        self.scope[\"method\"] = method.decode(\"ascii\")\n        if http_version != \"1.1\":\n            self.scope[\"http_version\"] = http_version\n        if self.parser.should_upgrade() and self._should_upgrade():\n            return\n        parsed_url = httptools.parse_url(self.url)\n        raw_path = parsed_url.path\n        path = raw_path.decode(\"ascii\")\n        if \"%\" in path:\n            path = urllib.parse.unquote(path)\n        full_path = self.root_path + path\n        full_raw_path = self.root_path.encode(\"ascii\") + raw_path\n        self.scope[\"path\"] = full_path\n        self.scope[\"raw_path\"] = full_raw_path\n        self.scope[\"query_string\"] = parsed_url.query or b\"\"\n\n        # Handle 503 responses when 'limit_concurrency' is exceeded.\n        if self.limit_concurrency is not None and (\n            len(self.connections) >= self.limit_concurrency or len(self.tasks) >= self.limit_concurrency\n        ):\n            app = service_unavailable\n            message = \"Exceeded concurrency limit.\"\n            self.logger.warning(message)\n        else:\n            app = self.app\n\n        existing_cycle = self.cycle\n        self.cycle = RequestResponseCycle(\n            scope=self.scope,\n            transport=self.transport,\n            flow=self.flow,\n            logger=self.logger,\n            access_logger=self.access_logger,\n            access_log=self.access_log,\n            default_headers=self.server_state.default_headers,\n            message_event=asyncio.Event(),\n            expect_100_continue=self.expect_100_continue,\n            keep_alive=http_version != \"1.0\",\n            on_response=self.on_response_complete,\n        )\n        if existing_cycle is None or existing_cycle.response_complete:\n            # Standard case - start processing the request.\n            task = self.loop.create_task(self.cycle.run_asgi(app))\n            task.add_done_callback(self.tasks.discard)\n            self.tasks.add(task)\n        else:\n            # Pipelined HTTP requests need to be queued up.\n            self.flow.pause_reading()\n            self.pipeline.appendleft((self.cycle, app))\n",
      "start_line": 244,
      "end_line": 297,
      "source_file": "uvicorn/protocols/http/httptools_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def on_body(self, body: bytes) -> None:\n        if (self.parser.should_upgrade() and self._should_upgrade()) or self.cycle.response_complete:\n            return\n        self.cycle.body += body\n        if len(self.cycle.body) > HIGH_WATER_LIMIT:\n            self.flow.pause_reading()\n        self.cycle.message_event.set()\n",
      "start_line": 297,
      "end_line": 305,
      "source_file": "uvicorn/protocols/http/httptools_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def on_message_complete(self) -> None:\n        if (self.parser.should_upgrade() and self._should_upgrade()) or self.cycle.response_complete:\n            return\n        self.cycle.more_body = False\n        self.cycle.message_event.set()\n",
      "start_line": 305,
      "end_line": 311,
      "source_file": "uvicorn/protocols/http/httptools_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def on_response_complete(self) -> None:\n        # Callback for pipelined HTTP requests to be started.\n        self.server_state.total_requests += 1\n\n        if self.transport.is_closing():\n            return\n\n        self._unset_keepalive_if_required()\n\n        # Unpause data reads if needed.\n        self.flow.resume_reading()\n\n        # Unblock any pipelined events. If there are none, arm the\n        # Keep-Alive timeout instead.\n        if self.pipeline:\n            cycle, app = self.pipeline.pop()\n            task = self.loop.create_task(cycle.run_asgi(app))\n            task.add_done_callback(self.tasks.discard)\n            self.tasks.add(task)\n        else:\n            self.timeout_keep_alive_task = self.loop.call_later(\n                self.timeout_keep_alive, self.timeout_keep_alive_handler\n            )\n",
      "start_line": 311,
      "end_line": 335,
      "source_file": "uvicorn/protocols/http/httptools_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def shutdown(self) -> None:\n        \"\"\"\n        Called by the server to commence a graceful shutdown.\n        \"\"\"\n        if self.cycle is None or self.cycle.response_complete:\n            self.transport.close()\n        else:\n            self.cycle.keep_alive = False\n",
      "start_line": 335,
      "end_line": 344,
      "source_file": "uvicorn/protocols/http/httptools_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def pause_writing(self) -> None:\n        \"\"\"\n        Called by the transport when the write buffer exceeds the high water mark.\n        \"\"\"\n        self.flow.pause_writing()  # pragma: full coverage\n",
      "start_line": 344,
      "end_line": 350,
      "source_file": "uvicorn/protocols/http/httptools_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def resume_writing(self) -> None:\n        \"\"\"\n        Called by the transport when the write buffer drops below the low water mark.\n        \"\"\"\n        self.flow.resume_writing()  # pragma: full coverage\n",
      "start_line": 350,
      "end_line": 356,
      "source_file": "uvicorn/protocols/http/httptools_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def timeout_keep_alive_handler(self) -> None:\n        \"\"\"\n        Called on a keep-alive connection if no new data is received after a short\n        delay.\n        \"\"\"\n        if not self.transport.is_closing():\n            self.transport.close()\n\n",
      "start_line": 356,
      "end_line": 365,
      "source_file": "uvicorn/protocols/http/httptools_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "class RequestResponseCycle:",
      "start_line": 365,
      "end_line": 366,
      "source_file": "uvicorn/protocols/http/httptools_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(\n        self,\n        scope: HTTPScope,\n        transport: asyncio.Transport,\n        flow: FlowControl,\n        logger: logging.Logger,\n        access_logger: logging.Logger,\n        access_log: bool,\n        default_headers: list[tuple[bytes, bytes]],\n        message_event: asyncio.Event,\n        expect_100_continue: bool,\n        keep_alive: bool,\n        on_response: Callable[..., None],\n    ):\n        self.scope = scope\n        self.transport = transport\n        self.flow = flow\n        self.logger = logger\n        self.access_logger = access_logger\n        self.access_log = access_log\n        self.default_headers = default_headers\n        self.message_event = message_event\n        self.on_response = on_response\n\n        # Connection state\n        self.disconnected = False\n        self.keep_alive = keep_alive\n        self.waiting_for_100_continue = expect_100_continue\n\n        # Request state\n        self.body = b\"\"\n        self.more_body = True\n\n        # Response state\n        self.response_started = False\n        self.response_complete = False\n        self.chunked_encoding: bool | None = None\n        self.expected_content_length = 0\n\n    # ASGI exception wrapper\n    async def run_asgi(self, app: ASGI3Application) -> None:\n        try:\n            result = await app(  # type: ignore[func-returns-value]\n                self.scope, self.receive, self.send\n            )\n        except BaseException as exc:\n            msg = \"Exception in ASGI application\\n\"\n            self.logger.error(msg, exc_info=exc)\n            if not self.response_started:\n                await self.send_500_response()\n            else:\n                self.transport.close()\n        else:\n            if result is not None:\n                msg = \"ASGI callable should return None, but returned '%s'.\"\n                self.logger.error(msg, result)\n                self.transport.close()\n            elif not self.response_started and not self.disconnected:\n                msg = \"ASGI callable returned without starting response.\"\n                self.logger.error(msg)\n                await self.send_500_response()\n            elif not self.response_complete and not self.disconnected:\n                msg = \"ASGI callable returned without completing response.\"\n                self.logger.error(msg)\n                self.transport.close()\n        finally:\n            self.on_response = lambda: None\n\n    async def send_500_response(self) -> None:\n        await self.send(\n            {\n                \"type\": \"http.response.start\",\n                \"status\": 500,\n                \"headers\": [\n                    (b\"content-type\", b\"text/plain; charset=utf-8\"),\n                    (b\"content-length\", b\"21\"),\n                    (b\"connection\", b\"close\"),\n                ],\n            }\n        )\n        await self.send({\"type\": \"http.response.body\", \"body\": b\"Internal Server Error\", \"more_body\": False})\n\n    # ASGI interface\n    async def send(self, message: ASGISendEvent) -> None:\n        message_type = message[\"type\"]\n\n        if self.flow.write_paused and not self.disconnected:\n            await self.flow.drain()  # pragma: full coverage\n\n        if self.disconnected:\n            return  # pragma: full coverage\n\n        if not self.response_started:\n            # Sending response status line and headers\n            if message_type != \"http.response.start\":\n                msg = \"Expected ASGI message 'http.response.start', but got '%s'.\"\n                raise RuntimeError(msg % message_type)\n            message = cast(\"HTTPResponseStartEvent\", message)\n\n            self.response_started = True\n            self.waiting_for_100_continue = False\n\n            status_code = message[\"status\"]\n            headers = self.default_headers + list(message.get(\"headers\", []))\n\n            if CLOSE_HEADER in self.scope[\"headers\"] and CLOSE_HEADER not in headers:\n                headers = headers + [CLOSE_HEADER]\n\n            if self.access_log:\n                self.access_logger.info(\n                    '%s - \"%s %s HTTP/%s\" %d',\n                    get_client_addr(self.scope),\n                    self.scope[\"method\"],\n                    get_path_with_query_string(self.scope),\n                    self.scope[\"http_version\"],\n                    status_code,\n                )\n\n            # Write response status line and headers\n            content = [STATUS_LINE[status_code]]\n\n            for name, value in headers:\n                if HEADER_RE.search(name):\n                    raise RuntimeError(\"Invalid HTTP header name.\")  # pragma: full coverage\n                if HEADER_VALUE_RE.search(value):\n                    raise RuntimeError(\"Invalid HTTP header value.\")\n\n                name = name.lower()\n                if name == b\"content-length\" and self.chunked_encoding is None:\n                    self.expected_content_length = int(value.decode())\n                    self.chunked_encoding = False\n                elif name == b\"transfer-encoding\" and value.lower() == b\"chunked\":\n                    self.expected_content_length = 0\n                    self.chunked_encoding = True\n                elif name == b\"connection\" and value.lower() == b\"close\":\n                    self.keep_alive = False\n                content.extend([name, b\": \", value, b\"\\r\\n\"])\n\n            if self.chunked_encoding is None and self.scope[\"method\"] != \"HEAD\" and status_code not in (204, 304):\n                # Neither content-length nor transfer-encoding specified\n                self.chunked_encoding = True\n                content.append(b\"transfer-encoding: chunked\\r\\n\")\n\n            content.append(b\"\\r\\n\")\n            self.transport.write(b\"\".join(content))\n\n        elif not self.response_complete:\n            # Sending response body\n            if message_type != \"http.response.body\":\n                msg = \"Expected ASGI message 'http.response.body', but got '%s'.\"\n                raise RuntimeError(msg % message_type)\n\n            body = cast(bytes, message.get(\"body\", b\"\"))\n            more_body = message.get(\"more_body\", False)\n\n            # Write response body\n            if self.scope[\"method\"] == \"HEAD\":\n                self.expected_content_length = 0\n            elif self.chunked_encoding:\n                if body:\n                    content = [b\"%x\\r\\n\" % len(body), body, b\"\\r\\n\"]\n                else:\n                    content = []\n                if not more_body:\n                    content.append(b\"0\\r\\n\\r\\n\")\n                self.transport.write(b\"\".join(content))\n            else:\n                num_bytes = len(body)\n                if num_bytes > self.expected_content_length:\n                    raise RuntimeError(\"Response content longer than Content-Length\")\n                else:\n                    self.expected_content_length -= num_bytes\n                self.transport.write(body)\n\n            # Handle response completion\n            if not more_body:\n                if self.expected_content_length != 0:\n                    raise RuntimeError(\"Response content shorter than Content-Length\")\n                self.response_complete = True\n                self.message_event.set()\n                if not self.keep_alive:\n                    self.transport.close()\n                self.on_response()\n\n        else:\n            # Response already sent\n            msg = \"Unexpected ASGI message '%s' sent, after response already completed.\"\n            raise RuntimeError(msg % message_type)\n\n    async def receive(self) -> ASGIReceiveEvent:\n        if self.waiting_for_100_continue and not self.transport.is_closing():\n            self.transport.write(b\"HTTP/1.1 100 Continue\\r\\n\\r\\n\")\n            self.waiting_for_100_continue = False\n\n        if not self.disconnected and not self.response_complete:\n            self.flow.resume_reading()\n            await self.message_event.wait()\n            self.message_event.clear()\n\n        if self.disconnected or self.response_complete:\n            return {\"type\": \"http.disconnect\"}\n        message: HTTPRequestEvent = {\"type\": \"http.request\", \"body\": self.body, \"more_body\": self.more_body}\n        self.body = b\"\"\n        return message",
      "start_line": 366,
      "end_line": 570,
      "source_file": "uvicorn/protocols/http/httptools_impl.py",
      "chunk_type": "code"
    },
    {
      "content": "{% extends \"base.html\" %}\n\n{% block announce %}\n<style>\n    div[data-md-component=\"announce\"] {\n        background-color: #f0f8ff;  /* Light blue */\n        color: #333;\n    }\n    div[data-md-component=\"announce\"] a {\n        color: #0366d6;\n    }\n</style>\n     If you're using uvicorn in production, please consider <a href=\"/sponsorship\">sponsoring the project</a> to help with maintenance and development. \u2728\n{% endblock %}\n",
      "source_file": "docs/overrides/main.html",
      "chunk_type": "unknown"
    },
    {
      "content": "from __future__ import annotations as _annotations\n\nimport re\nimport subprocess\nfrom functools import lru_cache\n\nfrom mkdocs.config import Config\nfrom mkdocs.structure.files import Files\nfrom mkdocs.structure.pages import Page\n\n",
      "start_line": 0,
      "end_line": 11,
      "source_file": "docs/plugins/main.py",
      "chunk_type": "code"
    },
    {
      "content": "def on_page_content(html: str, page: Page, config: Config, files: Files) -> str:\n    \"\"\"Called on each page after the markdown is converted to HTML.\"\"\"\n    html = add_hyperlink_to_pull_request(html, page, config, files)\n    return html\n\n",
      "start_line": 11,
      "end_line": 17,
      "source_file": "docs/plugins/main.py",
      "chunk_type": "code"
    },
    {
      "content": "def add_hyperlink_to_pull_request(html: str, page: Page, config: Config, files: Files) -> str:\n    \"\"\"Add hyperlink on PRs mentioned on the release notes page.\n\n    If we find \"(#\\\\d+)\" it will be added an hyperlink to https://github.com/encode/uvicorn/pull/$1.\n    \"\"\"\n    if not page.file.name == \"release-notes\":\n        return html\n\n    return re.sub(r\"\\(#(\\d+)\\)\", r\"(<a href='https://github.com/encode/uvicorn/pull/\\1'>#\\1</a>)\", html)\n\n",
      "start_line": 17,
      "end_line": 28,
      "source_file": "docs/plugins/main.py",
      "chunk_type": "code"
    },
    {
      "content": "def on_page_markdown(markdown: str, page: Page, config: Config, files: Files) -> str:\n    \"\"\"Called on each file after it is read and before it is converted to HTML.\"\"\"\n    markdown = uvicorn_print_help(markdown, page)\n    return markdown\n\n",
      "start_line": 28,
      "end_line": 34,
      "source_file": "docs/plugins/main.py",
      "chunk_type": "code"
    },
    {
      "content": "def uvicorn_print_help(markdown: str, page: Page) -> str:\n    return re.sub(r\"{{ *uvicorn_help *}}\", get_uvicorn_help(), markdown)\n\n\n@lru_cache",
      "start_line": 34,
      "end_line": 39,
      "source_file": "docs/plugins/main.py",
      "chunk_type": "code"
    },
    {
      "content": "def get_uvicorn_help():\n    output = subprocess.run([\"uvicorn\", \"--help\"], capture_output=True, check=True)\n    return output.stdout.decode()",
      "start_line": 39,
      "end_line": 42,
      "source_file": "docs/plugins/main.py",
      "chunk_type": "code"
    },
    {
      "content": "Server deployment is a complex area, that will depend on what kind of service you're deploying Uvicorn onto.\n\nAs a general rule, you probably want to:\n\n* Run `uvicorn --reload` from the command line for local development.\n* Run `gunicorn -k uvicorn.workers.UvicornWorker` for production.\n* Additionally run behind Nginx for self-hosted deployments.\n* Finally, run everything behind a CDN for caching support, and serious DDOS protection.\n",
      "source_file": "docs/deployment/index.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Running from the command line\n\nTypically you'll run `uvicorn` from the command line.\n\n```bash\n$ uvicorn main:app --reload --port 5000\n```\n\nThe ASGI application should be specified in the form `path.to.module:instance.path`.\n\nWhen running locally, use `--reload` to turn on auto-reloading.\n\nThe `--reload` and `--workers` arguments are **mutually exclusive**.\n\nTo see the complete set of available options, use `uvicorn --help`:\n\n```bash\n{{ uvicorn_help }}\n```\n\nSee the [settings documentation](../settings.md) for more details on the supported options for running uvicorn.\n",
      "source_file": "docs/deployment/index.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Running programmatically\n\nTo run directly from within a Python program, you should use `uvicorn.run(app, **config)`. For example:\n\n```py title=\"main.py\"\nimport uvicorn\n\nclass App:\n    ...\n\napp = App()\n\nif __name__ == \"__main__\":\n    uvicorn.run(\"main:app\", host=\"127.0.0.1\", port=5000, log_level=\"info\")\n```\n\nThe set of configuration options is the same as for the command line tool.\n\nNote that the application instance itself *can* be passed instead of the app\nimport string.\n\n```python\nuvicorn.run(app, host=\"127.0.0.1\", port=5000, log_level=\"info\")\n```\n\nHowever, this style only works if you are not using multiprocessing (`workers=NUM`)\nor reloading (`reload=True`), so we recommend using the import string style.\n\nAlso note that in this case, you should put `uvicorn.run` into `if __name__ == '__main__'` clause in the main module.\n\n!!! note\n    The `reload` and `workers` parameters are **mutually exclusive**.\n",
      "source_file": "docs/deployment/index.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Using a process manager\n\nRunning Uvicorn using a process manager ensures that you can run multiple processes in a resilient manner, and allows you to perform server upgrades without dropping requests.\n\nA process manager will handle the socket setup, start-up multiple server processes, monitor process aliveness, and listen for signals to provide for processes restarts, shutdowns, or dialing up and down the number of running processes.\n",
      "source_file": "docs/deployment/index.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Built-in\n\nUvicorn includes a `--workers` option that allows you to run multiple worker processes.\n\n```bash\n$ uvicorn main:app --workers 4\n```\n\nUnlike gunicorn, uvicorn does not use pre-fork, but uses [`spawn`](https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods), which allows uvicorn's multiprocess manager to still work well on Windows.\n\nThe default process manager monitors the status of child processes and automatically restarts child processes that die unexpectedly. Not only that, it will also monitor the status of the child process through the pipeline. When the child process is accidentally stuck, the corresponding child process will be killed through an unstoppable system signal or interface.\n\nYou can also manage child processes by sending specific signals to the main process. (Not supported on Windows.)\n\n- `SIGHUP`: Work processeses are graceful restarted one after another. If you update the code, the new worker process will use the new code.\n- `SIGTTIN`: Increase the number of worker processes by one.\n- `SIGTTOU`: Decrease the number of worker processes by one.\n",
      "source_file": "docs/deployment/index.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Gunicorn\n\n!!! warning\n    The `uvicorn.workers` module is deprecated and will be removed in a future release.\n\n    You should use the [`uvicorn-worker`](https://github.com/Kludex/uvicorn-worker) package instead.\n\n    ```bash\n    python -m pip install uvicorn-worker\n    ```\n\nGunicorn is probably the simplest way to run and manage Uvicorn in a production setting. Uvicorn includes a gunicorn worker class that means you can get set up with very little configuration.\n\nThe following will start Gunicorn with four worker processes:\n\n`gunicorn -w 4 -k uvicorn.workers.UvicornWorker`\n\nThe `UvicornWorker` implementation uses the `uvloop` and `httptools` implementations. To run under PyPy you'll want to use pure-python implementation instead. You can do this by using the `UvicornH11Worker` class.\n\n`gunicorn -w 4 -k uvicorn.workers.UvicornH11Worker`\n\nGunicorn provides a different set of configuration options to Uvicorn, so  some options such as `--limit-concurrency` are not yet supported when running with Gunicorn.\n\nIf you need to pass uvicorn's config arguments to gunicorn workers then you'll have to subclass `UvicornWorker`:\n\n```python\nfrom uvicorn.workers import UvicornWorker\n\nclass MyUvicornWorker(UvicornWorker):\n    CONFIG_KWARGS = {\"loop\": \"asyncio\", \"http\": \"h11\", \"lifespan\": \"off\"}\n```\n",
      "source_file": "docs/deployment/index.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Supervisor\n\nTo use `supervisor` as a process manager you should either:\n\n* Hand over the socket to uvicorn using its file descriptor, which supervisor always makes available as `0`, and which must be set in the `fcgi-program` section.\n* Or use a UNIX domain socket for each `uvicorn` process.\n\nA simple supervisor configuration might look something like this:\n\n```ini title=\"supervisord.conf\"\n[supervisord]\n\n[fcgi-program:uvicorn]\nsocket=tcp://localhost:8000\ncommand=venv/bin/uvicorn --fd 0 main:App\nnumprocs=4\nprocess_name=uvicorn-%(process_num)d\nstdout_logfile=/dev/stdout\nstdout_logfile_maxbytes=0\n```\n\nThen run with `supervisord -n`.\n",
      "source_file": "docs/deployment/index.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Running behind Nginx\n\nUsing Nginx as a proxy in front of your Uvicorn processes may not be necessary, but is recommended for additional resilience. Nginx can deal with serving your static media and buffering slow requests, leaving your application servers free from load as much as possible.\n\nIn managed environments such as `Heroku`, you won't typically need to configure Nginx, as your server processes will already be running behind load balancing proxies.\n\nThe recommended configuration for proxying from Nginx is to use a UNIX domain socket between Nginx and whatever the process manager that is being used to run Uvicorn. If using Uvicorn directly you can bind it to a UNIX domain socket using `uvicorn --uds /path/to/socket.sock <...>`.\n\nWhen running your application behind one or more proxies you will want to make sure that each proxy sets appropriate headers to ensure that your application can properly determine the client address of the incoming connection, and if the connection was over `http` or `https`. For more information see [Proxies and Forwarded Headers](#proxies-and-forwarded-headers) below.\n\nHere's how a simple Nginx configuration might look. This example includes setting proxy headers, and using a UNIX domain socket to communicate with the application server.\n\nIt also includes some basic configuration to forward websocket connections.\nFor more info on this, check [Nginx recommendations](https://nginx.org/en/docs/http/websocket.html).\n\n```conf\nhttp {\n  server {\n    listen 80;\n    client_max_body_size 4G;\n\n    server_name example.com;\n\n    location / {\n      proxy_set_header Host $http_host;\n      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n      proxy_set_header X-Forwarded-Proto $scheme;\n      proxy_set_header Upgrade $http_upgrade;\n      proxy_set_header Connection $connection_upgrade;\n      proxy_redirect off;\n      proxy_buffering off;\n      proxy_pass http://uvicorn;\n    }\n\n    location /static {\n      # path for static files\n      root /path/to/app/static;\n    }\n  }\n\n  map $http_upgrade $connection_upgrade {\n    default upgrade;\n    '' close;\n  }\n\n  upstream uvicorn {\n    server unix:/tmp/uvicorn.sock;\n  }\n\n}\n```\n\nUvicorn's `--proxy-headers` behavior may not be sufficient for more complex proxy configurations that use different combinations of headers, or where the application is running behind more than one intermediary proxying service.\n\nIn those cases, you might want to use an ASGI middleware to set the `client` and `scheme` dependant on the request headers.\n",
      "source_file": "docs/deployment/index.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Running behind a CDN\n\nRunning behind a content delivery network, such as Cloudflare or Cloud Front, provides a serious layer of protection against DDoS attacks. Your service will be running behind huge clusters of proxies and load balancers that are designed for handling huge amounts of traffic, and have capabilities for detecting and closing off connections from DDoS attacks.\n\nProper usage of cache control headers can mean that a CDN is able to serve large amounts of data without always having to forward the request on to your server.\n\nContent Delivery Networks can also be a low-effort way to provide HTTPS termination.\n",
      "source_file": "docs/deployment/index.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Running with HTTPS\n\nTo run uvicorn with https, a certificate and a private key are required.\nThe recommended way to get them is using [Let's Encrypt](https://letsencrypt.org/).\n\nFor local development with https, it's possible to use [mkcert](https://github.com/FiloSottile/mkcert)\nto generate a valid certificate and private key.\n\n```bash\n$ uvicorn main:app --port 5000 --ssl-keyfile=./key.pem --ssl-certfile=./cert.pem\n```\n",
      "source_file": "docs/deployment/index.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Running gunicorn worker\n\nIt's also possible to use certificates with uvicorn's worker for gunicorn.\n\n```bash\n$ gunicorn --keyfile=./key.pem --certfile=./cert.pem -k uvicorn.workers.UvicornWorker main:app\n```\n",
      "source_file": "docs/deployment/index.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Proxies and Forwarded Headers\n\nWhen running an application behind one or more proxies, certain information about the request is lost.\nTo avoid this most proxies will add headers containing this information for downstream servers to read.\n\nUvicorn currently supports the following headers:\n\n- `X-Forwarded-For` ([MDN Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For))\n- `X-Forwarded-Proto`([MDN Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Proto))\n\nUvicorn can use these headers to correctly set the client and protocol in the request.\nHowever as anyone can set these headers you must configure which \"clients\" you will trust to have set them correctly.\n\nUvicorn can be configured to trust IP Addresses (e.g. `127.0.0.1`), IP Networks (e.g. `10.100.0.0/16`),\nor Literals (e.g. `/path/to/socket.sock`). When running from CLI these are configured using `--forwarded-allow-ips`.\n\n!!! Warning \"Only trust clients you can actually trust!\"\n    Incorrectly trusting other clients can lead to malicious actors spoofing their apparent client address to your application.\n\nFor more information, check [`ProxyHeadersMiddleware`](https://github.com/encode/uvicorn/blob/master/uvicorn/middleware/proxy_headers.py).\n",
      "source_file": "docs/deployment/index.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Client Port\n\nCurrently if the `ProxyHeadersMiddleware` is able to retrieve a trusted client value then the client's port will be set to `0`.\nThis is because port information is lost when using these headers.\n",
      "source_file": "docs/deployment/index.md",
      "chunk_type": "doc"
    },
    {
      "content": "### UNIX Domain Sockets (UDS)\n\nAlthough it is common for UNIX Domain Sockets to be used for communicating between various HTTP servers, they can mess with some of the expected received values as they will be various non-address strings or missing values.\n\nFor example:\n\n- when NGINX itself is running behind a UDS it will add the literal `unix:` as the client in the `X-Forwarded-For` header.\n- When Uvicorn is running behind a UDS the initial client will be `None`.\n",
      "source_file": "docs/deployment/index.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Trust Everything\n\nRather than specifying what to trust, you can instruct Uvicorn to trust all clients using the literal `\"*\"`.\nYou should only set this when you know you can trust all values within the forwarded headers (e.g. because\nyour proxies remove the existing headers before setting their own).",
      "source_file": "docs/deployment/index.md",
      "chunk_type": "doc"
    },
    {
      "content": "# Dockerfile\n\n**Docker** is a popular choice for modern application deployment. However, creating a good Dockerfile from scratch can be challenging. This guide provides a **solid foundation** that works well for most Python projects.\n\nWhile the example below won't fit every use case, it offers an excellent starting point that you can adapt to your specific needs.\n\n",
      "source_file": "docs/deployment/docker.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Quickstart\n\nFor this example, we'll need to install [`docker`](https://docs.docker.com/get-docker/),\n[docker-compose](https://docs.docker.com/compose/install/) and\n[`uv`](https://docs.astral.sh/uv/getting-started/installation/).\n\nThen, let's create a new project with `uv`:\n\n```bash\nuv init app\n```\n\nThis will create a new project with a basic structure:\n\n```bash\napp/\n\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 pyproject.toml\n\u2514\u2500\u2500 README.md\n```\n\nOn `main.py`, let's create a simple ASGI application:\n\n```python title=\"main.py\"\nasync def app(scope, receive, send):\n    body = \"Hello, world!\"\n    await send(\n        {\n            \"type\": \"http.response.start\",\n            \"status\": 200,\n            \"headers\": [\n                [b\"content-type\", b\"text/plain\"],\n                [b\"content-length\", len(body)],\n            ],\n        }\n    )\n    await send(\n        {\n            \"type\": \"http.response.body\",\n            \"body\": body.encode(\"utf-8\"),\n        }\n    )\n```\n\nWe need to include `uvicorn` in the dependencies:\n\n```bash\nuv add uvicorn\n```\n\nThis will also create a `uv.lock` file. :sunglasses:\n\n??? tip \"What is `uv.lock`?\"\n\n    `uv.lock` is a `uv` specific lockfile. A lockfile is a file that contains the exact versions of the dependencies\n    that were installed when the `uv.lock` file was created.\n\n    This allows for deterministic builds and consistent deployments.\n\nJust to make sure everything is working, let's run the application:\n\n```bash\nuv run uvicorn main:app\n```\n\nYou should see the following output:\n\n```bash\nINFO:     Started server process [62727]\nINFO:     Waiting for application startup.\nINFO:     ASGI 'lifespan' protocol appears unsupported.\nINFO:     Application startup complete.\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n```\n",
      "source_file": "docs/deployment/docker.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Dockerfile\n\nWe'll create a **cache-aware Dockerfile** that optimizes build times. The key strategy is to install dependencies first, then copy the project files. This approach leverages Docker's caching mechanism to significantly speed up rebuilds.\n\n```dockerfile title=\"Dockerfile\"\nFROM python:3.12-slim\nCOPY --from=ghcr.io/astral-sh/uv:latest /uv /uvx /bin/\n",
      "source_file": "docs/deployment/docker.md",
      "chunk_type": "doc"
    },
    {
      "content": "# Change the working directory to the `app` directory\nWORKDIR /app\n",
      "source_file": "docs/deployment/docker.md",
      "chunk_type": "doc"
    },
    {
      "content": "# Install dependencies\nRUN --mount=type=cache,target=/root/.cache/uv \\\n    --mount=type=bind,source=uv.lock,target=uv.lock \\\n    --mount=type=bind,source=pyproject.toml,target=pyproject.toml \\\n    uv sync --frozen --no-install-project\n",
      "source_file": "docs/deployment/docker.md",
      "chunk_type": "doc"
    },
    {
      "content": "# Copy the project into the image\nADD . /app\n",
      "source_file": "docs/deployment/docker.md",
      "chunk_type": "doc"
    },
    {
      "content": "# Sync the project\nRUN --mount=type=cache,target=/root/.cache/uv \\\n    uv sync --frozen\n",
      "source_file": "docs/deployment/docker.md",
      "chunk_type": "doc"
    },
    {
      "content": "# Run with uvicorn\nCMD [\"uv\", \"run\", \"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n```\n\nA common question is **\"how many workers should I run?\"**. The image above uses a single Uvicorn worker.\nThe recommended approach is to let your orchestration system manage the number of deployed containers rather than\nrelying on the process manager inside the container.\n\nYou can read more about this in the\n[Decouple applications](https://docs.docker.com/build/building/best-practices/#decouple-applications) section\nof the Docker documentation.\n\n!!! warning \"For production, create a non-root user!\"\n    When running in production, you should create a non-root user and run the container as that user.\n\nTo make sure it works, let's build the image and run it:\n\n```bash\ndocker build -t my-app .\ndocker run -p 8000:8000 my-app\n```\n\nFor more information on using uv with Docker, refer to the\n[official uv Docker integration guide](https://docs.astral.sh/uv/guides/integration/docker/).\n",
      "source_file": "docs/deployment/docker.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Docker Compose\n\nWhen running in development, it's often useful to have a way to hot-reload the application when code changes.\n\nLet's create a `docker-compose.yml` file to run the application:\n\n```yaml title=\"docker-compose.yml\"\nservices:\n  backend:\n    build: .\n    ports:\n      - \"8000:8000\"\n    environment:\n      - UVICORN_RELOAD=true\n    volumes:\n      - .:/app\n    tty: true\n```\n\nYou can run the application with `docker compose up` and it will automatically rebuild the image when code changes.\n\nNow you have a fully working development environment! :tada:",
      "source_file": "docs/deployment/docker.md",
      "chunk_type": "doc"
    },
    {
      "content": "Since Uvicorn is an ASGI server, it supports the\n[ASGI lifespan protocol](https://asgi.readthedocs.io/en/latest/specs/lifespan.html).\nThis allows you to run **startup** and **shutdown** events for your application.\n\nThe lifespan protocol is useful for initializing resources that need to be available throughout\nthe lifetime of the application, such as database connections, caches, or other services.\n\nKeep in mind that the lifespan is executed **only once per application instance**. If you have\nmultiple workers, each worker will execute the lifespan independently.\n",
      "source_file": "docs/concepts/lifespan.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Lifespan Architecture\n\nThe lifespan protocol runs as a sibling task alongside your main application, allowing both to execute concurrently.\n\nLet's see how Uvicorn handles the lifespan and main application tasks:\n\n```mermaid\nsequenceDiagram\n    participant Server as Uvicorn Server\n    participant LifespanTask as Lifespan Task\n    participant AppTask as Application Task\n    participant UserApp as User Application\n\n    Note over Server: \u2705 Server starts\n\n    Server->>+LifespanTask: spawn_task(lifespan_handler)\n\n    LifespanTask->>UserApp: {\"type\": \"lifespan.startup\"}\n\n    Note over UserApp: Initialize databases, caches, etc.\n\n    UserApp-->>LifespanTask: {\"type\": \"lifespan.startup.complete\"}\n    LifespanTask->>Server: \u2705 Startup complete\n\n    Server->>+AppTask: spawn_task(application_handler)\n    Note over AppTask: \u2705 Ready for requests\n\n    rect rgb(240, 248, 255)\n        Note over LifespanTask, AppTask: Both tasks running concurrently\n\n        par Lifespan maintains state\n            LifespanTask->>LifespanTask: Keep lifespan connection alive\n        and Application serves requests\n            AppTask->>UserApp: HTTP/WebSocket requests\n            UserApp-->>AppTask: Responses\n        end\n    end\n\n    Note over Server: Shutdown signal received\n\n    Server->>AppTask: Stop accepting new connections\n    AppTask->>AppTask: Complete pending requests\n\n    LifespanTask->>UserApp: {\"type\": \"lifespan.shutdown\"}\n\n    Note over UserApp: Cleanup databases, caches, etc.\n\n    UserApp-->>LifespanTask: {\"type\": \"lifespan.shutdown.complete\"}\n\n    LifespanTask->>-Server: Lifespan task complete\n    AppTask->>-Server: Application task complete\n\n    Note over Server: \u2705 Server stopped\n```\n\nHaving the lifespan task run as a sibling task is a deliberate design choice. It could have been implemented as a parent task that spawns the\napplication task. This decision has the implication that if you create a [`ContextVar`][contextvars.ContextVar]\nin the lifespan task, it will not be available in the application task.\n",
      "source_file": "docs/concepts/lifespan.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Usage\n\nLet's see an example of a minimal (but complete) ASGI application that implements the lifespan protocol:\n\n```python title=\"ASGI application with lifespan\" hl_lines=\"3-11\"\nasync def app(scope, receive, send):\n    if scope['type'] == 'lifespan':\n        while True:\n            message = await receive()\n            if message['type'] == 'lifespan.startup':\n                print(\"Application is starting up...\")\n                await send({'type': 'lifespan.startup.complete'})\n            elif message['type'] == 'lifespan.shutdown':\n                print(\"Application is shutting down...\")\n                await send({'type': 'lifespan.shutdown.complete'})\n                return\n    elif scope['type'] == 'http':\n        await send({\n            'type': 'http.response.start',\n            'status': 200,\n            'headers': [(b'content-type', b'text/plain')],\n        })\n        await send({'type': 'http.response.body', 'body': b'Hello, World!'})\n    else:\n        raise RuntimeError(\"This server doesn't support WebSocket.\")\n```\n\nYou can run the above application with `uvicorn main:app`. Then you'll see the print statements when the\napplication starts. You can also try to send some HTTP requests to it, and it will respond with \"Hello, World!\".\nAnd if you stop the server (`CTRL + C`), it will print `\"Application is shutting down...\"`.\n",
      "source_file": "docs/concepts/lifespan.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Disabling Lifespan\n\nIf you want to disable the lifespan protocol, you can do so by setting the `lifespan` option to `off` when running Uvicorn:\n\n```bash\nuvicorn main:app --lifespan off\n```\n\nBy default, Uvicorn will automatically enable the lifespan protocol if the application supports it.",
      "source_file": "docs/concepts/lifespan.md",
      "chunk_type": "doc"
    },
    {
      "content": "## ASGI\n\n**Uvicorn** uses the [ASGI specification](https://asgi.readthedocs.io/en/latest/) for interacting with an application.\n\nThe application should expose an async callable which takes three arguments:\n\n* `scope` - A dictionary containing information about the incoming connection.\n* `receive` - A channel on which to receive incoming messages from the server.\n* `send` - A channel on which to send outgoing messages to the server.\n\nTwo common patterns you might use are either function-based applications:\n\n```python\nasync def app(scope, receive, send):\n    assert scope['type'] == 'http'\n    ...\n```\n\nOr instance-based applications:\n\n```python\nclass App:\n    async def __call__(self, scope, receive, send):\n        assert scope['type'] == 'http'\n        ...\n\napp = App()\n```\n\nIt's good practice for applications to raise an exception on scope types\nthat they do not handle.\n\nThe content of the `scope` argument, and the messages expected by `receive` and `send` depend on the protocol being used.\n\nThe format for HTTP messages is described in the [ASGI HTTP Message format](https://asgi.readthedocs.io/en/latest/specs/www.html).\n",
      "source_file": "docs/concepts/asgi.md",
      "chunk_type": "doc"
    },
    {
      "content": "### HTTP Scope\n\nAn incoming HTTP request might have a connection `scope` like this:\n\n```python\n{\n    'type': 'http',\n    'scheme': 'http',\n    'root_path': '',\n    'server': ('127.0.0.1', 8000),\n    'http_version': '1.1',\n    'method': 'GET',\n    'path': '/',\n    'headers': [\n        (b'host', b'127.0.0.1:8000'),\n        (b'user-agent', b'curl/7.51.0'),\n        (b'accept', b'*/*')\n    ]\n}\n```\n",
      "source_file": "docs/concepts/asgi.md",
      "chunk_type": "doc"
    },
    {
      "content": "### HTTP Messages\n\nThe instance coroutine communicates back to the server by sending messages to the `send` coroutine.\n\n```python\nawait send({\n    'type': 'http.response.start',\n    'status': 200,\n    'headers': [\n        [b'content-type', b'text/plain'],\n    ]\n})\nawait send({\n    'type': 'http.response.body',\n    'body': b'Hello, world!',\n})\n```\n",
      "source_file": "docs/concepts/asgi.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Requests & responses\n\nHere's an example that displays the method and path used in the incoming request:\n\n```python\nasync def app(scope, receive, send):\n    \"\"\"\n    Echo the method and path back in an HTTP response.\n    \"\"\"\n    assert scope['type'] == 'http'\n\n    body = f'Received {scope[\"method\"]} request to {scope[\"path\"]}'\n    await send({\n        'type': 'http.response.start',\n        'status': 200,\n        'headers': [\n            [b'content-type', b'text/plain'],\n        ]\n    })\n    await send({\n        'type': 'http.response.body',\n        'body': body.encode('utf-8'),\n    })\n```\n",
      "source_file": "docs/concepts/asgi.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Reading the request body\n\nYou can stream the request body without blocking the asyncio task pool,\nby fetching messages from the `receive` coroutine.\n\n```python\nasync def read_body(receive):\n    \"\"\"\n    Read and return the entire body from an incoming ASGI message.\n    \"\"\"\n    body = b''\n    more_body = True\n\n    while more_body:\n        message = await receive()\n        body += message.get('body', b'')\n        more_body = message.get('more_body', False)\n\n    return body\n\n\nasync def app(scope, receive, send):\n    \"\"\"\n    Echo the request body back in an HTTP response.\n    \"\"\"\n    body = await read_body(receive)\n    await send({\n        'type': 'http.response.start',\n        'status': 200,\n        'headers': [\n            (b'content-type', b'text/plain'),\n            (b'content-length', str(len(body)).encode())\n        ]\n    })\n    await send({\n        'type': 'http.response.body',\n        'body': body,\n    })\n```\n",
      "source_file": "docs/concepts/asgi.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Streaming responses\n\nYou can stream responses by sending multiple `http.response.body` messages to\nthe `send` coroutine.\n\n```python\nimport asyncio\n\n\nasync def app(scope, receive, send):\n    \"\"\"\n    Send a slowly streaming HTTP response back to the client.\n    \"\"\"\n    await send({\n        'type': 'http.response.start',\n        'status': 200,\n        'headers': [\n            [b'content-type', b'text/plain'],\n        ]\n    })\n    for chunk in [b'Hello', b', ', b'world!']:\n        await send({\n            'type': 'http.response.body',\n            'body': chunk,\n            'more_body': True\n        })\n        await asyncio.sleep(1)\n    await send({\n        'type': 'http.response.body',\n        'body': b'',\n    })\n```\n\n---\n",
      "source_file": "docs/concepts/asgi.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Why ASGI?\n\nMost well established Python Web frameworks started out as WSGI-based frameworks.\n\nWSGI applications are a single, synchronous callable that takes a request and returns a response.\nThis doesn\u2019t allow for long-lived connections, like you get with long-poll HTTP or WebSocket connections,\nwhich WSGI doesn't support well.\n\nHaving an async concurrency model also allows for options such as lightweight background tasks,\nand can be less of a limiting factor for endpoints that have long periods being blocked on network\nI/O such as dealing with slow HTTP requests.\n\n---\n",
      "source_file": "docs/concepts/asgi.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Alternative ASGI servers\n\nA strength of the ASGI protocol is that it decouples the server implementation\nfrom the application framework. This allows for an ecosystem of interoperating\nwebservers and application frameworks.\n",
      "source_file": "docs/concepts/asgi.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Daphne\n\nThe first ASGI server implementation, originally developed to power Django Channels, is\n[the Daphne webserver](https://github.com/django/daphne).\n\nIt is run widely in production, and supports HTTP/1.1, HTTP/2, and WebSockets.\n\nAny of the example applications given here can equally well be run using `daphne` instead.\n\n```shell\npip install daphne\ndaphne app:App\n```\n",
      "source_file": "docs/concepts/asgi.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Hypercorn\n\n[Hypercorn](https://github.com/pgjones/hypercorn) was initially part of the Quart web framework,\nbefore being separated out into a standalone ASGI server.\n\nHypercorn supports HTTP/1.1, HTTP/2, HTTP/3 and WebSockets.\n\n```shell\npip install hypercorn\nhypercorn app:App\n```\n\n---\n",
      "source_file": "docs/concepts/asgi.md",
      "chunk_type": "doc"
    },
    {
      "content": "## ASGI frameworks\n\nYou can use Uvicorn, Daphne, or Hypercorn to run any ASGI framework.\n\nFor small services you can also write ASGI applications directly.\n",
      "source_file": "docs/concepts/asgi.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Starlette\n\n[Starlette](https://github.com/encode/starlette) is a lightweight ASGI framework/toolkit.\n\nIt is ideal for building high performance asyncio services, and supports both HTTP and WebSockets.\n",
      "source_file": "docs/concepts/asgi.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Django Channels\n\nThe ASGI specification was originally designed for use with [Django Channels](https://channels.readthedocs.io/en/latest/).\n\nChannels is a little different to other ASGI frameworks in that it provides\nan asynchronous frontend onto a threaded-framework backend. It allows Django\nto support WebSockets, background tasks, and long-running connections,\nwith application code still running in a standard threaded context.\n",
      "source_file": "docs/concepts/asgi.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Quart\n\n[Quart](https://pgjones.gitlab.io/quart/) is a Flask-like ASGI web framework.\n",
      "source_file": "docs/concepts/asgi.md",
      "chunk_type": "doc"
    },
    {
      "content": "### FastAPI\n\n[**FastAPI**](https://github.com/tiangolo/fastapi) is an API framework based on **Starlette** and **Pydantic**, heavily inspired by previous server versions of **APIStar**.\n\nYou write your API function parameters with Python 3.6+ type declarations and get automatic data conversion, data validation, OpenAPI schemas (with JSON Schemas) and interactive API documentation UIs.\n",
      "source_file": "docs/concepts/asgi.md",
      "chunk_type": "doc"
    },
    {
      "content": "### BlackSheep\n\n[BlackSheep](https://www.neoteroi.dev/blacksheep/) is a web framework based on ASGI, inspired by Flask and ASP.NET Core.\n\nIts most distinctive features are built-in support for dependency injection, automatic binding of parameters by request handler's type annotations, and automatic generation of OpenAPI documentation and Swagger UI.\n",
      "source_file": "docs/concepts/asgi.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Falcon\n\n[Falcon](https://falconframework.org) is a minimalist REST and app backend framework for Python, with a focus on reliability, correctness, and performance at scale.\n",
      "source_file": "docs/concepts/asgi.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Muffin\n\n[Muffin](https://github.com/klen/muffin) is a fast, lightweight and asynchronous ASGI web-framework for Python 3.\n",
      "source_file": "docs/concepts/asgi.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Litestar\n\n[Litestar](https://litestar.dev) is a powerful, lightweight and flexible ASGI framework.\n\nIt includes everything that's needed to build modern APIs - from data serialization and validation to websockets, ORM integration, session management, authentication and more.\n",
      "source_file": "docs/concepts/asgi.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Panther\n\n[Panther](https://PantherPy.github.io/) is a fast & friendly web framework for building async APIs with Python 3.10+.\n\nIt has built-in Document-oriented Database, Caching System, Authentication and Permission Classes, Visual API Monitoring and also supports Websocket, Throttling, Middlewares.",
      "source_file": "docs/concepts/asgi.md",
      "chunk_type": "doc"
    },
    {
      "content": "**Uvicorn** supports the WebSocket protocol as defined in [RFC 6455](https://datatracker.ietf.org/doc/html/rfc6455).\n",
      "source_file": "docs/concepts/websockets.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Upgrade Process\n\nThe WebSocket protocol starts as an HTTP connection that gets \"upgraded\" to a WebSocket connection\nthrough a handshake process. Here's how it works:\n\n```mermaid\nsequenceDiagram\n    participant Client\n    participant Server\n    participant ASGI App\n\n    Note over Client,ASGI App: WebSocket Handshake Process\n\n    Client->>Server: HTTP GET Request\n    Note right of Client: Headers:<br/>Upgrade: websocket<br/>Connection: Upgrade<br/>Sec-WebSocket-Key: [key]<br/>Sec-WebSocket-Version: 13\n\n    Server->>ASGI App: websocket.connect event\n    Note right of Server: Scope type: \"websocket\"\n\n    alt Connection Accepted\n        ASGI App->>Server: {\"type\": \"websocket.accept\"}\n        Server->>Client: HTTP 101 Switching Protocols\n        Note right of Server: Headers:<br/>Upgrade: websocket<br/>Connection: Upgrade<br/>Sec-WebSocket-Accept: [hash]\n\n        Note over Client,ASGI App: WebSocket Connection Established\n\n        loop Message Exchange\n            Client->>Server: WebSocket Frame\n            Server->>ASGI App: websocket.receive event\n            ASGI App->>Server: {\"type\": \"websocket.send\", \"text\": \"...\"}\n            Server->>Client: WebSocket Frame\n        end\n\n        alt Client Closes\n            Client->>Server: Close Frame\n            Server->>ASGI App: websocket.disconnect event\n        else Server Closes\n            ASGI App->>Server: {\"type\": \"websocket.close\"}\n            Server->>Client: Close Frame\n        end\n\n    else Connection Rejected\n        ASGI App->>Server: {\"type\": \"websocket.http.response.start\", \"status\": 403}\n        Server->>Client: HTTP 403 Forbidden\n    end\n```\n\n1. **Initial HTTP Request**: The client sends a regular HTTP GET request with special headers indicating it wants to upgrade to WebSocket:\n    - `Upgrade: websocket`\n    - `Connection: Upgrade`\n    - `Sec-WebSocket-Key`: A base64-encoded random key\n    - `Sec-WebSocket-Version: 13`\n\n2. **Server Processing**: Uvicorn receives the request and creates a WebSocket scope, sending a `websocket.connect` event to the ASGI application.\n\n3. **Application Decision**: The ASGI app decides whether to accept or reject the connection based on authentication, authorization, or other logic.\n\n4. **Handshake Completion**: If accepted, the server responds with HTTP 101 status and the computed `Sec-WebSocket-Accept` header.\n\n5. **Full-Duplex Communication**: Once upgraded, both client and server can send messages at any time using WebSocket frames.\n\n6. **Connection Termination**: Either side can initiate closing the connection with a close frame.\n",
      "source_file": "docs/concepts/websockets.md",
      "chunk_type": "doc"
    },
    {
      "content": "## ASGI WebSocket Events\n\n**Uvicorn** translates WebSocket protocol messages into ASGI events:\n\n- `websocket.connect`: Sent when a client requests a WebSocket upgrade\n- `websocket.receive`: Sent when a message is received from the client\n- `websocket.disconnect`: Sent when the connection is closed\n\nThe ASGI app can respond with:\n\n- `websocket.accept`: Accept the connection upgrade with an optional subprotocol\n- `websocket.send`: Send a message to the client\n- `websocket.close`: Close the connection with an optional status code\n\nYou can read more about it on the [ASGI documentation](https://asgi.readthedocs.io/en/latest/specs/www.html#websocket).\n",
      "source_file": "docs/concepts/websockets.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Protocol Implementations\n\n**Uvicorn** has three implementations of the WebSocket protocol.\n",
      "source_file": "docs/concepts/websockets.md",
      "chunk_type": "doc"
    },
    {
      "content": "### WSProto Protocol\n\nThis implementation was the first implemented. It uses the\n[`wsproto`](https://python-hyper.org/projects/wsproto/en/stable/) package underneath.\n\nYou can choose this protocol by setting the `--ws` option to `wsproto`.\n",
      "source_file": "docs/concepts/websockets.md",
      "chunk_type": "doc"
    },
    {
      "content": "### WebSocket Protocol\n\nThis implementation uses the [`websockets`](https://websockets.readthedocs.io/) package as dependency.\n\nBy default, if you have `websockets` installed, Uvicorn will use this protocol.\n",
      "source_file": "docs/concepts/websockets.md",
      "chunk_type": "doc"
    },
    {
      "content": "### WebSockets SansIO Protocol\n\nSince `websockets` deprecated the API Uvicorn uses to run the previous protocol, we had to create this new\nprotocol that uses the `websockets` SansIO API.\n\nYou can choose this protocol by setting the `--ws` option to `websockets-sansio`.\n\n!!! note\n    The SansIO implementation was released in Uvicorn version 0.35.0 in June 2025.",
      "source_file": "docs/concepts/websockets.md",
      "chunk_type": "doc"
    },
    {
      "content": "<!-- Copied from https://github.com/squidfunk/mkdocs-material/issues/4827#issuecomment-1869812019 -->\n<li class=\"md-nav__item\"></li>\n<a href=\"{{ toc_item.url }}\" class=\"md-nav__link\">\n    <span class=\"md-ellipsis\">\n        {{ toc_item.title }}\n    </span>\n</a>\n\n<!-- Table of contents list -->\n{% if toc_item.children %}\n<nav class=\"md-nav\" aria-label=\"{{ toc_item.title | striptags }}\">\n    <ul class=\"md-nav__list\">\n        {% for toc_item in toc_item.children %}\n        {% if not page.meta.toc_depth or toc_item.level <= page.meta.toc_depth %} {% include \"partials/toc-item.html\" %}\n            {% endif %} {% endfor %} </ul>\n</nav>\n{% endif %}\n</li>\n",
      "source_file": "docs/overrides/partials/toc-item.html",
      "chunk_type": "unknown"
    },
    {
      "content": "{% import \"partials/nav-item.html\" as item with context %}\n\n<!-- Determine class according to configuration -->\n {% set class = \"md-nav md-nav--primary\" %}\n {% if \"navigation.tabs\" in features %}\n   {% set class = class ~ \" md-nav--lifted\" %}\n {% endif %}\n {% if \"toc.integrate\" in features %}\n   {% set class = class ~ \" md-nav--integrated\" %}\n {% endif %}\n\n <!-- Main navigation -->\n <nav\n   class=\"{{ class }}\"\n   aria-label=\"{{ lang.t('nav.title') }}\"\n   data-md-level=\"0\"\n >\n\n   <!-- Site title -->\n   <label class=\"md-nav__title\" for=\"__drawer\">\n     <a\n       href=\"{{ config.extra.homepage | d(nav.homepage.url, true) | url }}\"\n       title=\"{{ config.site_name | e }}\"\n       class=\"md-nav__button md-logo\"\n       aria-label=\"{{ config.site_name }}\"\n       data-md-component=\"logo\"\n     >\n       {% include \"partials/logo.html\" %}\n     </a>\n     {{ config.site_name }}\n   </label>\n\n   <!-- Repository information -->\n   {% if config.repo_url %}\n     <div class=\"md-nav__source\">\n       {% include \"partials/source.html\" %}\n     </div>\n   {% endif %}\n\n   <!-- Navigation list -->\n   <ul class=\"md-nav__list\" data-md-scrollfix>\n     {% for nav_item in nav %}\n       {% set path = \"__nav_\" ~ loop.index %}\n       {{ item.render(nav_item, path, 1) }}\n     {% endfor %}\n   </ul>\n </nav>\n",
      "source_file": "docs/overrides/partials/nav.html",
      "chunk_type": "unknown"
    }
  ],
  "_metadata": {
    "generation_info": {
      "model": "gemini-2.5-flash",
      "provider": "gemini",
      "base_url": "https://generativelanguage.googleapis.com/v1beta/openai/",
      "start_time": "2025-07-11T11:31:51.955786",
      "command": "analyze",
      "config_file": null,
      "version": "0.1.0"
    }
  }
}