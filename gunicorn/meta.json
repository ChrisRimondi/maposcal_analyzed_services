{
  "chunks": [
    {
      "content": "2009-2024 (c) Beno\u00eet Chesneau <benoitc@gunicorn.org>\n2009-2015 (c) Paul J. Davis <paul.joseph.davis@gmail.com>\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n",
      "source_file": "LICENSE",
      "chunk_type": "unknown"
    },
    {
      "content": "build:\n\tvirtualenv venv\n\tvenv/bin/pip install -e .\n\tvenv/bin/pip install -r requirements_dev.txt\n\ntest:\n\tvenv/bin/python setup.py test\n\ncoverage:\n\tvenv/bin/python setup.py test --cov\n\nclean:\n\t@rm -rf .Python MANIFEST build dist venv* *.egg-info *.egg\n\t@find . -type f -name \"*.py[co]\" -delete\n\t@find . -type d -name \"__pycache__\" -delete\n\n.PHONY: build clean coverage test\n",
      "source_file": "Makefile",
      "chunk_type": "unknown"
    },
    {
      "content": "include .gitignore\ninclude LICENSE\ninclude NOTICE\ninclude README.rst\ninclude THANKS\ninclude requirements_dev.txt\ninclude requirements_test.txt\ninclude tox.ini\ninclude .pylintrc\nrecursive-include tests *\nrecursive-include examples *\nrecursive-include docs *\nrecursive-include examples/frameworks *\nrecursive-exclude * __pycache__\nrecursive-exclude docs/build *\nrecursive-exclude docs/_build *\nrecursive-exclude * *.py[co]\n",
      "source_file": "MANIFEST.in",
      "chunk_type": "unknown"
    },
    {
      "content": "Core maintainers\n================\n\nBenoit Chesneau <benoitc@gunicorn.org>\nKonstantin Kapustin <sirkonst@gmail.com>\nRandall Leeds <randall.leeds@gmail.com>\nBerker Peksa\u011f <berker.peksag@gmail.com>\nJason Madden <jason@nextthought.com>\nBrett Randall <javabrett@gmail.com>\n\nAlumni\n======\n\nThis list contains maintainers that are no longer active on the project.\nIt is thanks to these people that the project has become what it is today.\nThank you!\n\n\nPaul J. Davis <paul.joseph.davis@gmail.com>\nKenneth Reitz <me@kennethreitz.com>\nNikolay Kim <fafhrd91@gmail.com>\nAndrew Svetlov <andrew.svetlov@gmail.com>\nSt\u00e9phane Wirtel <stephane@wirtel.be>",
      "source_file": "MAINTAINERS",
      "chunk_type": "unknown"
    },
    {
      "content": "Gunicorn\n\n2009-2024 (c) Beno\u00eet Chesneau <benoitc@gunicorn.org>\n2009-2015 (c) Paul J. Davis <paul.joseph.davis@gmail.com>\n\nGunicorn is released under the MIT license. See the LICENSE\nfile for the complete license.\n\ngunicorn.logging_config\n-----------------------\nCopyright 2001-2005 by Vinay Sajip. All Rights Reserved.\n\nPermission to use, copy, modify, and distribute this software and its\ndocumentation for any purpose and without fee is hereby granted,\nprovided that the above copyright notice appear in all copies and that\nboth that copyright notice and this permission notice appear in\nsupporting documentation, and that the name of Vinay Sajip\nnot be used in advertising or publicity pertaining to distribution\nof the software without specific, written prior permission.\n\nVINAY SAJIP DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\nINCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL\nVINAY SAJIP BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR\nANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\nIN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT\nOF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\ngunicorn.debug\n--------------\n\nBased on eventlet.debug module under MIT license:\n\nUnless otherwise noted, the files in Eventlet are under the following MIT license:\n\nCopyright (c) 2005-2006, Bob Ippolito\nCopyright (c) 2007-2010, Linden Research, Inc.\nCopyright (c) 2008-2010, Eventlet Contributors (see Eventlet AUTHORS)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\ngunicorn.reloader\n-----------------\n\nBased on greins.reloader module under MIT license:\n\n2010 (c) Meebo, Inc.\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n\n\nutil/unlink.py\n--------------\n\nbackport from python3 Lib/test/support.py\n",
      "source_file": "NOTICE",
      "chunk_type": "unknown"
    },
    {
      "content": "# Contributing to Gunicorn\n\nWant to hack on Gunicorn? Awesome! Here are instructions to get you\nstarted. They are probably not perfect, please let us know if anything\nfeels wrong or incomplete.\n",
      "source_file": "CONTRIBUTING.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Contribution guidelines\n",
      "source_file": "CONTRIBUTING.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Pull requests are always welcome\n\nWe are always thrilled to receive pull requests, and do our best to\nprocess them as fast as possible. Not sure if that typo is worth a pull\nrequest? Do it! We will appreciate it.\n\nIf your pull request is not accepted on the first try, don't be\ndiscouraged! If there's a problem with the implementation, hopefully you\nreceived feedback on what to improve.\n\nWe're trying very hard to keep Gunicorn lean and focused. We don't want it\nto do everything for everybody. This means that we might decide against\nincorporating a new feature. However, there might be a way to implement\nthat feature *on top of* Gunicorn.\n",
      "source_file": "CONTRIBUTING.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Discuss your design on the mailing list\n\nWe recommend discussing your plans [on the mailing\nlist](http://gunicorn.org/#community) before starting to code -\nespecially for more ambitious contributions.  This gives other\ncontributors a chance to point you in the right direction, give feedback\non your design, and maybe point out if someone else is working on the\nsame thing.\n",
      "source_file": "CONTRIBUTING.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Create issues...\n\nAny significant improvement should be documented as [a github\nissue](https://github.com/benoitc/gunicorn/issues) before anybody starts\nworking on it.\n",
      "source_file": "CONTRIBUTING.md",
      "chunk_type": "doc"
    },
    {
      "content": "### ...but check for existing issues first!\n\nPlease take a moment to check that an issue doesn't already exist\ndocumenting your bug report or improvement proposal. If it does, it\nnever hurts to add a quick \"+1\" or \"I have this problem too\". This will\nhelp prioritize the most common problems and requests.\n\n",
      "source_file": "CONTRIBUTING.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Conventions\n\nDon't comment on closed issues or PRs, instead open a new issue and link it to\nthe old one.\n\nFork the repo and make changes on your fork in a feature branch:\n\n- If it's a bugfix branch, name it XXX-something where XXX is the number\n  of the issue\n- If it's a feature branch, create an enhancement issue to announce your\n  intentions, and name it XXX-something where XXX is the number of the\nissue.\n\nSubmit unit tests for your changes. Python has a great test framework built\nin; use it! Take a look at existing tests for inspiration. Run the full\ntest suite on your branch before submitting a pull request.\n\nMake sure you include relevant updates or additions to documentation\nwhen creating or modifying features.\n\nIf you are adding a new configuration option or updating an existing one,\nplease do it in `gunicorn/config.py`, then run `make -C docs html` to update\n`docs/source/settings.rst`.\n\nWrite clean code.\n\nPull requests descriptions should be as clear as possible and include a\nreference to all the issues that they address.\n\nCode review comments may be added to your pull request. Discuss, then\nmake the suggested modifications and push additional commits to your\nfeature branch. Be sure to post a comment after pushing. The new commits\nwill show up in the pull request automatically, but the reviewers will\nnot be notified unless you comment.\n\nBefore the pull request is merged, make sure that you squash your\ncommits into logical units of work using `git rebase -i` and `git push\n-f`. After every commit the test suite should be passing. Include\ndocumentation changes in the same commit so that a revert would remove\nall traces of the feature or fix.\n\nCommits that fix or close an issue should include a reference like\n`Closes #XXX` or `Fixes #XXX`, which will automatically close the issue\nwhen merged.\n\nAdd your name to the THANKS file, but make sure the list is sorted and\nyour name and email address match your git configuration. The THANKS\nfile is regenerated occasionally from the git commit history, so a\nmismatch may result in your changes being overwritten.\n\n",
      "source_file": "CONTRIBUTING.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Decision process\n",
      "source_file": "CONTRIBUTING.md",
      "chunk_type": "doc"
    },
    {
      "content": "### How are decisions made?\n\nShort answer: with pull requests to the gunicorn repository.\n\nGunicorn is an open-source project under the MIT License with an open\ndesign philosophy. This means that the repository is the source of truth\nfor EVERY aspect of the project, including its philosophy, design,\nroadmap and APIs. *If it's part of the project, it's in the repo. It's\nin the repo, it's part of the project.*\n\nAs a result, all decisions can be expressed as changes to the\nrepository. An implementation change is a change to the source code. An\nAPI change is a change to the API specification. A philosophy change is\na change to the relevant documentation. And so on.\n\nAll decisions affecting gunicorn, big and small, follow the same 3 steps:\n\n* Step 1: Open a pull request. Anyone can do this.\n\n* Step 2: Discuss the pull request. Anyone can do this.\n\n* Step 3: Accept or refuse a pull request. The relevant maintainer does this (see below \"Who decides what?\")\n\n",
      "source_file": "CONTRIBUTING.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Who decides what?\n\nSo all decisions are pull requests, and the relevant maintainer makes\nthe decision by accepting or refusing the pull request.  But how do we\nidentify the relevant maintainer for a given pull request?\n\nGunicorn follows the timeless, highly efficient and totally unfair system\nknown as [Benevolent dictator for\nlife](http://en.wikipedia.org/wiki/Benevolent_Dictator_for_Life), with\nBenoit Chesneau (aka benoitc), in the role of BDFL.  This means that all\ndecisions are made by default by me. Since making every decision myself\nwould be highly unscalable, in practice decisions are spread across\nmultiple maintainers.\n\nThe relevant maintainer for a pull request is assigned in 3 steps:\n\n* Step 1: Determine the subdirectory affected by the pull request. This might be src/registry, docs/source/api, or any other part of the repo.\n\n* Step 2: Find the MAINTAINERS file which affects this directory. If the directory itself does not have a MAINTAINERS file, work your way up the repo hierarchy until you find one.\n\n* Step 3: The first maintainer listed is the primary maintainer who is assigned the Pull Request. The primary maintainer can reassign a Pull Request to other listed maintainers.\n\n",
      "source_file": "CONTRIBUTING.md",
      "chunk_type": "doc"
    },
    {
      "content": "### I'm a maintainer, should I make pull requests too?\n\nPrimary maintainers are not required to create pull requests when\nchanging their own subdirectory, but secondary maintainers are.\n",
      "source_file": "CONTRIBUTING.md",
      "chunk_type": "doc"
    },
    {
      "content": "### Who assigns maintainers?\n\nbenoitc.\n",
      "source_file": "CONTRIBUTING.md",
      "chunk_type": "doc"
    },
    {
      "content": "### How can I become a maintainer?\n\n* Step 1: learn the component inside out\n* Step 2: make yourself useful by contributing code, bugfixes, support etc.\n* Step 3: volunteer on the irc channel (#gunicorn@freenode)\n\nDon't forget: being a maintainer is a time investment. Make sure you\nwill have time to make yourself available.  You don't have to be a\nmaintainer to make a difference on the project!\n",
      "source_file": "CONTRIBUTING.md",
      "chunk_type": "doc"
    },
    {
      "content": "### What are a maintainer's responsibility?\n\nIt is every maintainer's responsibility to:\n\n* 1) Expose a clear roadmap for improving their component.\n* 2) Deliver prompt feedback and decisions on pull requests.\n* 3) Be available to anyone with questions, bug reports, criticism etc. on their component. This includes irc, github requests and the mailing list.\n* 4) Make sure their component respects the philosophy, design and roadmap of the project.\n",
      "source_file": "CONTRIBUTING.md",
      "chunk_type": "doc"
    },
    {
      "content": "### How is this process changed?\n\nJust like everything else: by making a pull request :)",
      "source_file": "CONTRIBUTING.md",
      "chunk_type": "doc"
    },
    {
      "content": "Gunicorn THANKS\n===============\n\nA number of people have contributed to Gunicorn by reporting problems,\nsuggesting improvements or submitting changes. Some of these people are:\n\n414nch4n <chanfung032@gmail.com>\nAaron Kavlie <akavlie@gmail.com>\naartur <asiekielski@soldevelo.com>\nAdnane Belmadiaf <adnane002@gmail.com>\nAdrien CLERC <adrien@antipoul.fr>\nAlasdair Nicol <alasdair@thenicols.net>\nAlex Conrad <alexandre.conrad@gmail.com>\nAlex Gaynor <alex.gaynor@gmail.com>\nAlex Robbins <alexander.j.robbins@gmail.com>\nAlexandre Zani <alexandre.zani@gmail.com>\nAlexis Le-Quoc <alq@datadoghq.com>\nAnand Chitipothu <anandology@gmail.com>\nAndreas St\u00fchrk <andy-python@hammerhartes.de>\nAndrew Burdo <zeezooz@gmail.com>\nAndrew Svetlov <andrew.svetlov@gmail.com>\nAnil V <avaitla16@gmail.com>\nAntoine Girard <antoine.girard.dev@gmail.com>\nAnton Vlasenko <antares.spica@gmail.com>\nArtur Kruchinin <arturkruchinin@gmail.com>\nBartosz Oler <bartosz@bzimage.us>\nBen Cochran <bcochran@gmail.com>\nBen Oswald <ben.oswald@root-space.de>\nBenjamin Gilbert <bgilbert@backtick.net>\nBenny Mei <meibenny@gmail.com>\nBenoit Chesneau <bchesneau@gmail.com>\nBerker Peksag <berker.peksag@gmail.com>\nbninja <andrew@poundpay.com>\nBob Hagemann <bob+code@twilio.com>\nBobby Beckmann <bobby@macs-MacBook-Pro.local>\nBrett Randall <javabrett@gmail.com>\nBrian Rosner <brosner@gmail.com>\nBruno Bigras <bigras.bruno@gmail.com>\nCaleb Brown <git@calebbrown.id.au>\nChris Adams <chris@improbable.org>\nChris Forbes <chrisf@ijw.co.nz>\nChris Lamb <lamby@debian.org>\nChris Streeter <chris@chrisstreeter.com>\nChristian Clauss <cclauss@me.com>\nChristoph Heer <Christoph.Heer@gmail.com>\nChristos Stavrakakis <cstavr@grnet.gr>\nCMGS <ilskdw@mspil.edu.cn>\nCurt Micol <asenchi@asenchi.com>\nDan Callaghan <dcallagh@redhat.com>\nDan Sully <daniel-github@electricrain.com>\nDaniel Quinn <code@danielquinn.org>\nDariusz Suchojad <dsuch-github@m.zato.io>\nDavid Black <github@dhb.is>\nDavid Vincelli <david@freshbooks.com>\nDavid Wolever <david@wolever.net>\nDenis Bilenko <denis.bilenko@gmail.com>\nDiego Oliveira <contact@diegoholiveira.com>\nDima Barsky <github@kappa.ac93.org>\nDjoume Salvetti <djoume@freshbooks.com>\nDmitry Medvinsky <me@dmedvinsky.name>\nDustin Ingram <di@users.noreply.github.com>\nEd Morley <edmorley@users.noreply.github.com>\nEric Florenzano <floguy@gmail.com>\nEric Shull <eric@elevenbasetwo.com>\nEugene Obukhov <irvind25@gmail.com>\nEvan Mezeske <evan@meebo-inc.com>\nFlorian Apolloner <florian@apolloner.eu>\nGaurav Kumar <gauravkumar37@gmail.com>\nGeorge Kollias <georgioskollias@gmail.com>\nGeorge Notaras <gnot@g-loaded.eu>\nGerman Larrain <germanlarrainm@gmail.com>\nGraham Dumpleton <Graham.Dumpleton@gmail.com>\nGraham Dumpleton <graham@newrelic.com>\nGreg McGuire <greg-github@greganem.com>\nGreg Taylor <gtaylor@duointeractive.com>\nHasan Ramezani <hasan.r67@gmail.com>\nHebert J <hebert@mail.ru>\nHobson Lane <shopper@totalgood.com>\nHugo van Kemenade <hugovk@users.noreply.github.com>\nIgor Petrov <igor.s.petrov@gmail.com>\nINADA Naoki <methane@users.noreply.github.com>\nJakub Pawe\u0142 G\u0142azik <zytek@nuxi.pl>\nJan-Philip Gehrcke <jgehrcke@googlemail.com>\nJannis Leidel <jannis@leidel.info>\nJason Madden <jason@nextthought.com>\njean-philippe serafin <serafinjp@gmail.com>\nJeremy Volkman <jeremy@jvolkman.com>\nJeryn Mathew <jerynmathew@gmail.com>\nJet Sun <jet.joins.sun@gmail.com>\nJim Garrison <jim@garrison.cc>\nJohan Bergstr\u00f6m <bugs@bergstroem.nu>\nJohn Hensley <john@fairviewcomputing.com>\nJonas Haag <jonas@lophus.org>\nJonas Nockert <jonasnockert@gmail.com>\nJorge Niedbalski <jorge@nimbic.com>\nJorge Niedbalski R <niedbalski@gmail.com>\nJustin Quick <justquick@gmail.com>\nkeakon <keakon@gmail.com>\nKeegan Carruthers-Smith <keegan.csmith@gmail.com>\nKenneth Reitz <me@kennethreitz.org>\nKevin Gessner <kevin@kevingessner.com>\nKevin Littlejohn <kevin@littlejohn.id.au>\nKevin Luikens <kluikens@gmail.com>\nKirill Zaborsky <qrilka@gmail.com>\nKonstantin Kapustin <sirkonst@gmail.com>\nkracekumar <kracethekingmaker@gmail.com>\nKristian Glass <git@doismellburning.co.uk>\nKristian \u00d8llegaard <kristian.ollegaard@divio.ch>\nKrystian <chrisjozwik@outlook.com>\nKrzysztof Urbaniak <urban@fail.pl>\nKyle Kelley <rgbkrk@gmail.com>\nKyle Mulka <repalviglator@yahoo.com>\nLars Hansson <romabysen@gmail.com>\nLeonardo Santagada <santagada@gmail.com>\nLevi Gross <levi@levigross.com>\nlicunlong <shenxiaogll@163.com>\n\u0141ukasz Kucharski <lkucharski@leon.pl>\nMahmoud Hashemi <mahmoudrhashemi@gmail.com>\nMalthe Borch <mborch@gmail.com>\nMarc Abramowitz <marc@marc-abramowitz.com>\nMarc Abramowitz <msabramo@gmail.com>\nMark Adams <mark@markadams.me>\nMatt Behrens <askedrelic@gmail.com>\nMatt Billenstein <mattb@flingo.tv>\nMatt Good <matt@matt-good.net>\nMatt Robenolt <m@robenolt.com>\nMaxim Kamenkov <mkamenkov@gmail.com>\nMazdak Rezvani <mazdak@mac.com>\nMichael Schurter <m@schmichael.com>\nMieszko <mieszko.chowaniec@gmail.com>\nMike Tigas <mike@tig.as>\nMoriyoshi Koizumi <mozo@mozo.jp>\nmpaolini <markopaolini@gmail.com>\nNeil Chintomby <nchintomby@gmail.com>\nNeil Williams <neil@reddit.com>\nNick Pillitteri <nick@tshlabs.org>\nNik Nyby <nnyby@columbia.edu>\nNikolay Kim <fafhrd91@gmail.com>\nOliver Bristow <evilumbrella+github@gmail.com>\nOliver Tonnhofer <olt@bogosoft.com>\nOmer Katz <omer.drow@gmail.com>\nPA Parent <paparent@paparent.me>\nPaul Davis <davisp@neb.com>\nPaul J. Davis <paul.joseph.davis@gmail.com>\nPaul Smith <paulsmith@pobox.com>\nPhil Schanely <phil@daylife.com>\nPhilip Cristiano <philipcristiano@gmail.com>\nPhilipp Saveliev <fsfeel@gmail.com>\nPrateek Singh Paudel <pratykschingh@gmail.com>\npy <py@douban.com>\nQiangning Hong <hongqn@douban.com>\nRandall Leeds <randall.leeds@gmail.com>\nRandall Leeds <randall@bleeds.info>\nRandall Leeds <randall@meebo-inc.com>\nRapha\u00ebl Slinckx <rslinckx@gmail.com>\nRhys Powell <rhys@rhyspowell.com>\nRik <rvachterberg@gmail.com>\nRonan Amicel <ronan.amicel@gmail.com>\nRyan Peck <ryan@rypeck.com>\nSaeed Gharedaghi <saeed.ghx68@gmail.com>\nSamuel Matos <samypr100@users.noreply.github.com>\nSergey Rublev <narma.nsk@gmail.com>\nShane Reustle <me@shanereustle.com>\nshouse-cars <shouse@cars.com>\nsib <andrew.sibley@gmail.com>\nSimon Lundmark <simon.lundmark@gmail.com>\nStephane Wirtel <stephane@wirtel.be>\nStephen DiCato <Locker537@gmail.com>\nStephen Holsapple <sholsapp@gmail.com>\nSteven Cummings <estebistec@gmail.com>\nS\u00e9bastien Fievet <zyegfryed@gmail.com>\nTal Einat <532281+taleinat@users.noreply.github.com>\nTalha Malik <talham7391@hotmail.com>\nTedWantsMore <TedWantsMore@gmx.com>\nTeko012 <112829523+Teko012@users.noreply.github.com>\nThomas Grainger <tagrain@gmail.com>\nThomas Steinacher <tom@eggdrop.ch>\nTravis Cline <travis.cline@gmail.com>\nTravis Swicegood <development@domain51.com>\nTrey Long <trey@ktrl.com>\nW. Trevor King <wking@tremily.us>\nWojtek <wojtek@monodev.com>\nWolfgang Schnerring <wosc@wosc.de>\nWoLpH <Rick@Fawo.nl>\nwong2 <wonderfuly@gmail.com>\nWooParadog <guohaochuan@gmail.com>\nXie Shi <xieshi@douban.com>\nYue Du <ifduyue@gmail.com>\nzakdances <zakdances@gmail.com>\nEmile Fugulin <emilefugulin@hotmail.com>\n",
      "source_file": "THANKS",
      "chunk_type": "unknown"
    },
    {
      "content": "Gunicorn\n--------\n\n.. image:: https://img.shields.io/pypi/v/gunicorn.svg?style=flat\n    :alt: PyPI version\n    :target: https://pypi.python.org/pypi/gunicorn\n\n.. image:: https://img.shields.io/pypi/pyversions/gunicorn.svg\n    :alt: Supported Python versions\n    :target: https://pypi.python.org/pypi/gunicorn\n\n.. image:: https://github.com/benoitc/gunicorn/actions/workflows/tox.yml/badge.svg\n    :alt: Build Status\n    :target: https://github.com/benoitc/gunicorn/actions/workflows/tox.yml\n\n.. image:: https://github.com/benoitc/gunicorn/actions/workflows/lint.yml/badge.svg\n    :alt: Lint Status\n    :target: https://github.com/benoitc/gunicorn/actions/workflows/lint.yml\n\nGunicorn 'Green Unicorn' is a Python WSGI HTTP Server for UNIX. It's a pre-fork\nworker model ported from Ruby's Unicorn_ project. The Gunicorn server is broadly\ncompatible with various web frameworks, simply implemented, light on server\nresource usage, and fairly speedy.\n\nFeel free to join us in `#gunicorn`_ on `Libera.chat`_.\n\nDocumentation\n-------------\n\nThe documentation is hosted at https://docs.gunicorn.org.\n\nInstallation\n------------\n\nGunicorn requires **Python 3.x >= 3.7**.\n\nInstall from PyPI::\n\n    $ pip install gunicorn\n\n\nUsage\n-----\n\nBasic usage::\n\n    $ gunicorn [OPTIONS] APP_MODULE\n\nWhere ``APP_MODULE`` is of the pattern ``$(MODULE_NAME):$(VARIABLE_NAME)``. The\nmodule name can be a full dotted path. The variable name refers to a WSGI\ncallable that should be found in the specified module.\n\nExample with test app::\n\n    $ cd examples\n    $ gunicorn --workers=2 test:app\n\n\nContributing\n------------\n\nSee `our complete contributor's guide <CONTRIBUTING.md>`_ for more details.\n\n\nLicense\n-------\n\nGunicorn is released under the MIT License. See the LICENSE_ file for more\ndetails.\n\n.. _Unicorn: https://bogomips.org/unicorn/\n.. _`#gunicorn`: https://web.libera.chat/?channels=#gunicorn\n.. _`Libera.chat`: https://libera.chat/\n.. _LICENSE: https://github.com/benoitc/gunicorn/blob/master/LICENSE\n",
      "source_file": "README.rst",
      "chunk_type": "doc"
    },
    {
      "content": "# Security Policy\n",
      "source_file": "SECURITY.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Reporting a Vulnerability\n\n**Please note that public Github issues are open for everyone to see!**\n\nIf you believe you are found a problem in Gunicorn software, examples or documentation, we encourage you to send your\n report privately via [email](mailto:security@gunicorn.org?subject=Security%20issue%20in%20Gunicorn), or via Github\n using the *Report a vulnerability* button in the [Security](https://github.com/benoitc/gunicorn/security) section.\n",
      "source_file": "SECURITY.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Supported Releases\n\nAt this time, **only the latest release** receives any security attention whatsoever.\n\nPlease target reports against :white_check_mark: or current master. Please understand that :x: will\n not receive further security attention.\n\n| Version | Status          |\n| ------- | ------------------ |\n| 23.0.0  | :white_check_mark: |\n| 22.0.0  | :x: |\n| 21.2.0  | :x: |\n| 20.0.0  | :x: |\n| < 20.0  | :x: |\n",
      "source_file": "SECURITY.md",
      "chunk_type": "doc"
    },
    {
      "content": "## Python Versions\n\nGunicorn runs on Python 3.7+, we *highly recommend* the latest release of a \n[supported series](https://devguide.python.org/versions/) and will not prioritize issues exclusively \naffecting in EoL environments.",
      "source_file": "SECURITY.md",
      "chunk_type": "doc"
    },
    {
      "content": "-r requirements_test.txt\n\n# setuptools v68.0 fails hard on invalid pyproject.toml\n# which a developer would want to know\n# otherwise, oldest known-working version is 61.2\nsetuptools>=68.0\n\nsphinx\nsphinx_rtd_theme\n",
      "source_file": "requirements_dev.txt",
      "chunk_type": "doc"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\nimport errno\nimport os\nimport tempfile\n\n",
      "start_line": 0,
      "end_line": 9,
      "source_file": "gunicorn/pidfile.py",
      "chunk_type": "code"
    },
    {
      "content": "class Pidfile:\n    \"\"\"\\\n    Manage a PID file. If a specific name is provided\n    it and '\"%s.oldpid\" % name' will be used. Otherwise\n    we create a temp file using os.mkstemp.\n    \"\"\"\n",
      "start_line": 9,
      "end_line": 16,
      "source_file": "gunicorn/pidfile.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, fname):\n        self.fname = fname\n        self.pid = None\n",
      "start_line": 16,
      "end_line": 20,
      "source_file": "gunicorn/pidfile.py",
      "chunk_type": "code"
    },
    {
      "content": "    def create(self, pid):\n        oldpid = self.validate()\n        if oldpid:\n            if oldpid == os.getpid():\n                return\n            msg = \"Already running on PID %s (or pid file '%s' is stale)\"\n            raise RuntimeError(msg % (oldpid, self.fname))\n\n        self.pid = pid\n\n        # Write pidfile\n        fdir = os.path.dirname(self.fname)\n        if fdir and not os.path.isdir(fdir):\n            raise RuntimeError(\"%s doesn't exist. Can't create pidfile.\" % fdir)\n        fd, fname = tempfile.mkstemp(dir=fdir)\n        os.write(fd, (\"%s\\n\" % self.pid).encode('utf-8'))\n        if self.fname:\n            os.rename(fname, self.fname)\n        else:\n            self.fname = fname\n        os.close(fd)\n\n        # set permissions to -rw-r--r--\n        os.chmod(self.fname, 420)\n",
      "start_line": 20,
      "end_line": 45,
      "source_file": "gunicorn/pidfile.py",
      "chunk_type": "code"
    },
    {
      "content": "    def rename(self, path):\n        self.unlink()\n        self.fname = path\n        self.create(self.pid)\n",
      "start_line": 45,
      "end_line": 50,
      "source_file": "gunicorn/pidfile.py",
      "chunk_type": "code"
    },
    {
      "content": "    def unlink(self):\n        \"\"\" delete pidfile\"\"\"\n        try:\n            with open(self.fname) as f:\n                pid1 = int(f.read() or 0)\n\n            if pid1 == self.pid:\n                os.unlink(self.fname)\n        except Exception:\n            pass\n",
      "start_line": 50,
      "end_line": 61,
      "source_file": "gunicorn/pidfile.py",
      "chunk_type": "code"
    },
    {
      "content": "    def validate(self):\n        \"\"\" Validate pidfile and make it stale if needed\"\"\"\n        if not self.fname:\n            return\n        try:\n            with open(self.fname) as f:\n                try:\n                    wpid = int(f.read())\n                except ValueError:\n                    return\n\n                try:\n                    os.kill(wpid, 0)\n                    return wpid\n                except OSError as e:\n                    if e.args[0] == errno.EPERM:\n                        return wpid\n                    if e.args[0] == errno.ESRCH:\n                        return\n                    raise\n        except OSError as e:\n            if e.args[0] == errno.ENOENT:\n                return\n            raise",
      "start_line": 61,
      "end_line": 85,
      "source_file": "gunicorn/pidfile.py",
      "chunk_type": "code"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n# pylint: disable=no-else-continue\n\nimport os\nimport os.path\nimport re\nimport sys\nimport time\nimport threading\n\nCOMPILED_EXT_RE = re.compile(r'py[co]$')\n\n",
      "start_line": 0,
      "end_line": 15,
      "source_file": "gunicorn/reloader.py",
      "chunk_type": "code"
    },
    {
      "content": "class Reloader(threading.Thread):",
      "start_line": 15,
      "end_line": 16,
      "source_file": "gunicorn/reloader.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, extra_files=None, interval=1, callback=None):\n        super().__init__()\n        self.daemon = True\n        self._extra_files = set(extra_files or ())\n        self._interval = interval\n        self._callback = callback\n",
      "start_line": 16,
      "end_line": 23,
      "source_file": "gunicorn/reloader.py",
      "chunk_type": "code"
    },
    {
      "content": "    def add_extra_file(self, filename):\n        self._extra_files.add(filename)\n",
      "start_line": 23,
      "end_line": 26,
      "source_file": "gunicorn/reloader.py",
      "chunk_type": "code"
    },
    {
      "content": "    def get_files(self):\n        fnames = [\n            COMPILED_EXT_RE.sub('py', module.__file__)\n            for module in tuple(sys.modules.values())\n            if getattr(module, '__file__', None)\n        ]\n\n        fnames.extend(self._extra_files)\n\n        return fnames\n",
      "start_line": 26,
      "end_line": 37,
      "source_file": "gunicorn/reloader.py",
      "chunk_type": "code"
    },
    {
      "content": "    def run(self):\n        mtimes = {}\n        while True:\n            for filename in self.get_files():\n                try:\n                    mtime = os.stat(filename).st_mtime\n                except OSError:\n                    continue\n                old_time = mtimes.get(filename)\n                if old_time is None:\n                    mtimes[filename] = mtime\n                    continue\n                elif mtime > old_time:\n                    if self._callback:\n                        self._callback(filename)\n            time.sleep(self._interval)\n\n\nhas_inotify = False\nif sys.platform.startswith('linux'):\n    try:\n        from inotify.adapters import Inotify\n        import inotify.constants\n        has_inotify = True\n    except ImportError:\n        pass\n\n\nif has_inotify:\n",
      "start_line": 37,
      "end_line": 67,
      "source_file": "gunicorn/reloader.py",
      "chunk_type": "code"
    },
    {
      "content": "    class InotifyReloader(threading.Thread):\n        event_mask = (inotify.constants.IN_CREATE | inotify.constants.IN_DELETE\n                      | inotify.constants.IN_DELETE_SELF | inotify.constants.IN_MODIFY\n                      | inotify.constants.IN_MOVE_SELF | inotify.constants.IN_MOVED_FROM\n                      | inotify.constants.IN_MOVED_TO)\n",
      "start_line": 67,
      "end_line": 73,
      "source_file": "gunicorn/reloader.py",
      "chunk_type": "code"
    },
    {
      "content": "        def __init__(self, extra_files=None, callback=None):\n            super().__init__()\n            self.daemon = True\n            self._callback = callback\n            self._dirs = set()\n            self._watcher = Inotify()\n\n            for extra_file in extra_files:\n                self.add_extra_file(extra_file)\n",
      "start_line": 73,
      "end_line": 83,
      "source_file": "gunicorn/reloader.py",
      "chunk_type": "code"
    },
    {
      "content": "        def add_extra_file(self, filename):\n            dirname = os.path.dirname(filename)\n\n            if dirname in self._dirs:\n                return\n\n            self._watcher.add_watch(dirname, mask=self.event_mask)\n            self._dirs.add(dirname)\n",
      "start_line": 83,
      "end_line": 92,
      "source_file": "gunicorn/reloader.py",
      "chunk_type": "code"
    },
    {
      "content": "        def get_dirs(self):\n            fnames = [\n                os.path.dirname(os.path.abspath(COMPILED_EXT_RE.sub('py', module.__file__)))\n                for module in tuple(sys.modules.values())\n                if getattr(module, '__file__', None)\n            ]\n\n            return set(fnames)\n",
      "start_line": 92,
      "end_line": 101,
      "source_file": "gunicorn/reloader.py",
      "chunk_type": "code"
    },
    {
      "content": "        def run(self):\n            self._dirs = self.get_dirs()\n\n            for dirname in self._dirs:\n                if os.path.isdir(dirname):\n                    self._watcher.add_watch(dirname, mask=self.event_mask)\n\n            for event in self._watcher.event_gen():\n                if event is None:\n                    continue\n\n                filename = event[3]\n\n                self._callback(filename)\n\nelse:\n",
      "start_line": 101,
      "end_line": 118,
      "source_file": "gunicorn/reloader.py",
      "chunk_type": "code"
    },
    {
      "content": "    class InotifyReloader:",
      "start_line": 118,
      "end_line": 119,
      "source_file": "gunicorn/reloader.py",
      "chunk_type": "code"
    },
    {
      "content": "        def __init__(self, extra_files=None, callback=None):\n            raise ImportError('You must have the inotify module installed to '\n                              'use the inotify reloader')\n\n\npreferred_reloader = InotifyReloader if has_inotify else Reloader\n\nreloader_engines = {\n    'auto': preferred_reloader,\n    'poll': Reloader,\n    'inotify': InotifyReloader,\n}",
      "start_line": 119,
      "end_line": 131,
      "source_file": "gunicorn/reloader.py",
      "chunk_type": "code"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\n# Please remember to run \"make -C docs html\" after update \"desc\" attributes.\n\nimport argparse\nimport copy\nimport grp\nimport inspect\nimport ipaddress\nimport os\nimport pwd\nimport re\nimport shlex\nimport ssl\nimport sys\nimport textwrap\n\nfrom gunicorn import __version__, util\nfrom gunicorn.errors import ConfigError\nfrom gunicorn.reloader import reloader_engines\n\nKNOWN_SETTINGS = []\nPLATFORM = sys.platform\n\n",
      "start_line": 0,
      "end_line": 27,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "def make_settings(ignore=None):\n    settings = {}\n    ignore = ignore or ()\n    for s in KNOWN_SETTINGS:\n        setting = s()\n        if setting.name in ignore:\n            continue\n        settings[setting.name] = setting.copy()\n    return settings\n\n",
      "start_line": 27,
      "end_line": 38,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "def auto_int(_, x):\n    # for compatible with octal numbers in python3\n    if re.match(r'0(\\d)', x, re.IGNORECASE):\n        x = x.replace('0', '0o', 1)\n    return int(x, 0)\n\n",
      "start_line": 38,
      "end_line": 45,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class Config:\n",
      "start_line": 45,
      "end_line": 47,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, usage=None, prog=None):\n        self.settings = make_settings()\n        self.usage = usage\n        self.prog = prog or os.path.basename(sys.argv[0])\n        self.env_orig = os.environ.copy()\n",
      "start_line": 47,
      "end_line": 53,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __str__(self):\n        lines = []\n        kmax = max(len(k) for k in self.settings)\n        for k in sorted(self.settings):\n            v = self.settings[k].value\n            if callable(v):\n                v = \"<{}()>\".format(v.__qualname__)\n            lines.append(\"{k:{kmax}} = {v}\".format(k=k, v=v, kmax=kmax))\n        return \"\\n\".join(lines)\n",
      "start_line": 53,
      "end_line": 63,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __getattr__(self, name):\n        if name not in self.settings:\n            raise AttributeError(\"No configuration setting for: %s\" % name)\n        return self.settings[name].get()\n",
      "start_line": 63,
      "end_line": 68,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __setattr__(self, name, value):\n        if name != \"settings\" and name in self.settings:\n            raise AttributeError(\"Invalid access!\")\n        super().__setattr__(name, value)\n",
      "start_line": 68,
      "end_line": 73,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def set(self, name, value):\n        if name not in self.settings:\n            raise AttributeError(\"No configuration setting for: %s\" % name)\n        self.settings[name].set(value)\n",
      "start_line": 73,
      "end_line": 78,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def get_cmd_args_from_env(self):\n        if 'GUNICORN_CMD_ARGS' in self.env_orig:\n            return shlex.split(self.env_orig['GUNICORN_CMD_ARGS'])\n        return []\n",
      "start_line": 78,
      "end_line": 83,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def parser(self):\n        kwargs = {\n            \"usage\": self.usage,\n            \"prog\": self.prog\n        }\n        parser = argparse.ArgumentParser(**kwargs)\n        parser.add_argument(\"-v\", \"--version\",\n                            action=\"version\", default=argparse.SUPPRESS,\n                            version=\"%(prog)s (version \" + __version__ + \")\\n\",\n                            help=\"show program's version number and exit\")\n        parser.add_argument(\"args\", nargs=\"*\", help=argparse.SUPPRESS)\n\n        keys = sorted(self.settings, key=self.settings.__getitem__)\n        for k in keys:\n            self.settings[k].add_option(parser)\n\n        return parser\n\n    @property",
      "start_line": 83,
      "end_line": 102,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def worker_class_str(self):\n        uri = self.settings['worker_class'].get()\n\n        if isinstance(uri, str):\n            # are we using a threaded worker?\n            is_sync = uri.endswith('SyncWorker') or uri == 'sync'\n            if is_sync and self.threads > 1:\n                return \"gthread\"\n            return uri\n        return uri.__name__\n\n    @property",
      "start_line": 102,
      "end_line": 114,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def worker_class(self):\n        uri = self.settings['worker_class'].get()\n\n        # are we using a threaded worker?\n        is_sync = isinstance(uri, str) and (uri.endswith('SyncWorker') or uri == 'sync')\n        if is_sync and self.threads > 1:\n            uri = \"gunicorn.workers.gthread.ThreadWorker\"\n\n        worker_class = util.load_class(uri)\n        if hasattr(worker_class, \"setup\"):\n            worker_class.setup()\n        return worker_class\n\n    @property",
      "start_line": 114,
      "end_line": 128,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def address(self):\n        s = self.settings['bind'].get()\n        return [util.parse_address(util.bytes_to_str(bind)) for bind in s]\n\n    @property",
      "start_line": 128,
      "end_line": 133,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def uid(self):\n        return self.settings['user'].get()\n\n    @property",
      "start_line": 133,
      "end_line": 137,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def gid(self):\n        return self.settings['group'].get()\n\n    @property",
      "start_line": 137,
      "end_line": 141,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def proc_name(self):\n        pn = self.settings['proc_name'].get()\n        if pn is not None:\n            return pn\n        else:\n            return self.settings['default_proc_name'].get()\n\n    @property",
      "start_line": 141,
      "end_line": 149,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def logger_class(self):\n        uri = self.settings['logger_class'].get()\n        if uri == \"simple\":\n            # support the default\n            uri = LoggerClass.default\n\n        # if default logger is in use, and statsd is on, automagically switch\n        # to the statsd logger\n        if uri == LoggerClass.default:\n            if 'statsd_host' in self.settings and self.settings['statsd_host'].value is not None:\n                uri = \"gunicorn.instrument.statsd.Statsd\"\n\n        logger_class = util.load_class(\n            uri,\n            default=\"gunicorn.glogging.Logger\",\n            section=\"gunicorn.loggers\")\n\n        if hasattr(logger_class, \"install\"):\n            logger_class.install()\n        return logger_class\n\n    @property",
      "start_line": 149,
      "end_line": 171,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def is_ssl(self):\n        return self.certfile or self.keyfile\n\n    @property",
      "start_line": 171,
      "end_line": 175,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def ssl_options(self):\n        opts = {}\n        for name, value in self.settings.items():\n            if value.section == 'SSL':\n                opts[name] = value.get()\n        return opts\n\n    @property",
      "start_line": 175,
      "end_line": 183,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def env(self):\n        raw_env = self.settings['raw_env'].get()\n        env = {}\n\n        if not raw_env:\n            return env\n\n        for e in raw_env:\n            s = util.bytes_to_str(e)\n            try:\n                k, v = s.split('=', 1)\n            except ValueError:\n                raise RuntimeError(\"environment setting %r invalid\" % s)\n\n            env[k] = v\n\n        return env\n\n    @property",
      "start_line": 183,
      "end_line": 202,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def sendfile(self):\n        if self.settings['sendfile'].get() is not None:\n            return False\n\n        if 'SENDFILE' in os.environ:\n            sendfile = os.environ['SENDFILE'].lower()\n            return sendfile in ['y', '1', 'yes', 'true']\n\n        return True\n\n    @property",
      "start_line": 202,
      "end_line": 213,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def reuse_port(self):\n        return self.settings['reuse_port'].get()\n\n    @property",
      "start_line": 213,
      "end_line": 217,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def paste_global_conf(self):\n        raw_global_conf = self.settings['raw_paste_global_conf'].get()\n        if raw_global_conf is None:\n            return None\n\n        global_conf = {}\n        for e in raw_global_conf:\n            s = util.bytes_to_str(e)\n            try:\n                k, v = re.split(r'(?<!\\\\)=', s, 1)\n            except ValueError:\n                raise RuntimeError(\"environment setting %r invalid\" % s)\n            k = k.replace('\\\\=', '=')\n            v = v.replace('\\\\=', '=')\n            global_conf[k] = v\n\n        return global_conf\n\n",
      "start_line": 217,
      "end_line": 236,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class SettingMeta(type):",
      "start_line": 236,
      "end_line": 237,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __new__(cls, name, bases, attrs):\n        super_new = super().__new__\n        parents = [b for b in bases if isinstance(b, SettingMeta)]\n        if not parents:\n            return super_new(cls, name, bases, attrs)\n\n        attrs[\"order\"] = len(KNOWN_SETTINGS)\n        attrs[\"validator\"] = staticmethod(attrs[\"validator\"])\n\n        new_class = super_new(cls, name, bases, attrs)\n        new_class.fmt_desc(attrs.get(\"desc\", \"\"))\n        KNOWN_SETTINGS.append(new_class)\n        return new_class\n",
      "start_line": 237,
      "end_line": 251,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def fmt_desc(cls, desc):\n        desc = textwrap.dedent(desc).strip()\n        setattr(cls, \"desc\", desc)\n        setattr(cls, \"short\", desc.splitlines()[0])\n\n",
      "start_line": 251,
      "end_line": 257,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class Setting:\n    name = None\n    value = None\n    section = None\n    cli = None\n    validator = None\n    type = None\n    meta = None\n    action = None\n    default = None\n    short = None\n    desc = None\n    nargs = None\n    const = None\n",
      "start_line": 257,
      "end_line": 272,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self):\n        if self.default is not None:\n            self.set(self.default)\n",
      "start_line": 272,
      "end_line": 276,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def add_option(self, parser):\n        if not self.cli:\n            return\n        args = tuple(self.cli)\n\n        help_txt = \"%s [%s]\" % (self.short, self.default)\n        help_txt = help_txt.replace(\"%\", \"%%\")\n\n        kwargs = {\n            \"dest\": self.name,\n            \"action\": self.action or \"store\",\n            \"type\": self.type or str,\n            \"default\": None,\n            \"help\": help_txt\n        }\n\n        if self.meta is not None:\n            kwargs['metavar'] = self.meta\n\n        if kwargs[\"action\"] != \"store\":\n            kwargs.pop(\"type\")\n\n        if self.nargs is not None:\n            kwargs[\"nargs\"] = self.nargs\n\n        if self.const is not None:\n            kwargs[\"const\"] = self.const\n\n        parser.add_argument(*args, **kwargs)\n",
      "start_line": 276,
      "end_line": 306,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def copy(self):\n        return copy.copy(self)\n",
      "start_line": 306,
      "end_line": 309,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def get(self):\n        return self.value\n",
      "start_line": 309,
      "end_line": 312,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def set(self, val):\n        if not callable(self.validator):\n            raise TypeError('Invalid validator: %s' % self.name)\n        self.value = self.validator(val)\n",
      "start_line": 312,
      "end_line": 317,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __lt__(self, other):\n        return (self.section == other.section and\n                self.order < other.order)\n    __cmp__ = __lt__\n",
      "start_line": 317,
      "end_line": 322,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __repr__(self):\n        return \"<%s.%s object at %x with value %r>\" % (\n            self.__class__.__module__,\n            self.__class__.__name__,\n            id(self),\n            self.value,\n        )\n\n\nSetting = SettingMeta('Setting', (Setting,), {})\n\n",
      "start_line": 322,
      "end_line": 334,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "def validate_bool(val):\n    if val is None:\n        return\n\n    if isinstance(val, bool):\n        return val\n    if not isinstance(val, str):\n        raise TypeError(\"Invalid type for casting: %s\" % val)\n    if val.lower().strip() == \"true\":\n        return True\n    elif val.lower().strip() == \"false\":\n        return False\n    else:\n        raise ValueError(\"Invalid boolean: %s\" % val)\n\n",
      "start_line": 334,
      "end_line": 350,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "def validate_dict(val):\n    if not isinstance(val, dict):\n        raise TypeError(\"Value is not a dictionary: %s \" % val)\n    return val\n\n",
      "start_line": 350,
      "end_line": 356,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "def validate_pos_int(val):\n    if not isinstance(val, int):\n        val = int(val, 0)\n    else:\n        # Booleans are ints!\n        val = int(val)\n    if val < 0:\n        raise ValueError(\"Value must be positive: %s\" % val)\n    return val\n\n",
      "start_line": 356,
      "end_line": 367,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "def validate_ssl_version(val):\n    if val != SSLVersion.default:\n        sys.stderr.write(\"Warning: option `ssl_version` is deprecated and it is ignored. Use ssl_context instead.\\n\")\n    return val\n\n",
      "start_line": 367,
      "end_line": 373,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "def validate_string(val):\n    if val is None:\n        return None\n    if not isinstance(val, str):\n        raise TypeError(\"Not a string: %s\" % val)\n    return val.strip()\n\n",
      "start_line": 373,
      "end_line": 381,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "def validate_file_exists(val):\n    if val is None:\n        return None\n    if not os.path.exists(val):\n        raise ValueError(\"File %s does not exists.\" % val)\n    return val\n\n",
      "start_line": 381,
      "end_line": 389,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "def validate_list_string(val):\n    if not val:\n        return []\n\n    # legacy syntax\n    if isinstance(val, str):\n        val = [val]\n\n    return [validate_string(v) for v in val]\n\n",
      "start_line": 389,
      "end_line": 400,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "def validate_list_of_existing_files(val):\n    return [validate_file_exists(v) for v in validate_list_string(val)]\n\n",
      "start_line": 400,
      "end_line": 404,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "def validate_string_to_addr_list(val):\n    val = validate_string_to_list(val)\n\n    for addr in val:\n        if addr == \"*\":\n            continue\n        _vaid_ip = ipaddress.ip_address(addr)\n\n    return val\n\n",
      "start_line": 404,
      "end_line": 415,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "def validate_string_to_list(val):\n    val = validate_string(val)\n\n    if not val:\n        return []\n\n    return [v.strip() for v in val.split(\",\") if v]\n\n",
      "start_line": 415,
      "end_line": 424,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "def validate_class(val):\n    if inspect.isfunction(val) or inspect.ismethod(val):\n        val = val()\n    if inspect.isclass(val):\n        return val\n    return validate_string(val)\n\n",
      "start_line": 424,
      "end_line": 432,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "def validate_callable(arity):",
      "start_line": 432,
      "end_line": 433,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def _validate_callable(val):\n        if isinstance(val, str):\n            try:\n                mod_name, obj_name = val.rsplit(\".\", 1)\n            except ValueError:\n                raise TypeError(\"Value '%s' is not import string. \"\n                                \"Format: module[.submodules...].object\" % val)\n            try:\n                mod = __import__(mod_name, fromlist=[obj_name])\n                val = getattr(mod, obj_name)\n            except ImportError as e:\n                raise TypeError(str(e))\n            except AttributeError:\n                raise TypeError(\"Can not load '%s' from '%s'\"\n                                \"\" % (obj_name, mod_name))\n        if not callable(val):\n            raise TypeError(\"Value is not callable: %s\" % val)\n        if arity != -1 and arity != util.get_arity(val):\n            raise TypeError(\"Value must have an arity of: %s\" % arity)\n        return val\n    return _validate_callable\n\n",
      "start_line": 433,
      "end_line": 456,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "def validate_user(val):\n    if val is None:\n        return os.geteuid()\n    if isinstance(val, int):\n        return val\n    elif val.isdigit():\n        return int(val)\n    else:\n        try:\n            return pwd.getpwnam(val).pw_uid\n        except KeyError:\n            raise ConfigError(\"No such user: '%s'\" % val)\n\n",
      "start_line": 456,
      "end_line": 470,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "def validate_group(val):\n    if val is None:\n        return os.getegid()\n\n    if isinstance(val, int):\n        return val\n    elif val.isdigit():\n        return int(val)\n    else:\n        try:\n            return grp.getgrnam(val).gr_gid\n        except KeyError:\n            raise ConfigError(\"No such group: '%s'\" % val)\n\n",
      "start_line": 470,
      "end_line": 485,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "def validate_post_request(val):\n    val = validate_callable(-1)(val)\n\n    largs = util.get_arity(val)\n    if largs == 4:\n        return val\n    elif largs == 3:\n        return lambda worker, req, env, _r: val(worker, req, env)\n    elif largs == 2:\n        return lambda worker, req, _e, _r: val(worker, req)\n    else:\n        raise TypeError(\"Value must have an arity of: 4\")\n\n",
      "start_line": 485,
      "end_line": 499,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "def validate_chdir(val):\n    # valid if the value is a string\n    val = validate_string(val)\n\n    # transform relative paths\n    path = os.path.abspath(os.path.normpath(os.path.join(util.getcwd(), val)))\n\n    # test if the path exists\n    if not os.path.exists(path):\n        raise ConfigError(\"can't chdir to %r\" % val)\n\n    return path\n\n",
      "start_line": 499,
      "end_line": 513,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "def validate_statsd_address(val):\n    val = validate_string(val)\n    if val is None:\n        return None\n\n    # As of major release 20, util.parse_address would recognize unix:PORT\n    # as a UDS address, breaking backwards compatibility. We defend against\n    # that regression here (this is also unit-tested).\n    # Feel free to remove in the next major release.\n    unix_hostname_regression = re.match(r'^unix:(\\d+)$', val)\n    if unix_hostname_regression:\n        return ('unix', int(unix_hostname_regression.group(1)))\n\n    try:\n        address = util.parse_address(val, default_port='8125')\n    except RuntimeError:\n        raise TypeError(\"Value must be one of ('host:port', 'unix://PATH')\")\n\n    return address\n\n",
      "start_line": 513,
      "end_line": 534,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "def validate_reload_engine(val):\n    if val not in reloader_engines:\n        raise ConfigError(\"Invalid reload_engine: %r\" % val)\n\n    return val\n\n",
      "start_line": 534,
      "end_line": 541,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "def get_default_config_file():\n    config_path = os.path.join(os.path.abspath(os.getcwd()),\n                               'gunicorn.conf.py')\n    if os.path.exists(config_path):\n        return config_path\n    return None\n\n",
      "start_line": 541,
      "end_line": 549,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class ConfigFile(Setting):\n    name = \"config\"\n    section = \"Config File\"\n    cli = [\"-c\", \"--config\"]\n    meta = \"CONFIG\"\n    validator = validate_string\n    default = \"./gunicorn.conf.py\"\n    desc = \"\"\"\\\n        :ref:`The Gunicorn config file<configuration_file>`.\n\n        A string of the form ``PATH``, ``file:PATH``, or ``python:MODULE_NAME``.\n\n        Only has an effect when specified on the command line or as part of an\n        application specific configuration.\n\n        By default, a file named ``gunicorn.conf.py`` will be read from the same\n        directory where gunicorn is being run.\n\n        .. versionchanged:: 19.4\n           Loading the config from a Python module requires the ``python:``\n           prefix.\n        \"\"\"\n\n",
      "start_line": 549,
      "end_line": 573,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class WSGIApp(Setting):\n    name = \"wsgi_app\"\n    section = \"Config File\"\n    meta = \"STRING\"\n    validator = validate_string\n    default = None\n    desc = \"\"\"\\\n        A WSGI application path in pattern ``$(MODULE_NAME):$(VARIABLE_NAME)``.\n\n        .. versionadded:: 20.1.0\n        \"\"\"\n\n",
      "start_line": 573,
      "end_line": 586,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class Bind(Setting):\n    name = \"bind\"\n    action = \"append\"\n    section = \"Server Socket\"\n    cli = [\"-b\", \"--bind\"]\n    meta = \"ADDRESS\"\n    validator = validate_list_string\n\n    if 'PORT' in os.environ:\n        default = ['0.0.0.0:{0}'.format(os.environ.get('PORT'))]\n    else:\n        default = ['127.0.0.1:8000']\n\n    desc = \"\"\"\\\n        The socket to bind.\n\n        A string of the form: ``HOST``, ``HOST:PORT``, ``unix:PATH``,\n        ``fd://FD``. An IP is a valid ``HOST``.\n\n        .. versionchanged:: 20.0\n           Support for ``fd://FD`` got added.\n\n        Multiple addresses can be bound. ex.::\n\n            $ gunicorn -b 127.0.0.1:8000 -b [::1]:8000 test:app\n\n        will bind the `test:app` application on localhost both on ipv6\n        and ipv4 interfaces.\n\n        If the ``PORT`` environment variable is defined, the default\n        is ``['0.0.0.0:$PORT']``. If it is not defined, the default\n        is ``['127.0.0.1:8000']``.\n        \"\"\"\n\n",
      "start_line": 586,
      "end_line": 621,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class Backlog(Setting):\n    name = \"backlog\"\n    section = \"Server Socket\"\n    cli = [\"--backlog\"]\n    meta = \"INT\"\n    validator = validate_pos_int\n    type = int\n    default = 2048\n    desc = \"\"\"\\\n        The maximum number of pending connections.\n\n        This refers to the number of clients that can be waiting to be served.\n        Exceeding this number results in the client getting an error when\n        attempting to connect. It should only affect servers under significant\n        load.\n\n        Must be a positive integer. Generally set in the 64-2048 range.\n        \"\"\"\n\n",
      "start_line": 621,
      "end_line": 641,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class Workers(Setting):\n    name = \"workers\"\n    section = \"Worker Processes\"\n    cli = [\"-w\", \"--workers\"]\n    meta = \"INT\"\n    validator = validate_pos_int\n    type = int\n    default = int(os.environ.get(\"WEB_CONCURRENCY\", 1))\n    desc = \"\"\"\\\n        The number of worker processes for handling requests.\n\n        A positive integer generally in the ``2-4 x $(NUM_CORES)`` range.\n        You'll want to vary this a bit to find the best for your particular\n        application's work load.\n\n        By default, the value of the ``WEB_CONCURRENCY`` environment variable,\n        which is set by some Platform-as-a-Service providers such as Heroku. If\n        it is not defined, the default is ``1``.\n        \"\"\"\n\n",
      "start_line": 641,
      "end_line": 662,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class WorkerClass(Setting):\n    name = \"worker_class\"\n    section = \"Worker Processes\"\n    cli = [\"-k\", \"--worker-class\"]\n    meta = \"STRING\"\n    validator = validate_class\n    default = \"sync\"\n    desc = \"\"\"\\\n        The type of workers to use.\n\n        The default class (``sync``) should handle most \"normal\" types of\n        workloads. You'll want to read :doc:`design` for information on when\n        you might want to choose one of the other worker classes. Required\n        libraries may be installed using setuptools' ``extras_require`` feature.\n\n        A string referring to one of the following bundled classes:\n\n        * ``sync``\n        * ``eventlet`` - Requires eventlet >= 0.24.1 (or install it via\n          ``pip install gunicorn[eventlet]``)\n        * ``gevent``   - Requires gevent >= 1.4 (or install it via\n          ``pip install gunicorn[gevent]``)\n        * ``tornado``  - Requires tornado >= 0.2 (or install it via\n          ``pip install gunicorn[tornado]``)\n        * ``gthread``  - Python 2 requires the futures package to be installed\n          (or install it via ``pip install gunicorn[gthread]``)\n\n        Optionally, you can provide your own worker by giving Gunicorn a\n        Python path to a subclass of ``gunicorn.workers.base.Worker``.\n        This alternative syntax will load the gevent class:\n        ``gunicorn.workers.ggevent.GeventWorker``.\n        \"\"\"\n\n",
      "start_line": 662,
      "end_line": 696,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class WorkerThreads(Setting):\n    name = \"threads\"\n    section = \"Worker Processes\"\n    cli = [\"--threads\"]\n    meta = \"INT\"\n    validator = validate_pos_int\n    type = int\n    default = 1\n    desc = \"\"\"\\\n        The number of worker threads for handling requests.\n\n        Run each worker with the specified number of threads.\n\n        A positive integer generally in the ``2-4 x $(NUM_CORES)`` range.\n        You'll want to vary this a bit to find the best for your particular\n        application's work load.\n\n        If it is not defined, the default is ``1``.\n\n        This setting only affects the Gthread worker type.\n\n        .. note::\n           If you try to use the ``sync`` worker type and set the ``threads``\n           setting to more than 1, the ``gthread`` worker type will be used\n           instead.\n        \"\"\"\n\n",
      "start_line": 696,
      "end_line": 724,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class WorkerConnections(Setting):\n    name = \"worker_connections\"\n    section = \"Worker Processes\"\n    cli = [\"--worker-connections\"]\n    meta = \"INT\"\n    validator = validate_pos_int\n    type = int\n    default = 1000\n    desc = \"\"\"\\\n        The maximum number of simultaneous clients.\n\n        This setting only affects the ``gthread``, ``eventlet`` and ``gevent`` worker types.\n        \"\"\"\n\n",
      "start_line": 724,
      "end_line": 739,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class MaxRequests(Setting):\n    name = \"max_requests\"\n    section = \"Worker Processes\"\n    cli = [\"--max-requests\"]\n    meta = \"INT\"\n    validator = validate_pos_int\n    type = int\n    default = 0\n    desc = \"\"\"\\\n        The maximum number of requests a worker will process before restarting.\n\n        Any value greater than zero will limit the number of requests a worker\n        will process before automatically restarting. This is a simple method\n        to help limit the damage of memory leaks.\n\n        If this is set to zero (the default) then the automatic worker\n        restarts are disabled.\n        \"\"\"\n\n",
      "start_line": 739,
      "end_line": 759,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class MaxRequestsJitter(Setting):\n    name = \"max_requests_jitter\"\n    section = \"Worker Processes\"\n    cli = [\"--max-requests-jitter\"]\n    meta = \"INT\"\n    validator = validate_pos_int\n    type = int\n    default = 0\n    desc = \"\"\"\\\n        The maximum jitter to add to the *max_requests* setting.\n\n        The jitter causes the restart per worker to be randomized by\n        ``randint(0, max_requests_jitter)``. This is intended to stagger worker\n        restarts to avoid all workers restarting at the same time.\n\n        .. versionadded:: 19.2\n        \"\"\"\n\n",
      "start_line": 759,
      "end_line": 778,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class Timeout(Setting):\n    name = \"timeout\"\n    section = \"Worker Processes\"\n    cli = [\"-t\", \"--timeout\"]\n    meta = \"INT\"\n    validator = validate_pos_int\n    type = int\n    default = 30\n    desc = \"\"\"\\\n        Workers silent for more than this many seconds are killed and restarted.\n\n        Value is a positive number or 0. Setting it to 0 has the effect of\n        infinite timeouts by disabling timeouts for all workers entirely.\n\n        Generally, the default of thirty seconds should suffice. Only set this\n        noticeably higher if you're sure of the repercussions for sync workers.\n        For the non sync workers it just means that the worker process is still\n        communicating and is not tied to the length of time required to handle a\n        single request.\n        \"\"\"\n\n",
      "start_line": 778,
      "end_line": 800,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class GracefulTimeout(Setting):\n    name = \"graceful_timeout\"\n    section = \"Worker Processes\"\n    cli = [\"--graceful-timeout\"]\n    meta = \"INT\"\n    validator = validate_pos_int\n    type = int\n    default = 30\n    desc = \"\"\"\\\n        Timeout for graceful workers restart.\n\n        After receiving a restart signal, workers have this much time to finish\n        serving requests. Workers still alive after the timeout (starting from\n        the receipt of the restart signal) are force killed.\n        \"\"\"\n\n",
      "start_line": 800,
      "end_line": 817,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class Keepalive(Setting):\n    name = \"keepalive\"\n    section = \"Worker Processes\"\n    cli = [\"--keep-alive\"]\n    meta = \"INT\"\n    validator = validate_pos_int\n    type = int\n    default = 2\n    desc = \"\"\"\\\n        The number of seconds to wait for requests on a Keep-Alive connection.\n\n        Generally set in the 1-5 seconds range for servers with direct connection\n        to the client (e.g. when you don't have separate load balancer). When\n        Gunicorn is deployed behind a load balancer, it often makes sense to\n        set this to a higher value.\n\n        .. note::\n           ``sync`` worker does not support persistent connections and will\n           ignore this option.\n        \"\"\"\n\n",
      "start_line": 817,
      "end_line": 839,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class LimitRequestLine(Setting):\n    name = \"limit_request_line\"\n    section = \"Security\"\n    cli = [\"--limit-request-line\"]\n    meta = \"INT\"\n    validator = validate_pos_int\n    type = int\n    default = 4094\n    desc = \"\"\"\\\n        The maximum size of HTTP request line in bytes.\n\n        This parameter is used to limit the allowed size of a client's\n        HTTP request-line. Since the request-line consists of the HTTP\n        method, URI, and protocol version, this directive places a\n        restriction on the length of a request-URI allowed for a request\n        on the server. A server needs this value to be large enough to\n        hold any of its resource names, including any information that\n        might be passed in the query part of a GET request. Value is a number\n        from 0 (unlimited) to 8190.\n\n        This parameter can be used to prevent any DDOS attack.\n        \"\"\"\n\n",
      "start_line": 839,
      "end_line": 863,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class LimitRequestFields(Setting):\n    name = \"limit_request_fields\"\n    section = \"Security\"\n    cli = [\"--limit-request-fields\"]\n    meta = \"INT\"\n    validator = validate_pos_int\n    type = int\n    default = 100\n    desc = \"\"\"\\\n        Limit the number of HTTP headers fields in a request.\n\n        This parameter is used to limit the number of headers in a request to\n        prevent DDOS attack. Used with the *limit_request_field_size* it allows\n        more safety. By default this value is 100 and can't be larger than\n        32768.\n        \"\"\"\n\n",
      "start_line": 863,
      "end_line": 881,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class LimitRequestFieldSize(Setting):\n    name = \"limit_request_field_size\"\n    section = \"Security\"\n    cli = [\"--limit-request-field_size\"]\n    meta = \"INT\"\n    validator = validate_pos_int\n    type = int\n    default = 8190\n    desc = \"\"\"\\\n        Limit the allowed size of an HTTP request header field.\n\n        Value is a positive number or 0. Setting it to 0 will allow unlimited\n        header field sizes.\n\n        .. warning::\n           Setting this parameter to a very high or unlimited value can open\n           up for DDOS attacks.\n        \"\"\"\n\n",
      "start_line": 881,
      "end_line": 901,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class Reload(Setting):\n    name = \"reload\"\n    section = 'Debugging'\n    cli = ['--reload']\n    validator = validate_bool\n    action = 'store_true'\n    default = False\n\n    desc = '''\\\n        Restart workers when code changes.\n\n        This setting is intended for development. It will cause workers to be\n        restarted whenever application code changes.\n\n        The reloader is incompatible with application preloading. When using a\n        paste configuration be sure that the server block does not import any\n        application code or the reload will not work as designed.\n\n        The default behavior is to attempt inotify with a fallback to file\n        system polling. Generally, inotify should be preferred if available\n        because it consumes less system resources.\n\n        .. note::\n           In order to use the inotify reloader, you must have the ``inotify``\n           package installed.\n        '''\n\n",
      "start_line": 901,
      "end_line": 929,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class ReloadEngine(Setting):\n    name = \"reload_engine\"\n    section = \"Debugging\"\n    cli = [\"--reload-engine\"]\n    meta = \"STRING\"\n    validator = validate_reload_engine\n    default = \"auto\"\n    desc = \"\"\"\\\n        The implementation that should be used to power :ref:`reload`.\n\n        Valid engines are:\n\n        * ``'auto'``\n        * ``'poll'``\n        * ``'inotify'`` (requires inotify)\n\n        .. versionadded:: 19.7\n        \"\"\"\n\n",
      "start_line": 929,
      "end_line": 949,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class ReloadExtraFiles(Setting):\n    name = \"reload_extra_files\"\n    action = \"append\"\n    section = \"Debugging\"\n    cli = [\"--reload-extra-file\"]\n    meta = \"FILES\"\n    validator = validate_list_of_existing_files\n    default = []\n    desc = \"\"\"\\\n        Extends :ref:`reload` option to also watch and reload on additional files\n        (e.g., templates, configurations, specifications, etc.).\n\n        .. versionadded:: 19.8\n        \"\"\"\n\n",
      "start_line": 949,
      "end_line": 965,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class Spew(Setting):\n    name = \"spew\"\n    section = \"Debugging\"\n    cli = [\"--spew\"]\n    validator = validate_bool\n    action = \"store_true\"\n    default = False\n    desc = \"\"\"\\\n        Install a trace function that spews every line executed by the server.\n\n        This is the nuclear option.\n        \"\"\"\n\n",
      "start_line": 965,
      "end_line": 979,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class ConfigCheck(Setting):\n    name = \"check_config\"\n    section = \"Debugging\"\n    cli = [\"--check-config\"]\n    validator = validate_bool\n    action = \"store_true\"\n    default = False\n    desc = \"\"\"\\\n        Check the configuration and exit. The exit status is 0 if the\n        configuration is correct, and 1 if the configuration is incorrect.\n        \"\"\"\n\n",
      "start_line": 979,
      "end_line": 992,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class PrintConfig(Setting):\n    name = \"print_config\"\n    section = \"Debugging\"\n    cli = [\"--print-config\"]\n    validator = validate_bool\n    action = \"store_true\"\n    default = False\n    desc = \"\"\"\\\n        Print the configuration settings as fully resolved. Implies :ref:`check-config`.\n        \"\"\"\n\n",
      "start_line": 992,
      "end_line": 1004,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class PreloadApp(Setting):\n    name = \"preload_app\"\n    section = \"Server Mechanics\"\n    cli = [\"--preload\"]\n    validator = validate_bool\n    action = \"store_true\"\n    default = False\n    desc = \"\"\"\\\n        Load application code before the worker processes are forked.\n\n        By preloading an application you can save some RAM resources as well as\n        speed up server boot times. Although, if you defer application loading\n        to each worker process, you can reload your application code easily by\n        restarting workers.\n        \"\"\"\n\n",
      "start_line": 1004,
      "end_line": 1021,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class Sendfile(Setting):\n    name = \"sendfile\"\n    section = \"Server Mechanics\"\n    cli = [\"--no-sendfile\"]\n    validator = validate_bool\n    action = \"store_const\"\n    const = False\n\n    desc = \"\"\"\\\n        Disables the use of ``sendfile()``.\n\n        If not set, the value of the ``SENDFILE`` environment variable is used\n        to enable or disable its usage.\n\n        .. versionadded:: 19.2\n        .. versionchanged:: 19.4\n           Swapped ``--sendfile`` with ``--no-sendfile`` to actually allow\n           disabling.\n        .. versionchanged:: 19.6\n           added support for the ``SENDFILE`` environment variable\n        \"\"\"\n\n",
      "start_line": 1021,
      "end_line": 1044,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class ReusePort(Setting):\n    name = \"reuse_port\"\n    section = \"Server Mechanics\"\n    cli = [\"--reuse-port\"]\n    validator = validate_bool\n    action = \"store_true\"\n    default = False\n\n    desc = \"\"\"\\\n        Set the ``SO_REUSEPORT`` flag on the listening socket.\n\n        .. versionadded:: 19.8\n        \"\"\"\n\n",
      "start_line": 1044,
      "end_line": 1059,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class Chdir(Setting):\n    name = \"chdir\"\n    section = \"Server Mechanics\"\n    cli = [\"--chdir\"]\n    validator = validate_chdir\n    default = util.getcwd()\n    default_doc = \"``'.'``\"\n    desc = \"\"\"\\\n        Change directory to specified directory before loading apps.\n        \"\"\"\n\n",
      "start_line": 1059,
      "end_line": 1071,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class Daemon(Setting):\n    name = \"daemon\"\n    section = \"Server Mechanics\"\n    cli = [\"-D\", \"--daemon\"]\n    validator = validate_bool\n    action = \"store_true\"\n    default = False\n    desc = \"\"\"\\\n        Daemonize the Gunicorn process.\n\n        Detaches the server from the controlling terminal and enters the\n        background.\n        \"\"\"\n\n",
      "start_line": 1071,
      "end_line": 1086,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class Env(Setting):\n    name = \"raw_env\"\n    action = \"append\"\n    section = \"Server Mechanics\"\n    cli = [\"-e\", \"--env\"]\n    meta = \"ENV\"\n    validator = validate_list_string\n    default = []\n\n    desc = \"\"\"\\\n        Set environment variables in the execution environment.\n\n        Should be a list of strings in the ``key=value`` format.\n\n        For example on the command line:\n\n        .. code-block:: console\n\n            $ gunicorn -b 127.0.0.1:8000 --env FOO=1 test:app\n\n        Or in the configuration file:\n\n        .. code-block:: python\n\n            raw_env = [\"FOO=1\"]\n        \"\"\"\n\n",
      "start_line": 1086,
      "end_line": 1114,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class Pidfile(Setting):\n    name = \"pidfile\"\n    section = \"Server Mechanics\"\n    cli = [\"-p\", \"--pid\"]\n    meta = \"FILE\"\n    validator = validate_string\n    default = None\n    desc = \"\"\"\\\n        A filename to use for the PID file.\n\n        If not set, no PID file will be written.\n        \"\"\"\n\n",
      "start_line": 1114,
      "end_line": 1128,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class WorkerTmpDir(Setting):\n    name = \"worker_tmp_dir\"\n    section = \"Server Mechanics\"\n    cli = [\"--worker-tmp-dir\"]\n    meta = \"DIR\"\n    validator = validate_string\n    default = None\n    desc = \"\"\"\\\n        A directory to use for the worker heartbeat temporary file.\n\n        If not set, the default temporary directory will be used.\n\n        .. note::\n           The current heartbeat system involves calling ``os.fchmod`` on\n           temporary file handlers and may block a worker for arbitrary time\n           if the directory is on a disk-backed filesystem.\n\n           See :ref:`blocking-os-fchmod` for more detailed information\n           and a solution for avoiding this problem.\n        \"\"\"\n\n",
      "start_line": 1128,
      "end_line": 1150,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class User(Setting):\n    name = \"user\"\n    section = \"Server Mechanics\"\n    cli = [\"-u\", \"--user\"]\n    meta = \"USER\"\n    validator = validate_user\n    default = os.geteuid()\n    default_doc = \"``os.geteuid()``\"\n    desc = \"\"\"\\\n        Switch worker processes to run as this user.\n\n        A valid user id (as an integer) or the name of a user that can be\n        retrieved with a call to ``pwd.getpwnam(value)`` or ``None`` to not\n        change the worker process user.\n        \"\"\"\n\n",
      "start_line": 1150,
      "end_line": 1167,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class Group(Setting):\n    name = \"group\"\n    section = \"Server Mechanics\"\n    cli = [\"-g\", \"--group\"]\n    meta = \"GROUP\"\n    validator = validate_group\n    default = os.getegid()\n    default_doc = \"``os.getegid()``\"\n    desc = \"\"\"\\\n        Switch worker process to run as this group.\n\n        A valid group id (as an integer) or the name of a user that can be\n        retrieved with a call to ``grp.getgrnam(value)`` or ``None`` to not\n        change the worker processes group.\n        \"\"\"\n\n",
      "start_line": 1167,
      "end_line": 1184,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class Umask(Setting):\n    name = \"umask\"\n    section = \"Server Mechanics\"\n    cli = [\"-m\", \"--umask\"]\n    meta = \"INT\"\n    validator = validate_pos_int\n    type = auto_int\n    default = 0\n    desc = \"\"\"\\\n        A bit mask for the file mode on files written by Gunicorn.\n\n        Note that this affects unix socket permissions.\n\n        A valid value for the ``os.umask(mode)`` call or a string compatible\n        with ``int(value, 0)`` (``0`` means Python guesses the base, so values\n        like ``0``, ``0xFF``, ``0022`` are valid for decimal, hex, and octal\n        representations)\n        \"\"\"\n\n",
      "start_line": 1184,
      "end_line": 1204,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class Initgroups(Setting):\n    name = \"initgroups\"\n    section = \"Server Mechanics\"\n    cli = [\"--initgroups\"]\n    validator = validate_bool\n    action = 'store_true'\n    default = False\n\n    desc = \"\"\"\\\n        If true, set the worker process's group access list with all of the\n        groups of which the specified username is a member, plus the specified\n        group id.\n\n        .. versionadded:: 19.7\n        \"\"\"\n\n",
      "start_line": 1204,
      "end_line": 1221,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class TmpUploadDir(Setting):\n    name = \"tmp_upload_dir\"\n    section = \"Server Mechanics\"\n    meta = \"DIR\"\n    validator = validate_string\n    default = None\n    desc = \"\"\"\\\n        Directory to store temporary request data as they are read.\n\n        This may disappear in the near future.\n\n        This path should be writable by the process permissions set for Gunicorn\n        workers. If not specified, Gunicorn will choose a system generated\n        temporary directory.\n        \"\"\"\n\n",
      "start_line": 1221,
      "end_line": 1238,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class SecureSchemeHeader(Setting):\n    name = \"secure_scheme_headers\"\n    section = \"Server Mechanics\"\n    validator = validate_dict\n    default = {\n        \"X-FORWARDED-PROTOCOL\": \"ssl\",\n        \"X-FORWARDED-PROTO\": \"https\",\n        \"X-FORWARDED-SSL\": \"on\"\n    }\n    desc = \"\"\"\\\n\n        A dictionary containing headers and values that the front-end proxy\n        uses to indicate HTTPS requests. If the source IP is permitted by\n        :ref:`forwarded-allow-ips` (below), *and* at least one request header matches\n        a key-value pair listed in this dictionary, then Gunicorn will set\n        ``wsgi.url_scheme`` to ``https``, so your application can tell that the\n        request is secure.\n\n        If the other headers listed in this dictionary are not present in the request, they will be ignored,\n        but if the other headers are present and do not match the provided values, then\n        the request will fail to parse. See the note below for more detailed examples of this behaviour.\n\n        The dictionary should map upper-case header names to exact string\n        values. The value comparisons are case-sensitive, unlike the header\n        names, so make sure they're exactly what your front-end proxy sends\n        when handling HTTPS requests.\n\n        It is important that your front-end proxy configuration ensures that\n        the headers defined here can not be passed directly from the client.\n        \"\"\"\n\n",
      "start_line": 1238,
      "end_line": 1270,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class ForwardedAllowIPS(Setting):\n    name = \"forwarded_allow_ips\"\n    section = \"Server Mechanics\"\n    cli = [\"--forwarded-allow-ips\"]\n    meta = \"STRING\"\n    validator = validate_string_to_addr_list\n    default = os.environ.get(\"FORWARDED_ALLOW_IPS\", \"127.0.0.1,::1\")\n    desc = \"\"\"\\\n        Front-end's IPs from which allowed to handle set secure headers.\n        (comma separated).\n\n        Set to ``*`` to disable checking of front-end IPs. This is useful for setups\n        where you don't know in advance the IP address of front-end, but\n        instead have ensured via other means that only your\n        authorized front-ends can access Gunicorn.\n\n        By default, the value of the ``FORWARDED_ALLOW_IPS`` environment\n        variable. If it is not defined, the default is ``\"127.0.0.1,::1\"``.\n\n        .. note::\n\n            This option does not affect UNIX socket connections. Connections not associated with\n            an IP address are treated as allowed, unconditionally.\n\n        .. note::\n\n            The interplay between the request headers, the value of ``forwarded_allow_ips``, and the value of\n            ``secure_scheme_headers`` is complex. Various scenarios are documented below to further elaborate.\n            In each case, we have a request from the remote address 134.213.44.18, and the default value of\n            ``secure_scheme_headers``:\n\n            .. code::\n\n                secure_scheme_headers = {\n                    'X-FORWARDED-PROTOCOL': 'ssl',\n                    'X-FORWARDED-PROTO': 'https',\n                    'X-FORWARDED-SSL': 'on'\n                }\n\n\n            .. list-table::\n                :header-rows: 1\n                :align: center\n                :widths: auto\n\n                * - ``forwarded-allow-ips``\n                  - Secure Request Headers\n                  - Result\n                  - Explanation\n                * - .. code::\n\n                        [\"127.0.0.1\"]\n                  - .. code::\n\n                        X-Forwarded-Proto: https\n                  - .. code::\n\n                        wsgi.url_scheme = \"http\"\n                  - IP address was not allowed\n                * - .. code::\n\n                        \"*\"\n                  - <none>\n                  - .. code::\n\n                        wsgi.url_scheme = \"http\"\n                  - IP address allowed, but no secure headers provided\n                * - .. code::\n\n                        \"*\"\n                  - .. code::\n\n                        X-Forwarded-Proto: https\n                  - .. code::\n\n                        wsgi.url_scheme = \"https\"\n                  - IP address allowed, one request header matched\n                * - .. code::\n\n                        [\"134.213.44.18\"]\n                  - .. code::\n\n                        X-Forwarded-Ssl: on\n                        X-Forwarded-Proto: http\n                  - ``InvalidSchemeHeaders()`` raised\n                  - IP address allowed, but the two secure headers disagreed on if HTTPS was used\n\n\n        \"\"\"\n\n",
      "start_line": 1270,
      "end_line": 1361,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class AccessLog(Setting):\n    name = \"accesslog\"\n    section = \"Logging\"\n    cli = [\"--access-logfile\"]\n    meta = \"FILE\"\n    validator = validate_string\n    default = None\n    desc = \"\"\"\\\n        The Access log file to write to.\n\n        ``'-'`` means log to stdout.\n        \"\"\"\n\n",
      "start_line": 1361,
      "end_line": 1375,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class DisableRedirectAccessToSyslog(Setting):\n    name = \"disable_redirect_access_to_syslog\"\n    section = \"Logging\"\n    cli = [\"--disable-redirect-access-to-syslog\"]\n    validator = validate_bool\n    action = 'store_true'\n    default = False\n    desc = \"\"\"\\\n    Disable redirect access logs to syslog.\n\n    .. versionadded:: 19.8\n    \"\"\"\n\n",
      "start_line": 1375,
      "end_line": 1389,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class AccessLogFormat(Setting):\n    name = \"access_log_format\"\n    section = \"Logging\"\n    cli = [\"--access-logformat\"]\n    meta = \"STRING\"\n    validator = validate_string\n    default = '%(h)s %(l)s %(u)s %(t)s \"%(r)s\" %(s)s %(b)s \"%(f)s\" \"%(a)s\"'\n    desc = \"\"\"\\\n        The access log format.\n\n        ===========  ===========\n        Identifier   Description\n        ===========  ===========\n        h            remote address\n        l            ``'-'``\n        u            user name (if HTTP Basic auth used)\n        t            date of the request\n        r            status line (e.g. ``GET / HTTP/1.1``)\n        m            request method\n        U            URL path without query string\n        q            query string\n        H            protocol\n        s            status\n        B            response length\n        b            response length or ``'-'`` (CLF format)\n        f            referrer (note: header is ``referer``)\n        a            user agent\n        T            request time in seconds\n        M            request time in milliseconds\n        D            request time in microseconds\n        L            request time in decimal seconds\n        p            process ID\n        {header}i    request header\n        {header}o    response header\n        {variable}e  environment variable\n        ===========  ===========\n\n        Use lowercase for header and environment variable names, and put\n        ``{...}x`` names inside ``%(...)s``. For example::\n\n            %({x-forwarded-for}i)s\n        \"\"\"\n\n",
      "start_line": 1389,
      "end_line": 1433,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class ErrorLog(Setting):\n    name = \"errorlog\"\n    section = \"Logging\"\n    cli = [\"--error-logfile\", \"--log-file\"]\n    meta = \"FILE\"\n    validator = validate_string\n    default = '-'\n    desc = \"\"\"\\\n        The Error log file to write to.\n\n        Using ``'-'`` for FILE makes gunicorn log to stderr.\n\n        .. versionchanged:: 19.2\n           Log to stderr by default.\n\n        \"\"\"\n\n",
      "start_line": 1433,
      "end_line": 1451,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class Loglevel(Setting):\n    name = \"loglevel\"\n    section = \"Logging\"\n    cli = [\"--log-level\"]\n    meta = \"LEVEL\"\n    validator = validate_string\n    default = \"info\"\n    desc = \"\"\"\\\n        The granularity of Error log outputs.\n\n        Valid level names are:\n\n        * ``'debug'``\n        * ``'info'``\n        * ``'warning'``\n        * ``'error'``\n        * ``'critical'``\n        \"\"\"\n\n",
      "start_line": 1451,
      "end_line": 1471,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class CaptureOutput(Setting):\n    name = \"capture_output\"\n    section = \"Logging\"\n    cli = [\"--capture-output\"]\n    validator = validate_bool\n    action = 'store_true'\n    default = False\n    desc = \"\"\"\\\n        Redirect stdout/stderr to specified file in :ref:`errorlog`.\n\n        .. versionadded:: 19.6\n        \"\"\"\n\n",
      "start_line": 1471,
      "end_line": 1485,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class LoggerClass(Setting):\n    name = \"logger_class\"\n    section = \"Logging\"\n    cli = [\"--logger-class\"]\n    meta = \"STRING\"\n    validator = validate_class\n    default = \"gunicorn.glogging.Logger\"\n    desc = \"\"\"\\\n        The logger you want to use to log events in Gunicorn.\n\n        The default class (``gunicorn.glogging.Logger``) handles most\n        normal usages in logging. It provides error and access logging.\n\n        You can provide your own logger by giving Gunicorn a Python path to a",
      "start_line": 1485,
      "end_line": 1499,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "        class that quacks like ``gunicorn.glogging.Logger``.\n        \"\"\"\n\n",
      "start_line": 1499,
      "end_line": 1503,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class LogConfig(Setting):\n    name = \"logconfig\"\n    section = \"Logging\"\n    cli = [\"--log-config\"]\n    meta = \"FILE\"\n    validator = validate_string\n    default = None\n    desc = \"\"\"\\\n    The log config file to use.\n    Gunicorn uses the standard Python logging module's Configuration\n    file format.\n    \"\"\"\n\n",
      "start_line": 1503,
      "end_line": 1517,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class LogConfigDict(Setting):\n    name = \"logconfig_dict\"\n    section = \"Logging\"\n    validator = validate_dict\n    default = {}\n    desc = \"\"\"\\\n    The log config dictionary to use, using the standard Python\n    logging module's dictionary configuration format. This option\n    takes precedence over the :ref:`logconfig` and :ref:`logconfig-json` options,\n    which uses the older file configuration format and JSON\n    respectively.\n\n    Format: https://docs.python.org/3/library/logging.config.html#logging.config.dictConfig\n\n    For more context you can look at the default configuration dictionary for logging,\n    which can be found at ``gunicorn.glogging.CONFIG_DEFAULTS``.\n\n    .. versionadded:: 19.8\n    \"\"\"\n\n",
      "start_line": 1517,
      "end_line": 1538,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class LogConfigJson(Setting):\n    name = \"logconfig_json\"\n    section = \"Logging\"\n    cli = [\"--log-config-json\"]\n    meta = \"FILE\"\n    validator = validate_string\n    default = None\n    desc = \"\"\"\\\n    The log config to read config from a JSON file\n\n    Format: https://docs.python.org/3/library/logging.config.html#logging.config.jsonConfig\n\n    .. versionadded:: 20.0\n    \"\"\"\n\n",
      "start_line": 1538,
      "end_line": 1554,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class SyslogTo(Setting):\n    name = \"syslog_addr\"\n    section = \"Logging\"\n    cli = [\"--log-syslog-to\"]\n    meta = \"SYSLOG_ADDR\"\n    validator = validate_string\n\n    if PLATFORM == \"darwin\":\n        default = \"unix:///var/run/syslog\"\n    elif PLATFORM in ('freebsd', 'dragonfly', ):\n        default = \"unix:///var/run/log\"\n    elif PLATFORM == \"openbsd\":\n        default = \"unix:///dev/log\"\n    else:\n        default = \"udp://localhost:514\"\n\n    desc = \"\"\"\\\n    Address to send syslog messages.\n\n    Address is a string of the form:\n\n    * ``unix://PATH#TYPE`` : for unix domain socket. ``TYPE`` can be ``stream``\n      for the stream driver or ``dgram`` for the dgram driver.\n      ``stream`` is the default.\n    * ``udp://HOST:PORT`` : for UDP sockets\n    * ``tcp://HOST:PORT`` : for TCP sockets\n\n    \"\"\"\n\n",
      "start_line": 1554,
      "end_line": 1584,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class Syslog(Setting):\n    name = \"syslog\"\n    section = \"Logging\"\n    cli = [\"--log-syslog\"]\n    validator = validate_bool\n    action = 'store_true'\n    default = False\n    desc = \"\"\"\\\n    Send *Gunicorn* logs to syslog.\n\n    .. versionchanged:: 19.8\n       You can now disable sending access logs by using the\n       :ref:`disable-redirect-access-to-syslog` setting.\n    \"\"\"\n\n",
      "start_line": 1584,
      "end_line": 1600,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class SyslogPrefix(Setting):\n    name = \"syslog_prefix\"\n    section = \"Logging\"\n    cli = [\"--log-syslog-prefix\"]\n    meta = \"SYSLOG_PREFIX\"\n    validator = validate_string\n    default = None\n    desc = \"\"\"\\\n    Makes Gunicorn use the parameter as program-name in the syslog entries.\n\n    All entries will be prefixed by ``gunicorn.<prefix>``. By default the\n    program name is the name of the process.\n    \"\"\"\n\n",
      "start_line": 1600,
      "end_line": 1615,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class SyslogFacility(Setting):\n    name = \"syslog_facility\"\n    section = \"Logging\"\n    cli = [\"--log-syslog-facility\"]\n    meta = \"SYSLOG_FACILITY\"\n    validator = validate_string\n    default = \"user\"\n    desc = \"\"\"\\\n    Syslog facility name\n    \"\"\"\n\n",
      "start_line": 1615,
      "end_line": 1627,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class EnableStdioInheritance(Setting):\n    name = \"enable_stdio_inheritance\"\n    section = \"Logging\"\n    cli = [\"-R\", \"--enable-stdio-inheritance\"]\n    validator = validate_bool\n    default = False\n    action = \"store_true\"\n    desc = \"\"\"\\\n    Enable stdio inheritance.\n\n    Enable inheritance for stdio file descriptors in daemon mode.\n\n    Note: To disable the Python stdout buffering, you can to set the user\n    environment variable ``PYTHONUNBUFFERED`` .\n    \"\"\"\n\n\n# statsD monitoring",
      "start_line": 1627,
      "end_line": 1645,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class StatsdHost(Setting):\n    name = \"statsd_host\"\n    section = \"Logging\"\n    cli = [\"--statsd-host\"]\n    meta = \"STATSD_ADDR\"\n    default = None\n    validator = validate_statsd_address\n    desc = \"\"\"\\\n    The address of the StatsD server to log to.\n\n    Address is a string of the form:\n\n    * ``unix://PATH`` : for a unix domain socket.\n    * ``HOST:PORT`` : for a network address\n\n    .. versionadded:: 19.1\n    \"\"\"\n\n\n# Datadog Statsd (dogstatsd) tags. https://docs.datadoghq.com/developers/dogstatsd/",
      "start_line": 1645,
      "end_line": 1665,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class DogstatsdTags(Setting):\n    name = \"dogstatsd_tags\"\n    section = \"Logging\"\n    cli = [\"--dogstatsd-tags\"]\n    meta = \"DOGSTATSD_TAGS\"\n    default = \"\"\n    validator = validate_string\n    desc = \"\"\"\\\n    A comma-delimited list of datadog statsd (dogstatsd) tags to append to\n    statsd metrics.\n\n    .. versionadded:: 20\n    \"\"\"\n\n",
      "start_line": 1665,
      "end_line": 1680,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class StatsdPrefix(Setting):\n    name = \"statsd_prefix\"\n    section = \"Logging\"\n    cli = [\"--statsd-prefix\"]\n    meta = \"STATSD_PREFIX\"\n    default = \"\"\n    validator = validate_string\n    desc = \"\"\"\\\n    Prefix to use when emitting statsd metrics (a trailing ``.`` is added,\n    if not provided).\n\n    .. versionadded:: 19.2\n    \"\"\"\n\n",
      "start_line": 1680,
      "end_line": 1695,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class Procname(Setting):\n    name = \"proc_name\"\n    section = \"Process Naming\"\n    cli = [\"-n\", \"--name\"]\n    meta = \"STRING\"\n    validator = validate_string\n    default = None\n    desc = \"\"\"\\\n        A base to use with setproctitle for process naming.\n\n        This affects things like ``ps`` and ``top``. If you're going to be\n        running more than one instance of Gunicorn you'll probably want to set a\n        name to tell them apart. This requires that you install the setproctitle\n        module.\n\n        If not set, the *default_proc_name* setting will be used.\n        \"\"\"\n\n",
      "start_line": 1695,
      "end_line": 1714,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class DefaultProcName(Setting):\n    name = \"default_proc_name\"\n    section = \"Process Naming\"\n    validator = validate_string\n    default = \"gunicorn\"\n    desc = \"\"\"\\\n        Internal setting that is adjusted for each type of application.\n        \"\"\"\n\n",
      "start_line": 1714,
      "end_line": 1724,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class PythonPath(Setting):\n    name = \"pythonpath\"\n    section = \"Server Mechanics\"\n    cli = [\"--pythonpath\"]\n    meta = \"STRING\"\n    validator = validate_string\n    default = None\n    desc = \"\"\"\\\n        A comma-separated list of directories to add to the Python path.\n\n        e.g.\n        ``'/home/djangoprojects/myproject,/home/python/mylibrary'``.\n        \"\"\"\n\n",
      "start_line": 1724,
      "end_line": 1739,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class Paste(Setting):\n    name = \"paste\"\n    section = \"Server Mechanics\"\n    cli = [\"--paste\", \"--paster\"]\n    meta = \"STRING\"\n    validator = validate_string\n    default = None\n    desc = \"\"\"\\\n        Load a PasteDeploy config file. The argument may contain a ``#``\n        symbol followed by the name of an app section from the config file,\n        e.g. ``production.ini#admin``.\n\n        At this time, using alternate server blocks is not supported. Use the\n        command line arguments to control server configuration instead.\n        \"\"\"\n\n",
      "start_line": 1739,
      "end_line": 1756,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class OnStarting(Setting):\n    name = \"on_starting\"\n    section = \"Server Hooks\"\n    validator = validate_callable(1)\n    type = callable\n",
      "start_line": 1756,
      "end_line": 1762,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def on_starting(server):\n        pass\n    default = staticmethod(on_starting)\n    desc = \"\"\"\\\n        Called just before the master process is initialized.\n\n        The callable needs to accept a single instance variable for the Arbiter.\n        \"\"\"\n\n",
      "start_line": 1762,
      "end_line": 1772,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class OnReload(Setting):\n    name = \"on_reload\"\n    section = \"Server Hooks\"\n    validator = validate_callable(1)\n    type = callable\n",
      "start_line": 1772,
      "end_line": 1778,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def on_reload(server):\n        pass\n    default = staticmethod(on_reload)\n    desc = \"\"\"\\\n        Called to recycle workers during a reload via SIGHUP.\n\n        The callable needs to accept a single instance variable for the Arbiter.\n        \"\"\"\n\n",
      "start_line": 1778,
      "end_line": 1788,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class WhenReady(Setting):\n    name = \"when_ready\"\n    section = \"Server Hooks\"\n    validator = validate_callable(1)\n    type = callable\n",
      "start_line": 1788,
      "end_line": 1794,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def when_ready(server):\n        pass\n    default = staticmethod(when_ready)\n    desc = \"\"\"\\\n        Called just after the server is started.\n\n        The callable needs to accept a single instance variable for the Arbiter.\n        \"\"\"\n\n",
      "start_line": 1794,
      "end_line": 1804,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class Prefork(Setting):\n    name = \"pre_fork\"\n    section = \"Server Hooks\"\n    validator = validate_callable(2)\n    type = callable\n",
      "start_line": 1804,
      "end_line": 1810,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def pre_fork(server, worker):\n        pass\n    default = staticmethod(pre_fork)\n    desc = \"\"\"\\\n        Called just before a worker is forked.\n\n        The callable needs to accept two instance variables for the Arbiter and\n        new Worker.\n        \"\"\"\n\n",
      "start_line": 1810,
      "end_line": 1821,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class Postfork(Setting):\n    name = \"post_fork\"\n    section = \"Server Hooks\"\n    validator = validate_callable(2)\n    type = callable\n",
      "start_line": 1821,
      "end_line": 1827,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def post_fork(server, worker):\n        pass\n    default = staticmethod(post_fork)\n    desc = \"\"\"\\\n        Called just after a worker has been forked.\n\n        The callable needs to accept two instance variables for the Arbiter and\n        new Worker.\n        \"\"\"\n\n",
      "start_line": 1827,
      "end_line": 1838,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class PostWorkerInit(Setting):\n    name = \"post_worker_init\"\n    section = \"Server Hooks\"\n    validator = validate_callable(1)\n    type = callable\n",
      "start_line": 1838,
      "end_line": 1844,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def post_worker_init(worker):\n        pass\n\n    default = staticmethod(post_worker_init)\n    desc = \"\"\"\\\n        Called just after a worker has initialized the application.\n\n        The callable needs to accept one instance variable for the initialized\n        Worker.\n        \"\"\"\n\n",
      "start_line": 1844,
      "end_line": 1856,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class WorkerInt(Setting):\n    name = \"worker_int\"\n    section = \"Server Hooks\"\n    validator = validate_callable(1)\n    type = callable\n",
      "start_line": 1856,
      "end_line": 1862,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def worker_int(worker):\n        pass\n\n    default = staticmethod(worker_int)\n    desc = \"\"\"\\\n        Called just after a worker exited on SIGINT or SIGQUIT.\n\n        The callable needs to accept one instance variable for the initialized\n        Worker.\n        \"\"\"\n\n",
      "start_line": 1862,
      "end_line": 1874,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class WorkerAbort(Setting):\n    name = \"worker_abort\"\n    section = \"Server Hooks\"\n    validator = validate_callable(1)\n    type = callable\n",
      "start_line": 1874,
      "end_line": 1880,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def worker_abort(worker):\n        pass\n\n    default = staticmethod(worker_abort)\n    desc = \"\"\"\\\n        Called when a worker received the SIGABRT signal.\n\n        This call generally happens on timeout.\n\n        The callable needs to accept one instance variable for the initialized\n        Worker.\n        \"\"\"\n\n",
      "start_line": 1880,
      "end_line": 1894,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class PreExec(Setting):\n    name = \"pre_exec\"\n    section = \"Server Hooks\"\n    validator = validate_callable(1)\n    type = callable\n",
      "start_line": 1894,
      "end_line": 1900,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def pre_exec(server):\n        pass\n    default = staticmethod(pre_exec)\n    desc = \"\"\"\\\n        Called just before a new master process is forked.\n\n        The callable needs to accept a single instance variable for the Arbiter.\n        \"\"\"\n\n",
      "start_line": 1900,
      "end_line": 1910,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class PreRequest(Setting):\n    name = \"pre_request\"\n    section = \"Server Hooks\"\n    validator = validate_callable(2)\n    type = callable\n",
      "start_line": 1910,
      "end_line": 1916,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def pre_request(worker, req):\n        worker.log.debug(\"%s %s\", req.method, req.path)\n    default = staticmethod(pre_request)\n    desc = \"\"\"\\\n        Called just before a worker processes the request.\n\n        The callable needs to accept two instance variables for the Worker and\n        the Request.\n        \"\"\"\n\n",
      "start_line": 1916,
      "end_line": 1927,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class PostRequest(Setting):\n    name = \"post_request\"\n    section = \"Server Hooks\"\n    validator = validate_post_request\n    type = callable\n",
      "start_line": 1927,
      "end_line": 1933,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def post_request(worker, req, environ, resp):\n        pass\n    default = staticmethod(post_request)\n    desc = \"\"\"\\\n        Called after a worker processes the request.\n\n        The callable needs to accept two instance variables for the Worker and\n        the Request.\n        \"\"\"\n\n",
      "start_line": 1933,
      "end_line": 1944,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class ChildExit(Setting):\n    name = \"child_exit\"\n    section = \"Server Hooks\"\n    validator = validate_callable(2)\n    type = callable\n",
      "start_line": 1944,
      "end_line": 1950,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def child_exit(server, worker):\n        pass\n    default = staticmethod(child_exit)\n    desc = \"\"\"\\\n        Called just after a worker has been exited, in the master process.\n\n        The callable needs to accept two instance variables for the Arbiter and\n        the just-exited Worker.\n\n        .. versionadded:: 19.7\n        \"\"\"\n\n",
      "start_line": 1950,
      "end_line": 1963,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class WorkerExit(Setting):\n    name = \"worker_exit\"\n    section = \"Server Hooks\"\n    validator = validate_callable(2)\n    type = callable\n",
      "start_line": 1963,
      "end_line": 1969,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def worker_exit(server, worker):\n        pass\n    default = staticmethod(worker_exit)\n    desc = \"\"\"\\\n        Called just after a worker has been exited, in the worker process.\n\n        The callable needs to accept two instance variables for the Arbiter and\n        the just-exited Worker.\n        \"\"\"\n\n",
      "start_line": 1969,
      "end_line": 1980,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class NumWorkersChanged(Setting):\n    name = \"nworkers_changed\"\n    section = \"Server Hooks\"\n    validator = validate_callable(3)\n    type = callable\n",
      "start_line": 1980,
      "end_line": 1986,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def nworkers_changed(server, new_value, old_value):\n        pass\n    default = staticmethod(nworkers_changed)\n    desc = \"\"\"\\\n        Called just after *num_workers* has been changed.\n\n        The callable needs to accept an instance variable of the Arbiter and\n        two integers of number of workers after and before change.\n\n        If the number of workers is set for the first time, *old_value* would\n        be ``None``.\n        \"\"\"\n\n",
      "start_line": 1986,
      "end_line": 2000,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class OnExit(Setting):\n    name = \"on_exit\"\n    section = \"Server Hooks\"\n    validator = validate_callable(1)\n",
      "start_line": 2000,
      "end_line": 2005,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def on_exit(server):\n        pass\n\n    default = staticmethod(on_exit)\n    desc = \"\"\"\\\n        Called just before exiting Gunicorn.\n\n        The callable needs to accept a single instance variable for the Arbiter.\n        \"\"\"\n\n",
      "start_line": 2005,
      "end_line": 2016,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class NewSSLContext(Setting):\n    name = \"ssl_context\"\n    section = \"Server Hooks\"\n    validator = validate_callable(2)\n    type = callable\n",
      "start_line": 2016,
      "end_line": 2022,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "    def ssl_context(config, default_ssl_context_factory):\n        return default_ssl_context_factory()\n\n    default = staticmethod(ssl_context)\n    desc = \"\"\"\\\n        Called when SSLContext is needed.\n\n        Allows customizing SSL context.\n\n        The callable needs to accept an instance variable for the Config and\n        a factory function that returns default SSLContext which is initialized\n        with certificates, private key, cert_reqs, and ciphers according to\n        config and can be further customized by the callable.\n        The callable needs to return SSLContext object.\n\n        Following example shows a configuration file that sets the minimum TLS version to 1.3:\n\n        .. code-block:: python\n",
      "start_line": 2022,
      "end_line": 2041,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "            def ssl_context(conf, default_ssl_context_factory):\n                import ssl\n                context = default_ssl_context_factory()\n                context.minimum_version = ssl.TLSVersion.TLSv1_3\n                return context\n\n        .. versionadded:: 21.0\n        \"\"\"\n\n",
      "start_line": 2041,
      "end_line": 2051,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class ProxyProtocol(Setting):\n    name = \"proxy_protocol\"\n    section = \"Server Mechanics\"\n    cli = [\"--proxy-protocol\"]\n    validator = validate_bool\n    default = False\n    action = \"store_true\"\n    desc = \"\"\"\\\n        Enable detect PROXY protocol (PROXY mode).\n\n        Allow using HTTP and Proxy together. It may be useful for work with\n        stunnel as HTTPS frontend and Gunicorn as HTTP server.\n\n        PROXY protocol: http://haproxy.1wt.eu/download/1.5/doc/proxy-protocol.txt\n\n        Example for stunnel config::\n\n            [https]\n            protocol = proxy\n            accept  = 443\n            connect = 80\n            cert = /etc/ssl/certs/stunnel.pem\n            key = /etc/ssl/certs/stunnel.key\n        \"\"\"\n\n",
      "start_line": 2051,
      "end_line": 2077,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class ProxyAllowFrom(Setting):\n    name = \"proxy_allow_ips\"\n    section = \"Server Mechanics\"\n    cli = [\"--proxy-allow-from\"]\n    validator = validate_string_to_addr_list\n    default = \"127.0.0.1,::1\"\n    desc = \"\"\"\\\n        Front-end's IPs from which allowed accept proxy requests (comma separated).\n\n        Set to ``*`` to disable checking of front-end IPs. This is useful for setups\n        where you don't know in advance the IP address of front-end, but\n        instead have ensured via other means that only your\n        authorized front-ends can access Gunicorn.\n\n        .. note::\n\n            This option does not affect UNIX socket connections. Connections not associated with\n            an IP address are treated as allowed, unconditionally.\n        \"\"\"\n\n",
      "start_line": 2077,
      "end_line": 2098,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class KeyFile(Setting):\n    name = \"keyfile\"\n    section = \"SSL\"\n    cli = [\"--keyfile\"]\n    meta = \"FILE\"\n    validator = validate_string\n    default = None\n    desc = \"\"\"\\\n    SSL key file\n    \"\"\"\n\n",
      "start_line": 2098,
      "end_line": 2110,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class CertFile(Setting):\n    name = \"certfile\"\n    section = \"SSL\"\n    cli = [\"--certfile\"]\n    meta = \"FILE\"\n    validator = validate_string\n    default = None\n    desc = \"\"\"\\\n    SSL certificate file\n    \"\"\"\n\n",
      "start_line": 2110,
      "end_line": 2122,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class SSLVersion(Setting):\n    name = \"ssl_version\"\n    section = \"SSL\"\n    cli = [\"--ssl-version\"]\n    validator = validate_ssl_version\n\n    if hasattr(ssl, \"PROTOCOL_TLS\"):\n        default = ssl.PROTOCOL_TLS\n    else:\n        default = ssl.PROTOCOL_SSLv23\n\n    default = ssl.PROTOCOL_SSLv23\n    desc = \"\"\"\\\n    SSL version to use (see stdlib ssl module's).\n\n    .. deprecated:: 21.0\n       The option is deprecated and it is currently ignored. Use :ref:`ssl-context` instead.\n\n    ============= ============\n    --ssl-version Description\n    ============= ============\n    SSLv3         SSLv3 is not-secure and is strongly discouraged.\n    SSLv23        Alias for TLS. Deprecated in Python 3.6, use TLS.\n    TLS           Negotiate highest possible version between client/server.\n                  Can yield SSL. (Python 3.6+)\n    TLSv1         TLS 1.0\n    TLSv1_1       TLS 1.1 (Python 3.4+)\n    TLSv1_2       TLS 1.2 (Python 3.4+)\n    TLS_SERVER    Auto-negotiate the highest protocol version like TLS,\n                  but only support server-side SSLSocket connections.\n                  (Python 3.6+)\n    ============= ============\n\n    .. versionchanged:: 19.7\n       The default value has been changed from ``ssl.PROTOCOL_TLSv1`` to\n       ``ssl.PROTOCOL_SSLv23``.\n    .. versionchanged:: 20.0\n       This setting now accepts string names based on ``ssl.PROTOCOL_``\n       constants.\n    .. versionchanged:: 20.0.1\n       The default value has been changed from ``ssl.PROTOCOL_SSLv23`` to\n       ``ssl.PROTOCOL_TLS`` when Python >= 3.6 .\n    \"\"\"\n\n",
      "start_line": 2122,
      "end_line": 2167,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class CertReqs(Setting):\n    name = \"cert_reqs\"\n    section = \"SSL\"\n    cli = [\"--cert-reqs\"]\n    validator = validate_pos_int\n    default = ssl.CERT_NONE\n    desc = \"\"\"\\\n    Whether client certificate is required (see stdlib ssl module's)\n\n    ===========  ===========================\n    --cert-reqs      Description\n    ===========  ===========================\n    `0`          no client verification\n    `1`          ssl.CERT_OPTIONAL\n    `2`          ssl.CERT_REQUIRED\n    ===========  ===========================\n    \"\"\"\n\n",
      "start_line": 2167,
      "end_line": 2186,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class CACerts(Setting):\n    name = \"ca_certs\"\n    section = \"SSL\"\n    cli = [\"--ca-certs\"]\n    meta = \"FILE\"\n    validator = validate_string\n    default = None\n    desc = \"\"\"\\\n    CA certificates file\n    \"\"\"\n\n",
      "start_line": 2186,
      "end_line": 2198,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class SuppressRaggedEOFs(Setting):\n    name = \"suppress_ragged_eofs\"\n    section = \"SSL\"\n    cli = [\"--suppress-ragged-eofs\"]\n    action = \"store_true\"\n    default = True\n    validator = validate_bool\n    desc = \"\"\"\\\n    Suppress ragged EOFs (see stdlib ssl module's)\n    \"\"\"\n\n",
      "start_line": 2198,
      "end_line": 2210,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class DoHandshakeOnConnect(Setting):\n    name = \"do_handshake_on_connect\"\n    section = \"SSL\"\n    cli = [\"--do-handshake-on-connect\"]\n    validator = validate_bool\n    action = \"store_true\"\n    default = False\n    desc = \"\"\"\\\n    Whether to perform SSL handshake on socket connect (see stdlib ssl module's)\n    \"\"\"\n\n",
      "start_line": 2210,
      "end_line": 2222,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class Ciphers(Setting):\n    name = \"ciphers\"\n    section = \"SSL\"\n    cli = [\"--ciphers\"]\n    validator = validate_string\n    default = None\n    desc = \"\"\"\\\n    SSL Cipher suite to use, in the format of an OpenSSL cipher list.\n\n    By default we use the default cipher list from Python's ``ssl`` module,\n    which contains ciphers considered strong at the time of each Python\n    release.\n\n    As a recommended alternative, the Open Web App Security Project (OWASP)\n    offers `a vetted set of strong cipher strings rated A+ to C-\n    <https://www.owasp.org/index.php/TLS_Cipher_String_Cheat_Sheet>`_.\n    OWASP provides details on user-agent compatibility at each security level.\n\n    See the `OpenSSL Cipher List Format Documentation\n    <https://www.openssl.org/docs/manmaster/man1/ciphers.html#CIPHER-LIST-FORMAT>`_\n    for details on the format of an OpenSSL cipher list.\n    \"\"\"\n\n",
      "start_line": 2222,
      "end_line": 2246,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class PasteGlobalConf(Setting):\n    name = \"raw_paste_global_conf\"\n    action = \"append\"\n    section = \"Server Mechanics\"\n    cli = [\"--paste-global\"]\n    meta = \"CONF\"\n    validator = validate_list_string\n    default = []\n\n    desc = \"\"\"\\\n        Set a PasteDeploy global config variable in ``key=value`` form.\n\n        The option can be specified multiple times.\n\n        The variables are passed to the PasteDeploy entrypoint. Example::\n\n            $ gunicorn -b 127.0.0.1:8000 --paste development.ini --paste-global FOO=1 --paste-global BAR=2\n\n        .. versionadded:: 19.7\n        \"\"\"\n\n",
      "start_line": 2246,
      "end_line": 2268,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class PermitObsoleteFolding(Setting):\n    name = \"permit_obsolete_folding\"\n    section = \"Server Mechanics\"\n    cli = [\"--permit-obsolete-folding\"]\n    validator = validate_bool\n    action = \"store_true\"\n    default = False\n    desc = \"\"\"\\\n        Permit requests employing obsolete HTTP line folding mechanism\n\n        The folding mechanism was deprecated by rfc7230 Section 3.2.4 and will not be\n         employed in HTTP request headers from standards-compliant HTTP clients.\n\n        This option is provided to diagnose backwards-incompatible changes.\n        Use with care and only if necessary. Temporary; the precise effect of this option may\n        change in a future version, or it may be removed altogether.\n\n        .. versionadded:: 23.0.0\n        \"\"\"\n\n",
      "start_line": 2268,
      "end_line": 2289,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class StripHeaderSpaces(Setting):\n    name = \"strip_header_spaces\"\n    section = \"Server Mechanics\"\n    cli = [\"--strip-header-spaces\"]\n    validator = validate_bool\n    action = \"store_true\"\n    default = False\n    desc = \"\"\"\\\n        Strip spaces present between the header name and the the ``:``.\n\n        This is known to induce vulnerabilities and is not compliant with the HTTP/1.1 standard.\n        See https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn.\n\n        Use with care and only if necessary. Deprecated; scheduled for removal in 25.0.0\n\n        .. versionadded:: 20.0.1\n        \"\"\"\n\n",
      "start_line": 2289,
      "end_line": 2308,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class PermitUnconventionalHTTPMethod(Setting):\n    name = \"permit_unconventional_http_method\"\n    section = \"Server Mechanics\"\n    cli = [\"--permit-unconventional-http-method\"]\n    validator = validate_bool\n    action = \"store_true\"\n    default = False\n    desc = \"\"\"\\\n        Permit HTTP methods not matching conventions, such as IANA registration guidelines\n\n        This permits request methods of length less than 3 or more than 20,\n        methods with lowercase characters or methods containing the # character.\n        HTTP methods are case sensitive by definition, and merely uppercase by convention.\n\n        If unset, Gunicorn will apply nonstandard restrictions and cause 400 response status\n        in cases where otherwise 501 status is expected. While this option does modify that\n        behaviour, it should not be depended upon to guarantee standards-compliant behaviour.\n        Rather, it is provided temporarily, to assist in diagnosing backwards-incompatible\n        changes around the incomplete application of those restrictions.\n\n        Use with care and only if necessary. Temporary; scheduled for removal in 24.0.0\n\n        .. versionadded:: 22.0.0\n        \"\"\"\n\n",
      "start_line": 2308,
      "end_line": 2334,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class PermitUnconventionalHTTPVersion(Setting):\n    name = \"permit_unconventional_http_version\"\n    section = \"Server Mechanics\"\n    cli = [\"--permit-unconventional-http-version\"]\n    validator = validate_bool\n    action = \"store_true\"\n    default = False\n    desc = \"\"\"\\\n        Permit HTTP version not matching conventions of 2023\n\n        This disables the refusal of likely malformed request lines.\n        It is unusual to specify HTTP 1 versions other than 1.0 and 1.1.\n\n        This option is provided to diagnose backwards-incompatible changes.\n        Use with care and only if necessary. Temporary; the precise effect of this option may\n        change in a future version, or it may be removed altogether.\n\n        .. versionadded:: 22.0.0\n        \"\"\"\n\n",
      "start_line": 2334,
      "end_line": 2355,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class CasefoldHTTPMethod(Setting):\n    name = \"casefold_http_method\"\n    section = \"Server Mechanics\"\n    cli = [\"--casefold-http-method\"]\n    validator = validate_bool\n    action = \"store_true\"\n    default = False\n    desc = \"\"\"\\\n         Transform received HTTP methods to uppercase\n\n         HTTP methods are case sensitive by definition, and merely uppercase by convention.\n\n         This option is provided because previous versions of gunicorn defaulted to this behaviour.\n\n         Use with care and only if necessary. Deprecated; scheduled for removal in 24.0.0\n\n         .. versionadded:: 22.0.0\n         \"\"\"\n\n",
      "start_line": 2355,
      "end_line": 2375,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "def validate_header_map_behaviour(val):\n    # FIXME: refactor all of this subclassing stdlib argparse\n\n    if val is None:\n        return\n\n    if not isinstance(val, str):\n        raise TypeError(\"Invalid type for casting: %s\" % val)\n    if val.lower().strip() == \"drop\":\n        return \"drop\"\n    elif val.lower().strip() == \"refuse\":\n        return \"refuse\"\n    elif val.lower().strip() == \"dangerous\":\n        return \"dangerous\"\n    else:\n        raise ValueError(\"Invalid header map behaviour: %s\" % val)\n\n",
      "start_line": 2375,
      "end_line": 2393,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class ForwarderHeaders(Setting):\n    name = \"forwarder_headers\"\n    section = \"Server Mechanics\"\n    cli = [\"--forwarder-headers\"]\n    validator = validate_string_to_list\n    default = \"SCRIPT_NAME,PATH_INFO\"\n    desc = \"\"\"\\\n\n        A list containing upper-case header field names that the front-end proxy\n        (see :ref:`forwarded-allow-ips`) sets, to be used in WSGI environment.\n\n        This option has no effect for headers not present in the request.\n\n        This option can be used to transfer ``SCRIPT_NAME``, ``PATH_INFO``\n        and ``REMOTE_USER``.\n\n        It is important that your front-end proxy configuration ensures that\n        the headers defined here can not be passed directly from the client.\n        \"\"\"\n\n",
      "start_line": 2393,
      "end_line": 2414,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "class HeaderMap(Setting):\n    name = \"header_map\"\n    section = \"Server Mechanics\"\n    cli = [\"--header-map\"]\n    validator = validate_header_map_behaviour\n    default = \"drop\"\n    desc = \"\"\"\\\n        Configure how header field names are mapped into environ\n\n        Headers containing underscores are permitted by RFC9110,\n        but gunicorn joining headers of different names into\n        the same environment variable will dangerously confuse applications as to which is which.\n\n        The safe default ``drop`` is to silently drop headers that cannot be unambiguously mapped.\n        The value ``refuse`` will return an error if a request contains *any* such header.\n        The value ``dangerous`` matches the previous, not advisable, behaviour of mapping different\n        header field names into the same environ name.\n\n        If the source is permitted as explained in :ref:`forwarded-allow-ips`, *and* the header name is\n        present in :ref:`forwarder-headers`, the header is mapped into environment regardless of\n        the state of this setting.\n\n        Use with care and only if necessary and after considering if your problem could\n        instead be solved by specifically renaming or rewriting only the intended headers\n        on a proxy in front of Gunicorn.\n\n        .. versionadded:: 22.0.0\n        \"\"\"",
      "start_line": 2414,
      "end_line": 2442,
      "source_file": "gunicorn/config.py",
      "chunk_type": "code"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\nimport ast\nimport email.utils\nimport errno\nimport fcntl\nimport html\nimport importlib\nimport inspect\nimport io\nimport logging\nimport os\nimport pwd\nimport random\nimport re\nimport socket\nimport sys\nimport textwrap\nimport time\nimport traceback\nimport warnings\n\ntry:\n    import importlib.metadata as importlib_metadata\nexcept (ModuleNotFoundError, ImportError):\n    import importlib_metadata\n\nfrom gunicorn.errors import AppImportError\nfrom gunicorn.workers import SUPPORTED_WORKERS\nimport urllib.parse\n\nREDIRECT_TO = getattr(os, 'devnull', '/dev/null')\n\n# Server and Date aren't technically hop-by-hop\n# headers, but they are in the purview of the\n# origin server which the WSGI spec says we should\n# act like. So we drop them and add our own.\n#\n# In the future, concatenation server header values\n# might be better, but nothing else does it and\n# dropping them is easier.\nhop_headers = set(\"\"\"\n    connection keep-alive proxy-authenticate proxy-authorization\n    te trailers transfer-encoding upgrade\n    server date\n    \"\"\".split())\n\ntry:\n    from setproctitle import setproctitle\n",
      "start_line": 0,
      "end_line": 51,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "    def _setproctitle(title):\n        setproctitle(\"gunicorn: %s\" % title)\nexcept ImportError:",
      "start_line": 51,
      "end_line": 54,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "    def _setproctitle(title):\n        pass\n\n",
      "start_line": 54,
      "end_line": 58,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "def load_entry_point(distribution, group, name):\n    dist_obj = importlib_metadata.distribution(distribution)\n    eps = [ep for ep in dist_obj.entry_points\n           if ep.group == group and ep.name == name]\n    if not eps:\n        raise ImportError(\"Entry point %r not found\" % ((group, name),))\n    return eps[0].load()\n\n",
      "start_line": 58,
      "end_line": 67,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "def load_class(uri, default=\"gunicorn.workers.sync.SyncWorker\",\n               section=\"gunicorn.workers\"):\n    if inspect.isclass(uri):\n        return uri\n    if uri.startswith(\"egg:\"):\n        # uses entry points\n        entry_str = uri.split(\"egg:\")[1]\n        try:\n            dist, name = entry_str.rsplit(\"#\", 1)\n        except ValueError:\n            dist = entry_str\n            name = default\n\n        try:\n            return load_entry_point(dist, section, name)\n        except Exception:\n            exc = traceback.format_exc()\n            msg = \"class uri %r invalid or not found: \\n\\n[%s]\"\n            raise RuntimeError(msg % (uri, exc))\n    else:\n        components = uri.split('.')\n        if len(components) == 1:\n            while True:\n                if uri.startswith(\"#\"):\n                    uri = uri[1:]\n\n                if uri in SUPPORTED_WORKERS:\n                    components = SUPPORTED_WORKERS[uri].split(\".\")\n                    break\n\n                try:\n                    return load_entry_point(\n                        \"gunicorn\", section, uri\n                    )\n                except Exception:\n                    exc = traceback.format_exc()\n                    msg = \"class uri %r invalid or not found: \\n\\n[%s]\"\n                    raise RuntimeError(msg % (uri, exc))\n\n        klass = components.pop(-1)\n\n        try:\n            mod = importlib.import_module('.'.join(components))\n        except Exception:\n            exc = traceback.format_exc()\n            msg = \"class uri %r invalid or not found: \\n\\n[%s]\"\n            raise RuntimeError(msg % (uri, exc))\n        return getattr(mod, klass)\n\n\npositionals = (\n    inspect.Parameter.POSITIONAL_ONLY,\n    inspect.Parameter.POSITIONAL_OR_KEYWORD,\n)\n\n",
      "start_line": 67,
      "end_line": 123,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "def get_arity(f):\n    sig = inspect.signature(f)\n    arity = 0\n\n    for param in sig.parameters.values():\n        if param.kind in positionals:\n            arity += 1\n\n    return arity\n\n",
      "start_line": 123,
      "end_line": 134,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "def get_username(uid):\n    \"\"\" get the username for a user id\"\"\"\n    return pwd.getpwuid(uid).pw_name\n\n",
      "start_line": 134,
      "end_line": 139,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "def set_owner_process(uid, gid, initgroups=False):\n    \"\"\" set user and group of workers processes \"\"\"\n\n    if gid:\n        if uid:\n            try:\n                username = get_username(uid)\n            except KeyError:\n                initgroups = False\n\n        if initgroups:\n            os.initgroups(username, gid)\n        elif gid != os.getgid():\n            os.setgid(gid)\n\n    if uid and uid != os.getuid():\n        os.setuid(uid)\n\n",
      "start_line": 139,
      "end_line": 158,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "def chown(path, uid, gid):\n    os.chown(path, uid, gid)\n\n\nif sys.platform.startswith(\"win\"):",
      "start_line": 158,
      "end_line": 163,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "    def _waitfor(func, pathname, waitall=False):\n        # Perform the operation\n        func(pathname)\n        # Now setup the wait loop\n        if waitall:\n            dirname = pathname\n        else:\n            dirname, name = os.path.split(pathname)\n            dirname = dirname or '.'\n        # Check for `pathname` to be removed from the filesystem.\n        # The exponential backoff of the timeout amounts to a total\n        # of ~1 second after which the deletion is probably an error\n        # anyway.\n        # Testing on a i7@4.3GHz shows that usually only 1 iteration is\n        # required when contention occurs.\n        timeout = 0.001\n        while timeout < 1.0:\n            # Note we are only testing for the existence of the file(s) in\n            # the contents of the directory regardless of any security or\n            # access rights.  If we have made it this far, we have sufficient\n            # permissions to do that much using Python's equivalent of the\n            # Windows API FindFirstFile.\n            # Other Windows APIs can fail or give incorrect results when\n            # dealing with files that are pending deletion.\n            L = os.listdir(dirname)\n            if not L if waitall else name in L:\n                return\n            # Increase the timeout and try again\n            time.sleep(timeout)\n            timeout *= 2\n        warnings.warn('tests may fail, delete still pending for ' + pathname,\n                      RuntimeWarning, stacklevel=4)\n",
      "start_line": 163,
      "end_line": 196,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "    def _unlink(filename):\n        _waitfor(os.unlink, filename)\nelse:\n    _unlink = os.unlink\n\n",
      "start_line": 196,
      "end_line": 202,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "def unlink(filename):\n    try:\n        _unlink(filename)\n    except OSError as error:\n        # The filename need not exist.\n        if error.errno not in (errno.ENOENT, errno.ENOTDIR):\n            raise\n\n",
      "start_line": 202,
      "end_line": 211,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "def is_ipv6(addr):\n    try:\n        socket.inet_pton(socket.AF_INET6, addr)\n    except OSError:  # not a valid address\n        return False\n    except ValueError:  # ipv6 not supported on this platform\n        return False\n    return True\n\n",
      "start_line": 211,
      "end_line": 221,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "def parse_address(netloc, default_port='8000'):\n    if re.match(r'unix:(//)?', netloc):\n        return re.split(r'unix:(//)?', netloc)[-1]\n\n    if netloc.startswith(\"fd://\"):\n        fd = netloc[5:]\n        try:\n            return int(fd)\n        except ValueError:\n            raise RuntimeError(\"%r is not a valid file descriptor.\" % fd) from None\n\n    if netloc.startswith(\"tcp://\"):\n        netloc = netloc.split(\"tcp://\")[1]\n    host, port = netloc, default_port\n\n    if '[' in netloc and ']' in netloc:\n        host = netloc.split(']')[0][1:]\n        port = (netloc.split(']:') + [default_port])[1]\n    elif ':' in netloc:\n        host, port = (netloc.split(':') + [default_port])[:2]\n    elif netloc == \"\":\n        host, port = \"0.0.0.0\", default_port\n\n    try:\n        port = int(port)\n    except ValueError:\n        raise RuntimeError(\"%r is not a valid port number.\" % port)\n\n    return host.lower(), port\n\n",
      "start_line": 221,
      "end_line": 252,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "def close_on_exec(fd):\n    flags = fcntl.fcntl(fd, fcntl.F_GETFD)\n    flags |= fcntl.FD_CLOEXEC\n    fcntl.fcntl(fd, fcntl.F_SETFD, flags)\n\n",
      "start_line": 252,
      "end_line": 258,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "def set_non_blocking(fd):\n    flags = fcntl.fcntl(fd, fcntl.F_GETFL) | os.O_NONBLOCK\n    fcntl.fcntl(fd, fcntl.F_SETFL, flags)\n\n",
      "start_line": 258,
      "end_line": 263,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "def close(sock):\n    try:\n        sock.close()\n    except OSError:\n        pass\n\n\ntry:\n    from os import closerange\nexcept ImportError:",
      "start_line": 263,
      "end_line": 273,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "    def closerange(fd_low, fd_high):\n        # Iterate through and close all file descriptors.\n        for fd in range(fd_low, fd_high):\n            try:\n                os.close(fd)\n            except OSError:  # ERROR, fd wasn't open to begin with (ignored)\n                pass\n\n",
      "start_line": 273,
      "end_line": 282,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "def write_chunk(sock, data):\n    if isinstance(data, str):\n        data = data.encode('utf-8')\n    chunk_size = \"%X\\r\\n\" % len(data)\n    chunk = b\"\".join([chunk_size.encode('utf-8'), data, b\"\\r\\n\"])\n    sock.sendall(chunk)\n\n",
      "start_line": 282,
      "end_line": 290,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "def write(sock, data, chunked=False):\n    if chunked:\n        return write_chunk(sock, data)\n    sock.sendall(data)\n\n",
      "start_line": 290,
      "end_line": 296,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "def write_nonblock(sock, data, chunked=False):\n    timeout = sock.gettimeout()\n    if timeout != 0.0:\n        try:\n            sock.setblocking(0)\n            return write(sock, data, chunked)\n        finally:\n            sock.setblocking(1)\n    else:\n        return write(sock, data, chunked)\n\n",
      "start_line": 296,
      "end_line": 308,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "def write_error(sock, status_int, reason, mesg):\n    html_error = textwrap.dedent(\"\"\"\\\n    <html>\n      <head>\n        <title>%(reason)s</title>\n      </head>\n      <body>\n        <h1><p>%(reason)s</p></h1>\n        %(mesg)s\n      </body>\n    </html>\n    \"\"\") % {\"reason\": reason, \"mesg\": html.escape(mesg)}\n\n    http = textwrap.dedent(\"\"\"\\\n    HTTP/1.1 %s %s\\r\n    Connection: close\\r\n    Content-Type: text/html\\r\n    Content-Length: %d\\r\n    \\r\n    %s\"\"\") % (str(status_int), reason, len(html_error), html_error)\n    write_nonblock(sock, http.encode('latin1'))\n\n",
      "start_line": 308,
      "end_line": 331,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "def _called_with_wrong_args(f):\n    \"\"\"Check whether calling a function raised a ``TypeError`` because\n    the call failed or because something in the function raised the\n    error.\n\n    :param f: The function that was called.\n    :return: ``True`` if the call failed.\n    \"\"\"\n    tb = sys.exc_info()[2]\n\n    try:\n        while tb is not None:\n            if tb.tb_frame.f_code is f.__code__:\n                # In the function, it was called successfully.\n                return False\n\n            tb = tb.tb_next\n\n        # Didn't reach the function.\n        return True\n    finally:\n        # Delete tb to break a circular reference in Python 2.\n        # https://docs.python.org/2/library/sys.html#sys.exc_info\n        del tb\n\n",
      "start_line": 331,
      "end_line": 357,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "def import_app(module):\n    parts = module.split(\":\", 1)\n    if len(parts) == 1:\n        obj = \"application\"\n    else:\n        module, obj = parts[0], parts[1]\n\n    try:\n        mod = importlib.import_module(module)\n    except ImportError:\n        if module.endswith(\".py\") and os.path.exists(module):\n            msg = \"Failed to find application, did you mean '%s:%s'?\"\n            raise ImportError(msg % (module.rsplit(\".\", 1)[0], obj))\n        raise\n\n    # Parse obj as a single expression to determine if it's a valid\n    # attribute name or function call.\n    try:\n        expression = ast.parse(obj, mode=\"eval\").body\n    except SyntaxError:\n        raise AppImportError(\n            \"Failed to parse %r as an attribute name or function call.\" % obj\n        )\n\n    if isinstance(expression, ast.Name):\n        name = expression.id\n        args = kwargs = None\n    elif isinstance(expression, ast.Call):\n        # Ensure the function name is an attribute name only.\n        if not isinstance(expression.func, ast.Name):\n            raise AppImportError(\"Function reference must be a simple name: %r\" % obj)\n\n        name = expression.func.id\n\n        # Parse the positional and keyword arguments as literals.\n        try:\n            args = [ast.literal_eval(arg) for arg in expression.args]\n            kwargs = {kw.arg: ast.literal_eval(kw.value) for kw in expression.keywords}\n        except ValueError:\n            # literal_eval gives cryptic error messages, show a generic\n            # message with the full expression instead.\n            raise AppImportError(\n                \"Failed to parse arguments as literal values: %r\" % obj\n            )\n    else:\n        raise AppImportError(\n            \"Failed to parse %r as an attribute name or function call.\" % obj\n        )\n\n    is_debug = logging.root.level == logging.DEBUG\n    try:\n        app = getattr(mod, name)\n    except AttributeError:\n        if is_debug:\n            traceback.print_exception(*sys.exc_info())\n        raise AppImportError(\"Failed to find attribute %r in %r.\" % (name, module))\n\n    # If the expression was a function call, call the retrieved object\n    # to get the real application.\n    if args is not None:\n        try:\n            app = app(*args, **kwargs)\n        except TypeError as e:\n            # If the TypeError was due to bad arguments to the factory\n            # function, show Python's nice error message without a\n            # traceback.\n            if _called_with_wrong_args(app):\n                raise AppImportError(\n                    \"\".join(traceback.format_exception_only(TypeError, e)).strip()\n                )\n\n            # Otherwise it was raised from within the function, show the\n            # full traceback.\n            raise\n\n    if app is None:\n        raise AppImportError(\"Failed to find application object: %r\" % obj)\n\n    if not callable(app):\n        raise AppImportError(\"Application object must be callable.\")\n    return app\n\n",
      "start_line": 357,
      "end_line": 440,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "def getcwd():\n    # get current path, try to use PWD env first\n    try:\n        a = os.stat(os.environ['PWD'])\n        b = os.stat(os.getcwd())\n        if a.st_ino == b.st_ino and a.st_dev == b.st_dev:\n            cwd = os.environ['PWD']\n        else:\n            cwd = os.getcwd()\n    except Exception:\n        cwd = os.getcwd()\n    return cwd\n\n",
      "start_line": 440,
      "end_line": 454,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "def http_date(timestamp=None):\n    \"\"\"Return the current date and time formatted for a message header.\"\"\"\n    if timestamp is None:\n        timestamp = time.time()\n    s = email.utils.formatdate(timestamp, localtime=False, usegmt=True)\n    return s\n\n",
      "start_line": 454,
      "end_line": 462,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "def is_hoppish(header):\n    return header.lower().strip() in hop_headers\n\n",
      "start_line": 462,
      "end_line": 466,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "def daemonize(enable_stdio_inheritance=False):\n    \"\"\"\\\n    Standard daemonization of a process.\n    http://www.faqs.org/faqs/unix-faq/programmer/faq/ section 1.7\n    \"\"\"\n    if 'GUNICORN_FD' not in os.environ:\n        if os.fork():\n            os._exit(0)\n        os.setsid()\n\n        if os.fork():\n            os._exit(0)\n\n        os.umask(0o22)\n\n        # In both the following any file descriptors above stdin\n        # stdout and stderr are left untouched. The inheritance\n        # option simply allows one to have output go to a file\n        # specified by way of shell redirection when not wanting\n        # to use --error-log option.\n\n        if not enable_stdio_inheritance:\n            # Remap all of stdin, stdout and stderr on to\n            # /dev/null. The expectation is that users have\n            # specified the --error-log option.\n\n            closerange(0, 3)\n\n            fd_null = os.open(REDIRECT_TO, os.O_RDWR)\n            # PEP 446, make fd for /dev/null inheritable\n            os.set_inheritable(fd_null, True)\n\n            # expect fd_null to be always 0 here, but in-case not ...\n            if fd_null != 0:\n                os.dup2(fd_null, 0)\n\n            os.dup2(fd_null, 1)\n            os.dup2(fd_null, 2)\n\n        else:\n            fd_null = os.open(REDIRECT_TO, os.O_RDWR)\n\n            # Always redirect stdin to /dev/null as we would\n            # never expect to need to read interactive input.\n\n            if fd_null != 0:\n                os.close(0)\n                os.dup2(fd_null, 0)\n\n            # If stdout and stderr are still connected to\n            # their original file descriptors we check to see\n            # if they are associated with terminal devices.\n            # When they are we map them to /dev/null so that\n            # are still detached from any controlling terminal\n            # properly. If not we preserve them as they are.\n            #\n            # If stdin and stdout were not hooked up to the\n            # original file descriptors, then all bets are\n            # off and all we can really do is leave them as\n            # they were.\n            #\n            # This will allow 'gunicorn ... > output.log 2>&1'\n            # to work with stdout/stderr going to the file\n            # as expected.\n            #\n            # Note that if using --error-log option, the log\n            # file specified through shell redirection will\n            # only be used up until the log file specified\n            # by the option takes over. As it replaces stdout\n            # and stderr at the file descriptor level, then\n            # anything using stdout or stderr, including having\n            # cached a reference to them, will still work.\n",
      "start_line": 466,
      "end_line": 539,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "            def redirect(stream, fd_expect):\n                try:\n                    fd = stream.fileno()\n                    if fd == fd_expect and stream.isatty():\n                        os.close(fd)\n                        os.dup2(fd_null, fd)\n                except AttributeError:\n                    pass\n\n            redirect(sys.stdout, 1)\n            redirect(sys.stderr, 2)\n\n",
      "start_line": 539,
      "end_line": 552,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "def seed():\n    try:\n        random.seed(os.urandom(64))\n    except NotImplementedError:\n        random.seed('%s.%s' % (time.time(), os.getpid()))\n\n",
      "start_line": 552,
      "end_line": 559,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "def check_is_writable(path):\n    try:\n        with open(path, 'a') as f:\n            f.close()\n    except OSError as e:\n        raise RuntimeError(\"Error: '%s' isn't writable [%r]\" % (path, e))\n\n",
      "start_line": 559,
      "end_line": 567,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "def to_bytestring(value, encoding=\"utf8\"):\n    \"\"\"Converts a string argument to a byte string\"\"\"\n    if isinstance(value, bytes):\n        return value\n    if not isinstance(value, str):\n        raise TypeError('%r is not a string' % value)\n\n    return value.encode(encoding)\n\n",
      "start_line": 567,
      "end_line": 577,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "def has_fileno(obj):\n    if not hasattr(obj, \"fileno\"):\n        return False\n\n    # check BytesIO case and maybe others\n    try:\n        obj.fileno()\n    except (AttributeError, OSError, io.UnsupportedOperation):\n        return False\n\n    return True\n\n",
      "start_line": 577,
      "end_line": 590,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "def warn(msg):\n    print(\"!!!\", file=sys.stderr)\n\n    lines = msg.splitlines()\n    for i, line in enumerate(lines):\n        if i == 0:\n            line = \"WARNING: %s\" % line\n        print(\"!!! %s\" % line, file=sys.stderr)\n\n    print(\"!!!\\n\", file=sys.stderr)\n    sys.stderr.flush()\n\n",
      "start_line": 590,
      "end_line": 603,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "def make_fail_app(msg):\n    msg = to_bytestring(msg)\n",
      "start_line": 603,
      "end_line": 606,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "    def app(environ, start_response):\n        start_response(\"500 Internal Server Error\", [\n            (\"Content-Type\", \"text/plain\"),\n            (\"Content-Length\", str(len(msg)))\n        ])\n        return [msg]\n\n    return app\n\n",
      "start_line": 606,
      "end_line": 616,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "def split_request_uri(uri):\n    if uri.startswith(\"//\"):\n        # When the path starts with //, urlsplit considers it as a\n        # relative uri while the RFC says we should consider it as abs_path\n        # http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.2\n        # We use temporary dot prefix to workaround this behaviour\n        parts = urllib.parse.urlsplit(\".\" + uri)\n        return parts._replace(path=parts.path[1:])\n\n    return urllib.parse.urlsplit(uri)\n\n\n# From six.reraise",
      "start_line": 616,
      "end_line": 629,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "def reraise(tp, value, tb=None):\n    try:\n        if value is None:\n            value = tp()\n        if value.__traceback__ is not tb:\n            raise value.with_traceback(tb)\n        raise value\n    finally:\n        value = None\n        tb = None\n\n",
      "start_line": 629,
      "end_line": 641,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "def bytes_to_str(b):\n    if isinstance(b, str):\n        return b\n    return str(b, 'latin1')\n\n",
      "start_line": 641,
      "end_line": 647,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "def unquote_to_wsgi_str(string):\n    return urllib.parse.unquote_to_bytes(string).decode('latin-1')",
      "start_line": 647,
      "end_line": 649,
      "source_file": "gunicorn/util.py",
      "chunk_type": "code"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\nimport os\nimport socket\n\nSD_LISTEN_FDS_START = 3\n\n",
      "start_line": 0,
      "end_line": 10,
      "source_file": "gunicorn/systemd.py",
      "chunk_type": "code"
    },
    {
      "content": "def listen_fds(unset_environment=True):\n    \"\"\"\n    Get the number of sockets inherited from systemd socket activation.\n\n    :param unset_environment: clear systemd environment variables unless False\n    :type unset_environment: bool\n    :return: the number of sockets to inherit from systemd socket activation\n    :rtype: int\n\n    Returns zero immediately if $LISTEN_PID is not set to the current pid.\n    Otherwise, returns the number of systemd activation sockets specified by\n    $LISTEN_FDS.\n\n    When $LISTEN_PID matches the current pid, unsets the environment variables\n    unless the ``unset_environment`` flag is ``False``.\n\n    .. note::\n        Unlike the sd_listen_fds C function, this implementation does not set\n        the FD_CLOEXEC flag because the gunicorn arbiter never needs to do this.\n\n    .. seealso::\n        `<https://www.freedesktop.org/software/systemd/man/sd_listen_fds.html>`_\n\n    \"\"\"\n    fds = int(os.environ.get('LISTEN_FDS', 0))\n    listen_pid = int(os.environ.get('LISTEN_PID', 0))\n\n    if listen_pid != os.getpid():\n        return 0\n\n    if unset_environment:\n        os.environ.pop('LISTEN_PID', None)\n        os.environ.pop('LISTEN_FDS', None)\n\n    return fds\n\n",
      "start_line": 10,
      "end_line": 47,
      "source_file": "gunicorn/systemd.py",
      "chunk_type": "code"
    },
    {
      "content": "def sd_notify(state, logger, unset_environment=False):\n    \"\"\"Send a notification to systemd. state is a string; see\n    the man page of sd_notify (http://www.freedesktop.org/software/systemd/man/sd_notify.html)\n    for a description of the allowable values.\n\n    If the unset_environment parameter is True, sd_notify() will unset\n    the $NOTIFY_SOCKET environment variable before returning (regardless of\n    whether the function call itself succeeded or not). Further calls to\n    sd_notify() will then fail, but the variable is no longer inherited by\n    child processes.\n    \"\"\"\n\n    addr = os.environ.get('NOTIFY_SOCKET')\n    if addr is None:\n        # not run in a service, just a noop\n        return\n    try:\n        sock = socket.socket(socket.AF_UNIX, socket.SOCK_DGRAM | socket.SOCK_CLOEXEC)\n        if addr[0] == '@':\n            addr = '\\0' + addr[1:]\n        sock.connect(addr)\n        sock.sendall(state.encode('utf-8'))\n    except Exception:\n        logger.debug(\"Exception while invoking sd_notify()\", exc_info=True)\n    finally:\n        if unset_environment:\n            os.environ.pop('NOTIFY_SOCKET')\n        sock.close()",
      "start_line": 47,
      "end_line": 75,
      "source_file": "gunicorn/systemd.py",
      "chunk_type": "code"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\nversion_info = (23, 0, 0)\n__version__ = \".\".join([str(v) for v in version_info])\nSERVER = \"gunicorn\"\nSERVER_SOFTWARE = \"%s/%s\" % (SERVER, __version__)",
      "start_line": 0,
      "end_line": 8,
      "source_file": "gunicorn/__init__.py",
      "chunk_type": "code"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\nimport errno\nimport os\nimport socket\nimport ssl\nimport stat\nimport sys\nimport time\n\nfrom gunicorn import util\n\n",
      "start_line": 0,
      "end_line": 15,
      "source_file": "gunicorn/sock.py",
      "chunk_type": "code"
    },
    {
      "content": "class BaseSocket:\n",
      "start_line": 15,
      "end_line": 17,
      "source_file": "gunicorn/sock.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, address, conf, log, fd=None):\n        self.log = log\n        self.conf = conf\n\n        self.cfg_addr = address\n        if fd is None:\n            sock = socket.socket(self.FAMILY, socket.SOCK_STREAM)\n            bound = False\n        else:\n            sock = socket.fromfd(fd, self.FAMILY, socket.SOCK_STREAM)\n            os.close(fd)\n            bound = True\n\n        self.sock = self.set_options(sock, bound=bound)\n",
      "start_line": 17,
      "end_line": 32,
      "source_file": "gunicorn/sock.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __str__(self):\n        return \"<socket %d>\" % self.sock.fileno()\n",
      "start_line": 32,
      "end_line": 35,
      "source_file": "gunicorn/sock.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __getattr__(self, name):\n        return getattr(self.sock, name)\n",
      "start_line": 35,
      "end_line": 38,
      "source_file": "gunicorn/sock.py",
      "chunk_type": "code"
    },
    {
      "content": "    def set_options(self, sock, bound=False):\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        if (self.conf.reuse_port\n                and hasattr(socket, 'SO_REUSEPORT')):  # pragma: no cover\n            try:\n                sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n            except OSError as err:\n                if err.errno not in (errno.ENOPROTOOPT, errno.EINVAL):\n                    raise\n        if not bound:\n            self.bind(sock)\n        sock.setblocking(0)\n\n        # make sure that the socket can be inherited\n        if hasattr(sock, \"set_inheritable\"):\n            sock.set_inheritable(True)\n\n        sock.listen(self.conf.backlog)\n        return sock\n",
      "start_line": 38,
      "end_line": 58,
      "source_file": "gunicorn/sock.py",
      "chunk_type": "code"
    },
    {
      "content": "    def bind(self, sock):\n        sock.bind(self.cfg_addr)\n",
      "start_line": 58,
      "end_line": 61,
      "source_file": "gunicorn/sock.py",
      "chunk_type": "code"
    },
    {
      "content": "    def close(self):\n        if self.sock is None:\n            return\n\n        try:\n            self.sock.close()\n        except OSError as e:\n            self.log.info(\"Error while closing socket %s\", str(e))\n\n        self.sock = None\n\n",
      "start_line": 61,
      "end_line": 73,
      "source_file": "gunicorn/sock.py",
      "chunk_type": "code"
    },
    {
      "content": "class TCPSocket(BaseSocket):\n\n    FAMILY = socket.AF_INET\n",
      "start_line": 73,
      "end_line": 77,
      "source_file": "gunicorn/sock.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __str__(self):\n        if self.conf.is_ssl:\n            scheme = \"https\"\n        else:\n            scheme = \"http\"\n\n        addr = self.sock.getsockname()\n        return \"%s://%s:%d\" % (scheme, addr[0], addr[1])\n",
      "start_line": 77,
      "end_line": 86,
      "source_file": "gunicorn/sock.py",
      "chunk_type": "code"
    },
    {
      "content": "    def set_options(self, sock, bound=False):\n        sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n        return super().set_options(sock, bound=bound)\n\n",
      "start_line": 86,
      "end_line": 91,
      "source_file": "gunicorn/sock.py",
      "chunk_type": "code"
    },
    {
      "content": "class TCP6Socket(TCPSocket):\n\n    FAMILY = socket.AF_INET6\n",
      "start_line": 91,
      "end_line": 95,
      "source_file": "gunicorn/sock.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __str__(self):\n        (host, port, _, _) = self.sock.getsockname()\n        return \"http://[%s]:%d\" % (host, port)\n\n",
      "start_line": 95,
      "end_line": 100,
      "source_file": "gunicorn/sock.py",
      "chunk_type": "code"
    },
    {
      "content": "class UnixSocket(BaseSocket):\n\n    FAMILY = socket.AF_UNIX\n",
      "start_line": 100,
      "end_line": 104,
      "source_file": "gunicorn/sock.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, addr, conf, log, fd=None):\n        if fd is None:\n            try:\n                st = os.stat(addr)\n            except OSError as e:\n                if e.args[0] != errno.ENOENT:\n                    raise\n            else:\n                if stat.S_ISSOCK(st.st_mode):\n                    os.remove(addr)\n                else:\n                    raise ValueError(\"%r is not a socket\" % addr)\n        super().__init__(addr, conf, log, fd=fd)\n",
      "start_line": 104,
      "end_line": 118,
      "source_file": "gunicorn/sock.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __str__(self):\n        return \"unix:%s\" % self.cfg_addr\n",
      "start_line": 118,
      "end_line": 121,
      "source_file": "gunicorn/sock.py",
      "chunk_type": "code"
    },
    {
      "content": "    def bind(self, sock):\n        old_umask = os.umask(self.conf.umask)\n        sock.bind(self.cfg_addr)\n        util.chown(self.cfg_addr, self.conf.uid, self.conf.gid)\n        os.umask(old_umask)\n\n",
      "start_line": 121,
      "end_line": 128,
      "source_file": "gunicorn/sock.py",
      "chunk_type": "code"
    },
    {
      "content": "def _sock_type(addr):\n    if isinstance(addr, tuple):\n        if util.is_ipv6(addr[0]):\n            sock_type = TCP6Socket\n        else:\n            sock_type = TCPSocket\n    elif isinstance(addr, (str, bytes)):\n        sock_type = UnixSocket\n    else:\n        raise TypeError(\"Unable to create socket from: %r\" % addr)\n    return sock_type\n\n",
      "start_line": 128,
      "end_line": 141,
      "source_file": "gunicorn/sock.py",
      "chunk_type": "code"
    },
    {
      "content": "def create_sockets(conf, log, fds=None):\n    \"\"\"\n    Create a new socket for the configured addresses or file descriptors.\n\n    If a configured address is a tuple then a TCP socket is created.\n    If it is a string, a Unix socket is created. Otherwise, a TypeError is\n    raised.\n    \"\"\"\n    listeners = []\n\n    # get it only once\n    addr = conf.address\n    fdaddr = [bind for bind in addr if isinstance(bind, int)]\n    if fds:\n        fdaddr += list(fds)\n    laddr = [bind for bind in addr if not isinstance(bind, int)]\n\n    # check ssl config early to raise the error on startup\n    # only the certfile is needed since it can contains the keyfile\n    if conf.certfile and not os.path.exists(conf.certfile):\n        raise ValueError('certfile \"%s\" does not exist' % conf.certfile)\n\n    if conf.keyfile and not os.path.exists(conf.keyfile):\n        raise ValueError('keyfile \"%s\" does not exist' % conf.keyfile)\n\n    # sockets are already bound\n    if fdaddr:\n        for fd in fdaddr:\n            sock = socket.fromfd(fd, socket.AF_UNIX, socket.SOCK_STREAM)\n            sock_name = sock.getsockname()\n            sock_type = _sock_type(sock_name)\n            listener = sock_type(sock_name, conf, log, fd=fd)\n            listeners.append(listener)\n\n        return listeners\n\n    # no sockets is bound, first initialization of gunicorn in this env.\n    for addr in laddr:\n        sock_type = _sock_type(addr)\n        sock = None\n        for i in range(5):\n            try:\n                sock = sock_type(addr, conf, log)\n            except OSError as e:\n                if e.args[0] == errno.EADDRINUSE:\n                    log.error(\"Connection in use: %s\", str(addr))\n                if e.args[0] == errno.EADDRNOTAVAIL:\n                    log.error(\"Invalid address: %s\", str(addr))\n                msg = \"connection to {addr} failed: {error}\"\n                log.error(msg.format(addr=str(addr), error=str(e)))\n                if i < 5:\n                    log.debug(\"Retrying in 1 second.\")\n                    time.sleep(1)\n            else:\n                break\n\n        if sock is None:\n            log.error(\"Can't connect to %s\", str(addr))\n            sys.exit(1)\n\n        listeners.append(sock)\n\n    return listeners\n\n",
      "start_line": 141,
      "end_line": 206,
      "source_file": "gunicorn/sock.py",
      "chunk_type": "code"
    },
    {
      "content": "def close_sockets(listeners, unlink=True):\n    for sock in listeners:\n        sock_name = sock.getsockname()\n        sock.close()\n        if unlink and _sock_type(sock_name) is UnixSocket:\n            os.unlink(sock_name)\n\n",
      "start_line": 206,
      "end_line": 214,
      "source_file": "gunicorn/sock.py",
      "chunk_type": "code"
    },
    {
      "content": "def ssl_context(conf):",
      "start_line": 214,
      "end_line": 215,
      "source_file": "gunicorn/sock.py",
      "chunk_type": "code"
    },
    {
      "content": "    def default_ssl_context_factory():\n        context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH, cafile=conf.ca_certs)\n        context.load_cert_chain(certfile=conf.certfile, keyfile=conf.keyfile)\n        context.verify_mode = conf.cert_reqs\n        if conf.ciphers:\n            context.set_ciphers(conf.ciphers)\n        return context\n\n    return conf.ssl_context(conf, default_ssl_context_factory)\n\n",
      "start_line": 215,
      "end_line": 226,
      "source_file": "gunicorn/sock.py",
      "chunk_type": "code"
    },
    {
      "content": "def ssl_wrap_socket(sock, conf):\n    return ssl_context(conf).wrap_socket(sock,\n                                         server_side=True,\n                                         suppress_ragged_eofs=conf.suppress_ragged_eofs,\n                                         do_handshake_on_connect=conf.do_handshake_on_connect)",
      "start_line": 226,
      "end_line": 231,
      "source_file": "gunicorn/sock.py",
      "chunk_type": "code"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\n\"\"\"The debug module contains utilities and functions for better\ndebugging Gunicorn.\"\"\"\n\nimport sys\nimport linecache\nimport re\nimport inspect\n\n__all__ = ['spew', 'unspew']\n\n_token_spliter = re.compile(r'\\W+')\n\n",
      "start_line": 0,
      "end_line": 17,
      "source_file": "gunicorn/debug.py",
      "chunk_type": "code"
    },
    {
      "content": "class Spew:\n",
      "start_line": 17,
      "end_line": 19,
      "source_file": "gunicorn/debug.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, trace_names=None, show_values=True):\n        self.trace_names = trace_names\n        self.show_values = show_values\n",
      "start_line": 19,
      "end_line": 23,
      "source_file": "gunicorn/debug.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __call__(self, frame, event, arg):\n        if event == 'line':\n            lineno = frame.f_lineno\n            if '__file__' in frame.f_globals:\n                filename = frame.f_globals['__file__']\n                if (filename.endswith('.pyc') or\n                        filename.endswith('.pyo')):\n                    filename = filename[:-1]\n                name = frame.f_globals['__name__']\n                line = linecache.getline(filename, lineno)\n            else:\n                name = '[unknown]'\n                try:\n                    src = inspect.getsourcelines(frame)\n                    line = src[lineno]\n                except OSError:\n                    line = 'Unknown code named [%s].  VM instruction #%d' % (\n                        frame.f_code.co_name, frame.f_lasti)\n            if self.trace_names is None or name in self.trace_names:\n                print('%s:%s: %s' % (name, lineno, line.rstrip()))\n                if not self.show_values:\n                    return self\n                details = []\n                tokens = _token_spliter.split(line)\n                for tok in tokens:\n                    if tok in frame.f_globals:\n                        details.append('%s=%r' % (tok, frame.f_globals[tok]))\n                    if tok in frame.f_locals:\n                        details.append('%s=%r' % (tok, frame.f_locals[tok]))\n                if details:\n                    print(\"\\t%s\" % ' '.join(details))\n        return self\n\n",
      "start_line": 23,
      "end_line": 57,
      "source_file": "gunicorn/debug.py",
      "chunk_type": "code"
    },
    {
      "content": "def spew(trace_names=None, show_values=False):\n    \"\"\"Install a trace hook which writes incredibly detailed logs\n    about what code is being executed to stdout.\n    \"\"\"\n    sys.settrace(Spew(trace_names, show_values))\n\n",
      "start_line": 57,
      "end_line": 64,
      "source_file": "gunicorn/debug.py",
      "chunk_type": "code"
    },
    {
      "content": "def unspew():\n    \"\"\"Remove the trace hook installed by spew.\n    \"\"\"\n    sys.settrace(None)",
      "start_line": 64,
      "end_line": 68,
      "source_file": "gunicorn/debug.py",
      "chunk_type": "code"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\nimport errno\nimport os\nimport random\nimport select\nimport signal\nimport sys\nimport time\nimport traceback\nimport socket\n\nfrom gunicorn.errors import HaltServer, AppImportError\nfrom gunicorn.pidfile import Pidfile\nfrom gunicorn import sock, systemd, util\n\nfrom gunicorn import __version__, SERVER_SOFTWARE\n\n",
      "start_line": 0,
      "end_line": 20,
      "source_file": "gunicorn/arbiter.py",
      "chunk_type": "code"
    },
    {
      "content": "class Arbiter:\n    \"\"\"\n    Arbiter maintain the workers processes alive. It launches or\n    kills them if needed. It also manages application reloading\n    via SIGHUP/USR2.\n    \"\"\"\n\n    # A flag indicating if a worker failed to\n    # to boot. If a worker process exist with\n    # this error code, the arbiter will terminate.\n    WORKER_BOOT_ERROR = 3\n\n    # A flag indicating if an application failed to be loaded\n    APP_LOAD_ERROR = 4\n\n    START_CTX = {}\n\n    LISTENERS = []\n    WORKERS = {}\n    PIPE = []\n\n    # I love dynamic languages\n    SIG_QUEUE = []\n    SIGNALS = [getattr(signal, \"SIG%s\" % x)\n               for x in \"HUP QUIT INT TERM TTIN TTOU USR1 USR2 WINCH\".split()]\n    SIG_NAMES = dict(\n        (getattr(signal, name), name[3:].lower()) for name in dir(signal)\n        if name[:3] == \"SIG\" and name[3] != \"_\"\n    )\n",
      "start_line": 20,
      "end_line": 50,
      "source_file": "gunicorn/arbiter.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, app):\n        os.environ[\"SERVER_SOFTWARE\"] = SERVER_SOFTWARE\n\n        self._num_workers = None\n        self._last_logged_active_worker_count = None\n        self.log = None\n\n        self.setup(app)\n\n        self.pidfile = None\n        self.systemd = False\n        self.worker_age = 0\n        self.reexec_pid = 0\n        self.master_pid = 0\n        self.master_name = \"Master\"\n\n        cwd = util.getcwd()\n\n        args = sys.argv[:]\n        args.insert(0, sys.executable)\n\n        # init start context\n        self.START_CTX = {\n            \"args\": args,\n            \"cwd\": cwd,\n            0: sys.executable\n        }\n",
      "start_line": 50,
      "end_line": 78,
      "source_file": "gunicorn/arbiter.py",
      "chunk_type": "code"
    },
    {
      "content": "    def _get_num_workers(self):\n        return self._num_workers\n",
      "start_line": 78,
      "end_line": 81,
      "source_file": "gunicorn/arbiter.py",
      "chunk_type": "code"
    },
    {
      "content": "    def _set_num_workers(self, value):\n        old_value = self._num_workers\n        self._num_workers = value\n        self.cfg.nworkers_changed(self, value, old_value)\n    num_workers = property(_get_num_workers, _set_num_workers)\n",
      "start_line": 81,
      "end_line": 87,
      "source_file": "gunicorn/arbiter.py",
      "chunk_type": "code"
    },
    {
      "content": "    def setup(self, app):\n        self.app = app\n        self.cfg = app.cfg\n\n        if self.log is None:\n            self.log = self.cfg.logger_class(app.cfg)\n\n        # reopen files\n        if 'GUNICORN_PID' in os.environ:\n            self.log.reopen_files()\n\n        self.worker_class = self.cfg.worker_class\n        self.address = self.cfg.address\n        self.num_workers = self.cfg.workers\n        self.timeout = self.cfg.timeout\n        self.proc_name = self.cfg.proc_name\n\n        self.log.debug('Current configuration:\\n{0}'.format(\n            '\\n'.join(\n                '  {0}: {1}'.format(config, value.value)\n                for config, value\n                in sorted(self.cfg.settings.items(),\n                          key=lambda setting: setting[1]))))\n\n        # set environment' variables\n        if self.cfg.env:\n            for k, v in self.cfg.env.items():\n                os.environ[k] = v\n\n        if self.cfg.preload_app:\n            self.app.wsgi()\n",
      "start_line": 87,
      "end_line": 119,
      "source_file": "gunicorn/arbiter.py",
      "chunk_type": "code"
    },
    {
      "content": "    def start(self):\n        \"\"\"\\\n        Initialize the arbiter. Start listening and set pidfile if needed.\n        \"\"\"\n        self.log.info(\"Starting gunicorn %s\", __version__)\n\n        if 'GUNICORN_PID' in os.environ:\n            self.master_pid = int(os.environ.get('GUNICORN_PID'))\n            self.proc_name = self.proc_name + \".2\"\n            self.master_name = \"Master.2\"\n\n        self.pid = os.getpid()\n        if self.cfg.pidfile is not None:\n            pidname = self.cfg.pidfile\n            if self.master_pid != 0:\n                pidname += \".2\"\n            self.pidfile = Pidfile(pidname)\n            self.pidfile.create(self.pid)\n        self.cfg.on_starting(self)\n\n        self.init_signals()\n\n        if not self.LISTENERS:\n            fds = None\n            listen_fds = systemd.listen_fds()\n            if listen_fds:\n                self.systemd = True\n                fds = range(systemd.SD_LISTEN_FDS_START,\n                            systemd.SD_LISTEN_FDS_START + listen_fds)\n\n            elif self.master_pid:\n                fds = []\n                for fd in os.environ.pop('GUNICORN_FD').split(','):\n                    fds.append(int(fd))\n\n            if not (self.cfg.reuse_port and hasattr(socket, 'SO_REUSEPORT')):\n                self.LISTENERS = sock.create_sockets(self.cfg, self.log, fds)\n\n        listeners_str = \",\".join([str(lnr) for lnr in self.LISTENERS])\n        self.log.debug(\"Arbiter booted\")\n        self.log.info(\"Listening at: %s (%s)\", listeners_str, self.pid)\n        self.log.info(\"Using worker: %s\", self.cfg.worker_class_str)\n        systemd.sd_notify(\"READY=1\\nSTATUS=Gunicorn arbiter booted\", self.log)\n\n        # check worker class requirements\n        if hasattr(self.worker_class, \"check_config\"):\n            self.worker_class.check_config(self.cfg, self.log)\n\n        self.cfg.when_ready(self)\n",
      "start_line": 119,
      "end_line": 169,
      "source_file": "gunicorn/arbiter.py",
      "chunk_type": "code"
    },
    {
      "content": "    def init_signals(self):\n        \"\"\"\\\n        Initialize master signal handling. Most of the signals\n        are queued. Child signals only wake up the master.\n        \"\"\"\n        # close old PIPE\n        for p in self.PIPE:\n            os.close(p)\n\n        # initialize the pipe\n        self.PIPE = pair = os.pipe()\n        for p in pair:\n            util.set_non_blocking(p)\n            util.close_on_exec(p)\n\n        self.log.close_on_exec()\n\n        # initialize all signals\n        for s in self.SIGNALS:\n            signal.signal(s, self.signal)\n        signal.signal(signal.SIGCHLD, self.handle_chld)\n",
      "start_line": 169,
      "end_line": 191,
      "source_file": "gunicorn/arbiter.py",
      "chunk_type": "code"
    },
    {
      "content": "    def signal(self, sig, frame):\n        if len(self.SIG_QUEUE) < 5:\n            self.SIG_QUEUE.append(sig)\n            self.wakeup()\n",
      "start_line": 191,
      "end_line": 196,
      "source_file": "gunicorn/arbiter.py",
      "chunk_type": "code"
    },
    {
      "content": "    def run(self):\n        \"Main master loop.\"\n        self.start()\n        util._setproctitle(\"master [%s]\" % self.proc_name)\n\n        try:\n            self.manage_workers()\n\n            while True:\n                self.maybe_promote_master()\n\n                sig = self.SIG_QUEUE.pop(0) if self.SIG_QUEUE else None\n                if sig is None:\n                    self.sleep()\n                    self.murder_workers()\n                    self.manage_workers()\n                    continue\n\n                if sig not in self.SIG_NAMES:\n                    self.log.info(\"Ignoring unknown signal: %s\", sig)\n                    continue\n\n                signame = self.SIG_NAMES.get(sig)\n                handler = getattr(self, \"handle_%s\" % signame, None)\n                if not handler:\n                    self.log.error(\"Unhandled signal: %s\", signame)\n                    continue\n                self.log.info(\"Handling signal: %s\", signame)\n                handler()\n                self.wakeup()\n        except (StopIteration, KeyboardInterrupt):\n            self.halt()\n        except HaltServer as inst:\n            self.halt(reason=inst.reason, exit_status=inst.exit_status)\n        except SystemExit:\n            raise\n        except Exception:\n            self.log.error(\"Unhandled exception in main loop\",\n                           exc_info=True)\n            self.stop(False)\n            if self.pidfile is not None:\n                self.pidfile.unlink()\n            sys.exit(-1)\n",
      "start_line": 196,
      "end_line": 240,
      "source_file": "gunicorn/arbiter.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_chld(self, sig, frame):\n        \"SIGCHLD handling\"\n        self.reap_workers()\n        self.wakeup()\n",
      "start_line": 240,
      "end_line": 245,
      "source_file": "gunicorn/arbiter.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_hup(self):\n        \"\"\"\\\n        HUP handling.\n        - Reload configuration\n        - Start the new worker processes with a new configuration\n        - Gracefully shutdown the old worker processes\n        \"\"\"\n        self.log.info(\"Hang up: %s\", self.master_name)\n        self.reload()\n",
      "start_line": 245,
      "end_line": 255,
      "source_file": "gunicorn/arbiter.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_term(self):\n        \"SIGTERM handling\"\n        raise StopIteration\n",
      "start_line": 255,
      "end_line": 259,
      "source_file": "gunicorn/arbiter.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_int(self):\n        \"SIGINT handling\"\n        self.stop(False)\n        raise StopIteration\n",
      "start_line": 259,
      "end_line": 264,
      "source_file": "gunicorn/arbiter.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_quit(self):\n        \"SIGQUIT handling\"\n        self.stop(False)\n        raise StopIteration\n",
      "start_line": 264,
      "end_line": 269,
      "source_file": "gunicorn/arbiter.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_ttin(self):\n        \"\"\"\\\n        SIGTTIN handling.\n        Increases the number of workers by one.\n        \"\"\"\n        self.num_workers += 1\n        self.manage_workers()\n",
      "start_line": 269,
      "end_line": 277,
      "source_file": "gunicorn/arbiter.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_ttou(self):\n        \"\"\"\\\n        SIGTTOU handling.\n        Decreases the number of workers by one.\n        \"\"\"\n        if self.num_workers <= 1:\n            return\n        self.num_workers -= 1\n        self.manage_workers()\n",
      "start_line": 277,
      "end_line": 287,
      "source_file": "gunicorn/arbiter.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_usr1(self):\n        \"\"\"\\\n        SIGUSR1 handling.\n        Kill all workers by sending them a SIGUSR1\n        \"\"\"\n        self.log.reopen_files()\n        self.kill_workers(signal.SIGUSR1)\n",
      "start_line": 287,
      "end_line": 295,
      "source_file": "gunicorn/arbiter.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_usr2(self):\n        \"\"\"\\\n        SIGUSR2 handling.\n        Creates a new arbiter/worker set as a fork of the current\n        arbiter without affecting old workers. Use this to do live\n        deployment with the ability to backout a change.\n        \"\"\"\n        self.reexec()\n",
      "start_line": 295,
      "end_line": 304,
      "source_file": "gunicorn/arbiter.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_winch(self):\n        \"\"\"SIGWINCH handling\"\"\"\n        if self.cfg.daemon:\n            self.log.info(\"graceful stop of workers\")\n            self.num_workers = 0\n            self.kill_workers(signal.SIGTERM)\n        else:\n            self.log.debug(\"SIGWINCH ignored. Not daemonized\")\n",
      "start_line": 304,
      "end_line": 313,
      "source_file": "gunicorn/arbiter.py",
      "chunk_type": "code"
    },
    {
      "content": "    def maybe_promote_master(self):\n        if self.master_pid == 0:\n            return\n\n        if self.master_pid != os.getppid():\n            self.log.info(\"Master has been promoted.\")\n            # reset master infos\n            self.master_name = \"Master\"\n            self.master_pid = 0\n            self.proc_name = self.cfg.proc_name\n            del os.environ['GUNICORN_PID']\n            # rename the pidfile\n            if self.pidfile is not None:\n                self.pidfile.rename(self.cfg.pidfile)\n            # reset proctitle\n            util._setproctitle(\"master [%s]\" % self.proc_name)\n",
      "start_line": 313,
      "end_line": 330,
      "source_file": "gunicorn/arbiter.py",
      "chunk_type": "code"
    },
    {
      "content": "    def wakeup(self):\n        \"\"\"\\\n        Wake up the arbiter by writing to the PIPE\n        \"\"\"\n        try:\n            os.write(self.PIPE[1], b'.')\n        except OSError as e:\n            if e.errno not in [errno.EAGAIN, errno.EINTR]:\n                raise\n",
      "start_line": 330,
      "end_line": 340,
      "source_file": "gunicorn/arbiter.py",
      "chunk_type": "code"
    },
    {
      "content": "    def halt(self, reason=None, exit_status=0):\n        \"\"\" halt arbiter \"\"\"\n        self.stop()\n\n        log_func = self.log.info if exit_status == 0 else self.log.error\n        log_func(\"Shutting down: %s\", self.master_name)\n        if reason is not None:\n            log_func(\"Reason: %s\", reason)\n\n        if self.pidfile is not None:\n            self.pidfile.unlink()\n        self.cfg.on_exit(self)\n        sys.exit(exit_status)\n",
      "start_line": 340,
      "end_line": 354,
      "source_file": "gunicorn/arbiter.py",
      "chunk_type": "code"
    },
    {
      "content": "    def sleep(self):\n        \"\"\"\\\n        Sleep until PIPE is readable or we timeout.\n        A readable PIPE means a signal occurred.\n        \"\"\"\n        try:\n            ready = select.select([self.PIPE[0]], [], [], 1.0)\n            if not ready[0]:\n                return\n            while os.read(self.PIPE[0], 1):\n                pass\n        except OSError as e:\n            # TODO: select.error is a subclass of OSError since Python 3.3.\n            error_number = getattr(e, 'errno', e.args[0])\n            if error_number not in [errno.EAGAIN, errno.EINTR]:\n                raise\n        except KeyboardInterrupt:\n            sys.exit()\n",
      "start_line": 354,
      "end_line": 373,
      "source_file": "gunicorn/arbiter.py",
      "chunk_type": "code"
    },
    {
      "content": "    def stop(self, graceful=True):\n        \"\"\"\\\n        Stop workers\n\n        :attr graceful: boolean, If True (the default) workers will be\n        killed gracefully  (ie. trying to wait for the current connection)\n        \"\"\"\n        unlink = (\n            self.reexec_pid == self.master_pid == 0\n            and not self.systemd\n            and not self.cfg.reuse_port\n        )\n        sock.close_sockets(self.LISTENERS, unlink)\n\n        self.LISTENERS = []\n        sig = signal.SIGTERM\n        if not graceful:\n            sig = signal.SIGQUIT\n        limit = time.time() + self.cfg.graceful_timeout\n        # instruct the workers to exit\n        self.kill_workers(sig)\n        # wait until the graceful timeout\n        while self.WORKERS and time.time() < limit:\n            time.sleep(0.1)\n\n        self.kill_workers(signal.SIGKILL)\n",
      "start_line": 373,
      "end_line": 400,
      "source_file": "gunicorn/arbiter.py",
      "chunk_type": "code"
    },
    {
      "content": "    def reexec(self):\n        \"\"\"\\\n        Relaunch the master and workers.\n        \"\"\"\n        if self.reexec_pid != 0:\n            self.log.warning(\"USR2 signal ignored. Child exists.\")\n            return\n\n        if self.master_pid != 0:\n            self.log.warning(\"USR2 signal ignored. Parent exists.\")\n            return\n\n        master_pid = os.getpid()\n        self.reexec_pid = os.fork()\n        if self.reexec_pid != 0:\n            return\n\n        self.cfg.pre_exec(self)\n\n        environ = self.cfg.env_orig.copy()\n        environ['GUNICORN_PID'] = str(master_pid)\n\n        if self.systemd:\n            environ['LISTEN_PID'] = str(os.getpid())\n            environ['LISTEN_FDS'] = str(len(self.LISTENERS))\n        else:\n            environ['GUNICORN_FD'] = ','.join(\n                str(lnr.fileno()) for lnr in self.LISTENERS)\n\n        os.chdir(self.START_CTX['cwd'])\n\n        # exec the process using the original environment\n        os.execvpe(self.START_CTX[0], self.START_CTX['args'], environ)\n",
      "start_line": 400,
      "end_line": 434,
      "source_file": "gunicorn/arbiter.py",
      "chunk_type": "code"
    },
    {
      "content": "    def reload(self):\n        old_address = self.cfg.address\n\n        # reset old environment\n        for k in self.cfg.env:\n            if k in self.cfg.env_orig:\n                # reset the key to the value it had before\n                # we launched gunicorn\n                os.environ[k] = self.cfg.env_orig[k]\n            else:\n                # delete the value set by gunicorn\n                try:\n                    del os.environ[k]\n                except KeyError:\n                    pass\n\n        # reload conf\n        self.app.reload()\n        self.setup(self.app)\n\n        # reopen log files\n        self.log.reopen_files()\n\n        # do we need to change listener ?\n        if old_address != self.cfg.address:\n            # close all listeners\n            for lnr in self.LISTENERS:\n                lnr.close()\n            # init new listeners\n            self.LISTENERS = sock.create_sockets(self.cfg, self.log)\n            listeners_str = \",\".join([str(lnr) for lnr in self.LISTENERS])\n            self.log.info(\"Listening at: %s\", listeners_str)\n\n        # do some actions on reload\n        self.cfg.on_reload(self)\n\n        # unlink pidfile\n        if self.pidfile is not None:\n            self.pidfile.unlink()\n\n        # create new pidfile\n        if self.cfg.pidfile is not None:\n            self.pidfile = Pidfile(self.cfg.pidfile)\n            self.pidfile.create(self.pid)\n\n        # set new proc_name\n        util._setproctitle(\"master [%s]\" % self.proc_name)\n\n        # spawn new workers\n        for _ in range(self.cfg.workers):\n            self.spawn_worker()\n\n        # manage workers\n        self.manage_workers()\n",
      "start_line": 434,
      "end_line": 489,
      "source_file": "gunicorn/arbiter.py",
      "chunk_type": "code"
    },
    {
      "content": "    def murder_workers(self):\n        \"\"\"\\\n        Kill unused/idle workers\n        \"\"\"\n        if not self.timeout:\n            return\n        workers = list(self.WORKERS.items())\n        for (pid, worker) in workers:\n            try:\n                if time.monotonic() - worker.tmp.last_update() <= self.timeout:\n                    continue\n            except (OSError, ValueError):\n                continue\n\n            if not worker.aborted:\n                self.log.critical(\"WORKER TIMEOUT (pid:%s)\", pid)\n                worker.aborted = True\n                self.kill_worker(pid, signal.SIGABRT)\n            else:\n                self.kill_worker(pid, signal.SIGKILL)\n",
      "start_line": 489,
      "end_line": 510,
      "source_file": "gunicorn/arbiter.py",
      "chunk_type": "code"
    },
    {
      "content": "    def reap_workers(self):\n        \"\"\"\\\n        Reap workers to avoid zombie processes\n        \"\"\"\n        try:\n            while True:\n                wpid, status = os.waitpid(-1, os.WNOHANG)\n                if not wpid:\n                    break\n                if self.reexec_pid == wpid:\n                    self.reexec_pid = 0\n                else:\n                    # A worker was terminated. If the termination reason was\n                    # that it could not boot, we'll shut it down to avoid\n                    # infinite start/stop cycles.\n                    exitcode = status >> 8\n                    if exitcode != 0:\n                        self.log.error('Worker (pid:%s) exited with code %s', wpid, exitcode)\n                    if exitcode == self.WORKER_BOOT_ERROR:\n                        reason = \"Worker failed to boot.\"\n                        raise HaltServer(reason, self.WORKER_BOOT_ERROR)\n                    if exitcode == self.APP_LOAD_ERROR:\n                        reason = \"App failed to load.\"\n                        raise HaltServer(reason, self.APP_LOAD_ERROR)\n\n                    if exitcode > 0:\n                        # If the exit code of the worker is greater than 0,\n                        # let the user know.\n                        self.log.error(\"Worker (pid:%s) exited with code %s.\",\n                                       wpid, exitcode)\n                    elif status > 0:\n                        # If the exit code of the worker is 0 and the status\n                        # is greater than 0, then it was most likely killed\n                        # via a signal.\n                        try:\n                            sig_name = signal.Signals(status).name\n                        except ValueError:\n                            sig_name = \"code {}\".format(status)\n                        msg = \"Worker (pid:{}) was sent {}!\".format(\n                            wpid, sig_name)\n\n                        # Additional hint for SIGKILL\n                        if status == signal.SIGKILL:\n                            msg += \" Perhaps out of memory?\"\n                        self.log.error(msg)\n\n                    worker = self.WORKERS.pop(wpid, None)\n                    if not worker:\n                        continue\n                    worker.tmp.close()\n                    self.cfg.child_exit(self, worker)\n        except OSError as e:\n            if e.errno != errno.ECHILD:\n                raise\n",
      "start_line": 510,
      "end_line": 565,
      "source_file": "gunicorn/arbiter.py",
      "chunk_type": "code"
    },
    {
      "content": "    def manage_workers(self):\n        \"\"\"\\\n        Maintain the number of workers by spawning or killing\n        as required.\n        \"\"\"\n        if len(self.WORKERS) < self.num_workers:\n            self.spawn_workers()\n\n        workers = self.WORKERS.items()\n        workers = sorted(workers, key=lambda w: w[1].age)\n        while len(workers) > self.num_workers:\n            (pid, _) = workers.pop(0)\n            self.kill_worker(pid, signal.SIGTERM)\n\n        active_worker_count = len(workers)\n        if self._last_logged_active_worker_count != active_worker_count:\n            self._last_logged_active_worker_count = active_worker_count\n            self.log.debug(\"{0} workers\".format(active_worker_count),\n                           extra={\"metric\": \"gunicorn.workers\",\n                                  \"value\": active_worker_count,\n                                  \"mtype\": \"gauge\"})\n",
      "start_line": 565,
      "end_line": 587,
      "source_file": "gunicorn/arbiter.py",
      "chunk_type": "code"
    },
    {
      "content": "    def spawn_worker(self):\n        self.worker_age += 1\n        worker = self.worker_class(self.worker_age, self.pid, self.LISTENERS,\n                                   self.app, self.timeout / 2.0,\n                                   self.cfg, self.log)\n        self.cfg.pre_fork(self, worker)\n        pid = os.fork()\n        if pid != 0:\n            worker.pid = pid\n            self.WORKERS[pid] = worker\n            return pid\n\n        # Do not inherit the temporary files of other workers\n        for sibling in self.WORKERS.values():\n            sibling.tmp.close()\n\n        # Process Child\n        worker.pid = os.getpid()\n        try:\n            util._setproctitle(\"worker [%s]\" % self.proc_name)\n            self.log.info(\"Booting worker with pid: %s\", worker.pid)\n            if self.cfg.reuse_port:\n                worker.sockets = sock.create_sockets(self.cfg, self.log)\n            self.cfg.post_fork(self, worker)\n            worker.init_process()\n            sys.exit(0)\n        except SystemExit:\n            raise\n        except AppImportError as e:\n            self.log.debug(\"Exception while loading the application\",\n                           exc_info=True)\n            print(\"%s\" % e, file=sys.stderr)\n            sys.stderr.flush()\n            sys.exit(self.APP_LOAD_ERROR)\n        except Exception:\n            self.log.exception(\"Exception in worker process\")\n            if not worker.booted:\n                sys.exit(self.WORKER_BOOT_ERROR)\n            sys.exit(-1)\n        finally:\n            self.log.info(\"Worker exiting (pid: %s)\", worker.pid)\n            try:\n                worker.tmp.close()\n                self.cfg.worker_exit(self, worker)\n            except Exception:\n                self.log.warning(\"Exception during worker exit:\\n%s\",\n                                 traceback.format_exc())\n",
      "start_line": 587,
      "end_line": 635,
      "source_file": "gunicorn/arbiter.py",
      "chunk_type": "code"
    },
    {
      "content": "    def spawn_workers(self):\n        \"\"\"\\\n        Spawn new workers as needed.\n\n        This is where a worker process leaves the main loop\n        of the master process.\n        \"\"\"\n\n        for _ in range(self.num_workers - len(self.WORKERS)):\n            self.spawn_worker()\n            time.sleep(0.1 * random.random())\n",
      "start_line": 635,
      "end_line": 647,
      "source_file": "gunicorn/arbiter.py",
      "chunk_type": "code"
    },
    {
      "content": "    def kill_workers(self, sig):\n        \"\"\"\\\n        Kill all workers with the signal `sig`\n        :attr sig: `signal.SIG*` value\n        \"\"\"\n        worker_pids = list(self.WORKERS.keys())\n        for pid in worker_pids:\n            self.kill_worker(pid, sig)\n",
      "start_line": 647,
      "end_line": 656,
      "source_file": "gunicorn/arbiter.py",
      "chunk_type": "code"
    },
    {
      "content": "    def kill_worker(self, pid, sig):\n        \"\"\"\\\n        Kill a worker\n\n        :attr pid: int, worker pid\n        :attr sig: `signal.SIG*` value\n         \"\"\"\n        try:\n            os.kill(pid, sig)\n        except OSError as e:\n            if e.errno == errno.ESRCH:\n                try:\n                    worker = self.WORKERS.pop(pid)\n                    worker.tmp.close()\n                    self.cfg.worker_exit(self, worker)\n                    return\n                except (KeyError, OSError):\n                    return\n            raise",
      "start_line": 656,
      "end_line": 675,
      "source_file": "gunicorn/arbiter.py",
      "chunk_type": "code"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\n# We don't need to call super() in __init__ methods of our\n# BaseException and Exception classes because we also define\n# our own __str__ methods so there is no need to pass 'message'\n# to the base class to get a meaningful output from 'str(exc)'.\n# pylint: disable=super-init-not-called\n\n\n# we inherit from BaseException here to make sure to not be caught\n# at application level",
      "start_line": 0,
      "end_line": 13,
      "source_file": "gunicorn/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "class HaltServer(BaseException):",
      "start_line": 13,
      "end_line": 14,
      "source_file": "gunicorn/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, reason, exit_status=1):\n        self.reason = reason\n        self.exit_status = exit_status\n",
      "start_line": 14,
      "end_line": 18,
      "source_file": "gunicorn/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __str__(self):\n        return \"<HaltServer %r %d>\" % (self.reason, self.exit_status)\n\n",
      "start_line": 18,
      "end_line": 22,
      "source_file": "gunicorn/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "class ConfigError(Exception):\n    \"\"\" Exception raised on config error \"\"\"\n\n",
      "start_line": 22,
      "end_line": 26,
      "source_file": "gunicorn/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "class AppImportError(Exception):\n    \"\"\" Exception raised when loading an application \"\"\"",
      "start_line": 26,
      "end_line": 28,
      "source_file": "gunicorn/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\nfrom gunicorn.app.wsgiapp import run\n\nif __name__ == \"__main__\":\n    # see config.py - argparse defaults to basename(argv[0]) == \"__main__.py\"\n    # todo: let runpy.run_module take care of argv[0] rewriting\n    run(prog=\"gunicorn\")",
      "start_line": 0,
      "end_line": 10,
      "source_file": "gunicorn/__main__.py",
      "chunk_type": "code"
    },
    {
      "content": "# Makefile for Sphinx documentation\n#\n# if you want to compare this file to current sphinx defaults, recreate it:\n# BUILDDIR=build sphinx-quickstart --sep --extensions=gunicorn_ext --templatedir=_templates --makefile --batchfile --no-use-make-mode --master=index\n\n# You can set these variables from the command line.\nPYTHON        = python\nSPHINXOPTS    =\nSPHINXBUILD   = sphinx-build\nPAPER         =\nBUILDDIR      = build\n\n# Internal variables.\nPAPEROPT_a4     = -D latex_paper_size=a4\nPAPEROPT_letter = -D latex_paper_size=letter\nALLSPHINXOPTS   = -d $(BUILDDIR)/doctrees $(PAPEROPT_$(PAPER)) $(SPHINXOPTS) source\n# the i18n builder cannot share the environment and doctrees with the others\nI18NSPHINXOPTS  = $(PAPEROPT_$(PAPER)) $(SPHINXOPTS) source\n\n.PHONY: help clean html htmlview dirhtml singlehtml pickle json htmlhelp qthelp devhelp epub latex latexpdf text man changes linkcheck doctest gettext\n\nhelp:\n\t@echo \"Please use \\`make <target>' where <target> is one of\"\n\t@echo \"  html       to make standalone HTML files\"\n\t@echo \"  htmlview   to open the index page built by the html target in your browser\"\n\t@echo \"  dirhtml    to make HTML files named index.html in directories\"\n\t@echo \"  singlehtml to make a single large HTML file\"\n\t@echo \"  pickle     to make pickle files\"\n\t@echo \"  json       to make JSON files\"\n\t@echo \"  htmlhelp   to make HTML files and a HTML help project\"\n\t@echo \"  qthelp     to make HTML files and a qthelp project\"\n\t@echo \"  devhelp    to make HTML files and a Devhelp project\"\n\t@echo \"  epub       to make an epub\"\n\t@echo \"  latex      to make LaTeX files, you can set PAPER=a4 or PAPER=letter\"\n\t@echo \"  latexpdf   to make LaTeX files and run them through pdflatex\"\n\t@echo \"  text       to make text files\"\n\t@echo \"  man        to make manual pages\"\n\t@echo \"  texinfo    to make Texinfo files\"\n\t@echo \"  info       to make Texinfo files and run them through makeinfo\"\n\t@echo \"  gettext    to make PO message catalogs\"\n\t@echo \"  changes    to make an overview of all changed/added/deprecated items\"\n\t@echo \"  linkcheck  to check all external links for integrity\"\n\t@echo \"  doctest    to run all doctests embedded in the documentation (if enabled)\"\n\nclean:\n\t-rm -rf $(BUILDDIR)/*\n\nhtml:\n\t$(SPHINXBUILD) -b html $(ALLSPHINXOPTS) $(BUILDDIR)/html\n\t@echo\n\t@echo \"Build finished. The HTML pages are in $(BUILDDIR)/html.\"\n\nhtmlview: html\n\t$(PYTHON) -c \"import webbrowser; webbrowser.open('build/html/index.html')\"\n\ndirhtml:\n\t$(SPHINXBUILD) -b dirhtml $(ALLSPHINXOPTS) $(BUILDDIR)/dirhtml\n\t@echo\n\t@echo \"Build finished. The HTML pages are in $(BUILDDIR)/dirhtml.\"\n\nsinglehtml:\n\t$(SPHINXBUILD) -b singlehtml $(ALLSPHINXOPTS) $(BUILDDIR)/singlehtml\n\t@echo\n\t@echo \"Build finished. The HTML page is in $(BUILDDIR)/singlehtml.\"\n\npickle:\n\t$(SPHINXBUILD) -b pickle $(ALLSPHINXOPTS) $(BUILDDIR)/pickle\n\t@echo\n\t@echo \"Build finished; now you can process the pickle files.\"\n\njson:\n\t$(SPHINXBUILD) -b json $(ALLSPHINXOPTS) $(BUILDDIR)/json\n\t@echo\n\t@echo \"Build finished; now you can process the JSON files.\"\n\nhtmlhelp:\n\t$(SPHINXBUILD) -b htmlhelp $(ALLSPHINXOPTS) $(BUILDDIR)/htmlhelp\n\t@echo\n\t@echo \"Build finished; now you can run HTML Help Workshop with the\" \\\n\t      \".hhp project file in $(BUILDDIR)/htmlhelp.\"\n\nqthelp:\n\t$(SPHINXBUILD) -b qthelp $(ALLSPHINXOPTS) $(BUILDDIR)/qthelp\n\t@echo\n\t@echo \"Build finished; now you can run \"qcollectiongenerator\" with the\" \\\n\t      \".qhcp project file in $(BUILDDIR)/qthelp, like this:\"\n\t@echo \"# qcollectiongenerator $(BUILDDIR)/qthelp/Gunicorn.qhcp\"\n\t@echo \"To view the help file:\"\n\t@echo \"# assistant -collectionFile $(BUILDDIR)/qthelp/Gunicorn.qhc\"\n\ndevhelp:\n\t$(SPHINXBUILD) -b devhelp $(ALLSPHINXOPTS) $(BUILDDIR)/devhelp\n\t@echo\n\t@echo \"Build finished.\"\n\t@echo \"To view the help file:\"\n\t@echo \"# mkdir -p $$HOME/.local/share/devhelp/Gunicorn\"\n\t@echo \"# ln -s $(BUILDDIR)/devhelp $$HOME/.local/share/devhelp/Gunicorn\"\n\t@echo \"# devhelp\"\n\nepub:\n\t$(SPHINXBUILD) -b epub $(ALLSPHINXOPTS) $(BUILDDIR)/epub\n\t@echo\n\t@echo \"Build finished. The epub file is in $(BUILDDIR)/epub.\"\n\nlatex:\n\t$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex\n\t@echo\n\t@echo \"Build finished; the LaTeX files are in $(BUILDDIR)/latex.\"\n\t@echo \"Run \\`make' in that directory to run these through (pdf)latex\" \\\n\t      \"(use \\`make latexpdf' here to do that automatically).\"\n\nlatexpdf:\n\t$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex\n\t@echo \"Running LaTeX files through pdflatex...\"\n\t$(MAKE) -C $(BUILDDIR)/latex all-pdf\n\t@echo \"pdflatex finished; the PDF files are in $(BUILDDIR)/latex.\"\n\ntext:\n\t$(SPHINXBUILD) -b text $(ALLSPHINXOPTS) $(BUILDDIR)/text\n\t@echo\n\t@echo \"Build finished. The text files are in $(BUILDDIR)/text.\"\n\nman:\n\t$(SPHINXBUILD) -b man $(ALLSPHINXOPTS) $(BUILDDIR)/man\n\t@echo\n\t@echo \"Build finished. The manual pages are in $(BUILDDIR)/man.\"\n\ntexinfo:\n\t$(SPHINXBUILD) -b texinfo $(ALLSPHINXOPTS) $(BUILDDIR)/texinfo\n\t@echo\n\t@echo \"Build finished. The Texinfo files are in $(BUILDDIR)/texinfo.\"\n\t@echo \"Run \\`make' in that directory to run these through makeinfo\" \\\n\t      \"(use \\`make info' here to do that automatically).\"\n\ninfo:\n\t$(SPHINXBUILD) -b texinfo $(ALLSPHINXOPTS) $(BUILDDIR)/texinfo\n\t@echo \"Running Texinfo files through makeinfo...\"\n\tmake -C $(BUILDDIR)/texinfo info\n\t@echo \"makeinfo finished; the Info files are in $(BUILDDIR)/texinfo.\"\n\ngettext:\n\t$(SPHINXBUILD) -b gettext $(I18NSPHINXOPTS) $(BUILDDIR)/locale\n\t@echo\n\t@echo \"Build finished. The message catalogs are in $(BUILDDIR)/locale.\"\n\nchanges:\n\t$(SPHINXBUILD) -b changes $(ALLSPHINXOPTS) $(BUILDDIR)/changes\n\t@echo\n\t@echo \"The overview file is in $(BUILDDIR)/changes.\"\n\nlinkcheck:\n\t$(SPHINXBUILD) -b linkcheck $(ALLSPHINXOPTS) $(BUILDDIR)/linkcheck\n\t@echo\n\t@echo \"Link check complete; look for any errors in the above output \" \\\n\t      \"or in $(BUILDDIR)/linkcheck/output.txt.\"\n\ndoctest:\n\t$(SPHINXBUILD) -b doctest $(ALLSPHINXOPTS) $(BUILDDIR)/doctest\n\t@echo \"Testing of doctests in the sources finished, look at the \" \\\n\t      \"results in $(BUILDDIR)/doctest/output.txt.\"\n",
      "source_file": "docs/Makefile",
      "chunk_type": "unknown"
    },
    {
      "content": "import os\nimport subprocess\nfrom xml.etree import ElementTree\n\n",
      "start_line": 0,
      "end_line": 5,
      "source_file": "docs/sitemap_gen.py",
      "chunk_type": "code"
    },
    {
      "content": "def main():\n    generate(\n        site_path=os.path.join(os.path.dirname(__file__), 'site'),\n        special_priorities={'index.html': 1.0})\n\n",
      "start_line": 5,
      "end_line": 11,
      "source_file": "docs/sitemap_gen.py",
      "chunk_type": "code"
    },
    {
      "content": "def generate(site_path, special_priorities, directory_index='index.html'):\n    urlset = ElementTree.Element('urlset', xmlns='http://www.sitemaps.org/schemas/sitemap/0.9')\n    urlset.text = '\\n '\n    for root, dirs, filenames in os.walk(site_path):\n        for filename in filenames:\n            if filename.endswith('.html'):\n                absolute_filepath = os.path.join(root, filename)\n                relative_path = os.path.relpath(absolute_filepath, site_path)\n                relative_url = os.path.dirname(relative_path) if filename == directory_index else relative_path\n                last_modification = subprocess.check_output(\n                    ['git', 'log', '-1', '--pretty=\"%cI\"', absolute_filepath]).decode('ascii').strip('\\n\"')\n                url_element = ElementTree.SubElement(urlset, 'url')\n                loc_element = ElementTree.SubElement(url_element, 'loc')\n                loc_element.text = 'http://gunicorn.org/' + relative_url\n                lastmod_element = ElementTree.SubElement(url_element, 'lastmod')\n                lastmod_element.text = last_modification\n                priority_element = ElementTree.SubElement(url_element, 'priority')\n                priority_element.text = str(special_priorities.get(relative_path, 0.5))\n                url_element.tail = priority_element.tail = '\\n '\n                url_element.text = loc_element.tail = lastmod_element.tail = '\\n  '\n    # We sort the url nodes instead of the filenames because\n    # filenames might be altered by the directory_index option\n    urlset[:] = sorted([url for url in urlset], key=lambda url: url[0].text)\n    urlset.tail = urlset[-1].tail = '\\n'\n    with open(os.path.join(site_path, 'sitemap.xml'), 'wb') as sitemap_file:\n        ElementTree.ElementTree(urlset).write(sitemap_file, encoding='UTF-8', xml_declaration=True)\n\n\nif __name__ == '__main__':\n    main()",
      "start_line": 11,
      "end_line": 41,
      "source_file": "docs/sitemap_gen.py",
      "chunk_type": "code"
    },
    {
      "content": "import os\nimport inspect\n\nfrom docutils import nodes, utils\n\nimport gunicorn.config as guncfg\n\nHEAD = \"\"\"\\\n.. Please update gunicorn/config.py instead.\n\n.. _settings:\n\nSettings\n========\n\nThis is an exhaustive list of settings for Gunicorn. Some settings are only\nable to be set from a configuration file. The setting name is what should be\nused in the configuration file. The command line arguments are listed as well\nfor reference on setting at the command line.\n\n.. note::\n\n    Settings can be specified by using environment variable\n    ``GUNICORN_CMD_ARGS``. All available command line arguments can be used.\n    For example, to specify the bind address and number of workers::\n\n        $ GUNICORN_CMD_ARGS=\"--bind=127.0.0.1 --workers=3\" gunicorn app:app\n\n    .. versionadded:: 19.7\n\n\"\"\"\nISSUE_URI = 'https://github.com/benoitc/gunicorn/issues/%s'\nPULL_REQUEST_URI = 'https://github.com/benoitc/gunicorn/pull/%s'\n\n",
      "start_line": 0,
      "end_line": 35,
      "source_file": "docs/gunicorn_ext.py",
      "chunk_type": "code"
    },
    {
      "content": "def format_settings(app):\n    settings_file = os.path.join(app.srcdir, \"settings.rst\")\n    ret = []\n    known_settings = sorted(guncfg.KNOWN_SETTINGS, key=lambda s: s.section)\n    for i, s in enumerate(known_settings):\n        if i == 0 or s.section != known_settings[i - 1].section:\n            ret.append(\"%s\\n%s\\n\\n\" % (s.section, \"-\" * len(s.section)))\n        ret.append(fmt_setting(s))\n\n    with open(settings_file, 'w') as settings:\n        settings.write(HEAD)\n        settings.write(''.join(ret))\n\n",
      "start_line": 35,
      "end_line": 49,
      "source_file": "docs/gunicorn_ext.py",
      "chunk_type": "code"
    },
    {
      "content": "def fmt_setting(s):\n    if hasattr(s, \"default_doc\"):\n        val = s.default_doc\n    elif callable(s.default):\n        val = inspect.getsource(s.default)\n        val = \"\\n\".join(\"    %s\" % line for line in val.splitlines())\n        val = \"\\n\\n.. code-block:: python\\n\\n\" + val\n    elif s.default == '':\n        val = \"``''``\"\n    else:\n        val = \"``%r``\" % s.default\n\n    if s.cli and s.meta:\n        cli = \" or \".join(\"``%s %s``\" % (arg, s.meta) for arg in s.cli)\n    elif s.cli:\n        cli = \" or \".join(\"``%s``\" % arg for arg in s.cli)\n    else:\n        cli = \"\"\n\n    out = []\n    out.append(\".. _%s:\\n\" % s.name.replace(\"_\", \"-\"))\n    out.append(\"``%s``\" % s.name)\n    out.append(\"~\" * (len(s.name) + 4))\n    out.append(\"\")\n    if s.cli:\n        out.append(\"**Command line:** %s\" % cli)\n        out.append(\"\")\n    out.append(\"**Default:** %s\" % val)\n    out.append(\"\")\n    out.append(s.desc)\n    out.append(\"\")\n    out.append(\"\")\n    return \"\\n\".join(out)\n\n",
      "start_line": 49,
      "end_line": 84,
      "source_file": "docs/gunicorn_ext.py",
      "chunk_type": "code"
    },
    {
      "content": "def issue_role(typ, rawtext, text, lineno, inliner, options={}, content=[]):\n    issue = utils.unescape(text)\n    text = 'issue ' + issue\n    refnode = nodes.reference(text, text, refuri=ISSUE_URI % issue)\n    return [refnode], []\n\n",
      "start_line": 84,
      "end_line": 91,
      "source_file": "docs/gunicorn_ext.py",
      "chunk_type": "code"
    },
    {
      "content": "def pull_request_role(typ, rawtext, text, lineno, inliner, options={}, content=[]):\n    issue = utils.unescape(text)\n    text = 'pull request ' + issue\n    refnode = nodes.reference(text, text, refuri=PULL_REQUEST_URI % issue)\n    return [refnode], []\n\n",
      "start_line": 91,
      "end_line": 98,
      "source_file": "docs/gunicorn_ext.py",
      "chunk_type": "code"
    },
    {
      "content": "def setup(app):\n    app.connect('builder-inited', format_settings)\n    app.add_role('issue', issue_role)\n    app.add_role('pr', pull_request_role)",
      "start_line": 98,
      "end_line": 102,
      "source_file": "docs/gunicorn_ext.py",
      "chunk_type": "code"
    },
    {
      "content": "@ECHO OFF\n\nREM Command file for Sphinx documentation\n\nif \"%SPHINXBUILD%\" == \"\" (\n\tset SPHINXBUILD=sphinx-build\n)\nset BUILDDIR=build\nset ALLSPHINXOPTS=-d %BUILDDIR%/doctrees %SPHINXOPTS% source\nset I18NSPHINXOPTS=%SPHINXOPTS% source\nif NOT \"%PAPER%\" == \"\" (\n\tset ALLSPHINXOPTS=-D latex_paper_size=%PAPER% %ALLSPHINXOPTS%\n\tset I18NSPHINXOPTS=-D latex_paper_size=%PAPER% %I18NSPHINXOPTS%\n)\n\nif \"%1\" == \"\" goto help\n\nif \"%1\" == \"help\" (\n\t:help\n\techo.Please use `make ^<target^>` where ^<target^> is one of\n\techo.  html       to make standalone HTML files\n\techo.  dirhtml    to make HTML files named index.html in directories\n\techo.  singlehtml to make a single large HTML file\n\techo.  pickle     to make pickle files\n\techo.  json       to make JSON files\n\techo.  htmlhelp   to make HTML files and a HTML help project\n\techo.  qthelp     to make HTML files and a qthelp project\n\techo.  devhelp    to make HTML files and a Devhelp project\n\techo.  epub       to make an epub\n\techo.  latex      to make LaTeX files, you can set PAPER=a4 or PAPER=letter\n\techo.  text       to make text files\n\techo.  man        to make manual pages\n\techo.  texinfo    to make Texinfo files\n\techo.  gettext    to make PO message catalogs\n\techo.  changes    to make an overview over all changed/added/deprecated items\n\techo.  linkcheck  to check all external links for integrity\n\techo.  doctest    to run all doctests embedded in the documentation if enabled\n\tgoto end\n)\n\nif \"%1\" == \"clean\" (\n\tfor /d %%i in (%BUILDDIR%\\*) do rmdir /q /s %%i\n\tdel /q /s %BUILDDIR%\\*\n\tgoto end\n)\n\nif \"%1\" == \"html\" (\n\t%SPHINXBUILD% -b html %ALLSPHINXOPTS% %BUILDDIR%/html\n\tif errorlevel 1 exit /b 1\n\techo.\n\techo.Build finished. The HTML pages are in %BUILDDIR%/html.\n\tgoto end\n)\n\nif \"%1\" == \"dirhtml\" (\n\t%SPHINXBUILD% -b dirhtml %ALLSPHINXOPTS% %BUILDDIR%/dirhtml\n\tif errorlevel 1 exit /b 1\n\techo.\n\techo.Build finished. The HTML pages are in %BUILDDIR%/dirhtml.\n\tgoto end\n)\n\nif \"%1\" == \"singlehtml\" (\n\t%SPHINXBUILD% -b singlehtml %ALLSPHINXOPTS% %BUILDDIR%/singlehtml\n\tif errorlevel 1 exit /b 1\n\techo.\n\techo.Build finished. The HTML pages are in %BUILDDIR%/singlehtml.\n\tgoto end\n)\n\nif \"%1\" == \"pickle\" (\n\t%SPHINXBUILD% -b pickle %ALLSPHINXOPTS% %BUILDDIR%/pickle\n\tif errorlevel 1 exit /b 1\n\techo.\n\techo.Build finished; now you can process the pickle files.\n\tgoto end\n)\n\nif \"%1\" == \"json\" (\n\t%SPHINXBUILD% -b json %ALLSPHINXOPTS% %BUILDDIR%/json\n\tif errorlevel 1 exit /b 1\n\techo.\n\techo.Build finished; now you can process the JSON files.\n\tgoto end\n)\n\nif \"%1\" == \"htmlhelp\" (\n\t%SPHINXBUILD% -b htmlhelp %ALLSPHINXOPTS% %BUILDDIR%/htmlhelp\n\tif errorlevel 1 exit /b 1\n\techo.\n\techo.Build finished; now you can run HTML Help Workshop with the ^\n.hhp project file in %BUILDDIR%/htmlhelp.\n\tgoto end\n)\n\nif \"%1\" == \"qthelp\" (\n\t%SPHINXBUILD% -b qthelp %ALLSPHINXOPTS% %BUILDDIR%/qthelp\n\tif errorlevel 1 exit /b 1\n\techo.\n\techo.Build finished; now you can run \"qcollectiongenerator\" with the ^\n.qhcp project file in %BUILDDIR%/qthelp, like this:\n\techo.^> qcollectiongenerator %BUILDDIR%\\qthelp\\Gunicorn.qhcp\n\techo.To view the help file:\n\techo.^> assistant -collectionFile %BUILDDIR%\\qthelp\\Gunicorn.ghc\n\tgoto end\n)\n\nif \"%1\" == \"devhelp\" (\n\t%SPHINXBUILD% -b devhelp %ALLSPHINXOPTS% %BUILDDIR%/devhelp\n\tif errorlevel 1 exit /b 1\n\techo.\n\techo.Build finished.\n\tgoto end\n)\n\nif \"%1\" == \"epub\" (\n\t%SPHINXBUILD% -b epub %ALLSPHINXOPTS% %BUILDDIR%/epub\n\tif errorlevel 1 exit /b 1\n\techo.\n\techo.Build finished. The epub file is in %BUILDDIR%/epub.\n\tgoto end\n)\n\nif \"%1\" == \"latex\" (\n\t%SPHINXBUILD% -b latex %ALLSPHINXOPTS% %BUILDDIR%/latex\n\tif errorlevel 1 exit /b 1\n\techo.\n\techo.Build finished; the LaTeX files are in %BUILDDIR%/latex.\n\tgoto end\n)\n\nif \"%1\" == \"text\" (\n\t%SPHINXBUILD% -b text %ALLSPHINXOPTS% %BUILDDIR%/text\n\tif errorlevel 1 exit /b 1\n\techo.\n\techo.Build finished. The text files are in %BUILDDIR%/text.\n\tgoto end\n)\n\nif \"%1\" == \"man\" (\n\t%SPHINXBUILD% -b man %ALLSPHINXOPTS% %BUILDDIR%/man\n\tif errorlevel 1 exit /b 1\n\techo.\n\techo.Build finished. The manual pages are in %BUILDDIR%/man.\n\tgoto end\n)\n\nif \"%1\" == \"texinfo\" (\n\t%SPHINXBUILD% -b texinfo %ALLSPHINXOPTS% %BUILDDIR%/texinfo\n\tif errorlevel 1 exit /b 1\n\techo.\n\techo.Build finished. The Texinfo files are in %BUILDDIR%/texinfo.\n\tgoto end\n)\n\nif \"%1\" == \"gettext\" (\n\t%SPHINXBUILD% -b gettext %I18NSPHINXOPTS% %BUILDDIR%/locale\n\tif errorlevel 1 exit /b 1\n\techo.\n\techo.Build finished. The message catalogs are in %BUILDDIR%/locale.\n\tgoto end\n)\n\nif \"%1\" == \"changes\" (\n\t%SPHINXBUILD% -b changes %ALLSPHINXOPTS% %BUILDDIR%/changes\n\tif errorlevel 1 exit /b 1\n\techo.\n\techo.The overview file is in %BUILDDIR%/changes.\n\tgoto end\n)\n\nif \"%1\" == \"linkcheck\" (\n\t%SPHINXBUILD% -b linkcheck %ALLSPHINXOPTS% %BUILDDIR%/linkcheck\n\tif errorlevel 1 exit /b 1\n\techo.\n\techo.Link check complete; look for any errors in the above output ^\nor in %BUILDDIR%/linkcheck/output.txt.\n\tgoto end\n)\n\nif \"%1\" == \"doctest\" (\n\t%SPHINXBUILD% -b doctest %ALLSPHINXOPTS% %BUILDDIR%/doctest\n\tif errorlevel 1 exit /b 1\n\techo.\n\techo.Testing of doctests in the sources finished, look at the ^\nresults in %BUILDDIR%/doctest/output.txt.\n\tgoto end\n)\n\n:end\n",
      "source_file": "docs/make.bat",
      "chunk_type": "unknown"
    },
    {
      "content": "Generate Documentation\n======================\n\nRequirements\n------------\n\nTo generate documentation you need to install:\n\n - Python >= 3.7\n - Sphinx (https://www.sphinx-doc.org/)\n\n\nGenerate html\n-------------\n::\n\n    $ make html\n\nThe command generates html document inside ``build/html`` dir.\n",
      "source_file": "docs/README.rst",
      "chunk_type": "doc"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\nimport re\n",
      "start_line": 0,
      "end_line": 6,
      "source_file": "examples/multidomainapp.py",
      "chunk_type": "code"
    },
    {
      "content": "class SubDomainApp:\n    \"\"\"WSGI application to delegate requests based on domain name.\n\"\"\"",
      "start_line": 6,
      "end_line": 9,
      "source_file": "examples/multidomainapp.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, mapping):\n        self.mapping = mapping\n",
      "start_line": 9,
      "end_line": 12,
      "source_file": "examples/multidomainapp.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __call__(self, environ, start_response):\n        host = environ.get(\"HTTP_HOST\", \"\")\n        host = host.split(\":\")[0]  # strip port\n\n        for pattern, app in self.mapping:\n            if re.match(\"^\" + pattern + \"$\", host):\n                return app(environ, start_response)\n        else:\n            start_response(\"404 Not Found\", [])\n            return [b\"\"]\n",
      "start_line": 12,
      "end_line": 23,
      "source_file": "examples/multidomainapp.py",
      "chunk_type": "code"
    },
    {
      "content": "def hello(environ, start_response):\n    start_response(\"200 OK\", [(\"Content-Type\", \"text/plain\")])\n    return [b\"Hello, world\\n\"]\n",
      "start_line": 23,
      "end_line": 27,
      "source_file": "examples/multidomainapp.py",
      "chunk_type": "code"
    },
    {
      "content": "def bye(environ, start_response):\n    start_response(\"200 OK\", [(\"Content-Type\", \"text/plain\")])\n    return [b\"Goodbye!\\n\"]\n\napp = SubDomainApp([\n    (\"localhost\", hello),\n    (\".*\", bye)\n])",
      "start_line": 27,
      "end_line": 35,
      "source_file": "examples/multidomainapp.py",
      "chunk_type": "code"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n#\n# Example code from Eventlet sources\n\nimport os\nfrom wsgiref.validate import validator\n\n\n# @validator  # breaks sendfile",
      "start_line": 0,
      "end_line": 11,
      "source_file": "examples/sendfile.py",
      "chunk_type": "code"
    },
    {
      "content": "def app(environ, start_response):\n    \"\"\"Simplest possible application object\"\"\"\n    status = '200 OK'\n    fname = os.path.join(os.path.dirname(__file__), \"hello.txt\")\n    f = open(fname, 'rb')\n\n    response_headers = [\n        ('Content-type', 'text/plain'),\n    ]\n    start_response(status, response_headers)\n\n    return environ['wsgi.file_wrapper'](f)",
      "start_line": 11,
      "end_line": 23,
      "source_file": "examples/sendfile.py",
      "chunk_type": "code"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\nimport sys\nimport time\n\n",
      "start_line": 0,
      "end_line": 8,
      "source_file": "examples/timeout.py",
      "chunk_type": "code"
    },
    {
      "content": "def app(environ, start_response):\n    \"\"\"Application which pauses 35 seconds before responding. the worker\n    will timeout in default case.\"\"\"\n    data = b'Hello, World!\\n'\n    status = '200 OK'\n    response_headers = [\n        ('Content-type', 'text/plain'),\n        ('Content-Length', str(len(data))),\n    ]\n    sys.stdout.write('request will timeout')\n    sys.stdout.flush()\n    time.sleep(35)\n    start_response(status, response_headers)\n    return iter([data])",
      "start_line": 8,
      "end_line": 22,
      "source_file": "examples/timeout.py",
      "chunk_type": "code"
    },
    {
      "content": "raise RuntimeError(\"Bad app!\")\n",
      "start_line": 0,
      "end_line": 2,
      "source_file": "examples/boot_fail.py",
      "chunk_type": "code"
    },
    {
      "content": "def app(environ, start_response):\n    assert 1 == 2, \"Shouldn't get here.\"",
      "start_line": 2,
      "end_line": 4,
      "source_file": "examples/boot_fail.py",
      "chunk_type": "code"
    },
    {
      "content": "\"\"\"\nUse this config file in your script like this:\n\n    $ gunicorn project_name.wsgi:application -c read_django_settings.py\n\"\"\"\n\nsettings_dict = {}\n\nwith open('frameworks/django/testing/testing/settings.py') as f:\n    exec(f.read(), settings_dict)\n\nloglevel = 'warning'\nproc_name = 'web-project'\nworkers = 1\n\nif settings_dict['DEBUG']:\n    loglevel = 'debug'\n    reload = True\n    proc_name += '_debug'",
      "start_line": 0,
      "end_line": 19,
      "source_file": "examples/read_django_settings.py",
      "chunk_type": "code"
    },
    {
      "content": "#\n# An example of how to pass information from the command line to\n# a WSGI app. Only applies to the native WSGI workers used by\n# Gunicorn sync (default) workers.\n#\n#   $ gunicorn 'alt_spec:load(arg)'\n#\n# Single quoting is generally necessary for shell escape semantics.\n#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n",
      "start_line": 0,
      "end_line": 12,
      "source_file": "examples/alt_spec.py",
      "chunk_type": "code"
    },
    {
      "content": "def load(arg):",
      "start_line": 12,
      "end_line": 13,
      "source_file": "examples/alt_spec.py",
      "chunk_type": "code"
    },
    {
      "content": "    def app(environ, start_response):\n        data = b'Hello, %s!\\n' % arg\n        status = '200 OK'\n        response_headers = [\n            ('Content-type', 'text/plain'),\n            ('Content-Length', str(len(data)))\n        ]\n        start_response(status, response_headers)\n        return iter([data])\n    return app",
      "start_line": 13,
      "end_line": 23,
      "source_file": "examples/alt_spec.py",
      "chunk_type": "code"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\n\nimport sys\nimport time\n",
      "start_line": 0,
      "end_line": 8,
      "source_file": "examples/longpoll.py",
      "chunk_type": "code"
    },
    {
      "content": "class TestIter:\n",
      "start_line": 8,
      "end_line": 10,
      "source_file": "examples/longpoll.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __iter__(self):\n        lines = [b'line 1\\n', b'line 2\\n']\n        for line in lines:\n            yield line\n            time.sleep(20)\n",
      "start_line": 10,
      "end_line": 16,
      "source_file": "examples/longpoll.py",
      "chunk_type": "code"
    },
    {
      "content": "def app(environ, start_response):\n    \"\"\"Application which cooperatively pauses 20 seconds (needed to surpass normal timeouts) before responding\"\"\"\n    status = '200 OK'\n    response_headers = [\n        ('Content-type', 'text/plain'),\n        ('Transfer-Encoding', \"chunked\"),\n    ]\n    sys.stdout.write('request received')\n    sys.stdout.flush()\n    start_response(status, response_headers)\n    return TestIter()",
      "start_line": 16,
      "end_line": 27,
      "source_file": "examples/longpoll.py",
      "chunk_type": "code"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n#\n# Run this application with:\n#\n#   $ gunicorn multiapp:app\n#\n# And then visit:\n#\n#   http://127.0.0.1:8000/app1url\n#   http://127.0.0.1:8000/app2url\n#   http://127.0.0.1:8000/this_is_a_404\n#\n\ntry:\n    from routes import Mapper\nexcept ImportError:\n    print(\"This example requires Routes to be installed\")\n\n# Obviously you'd import your app callables\n# from different places...\nfrom test import app as app1\nfrom test import app as app2\n\n",
      "start_line": 0,
      "end_line": 26,
      "source_file": "examples/multiapp.py",
      "chunk_type": "code"
    },
    {
      "content": "class Application:",
      "start_line": 26,
      "end_line": 27,
      "source_file": "examples/multiapp.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self):\n        self.map = Mapper()\n        self.map.connect('app1', '/app1url', app=app1)\n        self.map.connect('app2', '/app2url', app=app2)\n",
      "start_line": 27,
      "end_line": 32,
      "source_file": "examples/multiapp.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __call__(self, environ, start_response):\n        match = self.map.routematch(environ=environ)\n        if not match:\n            return self.error404(environ, start_response)\n        return match[0]['app'](environ, start_response)\n",
      "start_line": 32,
      "end_line": 38,
      "source_file": "examples/multiapp.py",
      "chunk_type": "code"
    },
    {
      "content": "    def error404(self, environ, start_response):\n        html = b\"\"\"\\\n        <html>\n          <head>\n            <title>404 - Not Found</title>\n          </head>\n          <body>\n            <h1>404 - Not Found</h1>\n          </body>\n        </html>\n        \"\"\"\n        headers = [\n            ('Content-Type', 'text/html'),\n            ('Content-Length', str(len(html)))\n        ]\n        start_response('404 Not Found', headers)\n        return [html]\n\napp = Application()",
      "start_line": 38,
      "end_line": 57,
      "source_file": "examples/multiapp.py",
      "chunk_type": "code"
    },
    {
      "content": "#!/usr/bin/env python\n#\n# An example of a standalone application using the internal API of Gunicorn.\n#\n#   $ python standalone_app.py\n#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\nimport multiprocessing\n\nimport gunicorn.app.base\n\n",
      "start_line": 0,
      "end_line": 14,
      "source_file": "examples/standalone_app.py",
      "chunk_type": "code"
    },
    {
      "content": "def number_of_workers():\n    return (multiprocessing.cpu_count() * 2) + 1\n\n",
      "start_line": 14,
      "end_line": 18,
      "source_file": "examples/standalone_app.py",
      "chunk_type": "code"
    },
    {
      "content": "def handler_app(environ, start_response):\n    response_body = b'Works fine'\n    status = '200 OK'\n\n    response_headers = [\n        ('Content-Type', 'text/plain'),\n    ]\n\n    start_response(status, response_headers)\n\n    return [response_body]\n\n",
      "start_line": 18,
      "end_line": 31,
      "source_file": "examples/standalone_app.py",
      "chunk_type": "code"
    },
    {
      "content": "class StandaloneApplication(gunicorn.app.base.BaseApplication):\n",
      "start_line": 31,
      "end_line": 33,
      "source_file": "examples/standalone_app.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, app, options=None):\n        self.options = options or {}\n        self.application = app\n        super().__init__()\n",
      "start_line": 33,
      "end_line": 38,
      "source_file": "examples/standalone_app.py",
      "chunk_type": "code"
    },
    {
      "content": "    def load_config(self):\n        config = {key: value for key, value in self.options.items()\n                  if key in self.cfg.settings and value is not None}\n        for key, value in config.items():\n            self.cfg.set(key.lower(), value)\n",
      "start_line": 38,
      "end_line": 44,
      "source_file": "examples/standalone_app.py",
      "chunk_type": "code"
    },
    {
      "content": "    def load(self):\n        return self.application\n\n\nif __name__ == '__main__':\n    options = {\n        'bind': '%s:%s' % ('127.0.0.1', '8080'),\n        'workers': number_of_workers(),\n    }\n    StandaloneApplication(handler_app, options).run()",
      "start_line": 44,
      "end_line": 54,
      "source_file": "examples/standalone_app.py",
      "chunk_type": "code"
    },
    {
      "content": "import signal\nimport commands\nimport threading\nimport time\n\nmax_mem = 100000\n",
      "start_line": 0,
      "end_line": 7,
      "source_file": "examples/when_ready.conf.py",
      "chunk_type": "code"
    },
    {
      "content": "class MemoryWatch(threading.Thread):\n",
      "start_line": 7,
      "end_line": 9,
      "source_file": "examples/when_ready.conf.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, server, max_mem):\n        super().__init__()\n        self.daemon = True\n        self.server = server\n        self.max_mem = max_mem\n        self.timeout = server.timeout / 2\n",
      "start_line": 9,
      "end_line": 16,
      "source_file": "examples/when_ready.conf.py",
      "chunk_type": "code"
    },
    {
      "content": "    def memory_usage(self, pid):\n        try:\n            out = commands.getoutput(\"ps -o rss -p %s\" % pid)\n        except OSError:\n            return -1\n        used_mem = sum(int(x) for x in out.split('\\n')[1:])\n        return used_mem\n",
      "start_line": 16,
      "end_line": 24,
      "source_file": "examples/when_ready.conf.py",
      "chunk_type": "code"
    },
    {
      "content": "    def run(self):\n        while True:\n            for (pid, worker) in list(self.server.WORKERS.items()):\n                if self.memory_usage(pid) > self.max_mem:\n                    self.server.log.info(\"Pid %s killed (memory usage > %s)\",\n                        pid, self.max_mem)\n                    self.server.kill_worker(pid, signal.SIGTERM)\n            time.sleep(self.timeout)\n\n",
      "start_line": 24,
      "end_line": 34,
      "source_file": "examples/when_ready.conf.py",
      "chunk_type": "code"
    },
    {
      "content": "def when_ready(server):\n    mw = MemoryWatch(server, max_mem)\n    mw.start()",
      "start_line": 34,
      "end_line": 37,
      "source_file": "examples/when_ready.conf.py",
      "chunk_type": "code"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n#\n# Simple example of readline, reading from a stream then echoing the response\n#\n# Usage:\n#\n# Launch a server with the app in a terminal\n#\n#     $ gunicorn -w3 readline_app:app\n#\n# Then in another terminal launch the following command:\n#\n#     $ curl -XPOST -d'test\\r\\ntest2\\r\\n' -H\"Transfer-Encoding: Chunked\" http://localhost:8000\n\n\n\nfrom gunicorn import __version__\n\n",
      "start_line": 0,
      "end_line": 21,
      "source_file": "examples/readline_app.py",
      "chunk_type": "code"
    },
    {
      "content": "def app(environ, start_response):\n    \"\"\"Simplest possible application object\"\"\"\n    status = '200 OK'\n\n    response_headers = [\n        ('Content-type', 'text/plain'),\n        ('Transfer-Encoding', \"chunked\"),\n        ('X-Gunicorn-Version', __version__)\n    ]\n    start_response(status, response_headers)\n\n    body = environ['wsgi.input']\n\n    lines = []\n    while True:\n        line = body.readline()\n        if line == b\"\":\n            break\n        print(line)\n        lines.append(line)\n\n    return iter(lines)",
      "start_line": 21,
      "end_line": 43,
      "source_file": "examples/readline_app.py",
      "chunk_type": "code"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\nimport sys\nimport time\n\n",
      "start_line": 0,
      "end_line": 8,
      "source_file": "examples/slowclient.py",
      "chunk_type": "code"
    },
    {
      "content": "def app(environ, start_response):\n    \"\"\"Application which cooperatively pauses 10 seconds before responding\"\"\"\n    data = b'Hello, World!\\n'\n    status = '200 OK'\n    response_headers = [\n        ('Content-type', 'text/plain'),\n        ('Content-Length', str(len(data))),\n    ]\n    sys.stdout.write('request received, pausing 10 seconds')\n    sys.stdout.flush()\n    time.sleep(10)\n    start_response(status, response_headers)\n    return iter([data])",
      "start_line": 8,
      "end_line": 21,
      "source_file": "examples/slowclient.py",
      "chunk_type": "code"
    },
    {
      "content": "#!/bin/sh\n\nGUNICORN=/usr/local/bin/gunicorn\nROOT=/path/to/project\nPID=/var/run/gunicorn.pid\n\nAPP=main:application\n\nif [ -f $PID ]; then rm $PID; fi\n\ncd $ROOT\nexec $GUNICORN -c $ROOT/gunicorn.conf.py --pid=$PID $APP\n",
      "source_file": "examples/gunicorn_rc",
      "chunk_type": "unknown"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n#\n# Example code from Eventlet sources\n\nfrom gunicorn import __version__\n\n",
      "start_line": 0,
      "end_line": 9,
      "source_file": "examples/echo.py",
      "chunk_type": "code"
    },
    {
      "content": "def app(environ, start_response):\n    \"\"\"Simplest possible application object\"\"\"\n\n    if environ['REQUEST_METHOD'].upper() != 'POST':\n        data = b'Hello, World!\\n'\n    else:\n        data = environ['wsgi.input'].read()\n\n    status = '200 OK'\n\n    response_headers = [\n        ('Content-type', 'text/plain'),\n        ('Content-Length', str(len(data))),\n        ('X-Gunicorn-Version', __version__)\n    ]\n    start_response(status, response_headers)\n    return iter([data])",
      "start_line": 9,
      "end_line": 26,
      "source_file": "examples/echo.py",
      "chunk_type": "code"
    },
    {
      "content": "Hello world!\n",
      "source_file": "examples/hello.txt",
      "chunk_type": "doc"
    },
    {
      "content": "import tempfile\nfiles = []",
      "start_line": 0,
      "end_line": 2,
      "source_file": "examples/bad.py",
      "chunk_type": "code"
    },
    {
      "content": "def app(environ, start_response):\n    files.append(tempfile.mkstemp())\n    start_response('200 OK', [('Content-type', 'text/plain'), ('Content-length', '2')])\n    return ['ok']",
      "start_line": 2,
      "end_line": 6,
      "source_file": "examples/bad.py",
      "chunk_type": "code"
    },
    {
      "content": "#!/usr/bin/env python\n# Usage: git log --format=\"%an <%ae>\" | python update_thanks.py\n# You will get a result.txt file, you can work with the file (update, remove, ...)\n#\n# Install\n# =======\n# pip install validate_email pyDNS\n#\nimport sys\n\nfrom validate_email import validate_email\nfrom email.utils import parseaddr\nimport DNS.Base\n\naddresses = set()\nbad_addresses = set()\ncollection = []\n\nlines = list(reversed(sys.stdin.readlines()))\n\nfor author in map(str.strip, lines):\n    realname, email_address = parseaddr(author)\n\n    if email_address not in addresses:\n        if email_address in bad_addresses:\n            continue\n        else:\n            try:\n                value = validate_email(email_address)\n                if value:\n                    addresses.add(email_address)\n                    collection.append(author)\n                else:\n                    bad_addresses.add(email_address)\n            except DNS.Base.TimeoutError:\n                bad_addresses.add(email_address)\n\n\nwith open('result.txt', 'w') as output:\n    output.write('\\n'.join(collection))",
      "start_line": 0,
      "end_line": 40,
      "source_file": "scripts/update_thanks.py",
      "chunk_type": "code"
    },
    {
      "content": "import collections\nimport errno\nimport re\nimport hashlib\nimport base64\nfrom base64 import b64encode, b64decode\nimport socket\nimport struct\nimport logging\nfrom socket import error as SocketError\n\nimport gevent\nfrom gunicorn.workers.base_async import ALREADY_HANDLED\n\nlogger = logging.getLogger(__name__)\n\nWS_KEY = b\"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\"\n",
      "start_line": 0,
      "end_line": 18,
      "source_file": "examples/websocket/gevent_websocket.py",
      "chunk_type": "code"
    },
    {
      "content": "class WebSocketWSGI:",
      "start_line": 18,
      "end_line": 19,
      "source_file": "examples/websocket/gevent_websocket.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, handler):\n        self.handler = handler\n",
      "start_line": 19,
      "end_line": 22,
      "source_file": "examples/websocket/gevent_websocket.py",
      "chunk_type": "code"
    },
    {
      "content": "    def verify_client(self, ws):\n        pass\n",
      "start_line": 22,
      "end_line": 25,
      "source_file": "examples/websocket/gevent_websocket.py",
      "chunk_type": "code"
    },
    {
      "content": "    def _get_key_value(self, key_value):\n        if not key_value:\n            return\n        key_number = int(re.sub(\"\\\\D\", \"\", key_value))\n        spaces = re.subn(\" \", \"\", key_value)[1]\n        if key_number % spaces != 0:\n            return\n        part = key_number / spaces\n        return part\n",
      "start_line": 25,
      "end_line": 35,
      "source_file": "examples/websocket/gevent_websocket.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __call__(self, environ, start_response):\n        if not (environ.get('HTTP_CONNECTION').find('Upgrade') != -1 and\n            environ['HTTP_UPGRADE'].lower() == 'websocket'):\n            # need to check a few more things here for true compliance\n            start_response('400 Bad Request', [('Connection','close')])\n            return []\n\n        sock = environ['gunicorn.socket']\n\n        version = environ.get('HTTP_SEC_WEBSOCKET_VERSION')\n\n        ws = WebSocket(sock, environ, version)\n\n        handshake_reply = (\"HTTP/1.1 101 Switching Protocols\\r\\n\"\n                   \"Upgrade: websocket\\r\\n\"\n                   \"Connection: Upgrade\\r\\n\")\n\n        key = environ.get('HTTP_SEC_WEBSOCKET_KEY')\n        if key:\n            ws_key = base64.b64decode(key)\n            if len(ws_key) != 16:\n                start_response('400 Bad Request', [('Connection','close')])\n                return []\n\n            protocols = []\n            subprotocols = environ.get('HTTP_SEC_WEBSOCKET_PROTOCOL')\n            ws_protocols = []\n            if subprotocols:\n                for s in subprotocols.split(','):\n                    s = s.strip()\n                    if s in protocols:\n                        ws_protocols.append(s)\n            if ws_protocols:\n                handshake_reply += 'Sec-WebSocket-Protocol: %s\\r\\n' % ', '.join(ws_protocols)\n\n            exts = []\n            extensions = environ.get('HTTP_SEC_WEBSOCKET_EXTENSIONS')\n            ws_extensions = []\n            if extensions:\n                for ext in extensions.split(','):\n                    ext = ext.strip()\n                    if ext in exts:\n                        ws_extensions.append(ext)\n            if ws_extensions:\n                handshake_reply += 'Sec-WebSocket-Extensions: %s\\r\\n' % ', '.join(ws_extensions)\n\n            key_hash = hashlib.sha1()\n            key_hash.update(key.encode())\n            key_hash.update(WS_KEY)\n\n            handshake_reply +=  (\n                \"Sec-WebSocket-Origin: %s\\r\\n\"\n                \"Sec-WebSocket-Location: ws://%s%s\\r\\n\"\n                \"Sec-WebSocket-Version: %s\\r\\n\"\n                \"Sec-WebSocket-Accept: %s\\r\\n\\r\\n\"\n                 % (\n                    environ.get('HTTP_ORIGIN'),\n                    environ.get('HTTP_HOST'),\n                    ws.path,\n                    version,\n                    base64.b64encode(key_hash.digest()).decode()\n                ))\n\n        else:\n\n            handshake_reply += (\n                       \"WebSocket-Origin: %s\\r\\n\"\n                       \"WebSocket-Location: ws://%s%s\\r\\n\\r\\n\" % (\n                            environ.get('HTTP_ORIGIN'),\n                            environ.get('HTTP_HOST'),\n                            ws.path))\n\n        sock.sendall(handshake_reply.encode())\n\n        try:\n            self.handler(ws)\n        except BrokenPipeError:\n            pass\n        else:\n            raise\n        # use this undocumented feature of grainbows to ensure that it\n        # doesn't barf on the fact that we didn't call start_response\n        return ALREADY_HANDLED\n",
      "start_line": 35,
      "end_line": 119,
      "source_file": "examples/websocket/gevent_websocket.py",
      "chunk_type": "code"
    },
    {
      "content": "class WebSocket:\n    \"\"\"A websocket object that handles the details of\n    serialization/deserialization to the socket.\n\n    The primary way to interact with a :class:`WebSocket` object is to\n    call :meth:`send` and :meth:`wait` in order to pass messages back\n    and forth with the browser.  Also available are the following\n    properties:\n\n    path\n        The path value of the request.  This is the same as the WSGI PATH_INFO variable, but more convenient.\n    protocol\n        The value of the Websocket-Protocol header.\n    origin\n        The value of the 'Origin' header.\n    environ\n        The full WSGI environment for this request.\n\n    \"\"\"",
      "start_line": 119,
      "end_line": 138,
      "source_file": "examples/websocket/gevent_websocket.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, sock, environ, version=76):\n        \"\"\"\n        :param socket: The eventlet socket\n        :type socket: :class:`eventlet.greenio.GreenSocket`\n        :param environ: The wsgi environment\n        :param version: The WebSocket spec version to follow (default is 76)\n        \"\"\"\n        self.socket = sock\n        self.origin = environ.get('HTTP_ORIGIN')\n        self.protocol = environ.get('HTTP_WEBSOCKET_PROTOCOL')\n        self.path = environ.get('PATH_INFO')\n        self.environ = environ\n        self.version = version\n        self.websocket_closed = False\n        self._buf = \"\"\n        self._msgs = collections.deque()\n        #self._sendlock = semaphore.Semaphore()\n\n    @staticmethod",
      "start_line": 138,
      "end_line": 157,
      "source_file": "examples/websocket/gevent_websocket.py",
      "chunk_type": "code"
    },
    {
      "content": "    def encode_hybi(buf, opcode, base64=False):\n        \"\"\" Encode a HyBi style WebSocket frame.\n        Optional opcode:\n            0x0 - continuation\n            0x1 - text frame (base64 encode buf)\n            0x2 - binary frame (use raw buf)\n            0x8 - connection close\n            0x9 - ping\n            0xA - pong\n        \"\"\"\n        if base64:\n            buf = b64encode(buf)\n        else:\n            buf = buf.encode()\n\n        b1 = 0x80 | (opcode & 0x0f) # FIN + opcode\n        payload_len = len(buf)\n        if payload_len <= 125:\n            header = struct.pack('>BB', b1, payload_len)\n        elif payload_len > 125 and payload_len < 65536:\n            header = struct.pack('>BBH', b1, 126, payload_len)\n        elif payload_len >= 65536:\n            header = struct.pack('>BBQ', b1, 127, payload_len)\n\n        #print(\"Encoded: %s\" % repr(header + buf))\n\n        return header + buf, len(header), 0\n\n    @staticmethod",
      "start_line": 157,
      "end_line": 186,
      "source_file": "examples/websocket/gevent_websocket.py",
      "chunk_type": "code"
    },
    {
      "content": "    def decode_hybi(buf, base64=False):\n        \"\"\" Decode HyBi style WebSocket packets.\n        Returns:\n            {'fin'          : 0_or_1,\n             'opcode'       : number,\n             'mask'         : 32_bit_number,\n             'hlen'         : header_bytes_number,\n             'length'       : payload_bytes_number,\n             'payload'      : decoded_buffer,\n             'left'         : bytes_left_number,\n             'close_code'   : number,\n             'close_reason' : string}\n        \"\"\"\n\n        f = {'fin'          : 0,\n             'opcode'       : 0,\n             'mask'         : 0,\n             'hlen'         : 2,\n             'length'       : 0,\n             'payload'      : None,\n             'left'         : 0,\n             'close_code'   : None,\n             'close_reason' : None}\n\n        blen = len(buf)\n        f['left'] = blen\n\n        if blen < f['hlen']:\n            return f # Incomplete frame header\n\n        b1, b2 = struct.unpack_from(\">BB\", buf)\n        f['opcode'] = b1 & 0x0f\n        f['fin'] = (b1 & 0x80) >> 7\n        has_mask = (b2 & 0x80) >> 7\n\n        f['length'] = b2 & 0x7f\n\n        if f['length'] == 126:\n            f['hlen'] = 4\n            if blen < f['hlen']:\n                return f # Incomplete frame header\n            (f['length'],) = struct.unpack_from('>xxH', buf)\n        elif f['length'] == 127:\n            f['hlen'] = 10\n            if blen < f['hlen']:\n                return f # Incomplete frame header\n            (f['length'],) = struct.unpack_from('>xxQ', buf)\n\n        full_len = f['hlen'] + has_mask * 4 + f['length']\n\n        if blen < full_len: # Incomplete frame\n            return f # Incomplete frame header\n\n        # Number of bytes that are part of the next frame(s)\n        f['left'] = blen - full_len\n\n        # Process 1 frame\n        if has_mask:\n            # unmask payload\n            f['mask'] = buf[f['hlen']:f['hlen']+4]\n            b = c = ''\n            if f['length'] >= 4:\n                data = struct.unpack('<I', buf[f['hlen']:f['hlen']+4])[0]\n                of1 = f['hlen']+4\n                b = ''\n                for i in range(0, int(f['length']/4)):\n                    mask = struct.unpack('<I', buf[of1+4*i:of1+4*(i+1)])[0]\n                    b += struct.pack('I', data ^ mask)\n\n            if f['length'] % 4:\n                l = f['length'] % 4\n                of1 = f['hlen']\n                of2 = full_len - l\n                c = ''\n                for i in range(0, l):\n                    mask = struct.unpack('B', buf[of1 + i])[0]\n                    data = struct.unpack('B', buf[of2 + i])[0]\n                    c += chr(data ^ mask)\n\n            f['payload'] = b + c\n        else:\n            print(\"Unmasked frame: %s\" % repr(buf))\n            f['payload'] = buf[(f['hlen'] + has_mask * 4):full_len]\n\n        if base64 and f['opcode'] in [1, 2]:\n            try:\n                f['payload'] = b64decode(f['payload'])\n            except:\n                print(\"Exception while b64decoding buffer: %s\" %\n                        repr(buf))\n                raise\n\n        if f['opcode'] == 0x08:\n            if f['length'] >= 2:\n                f['close_code'] = struct.unpack_from(\">H\", f['payload'])\n            if f['length'] > 3:\n                f['close_reason'] = f['payload'][2:]\n\n        return f\n\n\n    @staticmethod",
      "start_line": 186,
      "end_line": 288,
      "source_file": "examples/websocket/gevent_websocket.py",
      "chunk_type": "code"
    },
    {
      "content": "    def _pack_message(message):\n        \"\"\"Pack the message inside ``00`` and ``FF``\n\n        As per the dataframing section (5.3) for the websocket spec\n        \"\"\"\n        if isinstance(message, str):\n            message = message.encode('utf-8')\n        packed = \"\\x00%s\\xFF\" % message\n        return packed\n",
      "start_line": 288,
      "end_line": 298,
      "source_file": "examples/websocket/gevent_websocket.py",
      "chunk_type": "code"
    },
    {
      "content": "    def _parse_messages(self):\n        \"\"\" Parses for messages in the buffer *buf*.  It is assumed that\n        the buffer contains the start character for a message, but that it\n        may contain only part of the rest of the message.\n\n        Returns an array of messages, and the buffer remainder that\n        didn't contain any full messages.\"\"\"\n        msgs = []\n        end_idx = 0\n        buf = self._buf\n        while buf:\n            if self.version in ['7', '8', '13']:\n                frame = self.decode_hybi(buf, base64=False)\n                #print(\"Received buf: %s, frame: %s\" % (repr(buf), frame))\n\n                if frame['payload'] == None:\n                    break\n                else:\n                    if frame['opcode'] == 0x8: # connection close\n                        self.websocket_closed = True\n                        break\n                    #elif frame['opcode'] == 0x1:\n                    else:\n                        msgs.append(frame['payload']);\n                        #msgs.append(frame['payload'].decode('utf-8', 'replace'));\n                        #buf = buf[-frame['left']:]\n                        if frame['left']:\n                            buf = buf[-frame['left']:]\n                        else:\n                            buf = ''\n\n\n            else:\n                frame_type = ord(buf[0])\n                if frame_type == 0:\n                    # Normal message.\n                    end_idx = buf.find(\"\\xFF\")\n                    if end_idx == -1: #pragma NO COVER\n                        break\n                    msgs.append(buf[1:end_idx].decode('utf-8', 'replace'))\n                    buf = buf[end_idx+1:]\n                elif frame_type == 255:\n                    # Closing handshake.\n                    assert ord(buf[1]) == 0, \"Unexpected closing handshake: %r\" % buf\n                    self.websocket_closed = True\n                    break\n                else:\n                    raise ValueError(\"Don't understand how to parse this type of message: %r\" % buf)\n        self._buf = buf\n        return msgs\n",
      "start_line": 298,
      "end_line": 349,
      "source_file": "examples/websocket/gevent_websocket.py",
      "chunk_type": "code"
    },
    {
      "content": "    def send(self, message):\n        \"\"\"Send a message to the browser.\n\n        *message* should be convertible to a string; unicode objects should be\n        encodable as utf-8.  Raises socket.error with errno of 32\n        (broken pipe) if the socket has already been closed by the client.\"\"\"\n        if self.version in ['7', '8', '13']:\n            packed, lenhead, lentail = self.encode_hybi(message, opcode=0x01, base64=False)\n        else:\n            packed = self._pack_message(message)\n        # if two greenthreads are trying to send at the same time\n        # on the same socket, sendlock prevents interleaving and corruption\n        #self._sendlock.acquire()\n        try:\n            self.socket.sendall(packed)\n        finally:\n            pass\n            #self._sendlock.release()\n",
      "start_line": 349,
      "end_line": 368,
      "source_file": "examples/websocket/gevent_websocket.py",
      "chunk_type": "code"
    },
    {
      "content": "    def wait(self):\n        \"\"\"Waits for and deserializes messages.\n\n        Returns a single message; the oldest not yet processed. If the client\n        has already closed the connection, returns None.  This is different\n        from normal socket behavior because the empty string is a valid\n        websocket message.\"\"\"\n        while not self._msgs:\n            # Websocket might be closed already.\n            if self.websocket_closed:\n                return None\n            # no parsed messages, must mean buf needs more data\n            delta = self.socket.recv(8096)\n            if delta == b'':\n                return None\n            self._buf += delta\n            msgs = self._parse_messages()\n            self._msgs.extend(msgs)\n        return self._msgs.popleft()\n",
      "start_line": 368,
      "end_line": 388,
      "source_file": "examples/websocket/gevent_websocket.py",
      "chunk_type": "code"
    },
    {
      "content": "    def _send_closing_frame(self, ignore_send_errors=False):\n        \"\"\"Sends the closing frame to the client, if required.\"\"\"\n        if self.version in ['7', '8', '13'] and not self.websocket_closed:\n            msg = ''\n            #if code != None:\n            #    msg = struct.pack(\">H%ds\" % (len(reason)), code)\n\n            buf, h, t = self.encode_hybi(msg, opcode=0x08, base64=False)\n            self.socket.sendall(buf)\n            self.websocket_closed = True\n\n        elif self.version == 76 and not self.websocket_closed:\n            try:\n                self.socket.sendall(b\"\\xff\\x00\")\n            except SocketError:\n                # Sometimes, like when the remote side cuts off the connection,\n                # we don't care about this.\n                if not ignore_send_errors: #pragma NO COVER\n                    raise\n            self.websocket_closed = True\n",
      "start_line": 388,
      "end_line": 409,
      "source_file": "examples/websocket/gevent_websocket.py",
      "chunk_type": "code"
    },
    {
      "content": "    def close(self):\n        \"\"\"Forcibly close the websocket; generally it is preferable to\n        return from the handler method.\"\"\"\n        self._send_closing_frame()\n        self.socket.shutdown(True)\n        self.socket.close()\n\n\n# demo app\nimport os\nimport random",
      "start_line": 409,
      "end_line": 420,
      "source_file": "examples/websocket/gevent_websocket.py",
      "chunk_type": "code"
    },
    {
      "content": "def handle(ws):\n    \"\"\"  This is the websocket handler function.  Note that we\n    can dispatch based on path in here, too.\"\"\"\n    if ws.path == '/echo':\n        while True:\n            m = ws.wait()\n            if m is None:\n                break\n            ws.send(m)\n\n    elif ws.path == '/data':\n        for i in range(10000):\n            ws.send(\"0 %s %s\\n\" % (i, random.random()))\n            gevent.sleep(0.1)\n\nwsapp = WebSocketWSGI(handle)",
      "start_line": 420,
      "end_line": 436,
      "source_file": "examples/websocket/gevent_websocket.py",
      "chunk_type": "code"
    },
    {
      "content": "def app(environ, start_response):\n    \"\"\" This resolves to the web page or the websocket depending on\n    the path.\"\"\"\n    if environ['PATH_INFO'] == '/' or environ['PATH_INFO'] == \"\":\n        data = open(os.path.join(\n                     os.path.dirname(__file__),\n                     'websocket.html')).read()\n        data = data % environ\n        start_response('200 OK', [('Content-Type', 'text/html'),\n                                 ('Content-Length', str(len(data)))])\n        return [data.encode()]\n    else:\n        return wsapp(environ, start_response)",
      "start_line": 436,
      "end_line": 449,
      "source_file": "examples/websocket/gevent_websocket.py",
      "chunk_type": "code"
    },
    {
      "content": "<!DOCTYPE html>\n<html>\n<head>\n<!-- idea and code swiped from\nhttp://assorted.svn.sourceforge.net/viewvc/assorted/real-time-plotter/trunk/src/rtp.html?view=markup -->\n<script src=\"http://ajax.googleapis.com/ajax/libs/jquery/1.4.1/jquery.min.js\"></script>\n<script src=\"http://people.iola.dk/olau/flot/jquery.flot.js\"></script>\n<script>\nwindow.onload = function() {\n    var data = {};\n    var s = new WebSocket(\"ws://%(HTTP_HOST)s/data\");\n    s.onopen = function() {\n        //alert('open');\n        s.send('hi');\n    };\n    s.onmessage = function(e) {\n      //alert('got ' + e.data);\n      var lines = e.data.split('\\n');\n      for (var i = 0; i < lines.length - 1; i++) {\n        var parts = lines[i].split(' ');\n        var d = parts[0], x = parseFloat(parts[1]), y = parseFloat(parts[2]);\n        if (!(d in data)) data[d] = [];\n        data[d].push([x,y]);\n      }\n      var plots = [];\n      for (var d in data) plots.push( { data: data[d].slice(data[d].length - 200) } );\n      $.plot( $(\"#holder\"), plots,\n              {\n                series: {\n                  lines: { show: true, fill: true },\n                },\n                yaxis: { min: 0 },\n              } );\n\n      s.send('');\n    };\n};\n</script>\n</head>\n<body>\n<h3>Plot</h3>\n<div id=\"holder\" style=\"width:600px;height:300px\"></div>\n</body>\n</html>\n",
      "source_file": "examples/websocket/websocket.html",
      "chunk_type": "unknown"
    },
    {
      "content": "import collections\nimport errno\nimport re\nfrom hashlib import md5, sha1\nimport base64\nfrom base64 import b64encode, b64decode\nimport socket\nimport struct\nimport logging\nfrom socket import error as SocketError\n\nimport eventlet\nfrom gunicorn.workers.base_async import ALREADY_HANDLED\nfrom eventlet import pools\n\nlogger = logging.getLogger(__name__)\n\nWS_KEY = b\"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\"\n",
      "start_line": 0,
      "end_line": 19,
      "source_file": "examples/websocket/websocket.py",
      "chunk_type": "code"
    },
    {
      "content": "class WebSocketWSGI:",
      "start_line": 19,
      "end_line": 20,
      "source_file": "examples/websocket/websocket.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, handler):\n        self.handler = handler\n",
      "start_line": 20,
      "end_line": 23,
      "source_file": "examples/websocket/websocket.py",
      "chunk_type": "code"
    },
    {
      "content": "    def verify_client(self, ws):\n        pass\n",
      "start_line": 23,
      "end_line": 26,
      "source_file": "examples/websocket/websocket.py",
      "chunk_type": "code"
    },
    {
      "content": "    def _get_key_value(self, key_value):\n        if not key_value:\n            return\n        key_number = int(re.sub(\"\\\\D\", \"\", key_value))\n        spaces = re.subn(\" \", \"\", key_value)[1]\n        if key_number % spaces != 0:\n            return\n        part = key_number / spaces\n        return part\n",
      "start_line": 26,
      "end_line": 36,
      "source_file": "examples/websocket/websocket.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __call__(self, environ, start_response):\n        if not (environ.get('HTTP_CONNECTION').find('Upgrade') != -1 and\n            environ['HTTP_UPGRADE'].lower() == 'websocket'):\n            # need to check a few more things here for true compliance\n            start_response('400 Bad Request', [('Connection','close')])\n            return []\n\n        sock = environ['gunicorn.socket']\n\n        version = environ.get('HTTP_SEC_WEBSOCKET_VERSION')\n\n        ws = WebSocket(sock, environ, version)\n\n        handshake_reply = (\"HTTP/1.1 101 Switching Protocols\\r\\n\"\n                   \"Upgrade: websocket\\r\\n\"\n                   \"Connection: Upgrade\\r\\n\")\n\n        key = environ.get('HTTP_SEC_WEBSOCKET_KEY')\n        if key:\n            ws_key = base64.b64decode(key)\n            if len(ws_key) != 16:\n                start_response('400 Bad Request', [('Connection','close')])\n                return []\n\n            protocols = []\n            subprotocols = environ.get('HTTP_SEC_WEBSOCKET_PROTOCOL')\n            ws_protocols = []\n            if subprotocols:\n                for s in subprotocols.split(','):\n                    s = s.strip()\n                    if s in protocols:\n                        ws_protocols.append(s)\n            if ws_protocols:\n                handshake_reply += 'Sec-WebSocket-Protocol: %s\\r\\n' % ', '.join(ws_protocols)\n\n            exts = []\n            extensions = environ.get('HTTP_SEC_WEBSOCKET_EXTENSIONS')\n            ws_extensions = []\n            if extensions:\n                for ext in extensions.split(','):\n                    ext = ext.strip()\n                    if ext in exts:\n                        ws_extensions.append(ext)\n            if ws_extensions:\n                handshake_reply += 'Sec-WebSocket-Extensions: %s\\r\\n' % ', '.join(ws_extensions)\n\n            key_hash = sha1()\n            key_hash.update(key.encode())\n            key_hash.update(WS_KEY)\n\n            handshake_reply +=  (\n                \"Sec-WebSocket-Origin: %s\\r\\n\"\n                \"Sec-WebSocket-Location: ws://%s%s\\r\\n\"\n                \"Sec-WebSocket-Version: %s\\r\\n\"\n                \"Sec-WebSocket-Accept: %s\\r\\n\\r\\n\"\n                 % (\n                    environ.get('HTTP_ORIGIN'),\n                    environ.get('HTTP_HOST'),\n                    ws.path,\n                    version,\n                    base64.b64encode(key_hash.digest()).decode()\n                ))\n\n        else:\n\n            handshake_reply += (\n                       \"WebSocket-Origin: %s\\r\\n\"\n                       \"WebSocket-Location: ws://%s%s\\r\\n\\r\\n\" % (\n                            environ.get('HTTP_ORIGIN'),\n                            environ.get('HTTP_HOST'),\n                            ws.path))\n\n        sock.sendall(handshake_reply.encode())\n\n        try:\n            self.handler(ws)\n        except BrokenPipeError:\n            pass\n        else:\n            raise\n        # use this undocumented feature of grainbows to ensure that it\n        # doesn't barf on the fact that we didn't call start_response\n        return ALREADY_HANDLED\n",
      "start_line": 36,
      "end_line": 120,
      "source_file": "examples/websocket/websocket.py",
      "chunk_type": "code"
    },
    {
      "content": "class WebSocket:\n    \"\"\"A websocket object that handles the details of\n    serialization/deserialization to the socket.\n\n    The primary way to interact with a :class:`WebSocket` object is to\n    call :meth:`send` and :meth:`wait` in order to pass messages back\n    and forth with the browser.  Also available are the following\n    properties:\n\n    path\n        The path value of the request.  This is the same as the WSGI PATH_INFO variable, but more convenient.\n    protocol\n        The value of the Websocket-Protocol header.\n    origin\n        The value of the 'Origin' header.\n    environ\n        The full WSGI environment for this request.\n\n    \"\"\"",
      "start_line": 120,
      "end_line": 139,
      "source_file": "examples/websocket/websocket.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, sock, environ, version=76):\n        \"\"\"\n        :param socket: The eventlet socket\n        :type socket: :class:`eventlet.greenio.GreenSocket`\n        :param environ: The wsgi environment\n        :param version: The WebSocket spec version to follow (default is 76)\n        \"\"\"\n        self.socket = sock\n        self.origin = environ.get('HTTP_ORIGIN')\n        self.protocol = environ.get('HTTP_WEBSOCKET_PROTOCOL')\n        self.path = environ.get('PATH_INFO')\n        self.environ = environ\n        self.version = version\n        self.websocket_closed = False\n        self._buf = \"\"\n        self._msgs = collections.deque()\n        self._sendlock = pools.TokenPool(1)\n\n    @staticmethod",
      "start_line": 139,
      "end_line": 158,
      "source_file": "examples/websocket/websocket.py",
      "chunk_type": "code"
    },
    {
      "content": "    def encode_hybi(buf, opcode, base64=False):\n        \"\"\" Encode a HyBi style WebSocket frame.\n        Optional opcode:\n            0x0 - continuation\n            0x1 - text frame (base64 encode buf)\n            0x2 - binary frame (use raw buf)\n            0x8 - connection close\n            0x9 - ping\n            0xA - pong\n        \"\"\"\n        if base64:\n            buf = b64encode(buf)\n        else:\n            buf = buf.encode()\n\n        b1 = 0x80 | (opcode & 0x0f) # FIN + opcode\n        payload_len = len(buf)\n        if payload_len <= 125:\n            header = struct.pack('>BB', b1, payload_len)\n        elif payload_len > 125 and payload_len < 65536:\n            header = struct.pack('>BBH', b1, 126, payload_len)\n        elif payload_len >= 65536:\n            header = struct.pack('>BBQ', b1, 127, payload_len)\n\n        #print(\"Encoded: %s\" % repr(header + buf))\n\n        return header + buf, len(header), 0\n\n    @staticmethod",
      "start_line": 158,
      "end_line": 187,
      "source_file": "examples/websocket/websocket.py",
      "chunk_type": "code"
    },
    {
      "content": "    def decode_hybi(buf, base64=False):\n        \"\"\" Decode HyBi style WebSocket packets.\n        Returns:\n            {'fin'          : 0_or_1,\n             'opcode'       : number,\n             'mask'         : 32_bit_number,\n             'hlen'         : header_bytes_number,\n             'length'       : payload_bytes_number,\n             'payload'      : decoded_buffer,\n             'left'         : bytes_left_number,\n             'close_code'   : number,\n             'close_reason' : string}\n        \"\"\"\n\n        f = {'fin'          : 0,\n             'opcode'       : 0,\n             'mask'         : 0,\n             'hlen'         : 2,\n             'length'       : 0,\n             'payload'      : None,\n             'left'         : 0,\n             'close_code'   : None,\n             'close_reason' : None}\n\n        blen = len(buf)\n        f['left'] = blen\n\n        if blen < f['hlen']:\n            return f # Incomplete frame header\n\n        b1, b2 = struct.unpack_from(\">BB\", buf)\n        f['opcode'] = b1 & 0x0f\n        f['fin'] = (b1 & 0x80) >> 7\n        has_mask = (b2 & 0x80) >> 7\n\n        f['length'] = b2 & 0x7f\n\n        if f['length'] == 126:\n            f['hlen'] = 4\n            if blen < f['hlen']:\n                return f # Incomplete frame header\n            (f['length'],) = struct.unpack_from('>xxH', buf)\n        elif f['length'] == 127:\n            f['hlen'] = 10\n            if blen < f['hlen']:\n                return f # Incomplete frame header\n            (f['length'],) = struct.unpack_from('>xxQ', buf)\n\n        full_len = f['hlen'] + has_mask * 4 + f['length']\n\n        if blen < full_len: # Incomplete frame\n            return f # Incomplete frame header\n\n        # Number of bytes that are part of the next frame(s)\n        f['left'] = blen - full_len\n\n        # Process 1 frame\n        if has_mask:\n            # unmask payload\n            f['mask'] = buf[f['hlen']:f['hlen']+4]\n            b = c = ''\n            if f['length'] >= 4:\n                data = struct.unpack('<I', buf[f['hlen']:f['hlen']+4])[0]\n                of1 = f['hlen']+4\n                b = ''\n                for i in range(0, int(f['length']/4)):\n                    mask = struct.unpack('<I', buf[of1+4*i:of1+4*(i+1)])[0]\n                    b += struct.pack('I', data ^ mask)\n\n            if f['length'] % 4:\n                l = f['length'] % 4\n                of1 = f['hlen']\n                of2 = full_len - l\n                c = ''\n                for i in range(0, l):\n                    mask = struct.unpack('B', buf[of1 + i])[0]\n                    data = struct.unpack('B', buf[of2 + i])[0]\n                    c += chr(data ^ mask)\n\n            f['payload'] = b + c\n        else:\n            print(\"Unmasked frame: %s\" % repr(buf))\n            f['payload'] = buf[(f['hlen'] + has_mask * 4):full_len]\n\n        if base64 and f['opcode'] in [1, 2]:\n            try:\n                f['payload'] = b64decode(f['payload'])\n            except:\n                print(\"Exception while b64decoding buffer: %s\" %\n                        repr(buf))\n                raise\n\n        if f['opcode'] == 0x08:\n            if f['length'] >= 2:\n                f['close_code'] = struct.unpack_from(\">H\", f['payload'])\n            if f['length'] > 3:\n                f['close_reason'] = f['payload'][2:]\n\n        return f\n\n\n    @staticmethod",
      "start_line": 187,
      "end_line": 289,
      "source_file": "examples/websocket/websocket.py",
      "chunk_type": "code"
    },
    {
      "content": "    def _pack_message(message):\n        \"\"\"Pack the message inside ``00`` and ``FF``\n\n        As per the dataframing section (5.3) for the websocket spec\n        \"\"\"\n        if isinstance(message, str):\n            message = message.encode('utf-8')\n        packed = \"\\x00%s\\xFF\" % message\n        return packed\n",
      "start_line": 289,
      "end_line": 299,
      "source_file": "examples/websocket/websocket.py",
      "chunk_type": "code"
    },
    {
      "content": "    def _parse_messages(self):\n        \"\"\" Parses for messages in the buffer *buf*.  It is assumed that\n        the buffer contains the start character for a message, but that it\n        may contain only part of the rest of the message.\n\n        Returns an array of messages, and the buffer remainder that\n        didn't contain any full messages.\"\"\"\n        msgs = []\n        end_idx = 0\n        buf = self._buf\n        while buf:\n            if self.version in ['7', '8', '13']:\n                frame = self.decode_hybi(buf, base64=False)\n                #print(\"Received buf: %s, frame: %s\" % (repr(buf), frame))\n\n                if frame['payload'] == None:\n                    break\n                else:\n                    if frame['opcode'] == 0x8: # connection close\n                        self.websocket_closed = True\n                        break\n                    #elif frame['opcode'] == 0x1:\n                    else:\n                        msgs.append(frame['payload']);\n                        #msgs.append(frame['payload'].decode('utf-8', 'replace'));\n                        #buf = buf[-frame['left']:]\n                        if frame['left']:\n                            buf = buf[-frame['left']:]\n                        else:\n                            buf = ''\n\n\n            else:\n                frame_type = ord(buf[0])\n                if frame_type == 0:\n                    # Normal message.\n                    end_idx = buf.find(\"\\xFF\")\n                    if end_idx == -1: #pragma NO COVER\n                        break\n                    msgs.append(buf[1:end_idx].decode('utf-8', 'replace'))\n                    buf = buf[end_idx+1:]\n                elif frame_type == 255:\n                    # Closing handshake.\n                    assert ord(buf[1]) == 0, \"Unexpected closing handshake: %r\" % buf\n                    self.websocket_closed = True\n                    break\n                else:\n                    raise ValueError(\"Don't understand how to parse this type of message: %r\" % buf)\n        self._buf = buf\n        return msgs\n",
      "start_line": 299,
      "end_line": 350,
      "source_file": "examples/websocket/websocket.py",
      "chunk_type": "code"
    },
    {
      "content": "    def send(self, message):\n        \"\"\"Send a message to the browser.\n\n        *message* should be convertible to a string; unicode objects should be\n        encodable as utf-8.  Raises socket.error with errno of 32\n        (broken pipe) if the socket has already been closed by the client.\"\"\"\n        if self.version in ['7', '8', '13']:\n            packed, lenhead, lentail = self.encode_hybi(message, opcode=0x01, base64=False)\n        else:\n            packed = self._pack_message(message)\n        # if two greenthreads are trying to send at the same time\n        # on the same socket, sendlock prevents interleaving and corruption\n        #self._sendlock.acquire()\n        t = self._sendlock.get()\n        try:\n            self.socket.sendall(packed)\n        finally:\n            self._sendlock.put(t)\n",
      "start_line": 350,
      "end_line": 369,
      "source_file": "examples/websocket/websocket.py",
      "chunk_type": "code"
    },
    {
      "content": "    def wait(self):\n        \"\"\"Waits for and deserializes messages.\n\n        Returns a single message; the oldest not yet processed. If the client\n        has already closed the connection, returns None.  This is different\n        from normal socket behavior because the empty string is a valid\n        websocket message.\"\"\"\n        while not self._msgs:\n            # Websocket might be closed already.\n            if self.websocket_closed:\n                return None\n            # no parsed messages, must mean buf needs more data\n            delta = self.socket.recv(8096)\n            if delta == b'':\n                return None\n            self._buf += delta\n            msgs = self._parse_messages()\n            self._msgs.extend(msgs)\n        return self._msgs.popleft()\n",
      "start_line": 369,
      "end_line": 389,
      "source_file": "examples/websocket/websocket.py",
      "chunk_type": "code"
    },
    {
      "content": "    def _send_closing_frame(self, ignore_send_errors=False):\n        \"\"\"Sends the closing frame to the client, if required.\"\"\"\n        if self.version in ['7', '8', '13'] and not self.websocket_closed:\n            msg = ''\n            #if code != None:\n            #    msg = struct.pack(\">H%ds\" % (len(reason)), code)\n\n            buf, h, t = self.encode_hybi(msg, opcode=0x08, base64=False)\n            self.socket.sendall(buf)\n            self.websocket_closed = True\n\n        elif self.version == 76 and not self.websocket_closed:\n            try:\n                self.socket.sendall(b\"\\xff\\x00\")\n            except SocketError:\n                # Sometimes, like when the remote side cuts off the connection,\n                # we don't care about this.\n                if not ignore_send_errors: #pragma NO COVER\n                    raise\n            self.websocket_closed = True\n",
      "start_line": 389,
      "end_line": 410,
      "source_file": "examples/websocket/websocket.py",
      "chunk_type": "code"
    },
    {
      "content": "    def close(self):\n        \"\"\"Forcibly close the websocket; generally it is preferable to\n        return from the handler method.\"\"\"\n        self._send_closing_frame()\n        self.socket.shutdown(True)\n        self.socket.close()\n\n# demo app\nimport os\nimport random",
      "start_line": 410,
      "end_line": 420,
      "source_file": "examples/websocket/websocket.py",
      "chunk_type": "code"
    },
    {
      "content": "def handle(ws):\n    \"\"\"  This is the websocket handler function.  Note that we\n    can dispatch based on path in here, too.\"\"\"\n    if ws.path == '/echo':\n        while True:\n            m = ws.wait()\n            if m is None:\n                break\n            ws.send(m)\n\n    elif ws.path == '/data':\n        for i in range(10000):\n            ws.send(\"0 %s %s\\n\" % (i, random.random()))\n            eventlet.sleep(0.1)\n\nwsapp = WebSocketWSGI(handle)",
      "start_line": 420,
      "end_line": 436,
      "source_file": "examples/websocket/websocket.py",
      "chunk_type": "code"
    },
    {
      "content": "def app(environ, start_response):\n    \"\"\" This resolves to the web page or the websocket depending on\n    the path.\"\"\"\n    if environ['PATH_INFO'] == '/' or environ['PATH_INFO'] == \"\":\n        data = open(os.path.join(\n                     os.path.dirname(__file__),\n                     'websocket.html')).read()\n        data = data % environ\n        start_response('200 OK', [('Content-Type', 'text/html'),\n                                 ('Content-Length', str(len(data)))])\n        return [data.encode()]\n    else:\n        return wsapp(environ, start_response)",
      "start_line": 436,
      "end_line": 449,
      "source_file": "examples/websocket/websocket.py",
      "chunk_type": "code"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n#\n# Run with:\n#\n#   $ gunicorn -k tornado tornadoapp:app\n#\n\nimport tornado.ioloop\nimport tornado.web\nfrom tornado import gen\n",
      "start_line": 0,
      "end_line": 13,
      "source_file": "examples/frameworks/tornadoapp.py",
      "chunk_type": "code"
    },
    {
      "content": "class MainHandler(tornado.web.RequestHandler):\n    @gen.coroutine",
      "start_line": 13,
      "end_line": 15,
      "source_file": "examples/frameworks/tornadoapp.py",
      "chunk_type": "code"
    },
    {
      "content": "    def get(self):\n        # Your asynchronous code here\n        yield gen.sleep(1)  # Example of an asynchronous operation\n        self.write(\"Hello, World!\")\n",
      "start_line": 15,
      "end_line": 20,
      "source_file": "examples/frameworks/tornadoapp.py",
      "chunk_type": "code"
    },
    {
      "content": "def make_app():\n    return tornado.web.Application([\n        (r\"/\", MainHandler),\n    ])\n\nif __name__ == \"__main__\":\n    app = make_app()\n    app.listen(8888)\n    tornado.ioloop.IOLoop.current().start()",
      "start_line": 20,
      "end_line": 29,
      "source_file": "examples/frameworks/tornadoapp.py",
      "chunk_type": "code"
    },
    {
      "content": "web-py\n",
      "source_file": "examples/frameworks/requirements_webpyapp.txt",
      "chunk_type": "doc"
    },
    {
      "content": "-r requirements_flaskapp.txt\n-r requirements_cherryapp.txt\n-r requirements_pyramidapp.txt\n-r requirements_tornadoapp.txt\n-r requirements_webpyapp.txt\n",
      "source_file": "examples/frameworks/requirements.txt",
      "chunk_type": "doc"
    },
    {
      "content": "import cherrypy\n\n",
      "start_line": 0,
      "end_line": 3,
      "source_file": "examples/frameworks/cherryapp.py",
      "chunk_type": "code"
    },
    {
      "content": "class Root:\n    @cherrypy.expose",
      "start_line": 3,
      "end_line": 5,
      "source_file": "examples/frameworks/cherryapp.py",
      "chunk_type": "code"
    },
    {
      "content": "    def index(self):\n        return 'Hello World!'\n\ncherrypy.config.update({'environment': 'embedded'})\n\napp = cherrypy.tree.mount(Root())",
      "start_line": 5,
      "end_line": 11,
      "source_file": "examples/frameworks/cherryapp.py",
      "chunk_type": "code"
    },
    {
      "content": "flask\n",
      "source_file": "examples/frameworks/requirements_flaskapp.txt",
      "chunk_type": "doc"
    },
    {
      "content": "cherrypy\n",
      "source_file": "examples/frameworks/requirements_cherryapp.txt",
      "chunk_type": "doc"
    },
    {
      "content": "from pyramid.config import Configurator\nfrom pyramid.response import Response\n",
      "start_line": 0,
      "end_line": 3,
      "source_file": "examples/frameworks/pyramidapp.py",
      "chunk_type": "code"
    },
    {
      "content": "def hello_world(request):\n    return Response('Hello world!')\n",
      "start_line": 3,
      "end_line": 6,
      "source_file": "examples/frameworks/pyramidapp.py",
      "chunk_type": "code"
    },
    {
      "content": "def goodbye_world(request):\n    return Response('Goodbye world!')\n\nconfig = Configurator()\nconfig.add_view(hello_world)\nconfig.add_view(goodbye_world, name='goodbye')\napp = config.make_wsgi_app()",
      "start_line": 6,
      "end_line": 13,
      "source_file": "examples/frameworks/pyramidapp.py",
      "chunk_type": "code"
    },
    {
      "content": "# Run with\n#\n# $ gunicorn webpyapp:app\n#\n\nimport web\n\nurls = (\n    '/', 'index'\n)\n",
      "start_line": 0,
      "end_line": 11,
      "source_file": "examples/frameworks/webpyapp.py",
      "chunk_type": "code"
    },
    {
      "content": "class index:",
      "start_line": 11,
      "end_line": 12,
      "source_file": "examples/frameworks/webpyapp.py",
      "chunk_type": "code"
    },
    {
      "content": "    def GET(self):\n        return \"Hello, world!\"\n\napp = web.application(urls, globals()).wsgifunc()",
      "start_line": 12,
      "end_line": 16,
      "source_file": "examples/frameworks/webpyapp.py",
      "chunk_type": "code"
    },
    {
      "content": "# Run with:\n#\n#   $ gunicorn flaskapp:app\n#\n\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.route(\"/\")",
      "start_line": 0,
      "end_line": 9,
      "source_file": "examples/frameworks/flaskapp.py",
      "chunk_type": "code"
    },
    {
      "content": "def hello():\n    return \"Hello World!\"",
      "start_line": 9,
      "end_line": 11,
      "source_file": "examples/frameworks/flaskapp.py",
      "chunk_type": "code"
    },
    {
      "content": "tornado<6\n",
      "source_file": "examples/frameworks/requirements_tornadoapp.txt",
      "chunk_type": "doc"
    },
    {
      "content": "import io\n\nfrom flask import Flask, send_file\n\napp = Flask(__name__)\n\n@app.route('/')",
      "start_line": 0,
      "end_line": 7,
      "source_file": "examples/frameworks/flask_sendfile.py",
      "chunk_type": "code"
    },
    {
      "content": "def index():\n    buf = io.BytesIO()\n    buf.write(b'hello world')\n    buf.seek(0)\n    return send_file(buf,\n                     attachment_filename=\"testing.txt\",\n                     as_attachment=True)",
      "start_line": 7,
      "end_line": 14,
      "source_file": "examples/frameworks/flask_sendfile.py",
      "chunk_type": "code"
    },
    {
      "content": "pyramid\n",
      "source_file": "examples/frameworks/requirements_pyramidapp.txt",
      "chunk_type": "doc"
    },
    {
      "content": "# Example command to run the example:\n#\n#   $ gunicorn flaskapp_aiohttp_wsgi:aioapp -k aiohttp.worker.GunicornWebWorker\n#\n\nfrom aiohttp import web\nfrom aiohttp_wsgi import WSGIHandler\nfrom flask import Flask\n\napp = Flask(__name__)\n\n\n@app.route('/')",
      "start_line": 0,
      "end_line": 13,
      "source_file": "examples/frameworks/flaskapp_aiohttp_wsgi.py",
      "chunk_type": "code"
    },
    {
      "content": "def hello():\n    return 'Hello, world!'\n\n",
      "start_line": 13,
      "end_line": 17,
      "source_file": "examples/frameworks/flaskapp_aiohttp_wsgi.py",
      "chunk_type": "code"
    },
    {
      "content": "def make_aiohttp_app(app):\n    wsgi_handler = WSGIHandler(app)\n    aioapp = web.Application()\n    aioapp.router.add_route('*', '/{path_info:.*}', wsgi_handler)\n    return aioapp\n\naioapp = make_aiohttp_app(app)",
      "start_line": 17,
      "end_line": 24,
      "source_file": "examples/frameworks/flaskapp_aiohttp_wsgi.py",
      "chunk_type": "code"
    },
    {
      "content": "Applications to test Django support:\n\ntesting -> Django 1.4\n",
      "source_file": "examples/frameworks/django/README",
      "chunk_type": "unknown"
    },
    {
      "content": "============\nInstallation\n============\n\n.. highlight:: bash\n\n:Requirements: **Python 3.x >= 3.7**\n\nTo install the latest released version of Gunicorn::\n\n  $ pip install gunicorn\n\nFrom Source\n===========\n\nYou can install Gunicorn from source just as you would install any other\nPython package::\n\n    $ pip install git+https://github.com/benoitc/gunicorn.git\n\nThis will allow you to keep up to date with development on GitHub::\n\n    $ pip install -U git+https://github.com/benoitc/gunicorn.git\n\n\nAsync Workers\n=============\n\nYou may also want to install Eventlet_ or Gevent_ if you expect that your\napplication code may need to pause for extended periods of time during request\nprocessing. Check out the `design docs`_ for more information on when you'll\nwant to consider one of the alternate worker types.\n\n::\n\n    $ pip install greenlet            # Required for both\n    $ pip install eventlet            # For eventlet workers\n    $ pip install gunicorn[eventlet]  # Or, using extra\n    $ pip install gevent              # For gevent workers\n    $ pip install gunicorn[gevent]    # Or, using extra\n\n.. note::\n    Both require ``greenlet``, which should get installed automatically.\n    If its installation fails, you probably need to install\n    the Python headers. These headers are available in most package\n    managers. On Ubuntu the package name for ``apt-get`` is\n    ``python-dev``.\n\n    Gevent_ also requires that ``libevent`` 1.4.x or 2.0.4 is installed.\n    This could be a more recent version than what is available in your\n    package manager. If Gevent_ fails to build even with libevent_\n    installed, this is the most likely reason.\n\n\nExtra Packages\n==============\nSome Gunicorn options require additional packages. You can use the ``[extra]``\nsyntax to install these at the same time as Gunicorn.\n\nMost extra packages are needed for alternate worker types. See the\n`design docs`_ for more information on when you'll want to consider an\nalternate worker type.\n\n* ``gunicorn[eventlet]`` - Eventlet-based greenlets workers\n* ``gunicorn[gevent]`` - Gevent-based greenlets workers\n* ``gunicorn[gthread]`` - Threaded workers\n* ``gunicorn[tornado]`` - Tornado-based workers, not recommended\n\nIf you are running more than one instance of Gunicorn, the :ref:`proc-name`\nsetting will help distinguish between them in tools like ``ps`` and ``top``.\n\n* ``gunicorn[setproctitle]`` - Enables setting the process name\n\nMultiple extras can be combined, like\n``pip install gunicorn[gevent,setproctitle]``.\n\nDebian GNU/Linux\n================\n\nIf you are using Debian GNU/Linux it is recommended that you use\nsystem packages to install Gunicorn except maybe when you want to use\ndifferent versions of Gunicorn with virtualenv. This has a number of\nadvantages:\n\n* Zero-effort installation: Automatically starts multiple Gunicorn instances\n  based on configurations defined in ``/etc/gunicorn.d``.\n\n* Sensible default locations for logs (``/var/log/gunicorn``). Logs\n  can be automatically rotated and compressed using ``logrotate``.\n\n* Improved security: Can easily run each Gunicorn instance with a dedicated\n  UNIX user/group.\n\n* Sensible upgrade path: Upgrades to newer versions result in less downtime,\n  handle conflicting changes in configuration options, and can be quickly\n  rolled back in case of incompatibility. The package can also be purged\n  entirely from the system in seconds.\n\nstable (\"buster\")\n------------------\n\nThe version of Gunicorn in the Debian_ \"stable\" distribution is 19.9.0\n(December 2020). You can install it using::\n\n    $ sudo apt-get install gunicorn3\n\nYou can also use the most recent version 20.0.4 (December 2020) by using\n`Debian Backports`_. First, copy the following line to your\n``/etc/apt/sources.list``::\n\n    deb http://ftp.debian.org/debian buster-backports main\n\nThen, update your local package lists::\n\n    $ sudo apt-get update\n\nYou can then install the latest version using::\n\n    $ sudo apt-get -t buster-backports install gunicorn\n\noldstable (\"stretch\")\n---------------------\n\nWhile Debian releases newer than Stretch will give you gunicorn with Python 3\nsupport no matter if you install the gunicorn or gunicorn3 package for Stretch\nyou specifically have to install gunicorn3 to get Python 3 support.\n\nThe version of Gunicorn in the Debian_ \"oldstable\" distribution is 19.6.0\n(December 2020). You can install it using::\n\n    $ sudo apt-get install gunicorn3\n\nYou can also use the most recent version 19.7.1 (December 2020) by using\n`Debian Backports`_. First, copy the following line to your\n``/etc/apt/sources.list``::\n\n    deb http://ftp.debian.org/debian stretch-backports main\n\nThen, update your local package lists::\n\n    $ sudo apt-get update\n\nYou can then install the latest version using::\n\n    $ sudo apt-get -t stretch-backports install gunicorn3\n\nTesting (\"bullseye\") / Unstable (\"sid\")\n---------------------------------------\n\n\"bullseye\" and \"sid\" contain the latest released version of Gunicorn 20.0.4\n(December 2020). You can install it in the usual way::\n\n    $ sudo apt-get install gunicorn\n\n\nUbuntu\n======\n\nUbuntu_ 20.04 LTS (Focal Fossa) or later contains the Gunicorn package by\ndefault 20.0.4 (December 2020) so that you can install it in the usual way::\n\n    $ sudo apt-get update\n    $ sudo apt-get install gunicorn\n\n\n.. _`design docs`: design.html\n.. _Eventlet: http://eventlet.net\n.. _Gevent: http://www.gevent.org/\n.. _libevent: http://libevent.org/\n.. _Debian: https://www.debian.org/\n.. _`Debian Backports`: https://backports.debian.org/\n.. _Ubuntu: https://www.ubuntu.com/\n",
      "source_file": "docs/source/install.rst",
      "chunk_type": "doc"
    },
    {
      "content": ".. Please update gunicorn/config.py instead.\n\n.. _settings:\n\nSettings\n========\n\nThis is an exhaustive list of settings for Gunicorn. Some settings are only\nable to be set from a configuration file. The setting name is what should be\nused in the configuration file. The command line arguments are listed as well\nfor reference on setting at the command line.\n\n.. note::\n\n    Settings can be specified by using environment variable\n    ``GUNICORN_CMD_ARGS``. All available command line arguments can be used.\n    For example, to specify the bind address and number of workers::\n\n        $ GUNICORN_CMD_ARGS=\"--bind=127.0.0.1 --workers=3\" gunicorn app:app\n\n    .. versionadded:: 19.7\n\nConfig File\n-----------\n\n.. _config:\n\n``config``\n~~~~~~~~~~\n\n**Command line:** ``-c CONFIG`` or ``--config CONFIG``\n\n**Default:** ``'./gunicorn.conf.py'``\n\n:ref:`The Gunicorn config file<configuration_file>`.\n\nA string of the form ``PATH``, ``file:PATH``, or ``python:MODULE_NAME``.\n\nOnly has an effect when specified on the command line or as part of an\napplication specific configuration.\n\nBy default, a file named ``gunicorn.conf.py`` will be read from the same\ndirectory where gunicorn is being run.\n\n.. versionchanged:: 19.4\n   Loading the config from a Python module requires the ``python:``\n   prefix.\n\n.. _wsgi-app:\n\n``wsgi_app``\n~~~~~~~~~~~~\n\n**Default:** ``None``\n\nA WSGI application path in pattern ``$(MODULE_NAME):$(VARIABLE_NAME)``.\n\n.. versionadded:: 20.1.0\n\nDebugging\n---------\n\n.. _reload:\n\n``reload``\n~~~~~~~~~~\n\n**Command line:** ``--reload``\n\n**Default:** ``False``\n\nRestart workers when code changes.\n\nThis setting is intended for development. It will cause workers to be\nrestarted whenever application code changes.\n\nThe reloader is incompatible with application preloading. When using a\npaste configuration be sure that the server block does not import any\napplication code or the reload will not work as designed.\n\nThe default behavior is to attempt inotify with a fallback to file\nsystem polling. Generally, inotify should be preferred if available\nbecause it consumes less system resources.\n\n.. note::\n   In order to use the inotify reloader, you must have the ``inotify``\n   package installed.\n\n.. _reload-engine:\n\n``reload_engine``\n~~~~~~~~~~~~~~~~~\n\n**Command line:** ``--reload-engine STRING``\n\n**Default:** ``'auto'``\n\nThe implementation that should be used to power :ref:`reload`.\n\nValid engines are:\n\n* ``'auto'``\n* ``'poll'``\n* ``'inotify'`` (requires inotify)\n\n.. versionadded:: 19.7\n\n.. _reload-extra-files:\n\n``reload_extra_files``\n~~~~~~~~~~~~~~~~~~~~~~\n\n**Command line:** ``--reload-extra-file FILES``\n\n**Default:** ``[]``\n\nExtends :ref:`reload` option to also watch and reload on additional files\n(e.g., templates, configurations, specifications, etc.).\n\n.. versionadded:: 19.8\n\n.. _spew:\n\n``spew``\n~~~~~~~~\n\n**Command line:** ``--spew``\n\n**Default:** ``False``\n\nInstall a trace function that spews every line executed by the server.\n\nThis is the nuclear option.\n\n.. _check-config:\n\n``check_config``\n~~~~~~~~~~~~~~~~\n\n**Command line:** ``--check-config``\n\n**Default:** ``False``\n\nCheck the configuration and exit. The exit status is 0 if the\nconfiguration is correct, and 1 if the configuration is incorrect.\n\n.. _print-config:\n\n``print_config``\n~~~~~~~~~~~~~~~~\n\n**Command line:** ``--print-config``\n\n**Default:** ``False``\n\nPrint the configuration settings as fully resolved. Implies :ref:`check-config`.\n\nLogging\n-------\n\n.. _accesslog:\n\n``accesslog``\n~~~~~~~~~~~~~\n\n**Command line:** ``--access-logfile FILE``\n\n**Default:** ``None``\n\nThe Access log file to write to.\n\n``'-'`` means log to stdout.\n\n.. _disable-redirect-access-to-syslog:\n\n``disable_redirect_access_to_syslog``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n**Command line:** ``--disable-redirect-access-to-syslog``\n\n**Default:** ``False``\n\nDisable redirect access logs to syslog.\n\n.. versionadded:: 19.8\n\n.. _access-log-format:\n\n``access_log_format``\n~~~~~~~~~~~~~~~~~~~~~\n\n**Command line:** ``--access-logformat STRING``\n\n**Default:** ``'%(h)s %(l)s %(u)s %(t)s \"%(r)s\" %(s)s %(b)s \"%(f)s\" \"%(a)s\"'``\n\nThe access log format.\n\n===========  ===========\nIdentifier   Description\n===========  ===========\nh            remote address\nl            ``'-'``\nu            user name (if HTTP Basic auth used)\nt            date of the request\nr            status line (e.g. ``GET / HTTP/1.1``)\nm            request method\nU            URL path without query string\nq            query string\nH            protocol\ns            status\nB            response length\nb            response length or ``'-'`` (CLF format)\nf            referrer (note: header is ``referer``)\na            user agent\nT            request time in seconds\nM            request time in milliseconds\nD            request time in microseconds\nL            request time in decimal seconds\np            process ID\n{header}i    request header\n{header}o    response header\n{variable}e  environment variable\n===========  ===========\n\nUse lowercase for header and environment variable names, and put\n``{...}x`` names inside ``%(...)s``. For example::\n\n    %({x-forwarded-for}i)s\n\n.. _errorlog:\n\n``errorlog``\n~~~~~~~~~~~~\n\n**Command line:** ``--error-logfile FILE`` or ``--log-file FILE``\n\n**Default:** ``'-'``\n\nThe Error log file to write to.\n\nUsing ``'-'`` for FILE makes gunicorn log to stderr.\n\n.. versionchanged:: 19.2\n   Log to stderr by default.\n\n.. _loglevel:\n\n``loglevel``\n~~~~~~~~~~~~\n\n**Command line:** ``--log-level LEVEL``\n\n**Default:** ``'info'``\n\nThe granularity of Error log outputs.\n\nValid level names are:\n\n* ``'debug'``\n* ``'info'``\n* ``'warning'``\n* ``'error'``\n* ``'critical'``\n\n.. _capture-output:\n\n``capture_output``\n~~~~~~~~~~~~~~~~~~\n\n**Command line:** ``--capture-output``\n\n**Default:** ``False``\n\nRedirect stdout/stderr to specified file in :ref:`errorlog`.\n\n.. versionadded:: 19.6\n\n.. _logger-class:\n\n``logger_class``\n~~~~~~~~~~~~~~~~\n\n**Command line:** ``--logger-class STRING``\n\n**Default:** ``'gunicorn.glogging.Logger'``\n\nThe logger you want to use to log events in Gunicorn.\n\nThe default class (``gunicorn.glogging.Logger``) handles most\nnormal usages in logging. It provides error and access logging.\n\nYou can provide your own logger by giving Gunicorn a Python path to a\nclass that quacks like ``gunicorn.glogging.Logger``.\n\n.. _logconfig:\n\n``logconfig``\n~~~~~~~~~~~~~\n\n**Command line:** ``--log-config FILE``\n\n**Default:** ``None``\n\nThe log config file to use.\nGunicorn uses the standard Python logging module's Configuration\nfile format.\n\n.. _logconfig-dict:\n\n``logconfig_dict``\n~~~~~~~~~~~~~~~~~~\n\n**Default:** ``{}``\n\nThe log config dictionary to use, using the standard Python\nlogging module's dictionary configuration format. This option\ntakes precedence over the :ref:`logconfig` and :ref:`logconfig-json` options,\nwhich uses the older file configuration format and JSON\nrespectively.\n\nFormat: https://docs.python.org/3/library/logging.config.html#logging.config.dictConfig\n\nFor more context you can look at the default configuration dictionary for logging,\nwhich can be found at ``gunicorn.glogging.CONFIG_DEFAULTS``.\n\n.. versionadded:: 19.8\n\n.. _logconfig-json:\n\n``logconfig_json``\n~~~~~~~~~~~~~~~~~~\n\n**Command line:** ``--log-config-json FILE``\n\n**Default:** ``None``\n\nThe log config to read config from a JSON file\n\nFormat: https://docs.python.org/3/library/logging.config.html#logging.config.jsonConfig\n\n.. versionadded:: 20.0\n\n.. _syslog-addr:\n\n``syslog_addr``\n~~~~~~~~~~~~~~~\n\n**Command line:** ``--log-syslog-to SYSLOG_ADDR``\n\n**Default:** ``'udp://localhost:514'``\n\nAddress to send syslog messages.\n\nAddress is a string of the form:\n\n* ``unix://PATH#TYPE`` : for unix domain socket. ``TYPE`` can be ``stream``\n  for the stream driver or ``dgram`` for the dgram driver.\n  ``stream`` is the default.\n* ``udp://HOST:PORT`` : for UDP sockets\n* ``tcp://HOST:PORT`` : for TCP sockets\n\n.. _syslog:\n\n``syslog``\n~~~~~~~~~~\n\n**Command line:** ``--log-syslog``\n\n**Default:** ``False``\n\nSend *Gunicorn* logs to syslog.\n\n.. versionchanged:: 19.8\n   You can now disable sending access logs by using the\n   :ref:`disable-redirect-access-to-syslog` setting.\n\n.. _syslog-prefix:\n\n``syslog_prefix``\n~~~~~~~~~~~~~~~~~\n\n**Command line:** ``--log-syslog-prefix SYSLOG_PREFIX``\n\n**Default:** ``None``\n\nMakes Gunicorn use the parameter as program-name in the syslog entries.\n\nAll entries will be prefixed by ``gunicorn.<prefix>``. By default the\nprogram name is the name of the process.\n\n.. _syslog-facility:\n\n``syslog_facility``\n~~~~~~~~~~~~~~~~~~~\n\n**Command line:** ``--log-syslog-facility SYSLOG_FACILITY``\n\n**Default:** ``'user'``\n\nSyslog facility name\n\n.. _enable-stdio-inheritance:\n\n``enable_stdio_inheritance``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n**Command line:** ``-R`` or ``--enable-stdio-inheritance``\n\n**Default:** ``False``\n\nEnable stdio inheritance.\n\nEnable inheritance for stdio file descriptors in daemon mode.\n\nNote: To disable the Python stdout buffering, you can to set the user\nenvironment variable ``PYTHONUNBUFFERED`` .\n\n.. _statsd-host:\n\n``statsd_host``\n~~~~~~~~~~~~~~~\n\n**Command line:** ``--statsd-host STATSD_ADDR``\n\n**Default:** ``None``\n\nThe address of the StatsD server to log to.\n\nAddress is a string of the form:\n\n* ``unix://PATH`` : for a unix domain socket.\n* ``HOST:PORT`` : for a network address\n\n.. versionadded:: 19.1\n\n.. _dogstatsd-tags:\n\n``dogstatsd_tags``\n~~~~~~~~~~~~~~~~~~\n\n**Command line:** ``--dogstatsd-tags DOGSTATSD_TAGS``\n\n**Default:** ``''``\n\nA comma-delimited list of datadog statsd (dogstatsd) tags to append to\nstatsd metrics.\n\n.. versionadded:: 20\n\n.. _statsd-prefix:\n\n``statsd_prefix``\n~~~~~~~~~~~~~~~~~\n\n**Command line:** ``--statsd-prefix STATSD_PREFIX``\n\n**Default:** ``''``\n\nPrefix to use when emitting statsd metrics (a trailing ``.`` is added,\nif not provided).\n\n.. versionadded:: 19.2\n\nProcess Naming\n--------------\n\n.. _proc-name:\n\n``proc_name``\n~~~~~~~~~~~~~\n\n**Command line:** ``-n STRING`` or ``--name STRING``\n\n**Default:** ``None``\n\nA base to use with setproctitle for process naming.\n\nThis affects things like ``ps`` and ``top``. If you're going to be\nrunning more than one instance of Gunicorn you'll probably want to set a\nname to tell them apart. This requires that you install the setproctitle\nmodule.\n\nIf not set, the *default_proc_name* setting will be used.\n\n.. _default-proc-name:\n\n``default_proc_name``\n~~~~~~~~~~~~~~~~~~~~~\n\n**Default:** ``'gunicorn'``\n\nInternal setting that is adjusted for each type of application.\n\nSSL\n---\n\n.. _keyfile:\n\n``keyfile``\n~~~~~~~~~~~\n\n**Command line:** ``--keyfile FILE``\n\n**Default:** ``None``\n\nSSL key file\n\n.. _certfile:\n\n``certfile``\n~~~~~~~~~~~~\n\n**Command line:** ``--certfile FILE``\n\n**Default:** ``None``\n\nSSL certificate file\n\n.. _ssl-version:\n\n``ssl_version``\n~~~~~~~~~~~~~~~\n\n**Command line:** ``--ssl-version``\n\n**Default:** ``<_SSLMethod.PROTOCOL_TLS: 2>``\n\nSSL version to use (see stdlib ssl module's).\n\n.. deprecated:: 21.0\n   The option is deprecated and it is currently ignored. Use :ref:`ssl-context` instead.\n\n============= ============\n--ssl-version Description\n============= ============\nSSLv3         SSLv3 is not-secure and is strongly discouraged.\nSSLv23        Alias for TLS. Deprecated in Python 3.6, use TLS.\nTLS           Negotiate highest possible version between client/server.\n              Can yield SSL. (Python 3.6+)\nTLSv1         TLS 1.0\nTLSv1_1       TLS 1.1 (Python 3.4+)\nTLSv1_2       TLS 1.2 (Python 3.4+)\nTLS_SERVER    Auto-negotiate the highest protocol version like TLS,\n              but only support server-side SSLSocket connections.\n              (Python 3.6+)\n============= ============\n\n.. versionchanged:: 19.7\n   The default value has been changed from ``ssl.PROTOCOL_TLSv1`` to\n   ``ssl.PROTOCOL_SSLv23``.\n.. versionchanged:: 20.0\n   This setting now accepts string names based on ``ssl.PROTOCOL_``\n   constants.\n.. versionchanged:: 20.0.1\n   The default value has been changed from ``ssl.PROTOCOL_SSLv23`` to\n   ``ssl.PROTOCOL_TLS`` when Python >= 3.6 .\n\n.. _cert-reqs:\n\n``cert_reqs``\n~~~~~~~~~~~~~\n\n**Command line:** ``--cert-reqs``\n\n**Default:** ``<VerifyMode.CERT_NONE: 0>``\n\nWhether client certificate is required (see stdlib ssl module's)\n\n===========  ===========================\n--cert-reqs      Description\n===========  ===========================\n`0`          no client verification\n`1`          ssl.CERT_OPTIONAL\n`2`          ssl.CERT_REQUIRED\n===========  ===========================\n\n.. _ca-certs:\n\n``ca_certs``\n~~~~~~~~~~~~\n\n**Command line:** ``--ca-certs FILE``\n\n**Default:** ``None``\n\nCA certificates file\n\n.. _suppress-ragged-eofs:\n\n``suppress_ragged_eofs``\n~~~~~~~~~~~~~~~~~~~~~~~~\n\n**Command line:** ``--suppress-ragged-eofs``\n\n**Default:** ``True``\n\nSuppress ragged EOFs (see stdlib ssl module's)\n\n.. _do-handshake-on-connect:\n\n``do_handshake_on_connect``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n**Command line:** ``--do-handshake-on-connect``\n\n**Default:** ``False``\n\nWhether to perform SSL handshake on socket connect (see stdlib ssl module's)\n\n.. _ciphers:\n\n``ciphers``\n~~~~~~~~~~~\n\n**Command line:** ``--ciphers``\n\n**Default:** ``None``\n\nSSL Cipher suite to use, in the format of an OpenSSL cipher list.\n\nBy default we use the default cipher list from Python's ``ssl`` module,\nwhich contains ciphers considered strong at the time of each Python\nrelease.\n\nAs a recommended alternative, the Open Web App Security Project (OWASP)\noffers `a vetted set of strong cipher strings rated A+ to C-\n<https://www.owasp.org/index.php/TLS_Cipher_String_Cheat_Sheet>`_.\nOWASP provides details on user-agent compatibility at each security level.\n\nSee the `OpenSSL Cipher List Format Documentation\n<https://www.openssl.org/docs/manmaster/man1/ciphers.html#CIPHER-LIST-FORMAT>`_\nfor details on the format of an OpenSSL cipher list.\n\nSecurity\n--------\n\n.. _limit-request-line:\n\n``limit_request_line``\n~~~~~~~~~~~~~~~~~~~~~~\n\n**Command line:** ``--limit-request-line INT``\n\n**Default:** ``4094``\n\nThe maximum size of HTTP request line in bytes.\n\nThis parameter is used to limit the allowed size of a client's\nHTTP request-line. Since the request-line consists of the HTTP\nmethod, URI, and protocol version, this directive places a\nrestriction on the length of a request-URI allowed for a request\non the server. A server needs this value to be large enough to\nhold any of its resource names, including any information that\nmight be passed in the query part of a GET request. Value is a number\nfrom 0 (unlimited) to 8190.\n\nThis parameter can be used to prevent any DDOS attack.\n\n.. _limit-request-fields:\n\n``limit_request_fields``\n~~~~~~~~~~~~~~~~~~~~~~~~\n\n**Command line:** ``--limit-request-fields INT``\n\n**Default:** ``100``\n\nLimit the number of HTTP headers fields in a request.\n\nThis parameter is used to limit the number of headers in a request to\nprevent DDOS attack. Used with the *limit_request_field_size* it allows\nmore safety. By default this value is 100 and can't be larger than\n32768.\n\n.. _limit-request-field-size:\n\n``limit_request_field_size``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n**Command line:** ``--limit-request-field_size INT``\n\n**Default:** ``8190``\n\nLimit the allowed size of an HTTP request header field.\n\nValue is a positive number or 0. Setting it to 0 will allow unlimited\nheader field sizes.\n\n.. warning::\n   Setting this parameter to a very high or unlimited value can open\n   up for DDOS attacks.\n\nServer Hooks\n------------\n\n.. _on-starting:\n\n``on_starting``\n~~~~~~~~~~~~~~~\n\n**Default:** \n\n.. code-block:: python\n\n        def on_starting(server):\n            pass\n\nCalled just before the master process is initialized.\n\nThe callable needs to accept a single instance variable for the Arbiter.\n\n.. _on-reload:\n\n``on_reload``\n~~~~~~~~~~~~~\n\n**Default:** \n\n.. code-block:: python\n\n        def on_reload(server):\n            pass\n\nCalled to recycle workers during a reload via SIGHUP.\n\nThe callable needs to accept a single instance variable for the Arbiter.\n\n.. _when-ready:\n\n``when_ready``\n~~~~~~~~~~~~~~\n\n**Default:** \n\n.. code-block:: python\n\n        def when_ready(server):\n            pass\n\nCalled just after the server is started.\n\nThe callable needs to accept a single instance variable for the Arbiter.\n\n.. _pre-fork:\n\n``pre_fork``\n~~~~~~~~~~~~\n\n**Default:** \n\n.. code-block:: python\n\n        def pre_fork(server, worker):\n            pass\n\nCalled just before a worker is forked.\n\nThe callable needs to accept two instance variables for the Arbiter and\nnew Worker.\n\n.. _post-fork:\n\n``post_fork``\n~~~~~~~~~~~~~\n\n**Default:** \n\n.. code-block:: python\n\n        def post_fork(server, worker):\n            pass\n\nCalled just after a worker has been forked.\n\nThe callable needs to accept two instance variables for the Arbiter and\nnew Worker.\n\n.. _post-worker-init:\n\n``post_worker_init``\n~~~~~~~~~~~~~~~~~~~~\n\n**Default:** \n\n.. code-block:: python\n\n        def post_worker_init(worker):\n            pass\n\nCalled just after a worker has initialized the application.\n\nThe callable needs to accept one instance variable for the initialized\nWorker.\n\n.. _worker-int:\n\n``worker_int``\n~~~~~~~~~~~~~~\n\n**Default:** \n\n.. code-block:: python\n\n        def worker_int(worker):\n            pass\n\nCalled just after a worker exited on SIGINT or SIGQUIT.\n\nThe callable needs to accept one instance variable for the initialized\nWorker.\n\n.. _worker-abort:\n\n``worker_abort``\n~~~~~~~~~~~~~~~~\n\n**Default:** \n\n.. code-block:: python\n\n        def worker_abort(worker):\n            pass\n\nCalled when a worker received the SIGABRT signal.\n\nThis call generally happens on timeout.\n\nThe callable needs to accept one instance variable for the initialized\nWorker.\n\n.. _pre-exec:\n\n``pre_exec``\n~~~~~~~~~~~~\n\n**Default:** \n\n.. code-block:: python\n\n        def pre_exec(server):\n            pass\n\nCalled just before a new master process is forked.\n\nThe callable needs to accept a single instance variable for the Arbiter.\n\n.. _pre-request:\n\n``pre_request``\n~~~~~~~~~~~~~~~\n\n**Default:** \n\n.. code-block:: python\n\n        def pre_request(worker, req):\n            worker.log.debug(\"%s %s\", req.method, req.path)\n\nCalled just before a worker processes the request.\n\nThe callable needs to accept two instance variables for the Worker and\nthe Request.\n\n.. _post-request:\n\n``post_request``\n~~~~~~~~~~~~~~~~\n\n**Default:** \n\n.. code-block:: python\n\n        def post_request(worker, req, environ, resp):\n            pass\n\nCalled after a worker processes the request.\n\nThe callable needs to accept two instance variables for the Worker and\nthe Request.\n\n.. _child-exit:\n\n``child_exit``\n~~~~~~~~~~~~~~\n\n**Default:** \n\n.. code-block:: python\n\n        def child_exit(server, worker):\n            pass\n\nCalled just after a worker has been exited, in the master process.\n\nThe callable needs to accept two instance variables for the Arbiter and\nthe just-exited Worker.\n\n.. versionadded:: 19.7\n\n.. _worker-exit:\n\n``worker_exit``\n~~~~~~~~~~~~~~~\n\n**Default:** \n\n.. code-block:: python\n\n        def worker_exit(server, worker):\n            pass\n\nCalled just after a worker has been exited, in the worker process.\n\nThe callable needs to accept two instance variables for the Arbiter and\nthe just-exited Worker.\n\n.. _nworkers-changed:\n\n``nworkers_changed``\n~~~~~~~~~~~~~~~~~~~~\n\n**Default:** \n\n.. code-block:: python\n\n        def nworkers_changed(server, new_value, old_value):\n            pass\n\nCalled just after *num_workers* has been changed.\n\nThe callable needs to accept an instance variable of the Arbiter and\ntwo integers of number of workers after and before change.\n\nIf the number of workers is set for the first time, *old_value* would\nbe ``None``.\n\n.. _on-exit:\n\n``on_exit``\n~~~~~~~~~~~\n\n**Default:** \n\n.. code-block:: python\n\n        def on_exit(server):\n            pass\n\nCalled just before exiting Gunicorn.\n\nThe callable needs to accept a single instance variable for the Arbiter.\n\n.. _ssl-context:\n\n``ssl_context``\n~~~~~~~~~~~~~~~\n\n**Default:** \n\n.. code-block:: python\n\n        def ssl_context(config, default_ssl_context_factory):\n            return default_ssl_context_factory()\n\nCalled when SSLContext is needed.\n\nAllows customizing SSL context.\n\nThe callable needs to accept an instance variable for the Config and\na factory function that returns default SSLContext which is initialized\nwith certificates, private key, cert_reqs, and ciphers according to\nconfig and can be further customized by the callable.\nThe callable needs to return SSLContext object.\n\nFollowing example shows a configuration file that sets the minimum TLS version to 1.3:\n\n.. code-block:: python\n\n    def ssl_context(conf, default_ssl_context_factory):\n        import ssl\n        context = default_ssl_context_factory()\n        context.minimum_version = ssl.TLSVersion.TLSv1_3\n        return context\n\n.. versionadded:: 21.0\n\nServer Mechanics\n----------------\n\n.. _preload-app:\n\n``preload_app``\n~~~~~~~~~~~~~~~\n\n**Command line:** ``--preload``\n\n**Default:** ``False``\n\nLoad application code before the worker processes are forked.\n\nBy preloading an application you can save some RAM resources as well as\nspeed up server boot times. Although, if you defer application loading\nto each worker process, you can reload your application code easily by\nrestarting workers.\n\n.. _sendfile:\n\n``sendfile``\n~~~~~~~~~~~~\n\n**Command line:** ``--no-sendfile``\n\n**Default:** ``None``\n\nDisables the use of ``sendfile()``.\n\nIf not set, the value of the ``SENDFILE`` environment variable is used\nto enable or disable its usage.\n\n.. versionadded:: 19.2\n.. versionchanged:: 19.4\n   Swapped ``--sendfile`` with ``--no-sendfile`` to actually allow\n   disabling.\n.. versionchanged:: 19.6\n   added support for the ``SENDFILE`` environment variable\n\n.. _reuse-port:\n\n``reuse_port``\n~~~~~~~~~~~~~~\n\n**Command line:** ``--reuse-port``\n\n**Default:** ``False``\n\nSet the ``SO_REUSEPORT`` flag on the listening socket.\n\n.. versionadded:: 19.8\n\n.. _chdir:\n\n``chdir``\n~~~~~~~~~\n\n**Command line:** ``--chdir``\n\n**Default:** ``'.'``\n\nChange directory to specified directory before loading apps.\n\n.. _daemon:\n\n``daemon``\n~~~~~~~~~~\n\n**Command line:** ``-D`` or ``--daemon``\n\n**Default:** ``False``\n\nDaemonize the Gunicorn process.\n\nDetaches the server from the controlling terminal and enters the\nbackground.\n\n.. _raw-env:\n\n``raw_env``\n~~~~~~~~~~~\n\n**Command line:** ``-e ENV`` or ``--env ENV``\n\n**Default:** ``[]``\n\nSet environment variables in the execution environment.\n\nShould be a list of strings in the ``key=value`` format.\n\nFor example on the command line:\n\n.. code-block:: console\n\n    $ gunicorn -b 127.0.0.1:8000 --env FOO=1 test:app\n\nOr in the configuration file:\n\n.. code-block:: python\n\n    raw_env = [\"FOO=1\"]\n\n.. _pidfile:\n\n``pidfile``\n~~~~~~~~~~~\n\n**Command line:** ``-p FILE`` or ``--pid FILE``\n\n**Default:** ``None``\n\nA filename to use for the PID file.\n\nIf not set, no PID file will be written.\n\n.. _worker-tmp-dir:\n\n``worker_tmp_dir``\n~~~~~~~~~~~~~~~~~~\n\n**Command line:** ``--worker-tmp-dir DIR``\n\n**Default:** ``None``\n\nA directory to use for the worker heartbeat temporary file.\n\nIf not set, the default temporary directory will be used.\n\n.. note::\n   The current heartbeat system involves calling ``os.fchmod`` on\n   temporary file handlers and may block a worker for arbitrary time\n   if the directory is on a disk-backed filesystem.\n\n   See :ref:`blocking-os-fchmod` for more detailed information\n   and a solution for avoiding this problem.\n\n.. _user:\n\n``user``\n~~~~~~~~\n\n**Command line:** ``-u USER`` or ``--user USER``\n\n**Default:** ``os.geteuid()``\n\nSwitch worker processes to run as this user.\n\nA valid user id (as an integer) or the name of a user that can be\nretrieved with a call to ``pwd.getpwnam(value)`` or ``None`` to not\nchange the worker process user.\n\n.. _group:\n\n``group``\n~~~~~~~~~\n\n**Command line:** ``-g GROUP`` or ``--group GROUP``\n\n**Default:** ``os.getegid()``\n\nSwitch worker process to run as this group.\n\nA valid group id (as an integer) or the name of a user that can be\nretrieved with a call to ``pwd.getgrnam(value)`` or ``None`` to not\nchange the worker processes group.\n\n.. _umask:\n\n``umask``\n~~~~~~~~~\n\n**Command line:** ``-m INT`` or ``--umask INT``\n\n**Default:** ``0``\n\nA bit mask for the file mode on files written by Gunicorn.\n\nNote that this affects unix socket permissions.\n\nA valid value for the ``os.umask(mode)`` call or a string compatible\nwith ``int(value, 0)`` (``0`` means Python guesses the base, so values\nlike ``0``, ``0xFF``, ``0022`` are valid for decimal, hex, and octal\nrepresentations)\n\n.. _initgroups:\n\n``initgroups``\n~~~~~~~~~~~~~~\n\n**Command line:** ``--initgroups``\n\n**Default:** ``False``\n\nIf true, set the worker process's group access list with all of the\ngroups of which the specified username is a member, plus the specified\ngroup id.\n\n.. versionadded:: 19.7\n\n.. _tmp-upload-dir:\n\n``tmp_upload_dir``\n~~~~~~~~~~~~~~~~~~\n\n**Default:** ``None``\n\nDirectory to store temporary request data as they are read.\n\nThis may disappear in the near future.\n\nThis path should be writable by the process permissions set for Gunicorn\nworkers. If not specified, Gunicorn will choose a system generated\ntemporary directory.\n\n.. _secure-scheme-headers:\n\n``secure_scheme_headers``\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\n**Default:** ``{'X-FORWARDED-PROTOCOL': 'ssl', 'X-FORWARDED-PROTO': 'https', 'X-FORWARDED-SSL': 'on'}``\n\nA dictionary containing headers and values that the front-end proxy\nuses to indicate HTTPS requests. If the source IP is permitted by\n:ref:`forwarded-allow-ips` (below), *and* at least one request header matches\na key-value pair listed in this dictionary, then Gunicorn will set\n``wsgi.url_scheme`` to ``https``, so your application can tell that the\nrequest is secure.\n\nIf the other headers listed in this dictionary are not present in the request, they will be ignored,\nbut if the other headers are present and do not match the provided values, then\nthe request will fail to parse. See the note below for more detailed examples of this behaviour.\n\nThe dictionary should map upper-case header names to exact string\nvalues. The value comparisons are case-sensitive, unlike the header\nnames, so make sure they're exactly what your front-end proxy sends\nwhen handling HTTPS requests.\n\nIt is important that your front-end proxy configuration ensures that\nthe headers defined here can not be passed directly from the client.\n\n.. _forwarded-allow-ips:\n\n``forwarded_allow_ips``\n~~~~~~~~~~~~~~~~~~~~~~~\n\n**Command line:** ``--forwarded-allow-ips STRING``\n\n**Default:** ``'127.0.0.1,::1'``\n\nFront-end's IPs from which allowed to handle set secure headers.\n(comma separated).\n\nSet to ``*`` to disable checking of front-end IPs. This is useful for setups\nwhere you don't know in advance the IP address of front-end, but\ninstead have ensured via other means that only your\nauthorized front-ends can access Gunicorn.\n\nBy default, the value of the ``FORWARDED_ALLOW_IPS`` environment\nvariable. If it is not defined, the default is ``\"127.0.0.1,::1\"``.\n\n.. note::\n\n    This option does not affect UNIX socket connections. Connections not associated with\n    an IP address are treated as allowed, unconditionally.\n\n.. note::\n\n    The interplay between the request headers, the value of ``forwarded_allow_ips``, and the value of\n    ``secure_scheme_headers`` is complex. Various scenarios are documented below to further elaborate.\n    In each case, we have a request from the remote address 134.213.44.18, and the default value of\n    ``secure_scheme_headers``:\n\n    .. code::\n\n        secure_scheme_headers = {\n            'X-FORWARDED-PROTOCOL': 'ssl',\n            'X-FORWARDED-PROTO': 'https',\n            'X-FORWARDED-SSL': 'on'\n        }\n\n\n    .. list-table::\n        :header-rows: 1\n        :align: center\n        :widths: auto\n\n        * - ``forwarded-allow-ips``\n          - Secure Request Headers\n          - Result\n          - Explanation\n        * - .. code::\n\n                [\"127.0.0.1\"]\n          - .. code::\n\n                X-Forwarded-Proto: https\n          - .. code::\n\n                wsgi.url_scheme = \"http\"\n          - IP address was not allowed\n        * - .. code::\n\n                \"*\"\n          - <none>\n          - .. code::\n\n                wsgi.url_scheme = \"http\"\n          - IP address allowed, but no secure headers provided\n        * - .. code::\n\n                \"*\"\n          - .. code::\n\n                X-Forwarded-Proto: https\n          - .. code::\n\n                wsgi.url_scheme = \"https\"\n          - IP address allowed, one request header matched\n        * - .. code::\n\n                [\"134.213.44.18\"]\n          - .. code::\n\n                X-Forwarded-Ssl: on\n                X-Forwarded-Proto: http\n          - ``InvalidSchemeHeaders()`` raised\n          - IP address allowed, but the two secure headers disagreed on if HTTPS was used\n\n.. _pythonpath:\n\n``pythonpath``\n~~~~~~~~~~~~~~\n\n**Command line:** ``--pythonpath STRING``\n\n**Default:** ``None``\n\nA comma-separated list of directories to add to the Python path.\n\ne.g.\n``'/home/djangoprojects/myproject,/home/python/mylibrary'``.\n\n.. _paste:\n\n``paste``\n~~~~~~~~~\n\n**Command line:** ``--paste STRING`` or ``--paster STRING``\n\n**Default:** ``None``\n\nLoad a PasteDeploy config file. The argument may contain a ``#``\nsymbol followed by the name of an app section from the config file,\ne.g. ``production.ini#admin``.\n\nAt this time, using alternate server blocks is not supported. Use the\ncommand line arguments to control server configuration instead.\n\n.. _proxy-protocol:\n\n``proxy_protocol``\n~~~~~~~~~~~~~~~~~~\n\n**Command line:** ``--proxy-protocol``\n\n**Default:** ``False``\n\nEnable detect PROXY protocol (PROXY mode).\n\nAllow using HTTP and Proxy together. It may be useful for work with\nstunnel as HTTPS frontend and Gunicorn as HTTP server.\n\nPROXY protocol: http://haproxy.1wt.eu/download/1.5/doc/proxy-protocol.txt\n\nExample for stunnel config::\n\n    [https]\n    protocol = proxy\n    accept  = 443\n    connect = 80\n    cert = /etc/ssl/certs/stunnel.pem\n    key = /etc/ssl/certs/stunnel.key\n\n.. _proxy-allow-ips:\n\n``proxy_allow_ips``\n~~~~~~~~~~~~~~~~~~~\n\n**Command line:** ``--proxy-allow-from``\n\n**Default:** ``'127.0.0.1,::1'``\n\nFront-end's IPs from which allowed accept proxy requests (comma separated).\n\nSet to ``*`` to disable checking of front-end IPs. This is useful for setups\nwhere you don't know in advance the IP address of front-end, but\ninstead have ensured via other means that only your\nauthorized front-ends can access Gunicorn.\n\n.. note::\n\n    This option does not affect UNIX socket connections. Connections not associated with\n    an IP address are treated as allowed, unconditionally.\n\n.. _raw-paste-global-conf:\n\n``raw_paste_global_conf``\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\n**Command line:** ``--paste-global CONF``\n\n**Default:** ``[]``\n\nSet a PasteDeploy global config variable in ``key=value`` form.\n\nThe option can be specified multiple times.\n\nThe variables are passed to the PasteDeploy entrypoint. Example::\n\n    $ gunicorn -b 127.0.0.1:8000 --paste development.ini --paste-global FOO=1 --paste-global BAR=2\n\n.. versionadded:: 19.7\n\n.. _permit-obsolete-folding:\n\n``permit_obsolete_folding``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n**Command line:** ``--permit-obsolete-folding``\n\n**Default:** ``False``\n\nPermit requests employing obsolete HTTP line folding mechanism\n\nThe folding mechanism was deprecated by rfc7230 Section 3.2.4 and will not be\n employed in HTTP request headers from standards-compliant HTTP clients.\n\nThis option is provided to diagnose backwards-incompatible changes.\nUse with care and only if necessary. Temporary; the precise effect of this option may\nchange in a future version, or it may be removed altogether.\n\n.. versionadded:: 23.0.0\n\n.. _strip-header-spaces:\n\n``strip_header_spaces``\n~~~~~~~~~~~~~~~~~~~~~~~\n\n**Command line:** ``--strip-header-spaces``\n\n**Default:** ``False``\n\nStrip spaces present between the header name and the the ``:``.\n\nThis is known to induce vulnerabilities and is not compliant with the HTTP/1.1 standard.\nSee https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn.\n\nUse with care and only if necessary. Deprecated; scheduled for removal in 25.0.0\n\n.. versionadded:: 20.0.1\n\n.. _permit-unconventional-http-method:\n\n``permit_unconventional_http_method``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n**Command line:** ``--permit-unconventional-http-method``\n\n**Default:** ``False``\n\nPermit HTTP methods not matching conventions, such as IANA registration guidelines\n\nThis permits request methods of length less than 3 or more than 20,\nmethods with lowercase characters or methods containing the # character.\nHTTP methods are case sensitive by definition, and merely uppercase by convention.\n\nIf unset, Gunicorn will apply nonstandard restrictions and cause 400 response status\nin cases where otherwise 501 status is expected. While this option does modify that\nbehaviour, it should not be depended upon to guarantee standards-compliant behaviour.\nRather, it is provided temporarily, to assist in diagnosing backwards-incompatible\nchanges around the incomplete application of those restrictions.\n\nUse with care and only if necessary. Temporary; scheduled for removal in 24.0.0\n\n.. versionadded:: 22.0.0\n\n.. _permit-unconventional-http-version:\n\n``permit_unconventional_http_version``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n**Command line:** ``--permit-unconventional-http-version``\n\n**Default:** ``False``\n\nPermit HTTP version not matching conventions of 2023\n\nThis disables the refusal of likely malformed request lines.\nIt is unusual to specify HTTP 1 versions other than 1.0 and 1.1.\n\nThis option is provided to diagnose backwards-incompatible changes.\nUse with care and only if necessary. Temporary; the precise effect of this option may\nchange in a future version, or it may be removed altogether.\n\n.. versionadded:: 22.0.0\n\n.. _casefold-http-method:\n\n``casefold_http_method``\n~~~~~~~~~~~~~~~~~~~~~~~~\n\n**Command line:** ``--casefold-http-method``\n\n**Default:** ``False``\n\nTransform received HTTP methods to uppercase\n\nHTTP methods are case sensitive by definition, and merely uppercase by convention.\n\nThis option is provided because previous versions of gunicorn defaulted to this behaviour.\n\nUse with care and only if necessary. Deprecated; scheduled for removal in 24.0.0\n\n.. versionadded:: 22.0.0\n\n.. _forwarder-headers:\n\n``forwarder_headers``\n~~~~~~~~~~~~~~~~~~~~~\n\n**Command line:** ``--forwarder-headers``\n\n**Default:** ``'SCRIPT_NAME,PATH_INFO'``\n\nA list containing upper-case header field names that the front-end proxy\n(see :ref:`forwarded-allow-ips`) sets, to be used in WSGI environment.\n\nThis option has no effect for headers not present in the request.\n\nThis option can be used to transfer ``SCRIPT_NAME``, ``PATH_INFO``\nand ``REMOTE_USER``.\n\nIt is important that your front-end proxy configuration ensures that\nthe headers defined here can not be passed directly from the client.\n\n.. _header-map:\n\n``header_map``\n~~~~~~~~~~~~~~\n\n**Command line:** ``--header-map``\n\n**Default:** ``'drop'``\n\nConfigure how header field names are mapped into environ\n\nHeaders containing underscores are permitted by RFC9110,\nbut gunicorn joining headers of different names into\nthe same environment variable will dangerously confuse applications as to which is which.\n\nThe safe default ``drop`` is to silently drop headers that cannot be unambiguously mapped.\nThe value ``refuse`` will return an error if a request contains *any* such header.\nThe value ``dangerous`` matches the previous, not advisable, behaviour of mapping different\nheader field names into the same environ name.\n\nIf the source is permitted as explained in :ref:`forwarded-allow-ips`, *and* the header name is\npresent in :ref:`forwarder-headers`, the header is mapped into environment regardless of\nthe state of this setting.\n\nUse with care and only if necessary and after considering if your problem could\ninstead be solved by specifically renaming or rewriting only the intended headers\non a proxy in front of Gunicorn.\n\n.. versionadded:: 22.0.0\n\nServer Socket\n-------------\n\n.. _bind:\n\n``bind``\n~~~~~~~~\n\n**Command line:** ``-b ADDRESS`` or ``--bind ADDRESS``\n\n**Default:** ``['127.0.0.1:8000']``\n\nThe socket to bind.\n\nA string of the form: ``HOST``, ``HOST:PORT``, ``unix:PATH``,\n``fd://FD``. An IP is a valid ``HOST``.\n\n.. versionchanged:: 20.0\n   Support for ``fd://FD`` got added.\n\nMultiple addresses can be bound. ex.::\n\n    $ gunicorn -b 127.0.0.1:8000 -b [::1]:8000 test:app\n\nwill bind the `test:app` application on localhost both on ipv6\nand ipv4 interfaces.\n\nIf the ``PORT`` environment variable is defined, the default\nis ``['0.0.0.0:$PORT']``. If it is not defined, the default\nis ``['127.0.0.1:8000']``.\n\n.. _backlog:\n\n``backlog``\n~~~~~~~~~~~\n\n**Command line:** ``--backlog INT``\n\n**Default:** ``2048``\n\nThe maximum number of pending connections.\n\nThis refers to the number of clients that can be waiting to be served.\nExceeding this number results in the client getting an error when\nattempting to connect. It should only affect servers under significant\nload.\n\nMust be a positive integer. Generally set in the 64-2048 range.\n\nWorker Processes\n----------------\n\n.. _workers:\n\n``workers``\n~~~~~~~~~~~\n\n**Command line:** ``-w INT`` or ``--workers INT``\n\n**Default:** ``1``\n\nThe number of worker processes for handling requests.\n\nA positive integer generally in the ``2-4 x $(NUM_CORES)`` range.\nYou'll want to vary this a bit to find the best for your particular\napplication's work load.\n\nBy default, the value of the ``WEB_CONCURRENCY`` environment variable,\nwhich is set by some Platform-as-a-Service providers such as Heroku. If\nit is not defined, the default is ``1``.\n\n.. _worker-class:\n\n``worker_class``\n~~~~~~~~~~~~~~~~\n\n**Command line:** ``-k STRING`` or ``--worker-class STRING``\n\n**Default:** ``'sync'``\n\nThe type of workers to use.\n\nThe default class (``sync``) should handle most \"normal\" types of\nworkloads. You'll want to read :doc:`design` for information on when\nyou might want to choose one of the other worker classes. Required\nlibraries may be installed using setuptools' ``extras_require`` feature.\n\nA string referring to one of the following bundled classes:\n\n* ``sync``\n* ``eventlet`` - Requires eventlet >= 0.24.1 (or install it via\n  ``pip install gunicorn[eventlet]``)\n* ``gevent``   - Requires gevent >= 1.4 (or install it via\n  ``pip install gunicorn[gevent]``)\n* ``tornado``  - Requires tornado >= 0.2 (or install it via\n  ``pip install gunicorn[tornado]``)\n* ``gthread``  - Python 2 requires the futures package to be installed\n  (or install it via ``pip install gunicorn[gthread]``)\n\nOptionally, you can provide your own worker by giving Gunicorn a\nPython path to a subclass of ``gunicorn.workers.base.Worker``.\nThis alternative syntax will load the gevent class:\n``gunicorn.workers.ggevent.GeventWorker``.\n\n.. _threads:\n\n``threads``\n~~~~~~~~~~~\n\n**Command line:** ``--threads INT``\n\n**Default:** ``1``\n\nThe number of worker threads for handling requests.\n\nRun each worker with the specified number of threads.\n\nA positive integer generally in the ``2-4 x $(NUM_CORES)`` range.\nYou'll want to vary this a bit to find the best for your particular\napplication's work load.\n\nIf it is not defined, the default is ``1``.\n\nThis setting only affects the Gthread worker type.\n\n.. note::\n   If you try to use the ``sync`` worker type and set the ``threads``\n   setting to more than 1, the ``gthread`` worker type will be used\n   instead.\n\n.. _worker-connections:\n\n``worker_connections``\n~~~~~~~~~~~~~~~~~~~~~~\n\n**Command line:** ``--worker-connections INT``\n\n**Default:** ``1000``\n\nThe maximum number of simultaneous clients.\n\nThis setting only affects the ``gthread``, ``eventlet`` and ``gevent`` worker types.\n\n.. _max-requests:\n\n``max_requests``\n~~~~~~~~~~~~~~~~\n\n**Command line:** ``--max-requests INT``\n\n**Default:** ``0``\n\nThe maximum number of requests a worker will process before restarting.\n\nAny value greater than zero will limit the number of requests a worker\nwill process before automatically restarting. This is a simple method\nto help limit the damage of memory leaks.\n\nIf this is set to zero (the default) then the automatic worker\nrestarts are disabled.\n\n.. _max-requests-jitter:\n\n``max_requests_jitter``\n~~~~~~~~~~~~~~~~~~~~~~~\n\n**Command line:** ``--max-requests-jitter INT``\n\n**Default:** ``0``\n\nThe maximum jitter to add to the *max_requests* setting.\n\nThe jitter causes the restart per worker to be randomized by\n``randint(0, max_requests_jitter)``. This is intended to stagger worker\nrestarts to avoid all workers restarting at the same time.\n\n.. versionadded:: 19.2\n\n.. _timeout:\n\n``timeout``\n~~~~~~~~~~~\n\n**Command line:** ``-t INT`` or ``--timeout INT``\n\n**Default:** ``30``\n\nWorkers silent for more than this many seconds are killed and restarted.\n\nValue is a positive number or 0. Setting it to 0 has the effect of\ninfinite timeouts by disabling timeouts for all workers entirely.\n\nGenerally, the default of thirty seconds should suffice. Only set this\nnoticeably higher if you're sure of the repercussions for sync workers.\nFor the non sync workers it just means that the worker process is still\ncommunicating and is not tied to the length of time required to handle a\nsingle request.\n\n.. _graceful-timeout:\n\n``graceful_timeout``\n~~~~~~~~~~~~~~~~~~~~\n\n**Command line:** ``--graceful-timeout INT``\n\n**Default:** ``30``\n\nTimeout for graceful workers restart.\n\nAfter receiving a restart signal, workers have this much time to finish\nserving requests. Workers still alive after the timeout (starting from\nthe receipt of the restart signal) are force killed.\n\n.. _keepalive:\n\n``keepalive``\n~~~~~~~~~~~~~\n\n**Command line:** ``--keep-alive INT``\n\n**Default:** ``2``\n\nThe number of seconds to wait for requests on a Keep-Alive connection.\n\nGenerally set in the 1-5 seconds range for servers with direct connection\nto the client (e.g. when you don't have separate load balancer). When\nGunicorn is deployed behind a load balancer, it often makes sense to\nset this to a higher value.\n\n.. note::\n   ``sync`` worker does not support persistent connections and will\n   ignore this option.\n\n",
      "source_file": "docs/source/settings.rst",
      "chunk_type": "doc"
    },
    {
      "content": ".. _custom:\n\n==================\nCustom Application\n==================\n\n.. versionadded:: 19.0\n\nSometimes, you want to integrate Gunicorn with your WSGI application. In this\ncase, you can inherit from :class:`gunicorn.app.base.BaseApplication`.\n\nHere is a small example where we create a very small WSGI app and load it with\na custom Application:\n\n.. literalinclude:: ../../examples/standalone_app.py\n    :start-after: # See the NOTICE for more information\n    :lines: 2-\n\nUsing server hooks\n------------------\n\nIf you wish to include server hooks in your custom application, you can specify a function in the config options.  Here is an example with the `pre_fork` hook:\n\n.. code-block:: python\n\n   def pre_fork(server, worker):\n       print(f\"pre-fork server {server} worker {worker}\", file=sys.stderr)\n\n   # ...\n   if __name__ == '__main__':\n       options = {\n           'bind': '%s:%s' % ('127.0.0.1', '8080'),\n           'workers': number_of_workers(),\n           'pre_fork': pre_fork,\n       }\n\n\nDirect Usage of Existing WSGI Apps\n----------------------------------\n\nIf necessary, you can run Gunicorn straight from Python, allowing you to\nspecify a WSGI-compatible application at runtime. This can be handy for\nrolling deploys or in the case of using PEX files to deploy your application,\nas the app and Gunicorn can be bundled in the same PEX file. Gunicorn has\nthis functionality built-in as a first class citizen known as\n:class:`gunicorn.app.wsgiapp`. This can be used to run WSGI-compatible app\ninstances such as those produced by Flask or Django. Assuming your WSGI API\npackage is *exampleapi*, and your application instance is *app*, this is all\nyou need to get going::\n\n    gunicorn.app.wsgiapp exampleapi:app\n\nThis command will work with any Gunicorn CLI parameters or a config file - just\npass them along as if you're directly giving them to Gunicorn:\n\n.. code-block:: bash\n\n   # Custom parameters\n   $ python gunicorn.app.wsgiapp exampleapi:app --bind=0.0.0.0:8081 --workers=4\n   # Using a config file\n   $ python gunicorn.app.wsgiapp exampleapi:app -c config.py\n    \nNote for those using PEX: use ``-c gunicorn`` as your entry at build\ntime, and your compiled app should work with the entry point passed to it at\nrun time. \n\n.. code-block:: bash\n\n   # Generic pex build command via bash from root of exampleapi project\n   $ pex . -v -c gunicorn -o compiledapp.pex\n   # Running it\n   ./compiledapp.pex exampleapi:app -c gunicorn_config.py\n",
      "source_file": "docs/source/custom.rst",
      "chunk_type": "doc"
    },
    {
      "content": "======================\nGunicorn - WSGI server\n======================\n\n.. image:: _static/gunicorn.png\n\n:Website: http://gunicorn.org\n:Source code: https://github.com/benoitc/gunicorn\n:Issue tracker: https://github.com/benoitc/gunicorn/issues\n:IRC: ``#gunicorn`` on Libera Chat\n:Usage questions: https://github.com/benoitc/gunicorn/issues\n\nGunicorn 'Green Unicorn' is a Python WSGI HTTP Server for UNIX. It's a pre-fork\nworker model ported from Ruby's Unicorn project. The Gunicorn server is broadly\ncompatible with various web frameworks, simply implemented, light on server\nresources, and fairly speedy.\n\nFeatures\n--------\n\n* Natively supports WSGI, Django, and Paster\n* Automatic worker process management\n* Simple Python configuration\n* Multiple worker configurations\n* Various server hooks for extensibility\n* Compatible with Python 3.x >= 3.7\n\n\nContents\n--------\n\n.. toctree::\n    :maxdepth: 2\n\n    install\n    run\n    configure\n    settings\n    instrumentation\n    deploy\n    signals\n    custom\n    design\n    faq\n    community\n    news\n",
      "source_file": "docs/source/index.rst",
      "chunk_type": "doc"
    },
    {
      "content": "================\nChangelog - 2018\n================\n\n.. note::\n\n   Please see :doc:`news` for the latest changes\n\n19.9.0 / 2018/07/03\n===================\n\n- fix: address a regression that prevented syslog support from working\n  (:issue:`1668`, :pr:`1773`)\n- fix: correctly set `REMOTE_ADDR` on versions of Python 3 affected by\n  `Python Issue 30205 <https://bugs.python.org/issue30205>`_\n  (:issue:`1755`, :pr:`1796`)\n- fix: show zero response length correctly in access log (:pr:`1787`)\n- fix: prevent raising :exc:`AttributeError` when ``--reload`` is not passed\n  in case of a :exc:`SyntaxError` raised from the WSGI application.\n  (:issue:`1805`, :pr:`1806`)\n- The internal module ``gunicorn.workers.async`` was renamed to ``gunicorn.workers.base_async``\n  since ``async`` is now a reserved word in Python 3.7.\n  (:pr:`1527`)\n\n19.8.1 / 2018/04/30\n===================\n\n- fix: secure scheme headers when bound to a unix socket\n  (:issue:`1766`, :pr:`1767`)\n\n19.8.0 / 2018/04/28\n===================\n\n- Eventlet 0.21.0 support (:issue:`1584`)\n- Tornado 5 support (:issue:`1728`, :pr:`1752`)\n- support watching additional files with ``--reload-extra-file``\n  (:pr:`1527`)\n- support configuring logging with a dictionary with ``--logging-config-dict``\n  (:issue:`1087`, :pr:`1110`, :pr:`1602`)\n- add support for the ``--config`` flag in the ``GUNICORN_CMD_ARGS`` environment\n  variable (:issue:`1576`, :pr:`1581`)\n- disable ``SO_REUSEPORT`` by default and add the ``--reuse-port`` setting\n  (:issue:`1553`, :issue:`1603`, :pr:`1669`)\n- fix: installing `inotify` on MacOS no longer breaks the reloader\n  (:issue:`1540`, :pr:`1541`)\n- fix: do not throw ``TypeError`` when ``SO_REUSEPORT`` is not available\n  (:issue:`1501`, :pr:`1491`)\n- fix: properly decode HTTP paths containing certain non-ASCII characters\n  (:issue:`1577`, :pr:`1578`)\n- fix: remove whitespace when logging header values under gevent (:pr:`1607`)\n- fix: close unlinked temporary files (:issue:`1327`, :pr:`1428`)\n- fix: parse ``--umask=0`` correctly (:issue:`1622`, :pr:`1632`)\n- fix: allow loading applications using relative file paths\n  (:issue:`1349`, :pr:`1481`)\n- fix: force blocking mode on the gevent sockets (:issue:`880`, :pr:`1616`)\n- fix: preserve leading `/` in request path (:issue:`1512`, :pr:`1511`)\n- fix: forbid contradictory secure scheme headers\n- fix: handle malformed basic authentication headers in access log\n  (:issue:`1683`, :pr:`1684`)\n- fix: defer handling of ``USR1`` signal to a new greenlet under gevent\n  (:issue:`1645`, :pr:`1651`)\n- fix: the threaded worker would sometimes close the wrong keep-alive\n  connection under Python 2 (:issue:`1698`, :pr:`1699`)\n- fix: re-open log files on ``USR1`` signal using ``handler._open`` to\n  support subclasses of ``FileHandler`` (:issue:`1739`, :pr:`1742`)\n- deprecation: the ``gaiohttp`` worker is deprecated, see the\n  :ref:`worker-class` documentation for more information\n  (:issue:`1338`, :pr:`1418`, :pr:`1569`)",
      "source_file": "docs/source/2018-news.rst",
      "chunk_type": "doc"
    },
    {
      "content": "================\nChangelog - 2019\n================\n\n.. note::\n\n   Please see :doc:`news` for the latest changes\n\n20.0.4 / 2019/11/26\n===================\n\n- fix binding a socket using the file descriptor\n- remove support for the `bdist_rpm` build\n\n20.0.3 / 2019/11/24\n===================\n\n- fixed load of a config file without a Python extension\n- fixed `socketfromfd.fromfd` when defaults are not set\n\n.. note:: we now warn when we load a config file without Python Extension\n\n20.0.2 / 2019/11/23\n===================\n\n- fix changelog\n\n20.0.1 / 2019/11/23\n===================\n\n- fixed the way the config module is loaded. `__file__` is now available\n- fixed `wsgi.input_terminated`. It is always true.\n- use the highest protocol version of openssl by default\n- only support Python >= 3.5\n- added `__repr__` method to `Config` instance\n- fixed support of AIX platform and musl libc in  `socketfromfd.fromfd` function\n- fixed support of applications loaded from a factory function\n- fixed chunked encoding support to prevent any `request smuggling <https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn>`_\n- Capture os.sendfile before patching in gevent and eventlet workers.\n  fix `RecursionError`.\n- removed locking in reloader when adding new files\n- load the WSGI application before the loader to pick up all files\n\n.. note:: this release add official support for applications loaded from a factory function\n   as documented in Flask and other places.\n\n\n19.10.0 / 2019/11/23\n====================\n\n- unblock select loop during reload of a sync worker\n- security fix: http desync attack\n- handle `wsgi.input_terminated`\n- added support for str and bytes in unix  socket addresses\n- fixed `max_requests` setting\n- headers values are now encoded as LATN1, not ASCII\n- fixed `InotifyReloadeder`:  handle `module.__file__` is None\n- fixed compatibility with tornado 6\n- fixed root logging\n- Prevent removalof unix sockets from `reuse_port`\n- Clear tornado ioloop before os.fork\n- Miscellaneous fixes and improvement for linting using Pylint\n\n20.0 / 2019/10/30\n=================\n\n- Fixed `fdopen` `RuntimeWarning` in Python 3.8\n- Added  check and exception for str type on value in Response process_headers method.\n- Ensure WSGI header value is string before conducting regex search on it.\n- Added pypy3 to list of tested environments\n- Grouped `StopIteration` and `KeyboardInterrupt` exceptions with same body together in Arbiter.run()\n- Added `setproctitle` module to `extras_require` in setup.py\n- Avoid unnecessary chown of temporary files\n- Logging: Handle auth type case insensitively\n- Removed `util.import_module`\n- Removed fallback for `types.SimpleNamespace` in tests utils\n- Use `SourceFileLoader` instead instead of `execfile_`\n- Use `importlib` instead of `__import__` and eval`\n- Fixed eventlet patching\n- Added optional `datadog <https://www.datadoghq.com>`_ tags for statsd metrics\n- Header values now are encoded using latin-1, not ascii.\n- Rewritten `parse_address` util added test\n- Removed redundant super() arguments\n- Simplify `futures` import in gthread module\n- Fixed worker_connections` setting to also affects the Gthread worker type\n- Fixed setting max_requests\n- Bump minimum Eventlet and Gevent versions to 0.24 and 1.4\n- Use Python default SSL cipher list by default\n- handle `wsgi.input_terminated` extension\n- Simplify Paste Deployment documentation\n- Fix root logging: root and logger are same level.\n- Fixed typo in ssl_version documentation\n- Documented  systemd deployment unit examples\n- Added systemd sd_notify support\n- Fixed typo in gthread.py\n- Added `tornado <https://www.tornadoweb.org/>`_ 5 and  6 support\n- Declare our setuptools dependency\n- Added support to `--bind` to open file descriptors\n- Document how to serve WSGI app modules from Gunicorn\n- Provide guidance on X-Forwarded-For access log in documentation\n- Add support for named constants in the `--ssl-version` flag\n- Clarify log format usage of header & environment in documentation\n- Fixed systemd documentation to properly setup gunicorn unix socket\n- Prevent removal unix socket for reuse_port\n- Fix `ResourceWarning` when reading a Python config module\n- Remove unnecessary call to dict keys method\n- Support str and bytes for UNIX socket addresses\n- fixed `InotifyReloadeder`:  handle `module.__file__` is None\n- `/dev/shm` as a convenient alternative to making your own tmpfs mount in fchmod FAQ\n- fix examples to work on python3\n- Fix typo in `--max-requests` documentation\n- Clear tornado ioloop before os.fork\n- Miscellaneous fixes and improvement for linting using Pylint\n\nBreaking Change\n+++++++++++++++\n\n- Removed gaiohttp worker\n- Drop support for Python 2.x\n- Drop support for EOL Python 3.2 and 3.3\n- Drop support for Paste Deploy server blocks\n",
      "source_file": "docs/source/2019-news.rst",
      "chunk_type": "doc"
    },
    {
      "content": "=========\nChangelog\n=========\n\n23.0.0 - 2024-08-10\n===================\n\n- minor docs fixes (:pr:`3217`, :pr:`3089`, :pr:`3167`)\n- worker_class parameter accepts a class (:pr:`3079`)\n- fix deadlock if request terminated during chunked parsing (:pr:`2688`)\n- permit receiving Transfer-Encodings: compress, deflate, gzip (:pr:`3261`)\n- permit Transfer-Encoding headers specifying multiple encodings. note: no parameters, still (:pr:`3261`)\n- sdist generation now explicitly excludes sphinx build folder (:pr:`3257`)\n- decode bytes-typed status (as can be passed by gevent) as utf-8 instead of raising `TypeError` (:pr:`2336`)\n- raise correct Exception when encounting invalid chunked requests (:pr:`3258`)\n- the SCRIPT_NAME and PATH_INFO headers, when received from allowed forwarders, are no longer restricted for containing an underscore (:pr:`3192`)\n- include IPv6 loopback address ``[::1]`` in default for :ref:`forwarded-allow-ips` and :ref:`proxy-allow-ips` (:pr:`3192`)\n\n** NOTE **\n\n- The SCRIPT_NAME change mitigates a regression that appeared first in the 22.0.0 release\n- Review your :ref:`forwarded-allow-ips` setting if you are still not seeing the SCRIPT_NAME transmitted\n- Review your :ref:`forwarder-headers` setting if you are missing headers after upgrading from a version prior to 22.0.0\n\n** Breaking changes **\n\n- refuse requests where the uri field is empty (:pr:`3255`)\n- refuse requests with invalid CR/LR/NUL in heade field values (:pr:`3253`)\n- remove temporary ``--tolerate-dangerous-framing`` switch from 22.0 (:pr:`3260`)\n- If any of the breaking changes affect you, be aware that now refused requests can post a security problem, especially so in setups involving request pipe-lining and/or proxies.\n\n22.0.0 - 2024-04-17\n===================\n\n- use `utime` to notify workers liveness \n- migrate setup to pyproject.toml\n- fix numerous security vulnerabilities in HTTP parser (closing some request smuggling vectors)\n- parsing additional requests is no longer attempted past unsupported request framing\n- on HTTP versions < 1.1 support for chunked transfer is refused (only used in exploits)\n- requests conflicting configured or passed SCRIPT_NAME now produce a verbose error\n- Trailer fields are no longer inspected for headers indicating secure scheme\n- support Python 3.12\n\n** Breaking changes **\n\n- minimum version is Python 3.7\n- the limitations on valid characters in the HTTP method have been bounded to Internet Standards\n- requests specifying unsupported transfer coding (order) are refused by default (rare)\n- HTTP methods are no longer casefolded by default (IANA method registry contains none affected)\n- HTTP methods containing the number sign (#) are no longer accepted by default (rare)\n- HTTP versions < 1.0 or >= 2.0 are no longer accepted by default (rare, only HTTP/1.1 is supported)\n- HTTP versions consisting of multiple digits or containing a prefix/suffix are no longer accepted\n- HTTP header field names Gunicorn cannot safely map to variables are silently dropped, as in other software\n- HTTP headers with empty field name are refused by default (no legitimate use cases, used in exploits)\n- requests with both Transfer-Encoding and Content-Length are refused by default (such a message might indicate an attempt to perform request smuggling)\n- empty transfer codings are no longer permitted (reportedly seen with really old & broken proxies)\n\n\n** SECURITY **\n\n- fix CVE-2024-1135\n\nHistory\n=======\n\n.. toctree::\n   :titlesonly:\n   \n   2024-news\n   2023-news\n   2021-news\n   2020-news\n   2019-news\n   2018-news\n   2017-news\n   2016-news\n   2015-news\n   2014-news\n   2013-news\n   2012-news\n   2011-news\n   2010-news\n\n",
      "source_file": "docs/source/news.rst",
      "chunk_type": "doc"
    },
    {
      "content": "\n.. _design:\n\n======\nDesign\n======\n\nA brief description of the architecture of Gunicorn.\n\nServer Model\n============\n\nGunicorn is based on the pre-fork worker model. This means that there is a\ncentral master process that manages a set of worker processes. The master\nnever knows anything about individual clients. All requests and responses are\nhandled completely by worker processes.\n\nMaster\n------\n\nThe master process is a simple loop that listens for various process signals\nand reacts accordingly. It manages the list of running workers by listening\nfor signals like TTIN, TTOU, and CHLD. TTIN and TTOU tell the master to\nincrease or decrease the number of running workers. CHLD indicates that a child\nprocess has terminated, in this case the master process automatically restarts\nthe failed worker.\n\nSync Workers\n------------\n\nThe most basic and the default worker type is a synchronous worker class that\nhandles a single request at a time. This model is the simplest to reason about\nas any errors will affect at most a single request. Though as we describe below\nonly processing a single request at a time requires some assumptions about how\napplications are programmed.\n\n``sync`` worker does not support persistent connections - each connection is\nclosed after response has been sent (even if you manually add ``Keep-Alive``\nor ``Connection: keep-alive`` header in your application).\n\nAsync Workers\n-------------\n\nThe asynchronous workers available are based on Greenlets_ (via Eventlet_ and\nGevent_). Greenlets are an implementation of cooperative multi-threading for\nPython. In general, an application should be able to make use of these worker\nclasses with no changes.\n\nFor full greenlet support applications might need to be adapted.\nWhen using, e.g., Gevent_ and Psycopg_ it makes sense to ensure psycogreen_ is\ninstalled and `setup <http://www.gevent.org/api/gevent.monkey.html#plugins>`_.\n\nOther applications might not be compatible at all as they, e.g., rely on\nthe original unpatched behavior.\n\nGthread Workers\n---------------\n\nThe worker `gthread` is a threaded worker. It accepts connections in the\nmain loop. Accepted connections are added to the thread pool as a\nconnection job. On keepalive connections are put back in the loop\nwaiting for an event. If no event happens after the keepalive timeout,\nthe connection is closed.\n\nTornado Workers\n---------------\n\nThere's also a Tornado worker class. It can be used to write applications using\nthe Tornado framework. Although the Tornado workers are capable of serving a\nWSGI application, this is not a recommended configuration.\n\n\n.. _asyncio-workers:\n\nAsyncIO Workers\n---------------\n\nThird-party workers can be usedd to use Gunicorn with asyncio frameworks. \n\nChoosing a Worker Type\n======================\n\nThe default synchronous workers assume that your application is resource-bound\nin terms of CPU and network bandwidth. Generally this means that your\napplication shouldn't do anything that takes an undefined amount of time. An\nexample of something that takes an undefined amount of time is a request to the\ninternet. At some point the external network will fail in such a way that\nclients will pile up on your servers. So, in this sense, any web application\nwhich makes outgoing requests to APIs will benefit from an asynchronous worker.\n\nThis resource bound assumption is why we require a buffering proxy in front of\na default configuration Gunicorn. If you exposed synchronous workers to the\ninternet, a DOS attack would be trivial by creating a load that trickles data to\nthe servers. For the curious, Hey_ is an example of this type of load.\n\n\nSome examples of behavior requiring asynchronous workers:\n\n  * Applications making long blocking calls (Ie, external web services)\n  * Serving requests directly to the internet\n  * Streaming requests and responses\n  * Long polling\n  * Web sockets\n  * Comet\n\nHow Many Workers?\n=================\n\nDO NOT scale the number of workers to the number of clients you expect to have.\nGunicorn should only need 4-12 worker processes to handle hundreds or thousands\nof requests per second.\n\nGunicorn relies on the operating system to provide all of the load balancing\nwhen handling requests. Generally we recommend ``(2 x $num_cores) + 1`` as the\nnumber of workers to start off with. While not overly scientific, the formula\nis based on the assumption that for a given core, one worker will be reading\nor writing from the socket while the other worker is processing a request.\n\nObviously, your particular hardware and application are going to affect the\noptimal number of workers. Our recommendation is to start with the above guess\nand tune using TTIN and TTOU signals while the application is under load.\n\nAlways remember, there is such a thing as too many workers. After a point your\nworker processes will start thrashing system resources decreasing the\nthroughput of the entire system.\n\nHow Many Threads?\n===================\n\nSince Gunicorn 19, a threads option can be used to process requests in multiple\nthreads. Using threads assumes use of the gthread worker. One benefit from threads\nis that requests can take longer than the worker timeout while notifying the\nmaster process that it is not frozen and should not be killed. Depending on the\nsystem, using multiple threads, multiple worker processes, or some mixture, may\nyield the best results. For example, CPython may not perform as well as Jython\nwhen using threads, as threading is implemented differently by each. Using\nthreads instead of processes is a good way to reduce the memory footprint of\nGunicorn, while still allowing for application upgrades using the reload\nsignal, as the application code will be shared among workers but loaded only in\nthe worker processes (unlike when using the preload setting, which loads the\ncode in the master process).\n\n.. _Greenlets: https://github.com/python-greenlet/greenlet\n.. _Eventlet: http://eventlet.net/\n.. _Gevent: http://www.gevent.org/\n.. _Hey: https://github.com/rakyll/hey\n.. _aiohttp: https://docs.aiohttp.org/en/stable/deployment.html#nginx-gunicorn\n.. _`example`: https://github.com/benoitc/gunicorn/blob/master/examples/frameworks/flaskapp_aiohttp_wsgi.py\n.. _Psycopg: http://initd.org/psycopg/\n.. _psycogreen: https://github.com/psycopg/psycogreen/\n",
      "source_file": "docs/source/design.rst",
      "chunk_type": "doc"
    },
    {
      "content": ".. _signals:\n\n===============\nSignal Handling\n===============\n\nA brief description of the signals handled by Gunicorn. We also document the\nsignals used internally by Gunicorn to communicate with the workers.\n\nMaster process\n==============\n\n- ``QUIT``, ``INT``: Quick shutdown\n- ``TERM``: Graceful shutdown. Waits for workers to finish their\n  current requests up to the :ref:`graceful-timeout`.\n- ``HUP``: Reload the configuration, start the new worker processes with a new\n  configuration and gracefully shutdown older workers. If the application is\n  not preloaded (using the :ref:`preload-app` option), Gunicorn will also load\n  the new version of it.\n- ``TTIN``: Increment the number of processes by one\n- ``TTOU``: Decrement the number of processes by one\n- ``USR1``: Reopen the log files\n- ``USR2``: Upgrade Gunicorn on the fly. A separate ``TERM`` signal should\n  be used to kill the old master process. This signal can also be used to use\n  the new versions of pre-loaded applications. See :ref:`binary-upgrade` for\n  more information.\n- ``WINCH``: Gracefully shutdown the worker processes when Gunicorn is\n  daemonized.\n\nWorker process\n==============\n\nSending signals directly to the worker processes should not normally be\nneeded.  If the master process is running, any exited worker will be\nautomatically respawned.\n\n- ``QUIT``, ``INT``: Quick shutdown\n- ``TERM``: Graceful shutdown\n- ``USR1``: Reopen the log files\n\nReload the configuration\n========================\n\nThe ``HUP`` signal can be used to reload the Gunicorn configuration on the\nfly.\n\n::\n\n    2013-06-29 06:26:55 [20682] [INFO] Handling signal: hup\n    2013-06-29 06:26:55 [20682] [INFO] Hang up: Master\n    2013-06-29 06:26:55 [20703] [INFO] Booting worker with pid: 20703\n    2013-06-29 06:26:55 [20702] [INFO] Booting worker with pid: 20702\n    2013-06-29 06:26:55 [20688] [INFO] Worker exiting (pid: 20688)\n    2013-06-29 06:26:55 [20687] [INFO] Worker exiting (pid: 20687)\n    2013-06-29 06:26:55 [20689] [INFO] Worker exiting (pid: 20689)\n    2013-06-29 06:26:55 [20704] [INFO] Booting worker with pid: 20704\n\n\nSending a ``HUP`` signal will reload the configuration, start the new\nworker processes with a new configuration and gracefully shutdown older\nworkers. If the application is not preloaded (using the :ref:`preload-app`\noption), Gunicorn will also load the new version of it.\n\n.. _binary-upgrade:\n\nUpgrading to a new binary on the fly\n====================================\n\n.. versionchanged:: 19.6.0\n   PID file naming format has been changed from ``<name>.pid.oldbin`` to\n   ``<name>.pid.2``.\n\nIf you need to replace the Gunicorn binary with a new one (when\nupgrading to a new version or adding/removing server modules), you can\ndo it without any service downtime - no incoming requests will be\nlost. Preloaded applications will also be reloaded.\n\nFirst, replace the old binary with a new one, then send a ``USR2`` signal to\nthe current master process. It executes a new binary whose PID file is\npostfixed with ``.2`` (e.g. ``/var/run/gunicorn.pid.2``),\nwhich in turn starts a new master process and new worker processes::\n\n      PID USER      PR  NI  VIRT  RES  SHR S  %CPU %MEM    TIME+  COMMAND\n    20844 benoitc   20   0 54808  11m 3352 S   0.0  0.1   0:00.36 gunicorn: master [test:app]\n    20849 benoitc   20   0 54808 9.9m 1500 S   0.0  0.1   0:00.02 gunicorn: worker [test:app]\n    20850 benoitc   20   0 54808 9.9m 1500 S   0.0  0.1   0:00.01 gunicorn: worker [test:app]\n    20851 benoitc   20   0 54808 9.9m 1500 S   0.0  0.1   0:00.01 gunicorn: worker [test:app]\n    20854 benoitc   20   0 55748  12m 3348 S   0.0  0.2   0:00.35 gunicorn: master [test:app]\n    20859 benoitc   20   0 55748  11m 1500 S   0.0  0.1   0:00.01 gunicorn: worker [test:app]\n    20860 benoitc   20   0 55748  11m 1500 S   0.0  0.1   0:00.00 gunicorn: worker [test:app]\n    20861 benoitc   20   0 55748  11m 1500 S   0.0  0.1   0:00.01 gunicorn: worker [test:app]\n\nAt this point, two instances of Gunicorn are running, handling the\nincoming requests together. To phase the old instance out, you have to\nsend a ``WINCH`` signal to the old master process, and its worker\nprocesses will start to gracefully shut down.\n\nAt this point you can still revert to the old process since it hasn't closed\nits listen sockets yet, by following these steps:\n\n- Send a ``HUP`` signal to the old master process - it will start the worker\n  processes without reloading a configuration file\n- Send a ``TERM`` signal to the new master process to gracefully shut down its\n  worker processes\n- Send a ``QUIT`` signal to the new master process to force it quit\n\nIf for some reason the new worker processes do not quit, send a ``KILL`` signal\nto them after the new master process quits, and everything will back to exactly\nas before the upgrade attempt.\n\nIf the update is successful and you want to keep the new master process, send a\n``TERM`` signal to the old master process to leave only the new server\nrunning::\n\n      PID USER      PR  NI  VIRT  RES  SHR S  %CPU %MEM    TIME+  COMMAND\n    20854 benoitc   20   0 55748  12m 3348 S   0.0  0.2   0:00.45 gunicorn: master [test:app]\n    20859 benoitc   20   0 55748  11m 1500 S   0.0  0.1   0:00.02 gunicorn: worker [test:app]\n    20860 benoitc   20   0 55748  11m 1500 S   0.0  0.1   0:00.02 gunicorn: worker [test:app]\n    20861 benoitc   20   0 55748  11m 1500 S   0.0  0.1   0:00.01 gunicorn: worker [test:app]\n",
      "source_file": "docs/source/signals.rst",
      "chunk_type": "doc"
    },
    {
      "content": "Changelog - 2012\n================\n\n0.17.0 / 2012-12-25\n-------------------\n\n- allows gunicorn to bind to multiple address\n- add SSL support\n- add syslog support\n- add nworkers_changed hook\n- add response arg for post_request hook\n- parse command line with argparse (replace deprecated optparse)\n- fix PWD detection in arbiter\n- miscellaneous PEP8 fixes\n\n0.16.1 / 2012-11-19\n-------------------\n\n- Fix packaging\n\n0.16.0 / 2012-11-19\n-------------------\n\n- **Added support for Python 3.2 & 3.3**\n- Expose --pythonpath command to all gunicorn commands\n- Honor $PORT environment variable, useful for deployment on heroku\n- Removed support for Python 2.5\n- Make sure we reopen the logs on the console\n- Fix django settings module detection from path\n- Reverted timeout for client socket. Fix issue on blocking issues.\n- Fixed gevent worker\n\n0.15.0 / 2012-10-18\n-------------------\n\n- new documentation site on http://docs.gunicorn.org\n- new website on http://gunicorn.org\n- add `haproxy PROXY protocol <http://haproxy.1wt.eu/download/1.5/doc/proxy-protocol.txt>`_ support\n- add  ForwardedAllowIPS option: allows to filter Front-end's IPs\n  allowed to handle X-Forwarded-* headers.\n- add callable hooks for paster config\n- add x-forwarded-proto as secure scheme default (Heroku is using this)\n- allows gunicorn to load a pre-compiled application\n- support file reopening & reexec for all loggers\n- initialize the logging config file with defaults.\n- set timeout for client socket (slow client DoS).\n- NoMoreData, ChunkMissingTerminator, InvalidChunkSize are now\n  IOError exceptions\n- fix graceful shutdown in gevent\n- fix limit request line check\n\n0.14.6 / 2012-07-26\n-------------------\n\n\n- fix gevent & subproces\n- fix request line length check\n- fix keepalive = 0\n- fix tornado worker\n\n0.14.5 / 2012-06-24\n--------------------\n\n- fix logging during daemonisation\n\n0.14.4 / 2012-06-24\n-------------------\n\n- new --graceful-timeout option\n- fix multiple issues with request limit\n- more fixes in django settings resolutions\n- fix gevent.core import\n- fix keepalive=0 in eventlet worker\n- fix handle_error display with the unix worker\n- fix tornado.wsgi.WSGIApplication calling error\n\n- **breaking change**: take the control on graceful reload back.\n  graceful can't be overridden anymore using the on_reload function.\n\n0.14.3 / 2012-05-15\n-------------------\n\n- improvement: performance of http.body.Body.readline()\n- improvement: log HTTP errors in access log like Apache\n- improvement: display traceback when the worker fails to boot\n- improvement: makes gunicorn work with gevent 1.0\n- examples: websocket example now supports hybi13\n- fix: reopen log files after initialization\n- fix: websockets support\n- fix: django1.4 support\n- fix: only load the paster application 1 time\n\n0.14.2 / 2012-03-16\n-------------------\n\n- add validate_class validator: allows to use a class or a method to\n  initialize the app during in-code configuration\n- add support for max_requests in tornado worker\n- add support for disabling x_forwarded_for_header in tornado worker\n- gevent_wsgi is now an alias of gevent_pywsgi\n- Fix gevent_pywsgi worker\n\n0.14.1 / 2012-03-02\n-------------------\n\n- fixing source archive, reducing its size\n\n0.14.0 / 2012-02-27\n-------------------\n\n- check if Request line is too large: You can now pass the parameter\n  ``--limit-request-line`` or set the ``limit_request_line`` in your\n  configuration file to set the max size of the request line in bytes.\n- limit the number of headers fields and their size. Add\n  ``--limit-request-field`` and ``limit-request-field-size`` settings\n- add ``p`` variable to the log access format to log pidfile\n- add ``{HeaderName}o`` variable to the logo access format to log the\n  response header HeaderName\n- request header is now logged with the variable ``{HeaderName}i`` in the\n  access log file\n- improve error logging\n- support logging.configFile\n- support django 1.4 in both gunicorn_django & run_gunicorn command\n- improve reload in django run_gunicorn command (should just work now)\n- allows people to set the ``X-Forwarded-For`` header key and disable it by\n  setting an empty string.\n- fix support of Tornado\n- many other fixes.\n",
      "source_file": "docs/source/2012-news.rst",
      "chunk_type": "doc"
    },
    {
      "content": "Changelog - 2013\n================\n\n18.0 / 2013-08-26\n-----------------\n\n- new: add ``-e/--env`` command line argument to pass an environment variables to\n  gunicorn\n- new: add ``--chdir`` command line argument to specified directory\n  before apps loading.  - new: add wsgi.file_wrapper support in async workers\n- new: add ``--paste`` command line argument to set the paster config file\n- deprecated: the command ``gunicorn_django`` is now deprecated. You should now\n  run your application with the WSGI interface installed with your project (see\n  https://docs.djangoproject.com/en/1.4/howto/deployment/wsgi/gunicorn/) for\n  more infos.\n- deprecated:  the command ``gunicorn_paste`` is deprecated. You now should use\n  the new ``--paste`` argument to set the configuration file of your paster\n  application.\n- fix: Removes unmatched leading quote from the beginning of the default access\n  log format string\n- fix: null timeout\n- fix: gevent worker\n- fix: don't reload the paster app when using pserve\n- fix: after closing for error do not keep alive the connection\n- fix: responses 1xx, 204 and 304 should not force the connection to be closed\n\n17.5 / 2013-07-03\n------------------\n\n- new: add signals documentation\n- new: add post_worker_init hook for workers\n- new: try to use gunicorn.conf.py in current folder as the default\n  config file.\n- fix graceful timeout with the Eventlet worker\n- fix: don't raise an error when closing the socket if already closed\n- fix: fix --settings parameter for django application and try to find\n  the django settings when using the ``gunicorn`` command.\n- fix: give the initial global_conf to paster application\n- fix: fix 'Expect: 100-continue' support on Python 3\n\nNew versioning:\n++++++++++++++++\n\nWith this release, the versioning of Gunicorn is changing. Gunicorn is\nstable since a long time and there is no point to release a \"1.0\" now.\nIt should have been done since a long time. 0.17 really meant it was the\n17th stable version. From the beginning we have only 2 kind of\nreleases:\n\nmajor release: releases with major changes or huge features added\nservices releases: fixes and minor features added So from now we will\napply the following versioning ``<major>.<service>``. For example ``17.5`` is a\nservice release.\n\n0.17.4 / 2013-04-24\n-------------------\n\n- fix unix socket address parsing\n\n0.17.3 / 2013-04-23\n-------------------\n\n- add systemd sockets support\n- add ``python -m gunicorn.app.wsgiapp`` support\n- improve logger class inheritance\n- exit when the config file isn't found\n- add the -R option to enable stdio inheritance in daemon mode\n- don't close file descriptors > 3 in daemon mode\n- improve STDOUT/STDERR logging\n- fix pythonpath option\n- fix pidfile creation on Python 3\n- fix gevent worker exit\n- fix ipv6 detection when the platform isn't supporting it\n\n0.17.2 / 2013-01-07\n-------------------\n\n- optimize readline\n- make imports errors more visible when loading an app or a logging\n  class\n- fix tornado worker: don't pass ssl options if there are none\n- fix PEP3333: accept only bytetrings in the response body\n- fix support on CYGWIN platforms\n\n0.17.1 / 2013-01-05\n-------------------\n\n- add syslog facility name setting\n- fix ``--version`` command line argument\n- fix wsgi url_scheme for https\n",
      "source_file": "docs/source/2013-news.rst",
      "chunk_type": "doc"
    },
    {
      "content": "================\nChangelog - 2021\n================\n\n.. note::\n\n   Please see :doc:`news` for the latest changes\n\n20.1.0 - 2021-02-12\n===================\n\n- document WEB_CONCURRENCY is set by, at least, Heroku\n- capture peername from accept: Avoid calls to getpeername by capturing the peer name returned by\n  accept\n- log a warning when a worker was terminated due to a signal\n- fix tornado usage with latest versions of Django \n- add support for python -m gunicorn\n- fix systemd socket activation example\n- allows to set wsgi application in config file using `wsgi_app`\n- document `--timeout = 0`\n- always close a connection when the number of requests exceeds the max requests\n- Disable keepalive during graceful shutdown\n- kill tasks in the gthread workers during upgrade\n- fix latency in gevent worker when accepting new requests\n- fix file watcher: handle errors when new worker reboot and ensure the list of files is kept\n- document the default name and path of the configuration file\n- document how variable impact configuration\n- document the `$PORT` environment variable\n- added milliseconds option to request_time in access_log\n- added PIP requirements to be used for example\n- remove version from the Server header\n- fix sendfile: use `socket.sendfile` instead of `os.sendfile`\n- reloader: use  absolute path to prevent empty to prevent0 `InotifyError` when a file \n  is added to the working directory\n- Add --print-config option to print the resolved settings at startup.\n- remove the `--log-dict-config` CLI flag because it never had a working format\n  (the `logconfig_dict` setting in configuration files continues to work)\n\n\n** Breaking changes **\n\n- minimum version is Python 3.5\n- remove version from the Server header \n\n** Documentation **\n\n\n\n** Others **\n\n- miscellaneous changes in the code base to be a better citizen with Python 3\n- remove dead code\n- fix documentation generation\n\n",
      "source_file": "docs/source/2021-news.rst",
      "chunk_type": "doc"
    },
    {
      "content": "================\nChangelog - 2020\n================\n\n.. note::\n\n   Please see :doc:`news` for the latest changes\n",
      "source_file": "docs/source/2020-news.rst",
      "chunk_type": "doc"
    },
    {
      "content": "#\n# Gunicorn documentation build configuration file\n#\n\nimport os\nimport sys\nimport time\n\nDOCS_DIR = os.path.abspath(os.path.dirname(__file__))\n\non_rtd = os.environ.get('READTHEDOCS', None) == 'True'\n\n# for gunicorn_ext.py\nsys.path.append(os.path.join(DOCS_DIR, os.pardir))\nsys.path.insert(0, os.path.join(DOCS_DIR, os.pardir, os.pardir))\n\nextensions = ['gunicorn_ext']\ntemplates_path = ['_templates']\nsource_suffix = '.rst'\nmaster_doc = 'index'\n\n# General information about the project.\nproject = 'Gunicorn'\ncopyright = '2009-%s, Benoit Chesneau' % time.strftime('%Y')\n# gunicorn version\nimport gunicorn\nrelease = version = gunicorn.__version__\n\nexclude_patterns = []\npygments_style = 'sphinx'\n\n\n# -- Options for HTML output ---------------------------------------------------\n\nif not on_rtd:  # only import and set the theme if we're building docs locally\n    try:\n        import sphinx_rtd_theme\n    except ImportError:\n        html_theme = 'default'\n    else:\n        html_theme = 'sphinx_rtd_theme'\n        html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]\nelse:\n    html_theme = 'default'\n\nhtml_static_path = ['_static']\nhtmlhelp_basename = 'Gunicorndoc'\n\n\n# -- Options for LaTeX output --------------------------------------------------\n\nlatex_elements = {\n\n}\n\nlatex_documents = [\n  ('index', 'Gunicorn.tex', 'Gunicorn Documentation',\n   'Benoit Chesneau', 'manual'),\n]\n\n\n# -- Options for manual page output --------------------------------------------\nman_pages = [\n    ('index', 'gunicorn', 'Gunicorn Documentation',\n     ['Benoit Chesneau'], 1)\n]\n\ntexinfo_documents = [\n  ('index', 'Gunicorn', 'Gunicorn Documentation',\n   'Benoit Chesneau', 'Gunicorn', 'One line description of project.',\n   'Miscellaneous'),\n]",
      "start_line": 0,
      "end_line": 72,
      "source_file": "docs/source/conf.py",
      "chunk_type": "code"
    },
    {
      "content": "================\nChangelog - 2015\n================\n\n.. note::\n\n   Please see :doc:`news` for the latest changes.\n\n19.4.3 / 2015/12/30\n===================\n\n- fix: don't check if a file is writable using os.stat with SELINUX (:issue:`1171`)\n\n19.4.2 / 2015/12/29\n===================\n\nCore\n++++\n\n- improvement: handle HaltServer in manage_workers (:issue:`1095`)\n- fix: Do not rely on sendfile sending requested count (:issue:`1155`)\n- fix: claridy --no-sendfile default (:issue:`1156`)\n- fix: LoggingCatch sendfile failure from no file descriptor (:issue:`1160`)\n\nLogging\n+++++++\n\n- fix: Always send access log to syslog if syslog is on\n- fix: check auth before trying to own a file (:issue:`1157`)\n\n\nDocumentation\n+++++++++++++\n\n- fix: Fix Slowloris broken link. (:issue:`1142`)\n- Tweak markup in faq.rst\n\nTesting\n+++++++\n\n- fix: gaiohttp test (:issue:`1164`)\n\n19.4.1 / 2015/11/25\n===================\n\n- fix tornado worker (:issue:`1154`)\n\n19.4.0 / 2015/11/20\n===================\n\nCore\n++++\n\n- fix: make sure that a user is able to access to the logs after dropping a\n  privilege (:issue:`1116`)\n- improvement: inherit the `Exception` class where it needs to be (:issue:`997`)\n- fix: make sure headers are always encoded as latin1 RFC 2616 (:issue:`1102`)\n- improvement: reduce arbiter noise (:issue:`1078`)\n- fix: don't close the unix socket when the worker exit (:issue:`1088`)\n- improvement: Make last logged worker count an explicit instance var (:issue:`1078`)\n- improvement: prefix config file with its type (:issue:`836`)\n- improvement: pidfile handing (:issue:`1042`)\n- fix: catch OSError as well as ValueError on race condition (:issue:`1052`)\n- improve support of ipv6 by backporting urlparse.urlsplit from Python 2.7 to\n  Python 2.6.\n- fix: raise InvalidRequestLine when the line contains malicious data\n  (:issue:`1023`)\n- fix: fix argument to disable sendfile\n- fix: add gthread to the list of supported workers (:issue:`1011`)\n- improvement: retry socket binding up to five times upon EADDRNOTAVAIL\n  (:issue:`1004`)\n- **breaking change**: only honor headers that can be encoded in ascii to comply to\n  the RFC 7230 (See :issue:`1151`).\n\nLogging\n+++++++\n\n- add new parameters to access log (:issue:`1132`)\n- fix: make sure that files handles are correctly reopened on HUP\n  (:issue:`627`)\n- include request URL in error message (:issue:`1071`)\n- get username in access logs (:issue:`1069`)\n- fix statsd logging support on Python 3 (:issue:`1010`)\n\nTesting\n+++++++\n\n- use last version of mock.\n- many fixes in Travis CI support\n- miscellaneous improvements in tests\n\nThread worker\n+++++++++++++\n\n- fix: Fix self.nr usage in ThreadedWorker so that auto restart works as\n  expected (:issue:`1031`)\n\nGevent worker\n+++++++++++++\n\n- fix quit signal handling (:issue:`1128`)\n- add support for Python 3 (:issue:`1066`)\n- fix: make graceful shutdown thread-safe (:issue:`1032`)\n\nTornado worker\n++++++++++++++\n\n- fix ssl options (:issue:`1146`, :issue:`1135`)\n- don't check timeout when stopping gracefully (:issue:`1106`)\n\nAIOHttp worker\n++++++++++++++\n\n- add SSL support (:issue:`1105`)\n\nDocumentation\n+++++++++++++\n\n- fix link to proc name setting (:issue:`1144`)\n- fix worker class documentation (:issue:`1141`, :issue:`1104`)\n- clarify graceful timeout documentation (:issue:`1137`)\n- don't duplicate NGINX config files examples (:issue:`1050`, :issue:`1048`)\n- add `web.py` framework example (:issue:`1117`)\n- update Debian/Ubuntu installations instructions (:issue:`1112`)\n- clarify `pythonpath` setting description (:issue:`1080`)\n- tweak some example for python3\n- clarify `sendfile` documentation\n- miscellaneous typos in source code comments (thanks!)\n- clarify why REMOTE_ADD may not be the user's IP address (:issue:`1037`)\n\n\nMisc\n++++\n\n- fix: reloader should survive SyntaxError (:issue:`994`)\n- fix: expose the reloader class to the worker.\n\n\n\n19.3.0 / 2015/03/06\n===================\n\nCore\n++++\n\n- fix: :issue:`978` make sure a listener is inheritable\n- add `check_config` class method to workers\n- fix: :issue:`983` fix select timeout in sync worker with multiple\n  connections\n- allows workers to access to the reloader. close :issue:`984`\n- raise TypeError instead of AssertionError\n\nLogging\n+++++++\n\n- make Logger.loglevel a class attribute\n\nDocumentation\n+++++++++++++\n\n- fix: :issue:`988` fix syntax errors in examples/gunicorn_rc\n\n\n19.2.1 / 2015/02/4\n==================\n\nLogging\n+++++++\n\n- expose loglevel in the Logger class\n\nAsyncIO worker (gaiohttp)\n+++++++++++++++++++++++++\n\n- fix :issue:`977` fix initial crash\n\nDocumentation\n+++++++++++++\n\n- document security mailing-list in the contributing page.\n\n19.2 / 2015/01/30\n=================\n\nCore\n++++\n\n- optimize the sync workers when listening on a single interface\n- add `--sendfile` settings to enable/disable sendfile. fix :issue:`856` .\n- add the selectors module to the code base. :issue:`886`\n- add `--max-requests-jitter` setting to set the maximum jitter to add to the\n  max-requests setting.\n- fix :issue:`899` propagate proxy_protocol_info to keep-alive requests\n- fix :issue:`863` worker timeout: dynamic timeout has been removed\n- fix: Avoid world writable file\n\nLogging\n+++++++\n\n- fix :issue:`941`  set logconfig default to paster more trivially\n- add statsd-prefix config setting: set the prefix to use when emitting statsd\n  metrics\n- :issue:`832` log to console by default\n\nThread Worker\n+++++++++++++\n\n- fix :issue:`908` make sure the worker can continue to accept requests\n\nEventlet Worker\n+++++++++++++++\n\n- fix :issue:`867` Fix eventlet shutdown to actively shut down the workers.\n\nDocumentation\n+++++++++++++\n\nMany improvements and fixes have been done, see the detailed changelog for\nmore information.\n",
      "source_file": "docs/source/2015-news.rst",
      "chunk_type": "doc"
    },
    {
      "content": "================\nChangelog - 2014\n================\n\n.. note::\n\n   Please see :doc:`news` for the latest changes.\n\n19.1.1 / 2014-08-16\n===================\n\nChanges\n-------\n\nCore\n++++\n\n- fix :issue:`835`: display correct pid of already running instance\n- fix :pr:`833`: fix `PyTest` class in setup.py.\n\n\nLogging\n+++++++\n\n- fix :issue:`838`: statsd logger, send statsd timing metrics in milliseconds\n- fix :issue:`839`: statsd logger, allows for empty log message while pushing\n  metrics and restore worker number in DEBUG logs\n- fix :issue:`850`: add timezone to logging\n- fix :issue:`853`: Respect logger_class setting unless statsd is on\n\nAioHttp worker\n++++++++++++++\n\n- fix :issue:`830` make sure gaiohttp worker is shipped with gunicorn.\n\n19.1 / 2014-07-26\n=================\n\nChanges\n-------\n\nCore\n++++\n\n- fix :issue:`785`: handle binary type address given to a client socket address\n- fix graceful shutdown. make sure QUIT and TERMS signals are switched everywhere.\n- :issue:`799`: fix support loading config from module\n- :issue:`805`: fix check for file-like objects\n- fix :issue:`815`: args validation in WSGIApplication.init\n- fix :issue:`787`: check if we load a pyc file or not.\n\n\nTornado worker\n++++++++++++++\n\n- fix :issue:`771`: support tornado 4.0\n- fix :issue:`783`: x_headers error. The x-forwarded-headers option has been removed\n  in `c4873681299212d6082cd9902740eef18c2f14f1\n  <https://github.com/benoitc/gunicorn/commit/c4873681299212d6082cd9902740eef18c2f14f1>`_.\n  The discussion is available on :pr:`633`.\n\n\nAioHttp worker\n++++++++++++++\n\n- fix: fetch all body in input. fix :issue:`803`\n- fix: don't install the worker if python < 3.3\n- fix :issue:`822`: Support UNIX sockets in gaiohttp worker\n\n\nAsync worker\n++++++++++++\n\n- fix :issue:`790`: StopIteration shouldn't be caught at this level.\n\n\nLogging\n+++++++\n\n- add statsd logging handler fix :issue:`748`\n\n\nPaster\n++++++\n\n- fix :issue:`809`: Set global logging configuration from a Paste config.\n\n\nExtra\n+++++\n\n- fix RuntimeError in gunicorn.reloader (:issue:`807`)\n\n\nDocumentation\n+++++++++++++\n\n- update faq: put a note on how `watch logs in the console\n  <http://docs.gunicorn.org/en/latest/faq.html#why-i-don-t-see-any-logs-in-the-console>`_\n  since many people asked for it.\n\n\n19.0 / 2014-06-12\n=================\n\nGunicorn 19.0 is a major release with new features and fixes. This\nversion improve a lot the usage of Gunicorn with python 3 by adding `two\nnew workers <http://docs.gunicorn.org/en/latest/design.html#asyncio-workers>`_\nto it: `gthread` a fully threaded async worker using futures and `gaiohttp` a\nworker using asyncio.\n\n\nBreaking Changes\n----------------\n\nSwitch QUIT and TERM signals\n++++++++++++++++++++++++++++\n\nWith this change, when gunicorn receives a QUIT all the workers are\nkilled immediately and exit and TERM is used for the graceful shutdown.\n\nNote: the old behaviour was based on the NGINX but the new one is more\ncorrect according the following doc:\n\nhttps://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html\n\nalso it is complying with the way the signals are sent by heroku:\n\nhttps://devcenter.heroku.com/articles/python-faq#what-constraints-exist-when-developing-applications-on-heroku\n\nDeprecations\n++++++++++++\n\n`run_gunicorn`, `gunicorn_django` and `gunicorn_paster` are now\ncompletely deprecated and will be removed in the next release. Use the\n`gunicorn` command instead.\n\n\nChanges\n-------\n\ncore\n++++\n\n- add aiohttp worker named `gaiohttp` using asyncio. Full async worker\n  on python 3.\n- fix HTTP-violating excess whitespace in write_error output\n- fix: try to log what happened in the worker after a timeout, add a\n  `worker_abort` hook on SIGABRT signal.\n- fix: save listener socket name in workers so we can handle buffered\n  keep-alive requests after the listener has closed.\n- add on_exit hook called just before exiting gunicorn.\n- add support for python 3.4\n- fix: do not swallow unexpected errors when reaping\n- fix: remove incompatible SSL option with python 2.6\n- add new async gthread worker and `--threads` options allows to set multiple\n  threads to listen on connection\n- deprecate `gunicorn_django` and `gunicorn_paster`\n- switch QUIT and TERM signal\n- reap workers in SIGCHLD handler\n- add universal wheel support\n- use `email.utils.formatdate` in gunicorn.util.http_date\n- deprecate the `--debug` option\n- fix: log exceptions that occur after response start \u2026\n- allows loading of applications from `.pyc` files (#693)\n- fix: issue #691, raw_env config file parsing\n- use a dynamic timeout to wait for the optimal time. (Reduce power\n  usage)\n- fix python3 support when notifying the arbiter\n- add: honor $WEB_CONCURRENCY environment variable. Useful for heroku\n  setups.\n- add: include tz offset in access log\n- add: include access logs in the syslog handler.\n- add --reload option for code reloading\n- add the capability to load `gunicorn.base.Application` without the loading of\n  the arguments of the command line. It allows you to :ref:`embed gunicorn in\n  your own application <custom>`.\n- improve: set wsgi.multithread to True for async workers\n- fix logging: make sure to redirect wsgi.errors when needed\n- add: syslog logging can now be done to a unix socket\n- fix logging: don't try to redirect stdout/stderr to the logfile.\n- fix logging: don't propagate log\n- improve logging: file option can be overridden by the gunicorn options\n  `--error-logfile` and `--access-logfile` if they are given.\n- fix: don't override SERVER_* by the Host header\n- fix: handle_error\n- add more option to configure SSL\n- fix: sendfile with SSL\n- add: worker_int callback (to react on SIGTERM)\n- fix: don't depend on entry point for internal classes, now absolute\n  modules path can be given.\n- fix: Error messages are now encoded in latin1\n- fix: request line length check\n- improvement: proxy_allow_ips: Allow proxy protocol if \"*\" specified\n- fix: run worker's `setup` method  before setting num_workers\n- fix: FileWrapper inherit from `object` now\n- fix: Error messages are now encoded in latin1\n- fix: don't spam the console on SIGWINCH.\n- fix: logging -don't stringify T and D logging atoms (#621)\n- add support for the latest django version\n- deprecate `run_gunicorn` django option\n- fix: sys imported twice\n\n\ngevent worker\n+++++++++++++\n\n- fix: make sure to stop all listeners\n- fix: monkey patching is now done in the worker\n- fix: \"global name 'hub' is not defined\"\n- fix: reinit `hub` on old versions of gevent\n- support gevent 1.0\n- fix: add subprocess in monkey patching\n- fix: add support for multiple listener\n\n\neventlet worker\n+++++++++++++++\n\n- fix: merge duplicate EventletWorker.init_process method (fixes #657)\n- fix: missing errno import for eventlet sendfile patch\n- fix: add support for multiple listener\n\n\ntornado worker\n++++++++++++++\n\n- add graceful stop support\n",
      "source_file": "docs/source/2014-news.rst",
      "chunk_type": "doc"
    },
    {
      "content": "==================\nDeploying Gunicorn\n==================\n\nWe strongly recommend using Gunicorn behind a proxy server.\n\nNginx Configuration\n===================\n\nAlthough there are many HTTP proxies available, we strongly advise that you\nuse Nginx_. If you choose another proxy server you need to make sure that it\nbuffers slow clients when you use default Gunicorn workers. Without this\nbuffering Gunicorn will be easily susceptible to denial-of-service attacks.\nYou can use Hey_ to check if your proxy is behaving properly.\n\nAn `example configuration`_ file for fast clients with Nginx_:\n\n.. literalinclude:: ../../examples/nginx.conf\n   :language: nginx\n   :caption: **nginx.conf**\n\nIf you want to be able to handle streaming request/responses or other fancy\nfeatures like Comet, Long polling, or Web sockets, you need to turn off the\nproxy buffering. **When you do this** you must run with one of the async worker\nclasses.\n\nTo turn off buffering, you only need to add ``proxy_buffering off;`` to your\n``location`` block::\n\n  ...\n  location @proxy_to_app {\n      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n      proxy_set_header Host $http_host;\n      proxy_redirect off;\n      proxy_buffering off;\n\n      proxy_pass http://app_server;\n  }\n  ...\n\nIf you want to ignore aborted requests like health check of Load Balancer, some\nof which close the connection without waiting for a response, you need to turn\non `ignoring client abort`_.\n\nTo ignore aborted requests, you only need to add\n``proxy_ignore_client_abort on;`` to your ``location`` block::\n\n    ...\n    proxy_ignore_client_abort on;\n    ...\n\n.. note::\n    The default value of ``proxy_ignore_client_abort`` is ``off``. Error code\n    499 may appear in Nginx log and ``Ignoring EPIPE`` may appear in Gunicorn\n    log if loglevel is set to ``debug``.\n\nIt is recommended to pass protocol information to Gunicorn. Many web\nframeworks use this information to generate URLs. Without this\ninformation, the application may mistakenly generate 'http' URLs in\n'https' responses, leading to mixed content warnings or broken\napplications. To configure Nginx to pass an appropriate header, add\na ``proxy_set_header`` directive to your ``location`` block::\n\n    ...\n    proxy_set_header X-Forwarded-Proto $scheme;\n    ...\n\nIf you are running Nginx on a different host than Gunicorn you need to tell\nGunicorn to trust the ``X-Forwarded-*`` headers sent by Nginx. By default,\nGunicorn will only trust these headers if the connection comes from localhost.\nThis is to prevent a malicious client from forging these headers::\n\n    $ gunicorn -w 3 --forwarded-allow-ips=\"10.170.3.217,10.170.3.220\" test:app\n\nWhen the Gunicorn host is completely firewalled from the external network such\nthat all connections come from a trusted proxy (e.g. Heroku) this value can\nbe set to '*'. Using this value is **potentially dangerous** if connections to\nGunicorn may come from untrusted proxies or directly from clients since the\napplication may be tricked into serving SSL-only content over an insecure\nconnection.\n\nGunicorn 19 introduced a breaking change concerning how ``REMOTE_ADDR`` is\nhandled. Previous to Gunicorn 19 this was set to the value of\n``X-Forwarded-For`` if received from a trusted proxy. However, this was not in\ncompliance with :rfc:`3875` which is why the ``REMOTE_ADDR`` is now the IP\naddress of **the proxy** and **not the actual user**.\n\nTo have access logs indicate **the actual user** IP when proxied, set\n:ref:`access-log-format` with a format which includes ``X-Forwarded-For``. For\nexample, this format uses ``X-Forwarded-For`` in place of ``REMOTE_ADDR``::\n\n    %({x-forwarded-for}i)s %(l)s %(u)s %(t)s \"%(r)s\" %(s)s %(b)s \"%(f)s\" \"%(a)s\"\n\nIt is also worth noting that the ``REMOTE_ADDR`` will be completely empty if\nyou bind Gunicorn to a UNIX socket and not a TCP ``host:port`` tuple.\n\nUsing Virtualenv\n================\n\nTo serve an app from a Virtualenv_ it is generally easiest to just install\nGunicorn directly into the Virtualenv. This will create a set of Gunicorn\nscripts for that Virtualenv which can be used to run applications normally.\n\nIf you have Virtualenv installed, you should be able to do something like\nthis::\n\n    $ mkdir ~/venvs/\n    $ virtualenv ~/venvs/webapp\n    $ source ~/venvs/webapp/bin/activate\n    $ pip install gunicorn\n    $ deactivate\n\nThen you just need to use one of the three Gunicorn scripts that was installed\ninto ``~/venvs/webapp/bin``.\n\nNote: You can force the installation of Gunicorn in your Virtualenv by\npassing ``-I`` or ``--ignore-installed`` option to pip::\n\n     $ source ~/venvs/webapp/bin/activate\n     $ pip install -I gunicorn\n\nMonitoring\n==========\n\n.. note::\n   Make sure that when using either of these service monitors you do not\n   enable the Gunicorn's daemon mode. These monitors expect that the process\n   they launch will be the process they need to monitor. Daemonizing will\n   fork-exec which creates an unmonitored process and generally just\n   confuses the monitor services.\n\nGaffer\n------\n\nUsing Gafferd and gaffer\n++++++++++++++++++++++++\n\nGaffer_ can be used to monitor Gunicorn. A simple configuration is::\n\n    [process:gunicorn]\n    cmd = gunicorn -w 3 test:app\n    cwd = /path/to/project\n\nThen you can easily manage Gunicorn using Gaffer_.\n\n\nUsing a Procfile\n++++++++++++++++\n\nCreate a ``Procfile`` in your project::\n\n    gunicorn = gunicorn -w 3 test:app\n\nYou can launch any other applications that should be launched at the same time.\n\nThen you can start your Gunicorn application using Gaffer_::\n\n    gaffer start\n\nIf gafferd is launched you can also load your Procfile in it directly::\n\n    gaffer load\n\nAll your applications will be then supervised by gafferd.\n\nRunit\n-----\n\nA popular method for deploying Gunicorn is to have it monitored by runit_.\nHere is an `example service`_ definition::\n\n    #!/bin/sh\n\n    GUNICORN=/usr/local/bin/gunicorn\n    ROOT=/path/to/project\n    PID=/var/run/gunicorn.pid\n\n    APP=main:application\n\n    if [ -f $PID ]; then rm $PID; fi\n\n    cd $ROOT\n    exec $GUNICORN -c $ROOT/gunicorn.conf.py --pid=$PID $APP\n\nSave this as ``/etc/sv/[app_name]/run``, and make it executable\n(``chmod u+x /etc/sv/[app_name]/run``).\nThen run ``ln -s /etc/sv/[app_name] /etc/service/[app_name]``.\nIf runit is installed, Gunicorn should start running automatically as soon\nas you create the symlink.\n\nIf it doesn't start automatically, run the script directly to troubleshoot.\n\nSupervisor\n----------\n\nAnother useful tool to monitor and control Gunicorn is Supervisor_. A\n`simple configuration`_ is::\n\n    [program:gunicorn]\n    command=/path/to/gunicorn main:application -c /path/to/gunicorn.conf.py\n    directory=/path/to/project\n    user=nobody\n    autostart=true\n    autorestart=true\n    redirect_stderr=true\n\nUpstart\n-------\n\nUsing Gunicorn with upstart is simple. In this example we will run the app\n\"myapp\" from a virtualenv. All errors will go to\n``/var/log/upstart/myapp.log``.\n\n**/etc/init/myapp.conf**::\n\n    description \"myapp\"\n\n    start on (filesystem)\n    stop on runlevel [016]\n\n    respawn\n    setuid nobody\n    setgid nogroup\n    chdir /path/to/app/directory\n\n    exec /path/to/virtualenv/bin/gunicorn myapp:app\n\nSystemd\n-------\n\nA tool that is starting to be common on linux systems is Systemd_. It is a\nsystem services manager that allows for strict process management, resources\nand permissions control.\n\nBelow are configuration files and instructions for using systemd to create\na unix socket for incoming Gunicorn requests.  Systemd will listen on this\nsocket and start gunicorn automatically in response to traffic.  Later in\nthis section are instructions for configuring Nginx to forward web traffic\nto the newly created unix socket:\n\n**/etc/systemd/system/gunicorn.service**::\n\n    [Unit]\n    Description=gunicorn daemon\n    Requires=gunicorn.socket\n    After=network.target\n\n    [Service]\n    # gunicorn can let systemd know when it is ready\n    Type=notify\n    NotifyAccess=main\n    # the specific user that our service will run as\n    User=someuser\n    Group=someuser\n    # this user can be transiently created by systemd\n    # DynamicUser=true\n    RuntimeDirectory=gunicorn\n    WorkingDirectory=/home/someuser/applicationroot\n    ExecStart=/usr/bin/gunicorn applicationname.wsgi\n    ExecReload=/bin/kill -s HUP $MAINPID\n    KillMode=mixed\n    TimeoutStopSec=5\n    PrivateTmp=true\n    # if your app does not need administrative capabilities, let systemd know\n    # ProtectSystem=strict\n\n    [Install]\n    WantedBy=multi-user.target\n\n**/etc/systemd/system/gunicorn.socket**::\n\n    [Unit]\n    Description=gunicorn socket\n\n    [Socket]\n    ListenStream=/run/gunicorn.sock\n    # Our service won't need permissions for the socket, since it\n    # inherits the file descriptor by socket activation.\n    # Only the nginx daemon will need access to the socket:\n    SocketUser=www-data\n    SocketGroup=www-data\n    # Once the user/group is correct, restrict the permissions:\n    SocketMode=0660\n\n    [Install]\n    WantedBy=sockets.target\n\n\nNext enable and start the socket (it will autostart at boot too)::\n\n    systemctl enable --now gunicorn.socket\n\n\nNow let's see if the nginx daemon will be able to connect to the socket.\nRunning ``sudo -u www-data curl --unix-socket /run/gunicorn.sock http``,\nour Gunicorn service will be automatically started and you should see some\nHTML from your server in the terminal.\n\n.. note::\n\n    systemd employs cgroups to track the processes of a service, so it doesn't\n    need pid files. In the rare case that you need to find out the service main\n    pid, you can use ``systemctl show --value -p MainPID gunicorn.service``, but\n    if you only want to send a signal an even better option is\n    ``systemctl kill -s HUP gunicorn.service``.\n\n.. note::\n\n    ``www-data`` is the default nginx user in debian, other distributions use\n    different users (for example: ``http`` or ``nginx``). Check your distro to\n    know what to put for the socket user, and for the sudo command.\n\nYou must now configure your web proxy to send traffic to the new Gunicorn\nsocket. Edit your ``nginx.conf`` to include the following:\n\n**/etc/nginx/nginx.conf**::\n\n    user www-data;\n    ...\n    http {\n        server {\n            listen          8000;\n            server_name     127.0.0.1;\n            location / {\n                proxy_pass http://unix:/run/gunicorn.sock;\n            }\n        }\n    }\n    ...\n\n.. note::\n\n    The listen and server_name used here are configured for a local machine.\n    In a production server you will most likely listen on port 80,\n    and use your URL as the server_name.\n\nNow make sure you enable the nginx service so it automatically starts at boot::\n\n    systemctl enable nginx.service\n\nEither reboot, or start Nginx with the following command::\n\n    systemctl start nginx\n\nNow you should be able to test Nginx with Gunicorn by visiting\nhttp://127.0.0.1:8000/ in any web browser. Systemd is now set up.\n\n\nLogging\n=======\n\nLogging can be configured by using various flags detailed in the\n`configuration documentation`_ or by creating a `logging configuration file`_.\nSend the ``USR1`` signal to rotate logs if you are using the logrotate\nutility::\n\n    kill -USR1 $(cat /var/run/gunicorn.pid)\n\n.. note::\n   Overriding the ``LOGGING`` dictionary requires to set\n   ``disable_existing_loggers: False`` to not interfere with the Gunicorn\n   logging.\n\n.. warning::\n   Gunicorn error log is here to log errors from Gunicorn, not from another\n   application.\n\n.. _Nginx: https://nginx.org/\n.. _Hey: https://github.com/rakyll/hey\n.. _`example configuration`: https://github.com/benoitc/gunicorn/blob/master/examples/nginx.conf\n.. _runit: http://smarden.org/runit/\n.. _`example service`: https://github.com/benoitc/gunicorn/blob/master/examples/gunicorn_rc\n.. _Supervisor: http://supervisord.org/\n.. _`simple configuration`: https://github.com/benoitc/gunicorn/blob/master/examples/supervisor.conf\n.. _`configuration documentation`: http://docs.gunicorn.org/en/latest/settings.html#logging\n.. _`logging configuration file`: https://github.com/benoitc/gunicorn/blob/master/examples/logging.conf\n.. _Virtualenv: https://pypi.python.org/pypi/virtualenv\n.. _Systemd: https://www.freedesktop.org/wiki/Software/systemd/\n.. _Gaffer: https://gaffer.readthedocs.io/\n.. _`ignoring client abort`: http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_ignore_client_abort\n",
      "source_file": "docs/source/deploy.rst",
      "chunk_type": "doc"
    },
    {
      "content": "=========\nCommunity\n=========\n\nUse these channels to communicate about the project.\n\nProject Management & Discussions\n================================\n\nGunicorn uses `GitHub for the project management <https://github.com/benoitc/gunicorn/projects>`_. GitHub issues are used\nfor 3 different purposes:\n\n  * `Bug tracker <https://github.com/benoitc/gunicorn/projects/2>`_ : to check latest bug \n  * `Forum <https://github.com/benoitc/gunicorn/projects/4>`_ : Stackoverflow-style questions about Gunicorn usage\n  * `Mailing list <https://github.com/benoitc/gunicorn/projects/3>`_ : Discussion of Gunicorn development, new features\n    and project management.  \n\nProject maintenance guidelines are available on the `wiki <https://github.com/benoitc/gunicorn/wiki/Project-management>`_\n.\n\nIRC\n===\n\nThe Gunicorn channel is on the `Freenode <http://freenode.net/>`_ IRC\nnetwork. You can chat with other on `#gunicorn channel\n<http://webchat.freenode.net/?channels=gunicorn>`_.\n\nIssue Tracking\n==============\n\nBug reports, enhancement requests and tasks generally go in the `Github\nissue tracker <http://github.com/benoitc/gunicorn/issues>`_.\n\nSecurity Issues\n===============\n\nThe security mailing list is a place to report security issues. Only\ndevelopers are subscribed to it. To post a message to the list use the address\nto `security@gunicorn.org <mailto:security@gunicorn.org>`_ .\n",
      "source_file": "docs/source/community.rst",
      "chunk_type": "doc"
    },
    {
      "content": "Changelog - 2011\n================\n\n0.13.4 / 2011-09-23\n-------------------\n\n- fix util.closerange function used to prevent leaking fds on python 2.5\n  (typo)\n\n0.13.3 / 2011-09-19\n-------------------\n- refactor gevent worker\n- prevent leaking fds on reexec\n- fix inverted request_time computation\n\n0.13.2 / 2011-09-17\n-------------------\n\n- Add support for Tornado 2.0 in tornado worker\n- Improve access logs: allows customisation of the log format & add\n  request time\n- Logger module is now pluggable\n- Improve graceful shutdown in Python versions >= 2.6\n- Fix post_request root arity for compatibility\n- Fix sendfile support\n- Fix Django reloading\n\n0.13.1 / 2011-08-22\n-------------------\n\n- Fix unix socket. log argument was missing.\n\n0.13.0 / 2011-08-22\n-------------------\n\n- Improve logging: allows file-reopening and add access log file\n  compatible with the `apache combined log format <http://httpd.apache.org/docs/2.0/logs.html#combined>`_\n- Add the possibility to set custom SSL headers. X-Forwarded-Protocol\n  and X-Forwarded-SSL are still the default\n- New `on_reload` hook to customize how gunicorn spawn new workers on\n  SIGHUP\n- Handle projects with relative path in django_gunicorn command\n- Preserve path parameters in PATH_INFO\n- post_request hook now accepts the environ as argument.\n- When stopping the arbiter, close the listener asap.\n- Fix Django command `run_gunicorn` in settings reloading\n- Fix Tornado_ worker exiting\n- Fix the use of sendfile in wsgi.file_wrapper\n\n\n0.12.2 / 2011-05-18\n-------------------\n\n- Add wsgi.file_wrapper optimised for FreeBSD, Linux & MacOSX (use\n  sendfile if available)\n- Fix django run_gunicorn command. Make sure we reload the application\n  code.\n- Fix django localisation\n- Compatible with gevent 0.14dev\n\n0.12.1 / 2011-03-23\n-------------------\n\n- Add \"on_starting\" hook. This hook can be used to set anything before\n  the arbiter really start\n- Support bdist_rpm in setup\n- Improve content-length handling (pep 3333)\n- Improve Django support\n- Fix daemonizing (#142)\n- Fix ipv6 handling\n\n\n.. _Tornado: http://www.tornadoweb.org/\n",
      "source_file": "docs/source/2011-news.rst",
      "chunk_type": "doc"
    },
    {
      "content": "Changelog - 2010\n================\n\n0.12.0 / 2010-12-22\n-------------------\n\n- Add support for logging configuration using a ini file.\n  It uses the standard Python logging's module Configuration\n  file format and allows anyone to use his custom file handler\n- Add IPV6 support\n- Add multidomain application example\n- Improve gunicorn_django command when importing settings module\n  using DJANGO_SETTINGS_MODULE environment variable\n- Send appropriate error status on http parsing\n- Fix pidfile, set permissions so other user can read\n  it and use it.\n- Fix temporary file leaking\n- Fix setpgrp issue, can now be launched via ubuntu upstart\n- Set the number of workers to zero on WINCH\n\n0.11.2 / 2010-10-30\n-------------------\n\n* Add SERVER_SOFTWARE to the os.environ\n* Add support for django settings environment variable\n* Add support for logging configuration in Paster ini-files\n* Improve arbiter notification in asynchronous workers\n* Display the right error when a worker can't be used\n* Fix Django support\n* Fix HUP with Paster applications\n* Fix readline in wsgi.input\n\n0.11.1 / 2010-09-02\n-------------------\n\n* Implement max-requests feature to prevent memory leaks.\n* Added 'worker_exit' server hook.\n* Reseed the random number generator after fork().\n* Improve Eventlet worker.\n* Fix Django command `run_gunicorn`.\n* Fix the default proc name internal setting.\n* Workaround to prevent Gevent worker to segfault on MacOSX.\n\n0.11.0 / 2010-08-12\n-------------------\n\n* Improve dramatically performances of Gevent and Eventlet workers\n* Optimize HTTP parsing\n* Drop Server and Date headers in start_response when provided.\n* Fix latency issue in async workers\n\n0.10.1 / 2010-08-06\n-------------------\n\n* Improve gevent's workers. Add \"egg:gunicorn#gevent_wsgi\" worker using\n  `gevent.wsgi <http://www.gevent.org/gevent.wsgi.html>`_ and\n  \"egg:gunicorn#gevent_pywsgi\" worker using `gevent.pywsgi\n  <http://www.gevent.org/gevent.pywsgi.html>`_ .\n  **\"egg:gunicorn#gevent\"** using our own HTTP parser is still here and\n  is **recommended** for normal uses. Use the \"gevent.wsgi\" parser if you\n  need really fast connections and don't need streaming, keepalive or ssl.\n* Add pre/post request hooks\n* Exit more quietly\n* Fix gevent dns issue\n\n0.10.0 / 2010-07-08\n-------------------\n\n* New HTTP parser.\n* New HUP behaviour. Re-reads the configuration and then reloads all\n  worker processes without changing the master process id. Helpful for\n  code reloading and monitoring applications like supervisord and runit.\n* Added a preload configuration parameter. By default, application code\n  is now loaded after a worker forks. This couple with the new HUP\n  handling can be used for dev servers to do hot code reloading. Using\n  the preload flag can help a bit in small memory VM's.\n* Allow people to pass command line arguments to WSGI applications. See:\n  `examples/alt_spec.py\n  <http://github.com/benoitc/gunicorn/raw/master/examples/alt_spec.py>`_\n* Added an example gevent reloader configuration:\n  `examples/example_gevent_reloader.py\n  <http://github.com/benoitc/gunicorn/blob/master/examples/example_gevent_reloader.py>`_.\n* New gevent worker \"egg:gunicorn#gevent2\", working with gevent.wsgi.\n* Internal refactoring and various bug fixes.\n* New documentation website.\n\n0.9.1 / 2010-05-26\n------------------\n\n* Support https via X-Forwarded-Protocol or X-Forwarded-Ssl headers\n* Fix configuration\n* Remove -d options which was used instead of -D for daemon.\n* Fix umask in unix socket\n\n0.9.0 / 2010-05-24\n------------------\n\n* Added *when_ready* hook. Called just after the server is started\n* Added *preload* setting. Load application code before the worker processes\n  are forked.\n* Refactored Config\n* Fix pidfile\n* Fix QUIT/HUP in async workers\n* Fix reexec\n* Documentation improvements\n\n0.8.1 / 2010-04-29\n------------------\n\n* Fix builtins import in config\n* Fix installation with pip\n* Fix Tornado WSGI support\n* Delay application loading until after processing all configuration\n\n0.8.0 / 2010-04-22\n------------------\n\n* Refactored Worker management for better async support. Now use the -k option\n  to set the type of request processing to use\n* Added support for Tornado_\n\n0.7.2 / 2010-04-15\n------------------\n\n* Added --spew option to help debugging (installs a system trace hook)\n* Some fixes in async arbiters\n* Fix a bug in start_response on error\n\n0.7.1 / 2010-04-01\n------------------\n\n* Fix bug when responses have no body.\n\n0.7.0 / 2010-03-26\n------------------\n\n* Added support for Eventlet_ and Gevent_ based workers.\n* Added Websockets_ support\n* Fix Chunked Encoding\n* Fix SIGWINCH on OpenBSD_\n* Fix `PEP 333`_ compliance for the write callable.\n\n0.6.5 / 2010-03-11\n------------------\n\n* Fix pidfile handling\n* Fix Exception Error\n\n0.6.4 / 2010-03-08\n------------------\n\n* Use cStringIO for performance when possible.\n* Fix worker freeze when a remote connection closes unexpectedly.\n\n0.6.3 / 2010-03-07\n------------------\n\n* Make HTTP parsing faster.\n* Various bug fixes\n\n0.6.2 / 2010-03-01\n------------------\n\n* Added support for chunked response.\n* Added proc_name option to the config file.\n* Improved the HTTP parser. It now uses buffers instead of strings to store\n  temporary data.\n* Improved performance when sending responses.\n* Workers are now murdered by age (the oldest is killed first).\n\n0.6.1 / 2010-02-24\n------------------\n\n* Added gunicorn config file support for Django admin command\n* Fix gunicorn config file. -c was broken.\n* Removed TTIN/TTOU from workers which blocked other signals.\n\n0.6.0 / 2010-02-22\n------------------\n\n* Added setproctitle support\n* Change privilege switch behavior. We now work like NGINX, master keeps the\n  permissions, new uid/gid permissions are only set for workers.\n\n0.5.1 / 2010-02-22\n------------------\n\n* Fix umask\n* Added Debian packaging\n\n0.5.0 / 2010-02-20\n------------------\n\n* Added `configuration file <configuration.html>`_ handler.\n* Added support for pre/post fork hooks\n* Added support for before_exec hook\n* Added support for unix sockets\n* Added launch of workers processes under different user/group\n* Added umask option\n* Added SCRIPT_NAME support\n* Better support of some exotic settings for Django projects\n* Better support of Paste-compatible applications\n* Some refactoring to make the code easier to hack\n* Allow multiple keys in request and response headers\n\n.. _Tornado: http://www.tornadoweb.org/\n.. _`PEP 333`: https://www.python.org/dev/peps/pep-0333/\n.. _Eventlet: http://eventlet.net/\n.. _Gevent: http://www.gevent.org/\n.. _OpenBSD: https://www.openbsd.org/\n.. _Websockets: https://html.spec.whatwg.org/multipage/web-sockets.html\n",
      "source_file": "docs/source/2010-news.rst",
      "chunk_type": "doc"
    },
    {
      "content": ".. _instrumentation:\n\n===============\nInstrumentation\n===============\n\n.. versionadded:: 19.1\n\nGunicorn provides an optional instrumentation of the arbiter and\nworkers using the statsD_ protocol over UDP. Thanks to the\n``gunicorn.instrument.statsd`` module, Gunicorn becomes a statsD client.\nThe use of UDP cleanly isolates Gunicorn from the receiving end of the statsD\nmetrics so that instrumentation does not cause Gunicorn to be held up by a slow\nstatsD consumer.\n\nTo use statsD, just tell Gunicorn where the statsD server is:\n\n.. code-block:: bash\n\n    $ gunicorn --statsd-host=localhost:8125 --statsd-prefix=service.app ...\n\nThe ``Statsd`` logger overrides ``gunicorn.glogging.Logger`` to track\nall requests. The following metrics are generated:\n\n* ``gunicorn.requests``: request rate per second\n* ``gunicorn.request.duration``: histogram of request duration (in millisecond)\n* ``gunicorn.workers``: number of workers managed by the arbiter (gauge)\n* ``gunicorn.log.critical``: rate of critical log messages\n* ``gunicorn.log.error``: rate of error log messages\n* ``gunicorn.log.warning``: rate of warning log messages\n* ``gunicorn.log.exception``: rate of exceptional log messages\n\nSee the statsd-host_ setting for more information.\n\n.. _statsd-host: settings.html#statsd-host\n.. _statsD: https://github.com/etsy/statsd\n",
      "source_file": "docs/source/instrumentation.rst",
      "chunk_type": "doc"
    },
    {
      "content": "================\nChangelog - 2024\n================\n\n23.0.0 - 2024-08-10\n===================\n\n- minor docs fixes (:pr:`3217`, :pr:`3089`, :pr:`3167`)\n- worker_class parameter accepts a class (:pr:`3079`)\n- fix deadlock if request terminated during chunked parsing (:pr:`2688`)\n- permit receiving Transfer-Encodings: compress, deflate, gzip (:pr:`3261`)\n- permit Transfer-Encoding headers specifying multiple encodings. note: no parameters, still (:pr:`3261`)\n- sdist generation now explicitly excludes sphinx build folder (:pr:`3257`)\n- decode bytes-typed status (as can be passed by gevent) as utf-8 instead of raising `TypeError` (:pr:`2336`)\n- raise correct Exception when encounting invalid chunked requests (:pr:`3258`)\n- the SCRIPT_NAME and PATH_INFO headers, when received from allowed forwarders, are no longer restricted for containing an underscore (:pr:`3192`)\n- include IPv6 loopback address ``[::1]`` in default for :ref:`forwarded-allow-ips` and :ref:`proxy-allow-ips` (:pr:`3192`)\n\n** NOTE **\n\n- The SCRIPT_NAME change mitigates a regression that appeared first in the 22.0.0 release\n- Review your :ref:`forwarded-allow-ips` setting if you are still not seeing the SCRIPT_NAME transmitted\n- Review your :ref:`forwarder-headers` setting if you are missing headers after upgrading from a version prior to 22.0.0\n\n** Breaking changes **\n\n- refuse requests where the uri field is empty (:pr:`3255`)\n- refuse requests with invalid CR/LR/NUL in heade field values (:pr:`3253`)\n- remove temporary ``--tolerate-dangerous-framing`` switch from 22.0 (:pr:`3260`)\n- If any of the breaking changes affect you, be aware that now refused requests can post a security problem, especially so in setups involving request pipe-lining and/or proxies.\n\n22.0.0 - 2024-04-17\n===================\n\n- use `utime` to notify workers liveness \n- migrate setup to pyproject.toml\n- fix numerous security vulnerabilities in HTTP parser (closing some request smuggling vectors)\n- parsing additional requests is no longer attempted past unsupported request framing\n- on HTTP versions < 1.1 support for chunked transfer is refused (only used in exploits)\n- requests conflicting configured or passed SCRIPT_NAME now produce a verbose error\n- Trailer fields are no longer inspected for headers indicating secure scheme\n- support Python 3.12\n\n** Breaking changes **\n\n- minimum version is Python 3.7\n- the limitations on valid characters in the HTTP method have been bounded to Internet Standards\n- requests specifying unsupported transfer coding (order) are refused by default (rare)\n- HTTP methods are no longer casefolded by default (IANA method registry contains none affected)\n- HTTP methods containing the number sign (#) are no longer accepted by default (rare)\n- HTTP versions < 1.0 or >= 2.0 are no longer accepted by default (rare, only HTTP/1.1 is supported)\n- HTTP versions consisting of multiple digits or containing a prefix/suffix are no longer accepted\n- HTTP header field names Gunicorn cannot safely map to variables are silently dropped, as in other software\n- HTTP headers with empty field name are refused by default (no legitimate use cases, used in exploits)\n- requests with both Transfer-Encoding and Content-Length are refused by default (such a message might indicate an attempt to perform request smuggling)\n- empty transfer codings are no longer permitted (reportedly seen with really old & broken proxies)\n\n\n** SECURITY **\n\n- fix CVE-2024-1135\n",
      "source_file": "docs/source/2024-news.rst",
      "chunk_type": "doc"
    },
    {
      "content": "================\nRunning Gunicorn\n================\n\n.. highlight:: bash\n\nYou can run Gunicorn by using commands or integrate with popular frameworks\nlike Django, Pyramid, or TurboGears. For deploying Gunicorn in production see\n:doc:`deploy`.\n\nCommands\n========\n\nAfter installing Gunicorn you will have access to the command line script\n``gunicorn``.\n\n.. _gunicorn-cmd:\n\ngunicorn\n--------\n\nBasic usage::\n\n    $ gunicorn [OPTIONS] [WSGI_APP]\n\nWhere ``WSGI_APP`` is of the pattern ``$(MODULE_NAME):$(VARIABLE_NAME)``. The\nmodule name can be a full dotted path. The variable name refers to a WSGI\ncallable that should be found in the specified module.\n\n.. versionchanged:: 20.1.0\n    ``WSGI_APP`` is optional if it is defined in a :ref:`config` file.\n\nExample with the test app:\n\n.. code-block:: python\n\n    def app(environ, start_response):\n        \"\"\"Simplest possible application object\"\"\"\n        data = b'Hello, World!\\n'\n        status = '200 OK'\n        response_headers = [\n            ('Content-type', 'text/plain'),\n            ('Content-Length', str(len(data)))\n        ]\n        start_response(status, response_headers)\n        return iter([data])\n\nYou can now run the app with the following command:\n\n.. code-block:: text\n\n    $ gunicorn --workers=2 test:app\n\nThe variable name can also be a function call. In that case the name\nwill be imported from the module, then called to get the application\nobject. This is commonly referred to as the \"application factory\"\npattern.\n\n.. code-block:: python\n\n    def create_app():\n        app = FrameworkApp()\n        ...\n        return app\n\n.. code-block:: text\n\n    $ gunicorn --workers=2 'test:create_app()'\n\nPositional and keyword arguments can also be passed, but it is\nrecommended to load configuration from environment variables rather than\nthe command line.\n\nCommonly Used Arguments\n^^^^^^^^^^^^^^^^^^^^^^^\n\n* ``-c CONFIG, --config=CONFIG`` - Specify a config file in the form\n  ``$(PATH)``, ``file:$(PATH)``, or ``python:$(MODULE_NAME)``.\n* ``-b BIND, --bind=BIND`` - Specify a server socket to bind. Server sockets\n  can be any of ``$(HOST)``, ``$(HOST):$(PORT)``, ``fd://$(FD)``, or\n  ``unix:$(PATH)``. An IP is a valid ``$(HOST)``.\n* ``-w WORKERS, --workers=WORKERS`` - The number of worker processes. This\n  number should generally be between 2-4 workers per core in the server.\n  Check the :ref:`faq` for ideas on tuning this parameter.\n* ``-k WORKERCLASS, --worker-class=WORKERCLASS`` - The type of worker process\n  to run. You'll definitely want to read the production page for the\n  implications of this parameter. You can set this to ``$(NAME)``\n  where ``$(NAME)`` is one of ``sync``, ``eventlet``, ``gevent``,\n  ``tornado``, ``gthread``.\n  ``sync`` is the default. See the :ref:`worker-class` documentation for more\n  information.\n* ``-n APP_NAME, --name=APP_NAME`` - If setproctitle_ is installed you can\n  adjust the name of Gunicorn process as they appear in the process system\n  table (which affects tools like ``ps`` and ``top``).\n\nSettings can be specified by using environment variable\n:ref:`GUNICORN_CMD_ARGS <settings>`.\n\nSee :ref:`configuration` and :ref:`settings` for detailed usage.\n\n.. _setproctitle: https://pypi.python.org/pypi/setproctitle\n\nIntegration\n===========\n\nGunicorn also provides integration for Django and Paste Deploy applications.\n\nDjango\n------\n\nGunicorn will look for a WSGI callable named ``application`` if not specified.\nSo for a typical Django project, invoking Gunicorn would look like::\n\n    $ gunicorn myproject.wsgi\n\n\n.. note::\n\n   This requires that your project be on the Python path; the simplest way to\n   ensure that is to run this command from the same directory as your\n   ``manage.py`` file.\n\nYou can use the\n`--env <http://docs.gunicorn.org/en/latest/settings.html#raw-env>`_ option\nto set the path to load the settings. In case you need it you can also\nadd your application path to ``PYTHONPATH`` using the\n`--pythonpath <http://docs.gunicorn.org/en/latest/settings.html#pythonpath>`_\noption::\n\n    $ gunicorn --env DJANGO_SETTINGS_MODULE=myproject.settings myproject.wsgi\n\nPaste Deployment\n----------------\n\nFrameworks such as Pyramid and Turbogears are typically configured using Paste\nDeployment configuration files. If you would like to use these files with\nGunicorn, there are two approaches.\n\nAs a server runner, Gunicorn can serve your application using the commands from\nyour framework, such as ``pserve`` or ``gearbox``. To use Gunicorn with these\ncommands, specify it as a server in your configuration file:\n\n.. code-block:: ini\n\n    [server:main]\n    use = egg:gunicorn#main\n    host = 127.0.0.1\n    port = 8080\n    workers = 3\n\nThis approach is the quickest way to get started with Gunicorn, but there are\nsome limitations. Gunicorn will have no control over how the application is\nloaded, so settings such as reload_ will have no effect and Gunicorn will be\nunable to hot upgrade a running application. Using the daemon_ option may\nconfuse your command line tool. Instead, use the built-in support for these\nfeatures provided by that tool. For example, run ``pserve --reload`` instead of\nspecifying ``reload = True`` in the server configuration block. For advanced\nconfiguration of Gunicorn, such as `Server Hooks`_ specifying a Gunicorn\nconfiguration file using the ``config`` key is supported.\n\nTo use the full power of Gunicorn's reloading and hot code upgrades, use the\n`paste option`_ to run your application instead. When used this way, Gunicorn\nwill use the application defined by the PasteDeploy configuration file, but\nGunicorn will not use any server configuration defined in the file. Instead,\n`configure gunicorn`_.\n\nFor example::\n\n    $ gunicorn --paste development.ini -b :8080 --chdir /path/to/project\n\nOr use a different application::\n\n    $ gunicorn --paste development.ini#admin -b :8080 --chdir /path/to/project\n\nWith both approaches, Gunicorn will use any loggers section found in Paste\nDeployment configuration file, unless instructed otherwise by specifying\nadditional `logging settings`_.\n\n.. _reload: http://docs.gunicorn.org/en/latest/settings.html#reload\n.. _daemon: http://docs.gunicorn.org/en/latest/settings.html#daemon\n.. _Server Hooks: http://docs.gunicorn.org/en/latest/settings.html#server-hooks\n.. _paste option: http://docs.gunicorn.org/en/latest/settings.html#paste\n.. _configure gunicorn: http://docs.gunicorn.org/en/latest/configure.html\n.. _logging settings: http://docs.gunicorn.org/en/latest/settings.html#logging\n",
      "source_file": "docs/source/run.rst",
      "chunk_type": "doc"
    },
    {
      "content": ".. _configuration:\n\n======================\nConfiguration Overview\n======================\n\nGunicorn reads configuration information from five places.\n\nGunicorn first reads environment variables for some configuration\n:ref:`settings <settings>`.\n\nGunicorn then reads configuration from a framework specific configuration\nfile. Currently this only affects Paster applications.\n\nThe third source of configuration information is an optional configuration file\n``gunicorn.conf.py`` searched in the current working directory or specified\nusing a command line argument. Anything specified in this configuration file\nwill override any framework specific settings.\n\nThe fourth place of configuration information are command line arguments\nstored in an environment variable named ``GUNICORN_CMD_ARGS``.\n\nLastly, the command line arguments used to invoke Gunicorn are the final place\nconsidered for configuration settings. If an option is specified on the command\nline, this is the value that will be used.\n\nWhen a configuration file is specified in the command line arguments and in the\n``GUNICORN_CMD_ARGS`` environment variable, only the configuration\nfile specified on the command line is used.\n\nOnce again, in order of least to most authoritative:\n    1. Environment Variables\n    2. Framework Settings\n    3. Configuration File\n    4. ``GUNICORN_CMD_ARGS``\n    5. Command Line\n\n\n.. note::\n\n    To print your resolved configuration when using the command line or the\n    configuration file you can run the following command::\n\n        $ gunicorn --print-config APP_MODULE\n\n    To check your resolved configuration when using the command line or the\n    configuration file you can run the following command::\n\n        $ gunicorn --check-config APP_MODULE\n\n    It also allows you to know if your application can be launched.\n\n\nCommand Line\n============\n\nIf an option is specified on the command line, it overrides all other values\nthat may have been specified in the app specific settings, or in the optional\nconfiguration file. Not all Gunicorn settings are available to be set from the\ncommand line. To see the full list of command line settings you can do the\nusual::\n\n    $ gunicorn -h\n\nThere is also a ``--version`` flag available to the command line scripts that\nisn't mentioned in the list of :ref:`settings <settings>`.\n\n.. _configuration_file:\n\nConfiguration File\n==================\n\nThe configuration file should be a valid Python source file with a **python\nextension** (e.g. `gunicorn.conf.py`). It only needs to be readable from the\nfile system. More specifically, it does not have to be on the module path\n(sys.path, PYTHONPATH). Any Python is valid. Just consider that this will be\nrun every time you start Gunicorn (including when you signal Gunicorn to reload).\n\nTo set a parameter, just assign to it. There's no special syntax. The values\nyou provide will be used for the configuration values.\n\nFor instance::\n\n    import multiprocessing\n\n    bind = \"127.0.0.1:8000\"\n    workers = multiprocessing.cpu_count() * 2 + 1\n\nAll the settings are mentioned in the :ref:`settings <settings>` list.\n\n\nFramework Settings\n==================\n\nCurrently, only Paster applications have access to framework specific\nsettings. If you have ideas for providing settings to WSGI applications or\npulling information from Django's settings.py feel free to open an issue_ to\nlet us know.\n\n.. _issue: https://github.com/benoitc/gunicorn/issues\n\nPaster Applications\n-------------------\n\nIn your INI file, you can specify to use Gunicorn as the server like such:\n\n.. code-block:: ini\n\n    [server:main]\n    use = egg:gunicorn#main\n    host = 192.168.0.1\n    port = 80\n    workers = 2\n    proc_name = brim\n\nAny parameters that Gunicorn knows about will automatically be inserted into\nthe base configuration. Remember that these will be overridden by the config\nfile and/or the command line.\n",
      "source_file": "docs/source/configure.rst",
      "chunk_type": "doc"
    },
    {
      "content": "================\nChangelog - 2016\n================\n\n.. note::\n\n   Please see :doc:`news` for the latest changes\n\n19.6.0 / 2016/05/21\n===================\n\nCore & Logging\n++++++++++++++\n\n- improvement of the binary upgrade behaviour using USR2: remove file locking (:issue:`1270`)\n- add the ``--capture-output`` setting to capture stdout/stderr tot the log\n  file (:issue:`1271`)\n- Allow disabling ``sendfile()`` via the ``SENDFILE`` environment variable\n  (:issue:`1252`)\n- fix reload under pycharm (:issue:`1129`)\n\nWorkers\n+++++++\n\n- fix: make sure to remove the signal from the worker pipe (:issue:`1269`)\n- fix: **gthread** worker, handle removed socket in the select loop\n  (:issue:`1258`)\n\n19.5.0 / 2016/05/10\n===================\n\nCore\n++++\n\n- fix: Ensure response to HEAD request won't have message body\n- fix: lock domain socket and remove on last arbiter exit (:issue:`1220`)\n- improvement: use EnvironmentError instead of socket.error (:issue:`939`)\n- add: new ``FORWARDED_ALLOW_IPS`` environment variable (:issue:`1205`)\n- fix: infinite recursion when destroying sockets (:issue:`1219`)\n- fix: close sockets on shutdown (:issue:`922`)\n- fix: clean up sys.exc_info calls to drop circular refs (:issue:`1228`)\n- fix: do post_worker_init after load_wsgi (:issue:`1248`)\n\nWorkers\n+++++++\n\n- fix access logging in gaiohttp worker (:issue:`1193`)\n- eventlet: handle QUIT in a new coroutine (:issue:`1217`)\n- gevent: remove obsolete exception clauses in run (:issue:`1218`)\n- tornado: fix extra \"Server\" response header (:issue:`1246`)\n- fix: unblock the wait loop under python 3.5 in sync worker (:issue:`1256`)\n\nLogging\n+++++++\n\n- fix: log message for listener reloading (:issue:`1181`)\n- Let logging module handle traceback printing (:issue:`1201`)\n- improvement: Allow configuring logger_class with statsd_host (:issue:`1188`)\n- fix: traceback formatting (:issue:`1235`)\n- fix: print error logs on stderr and access logs on stdout (:issue:`1184`)\n\n\nDocumentation\n+++++++++++++\n\n- Simplify installation instructions in gunicorn.org (:issue:`1072`)\n- Fix URL and default worker type in example_config (:issue:`1209`)\n- update django doc url to 1.8 lts (:issue:`1213`)\n- fix: miscellaneous wording corrections (:issue:`1216`)\n- Add PSF License Agreement of selectors.py to NOTICE (:issue: `1226`)\n- document LOGGING overriding (:issue:`1051`)\n- put a note that error logs are only errors from Gunicorn (:issue:`1124`)\n- add a note about the requirements of the threads workers under python 2.x (:issue:`1200`)\n- add access_log_format to config example (:issue:`1251`)\n\nTests\n+++++\n\n- Use more pytest.raises() in test_http.py\n\n\n19.4.5 / 2016/01/05\n===================\n\n- fix: NameError fileno in gunicorn.http.wsgi (:issue:`1178`)\n\n19.4.4 / 2016/01/04\n===================\n\n- fix: check if a fileobject can be used with sendfile(2) (:issue:`1174`)\n- doc: be more descriptive in errorlog option (:issue:`1173`)\n",
      "source_file": "docs/source/2016-news.rst",
      "chunk_type": "doc"
    },
    {
      "content": "================\nChangelog - 2017\n================\n\n.. note::\n\n   Please see :doc:`news` for the latest changes\n\n19.7.1 / 2017/03/21\n===================\n\n- fix: continue if SO_REUSEPORT seems to be available but fails (:issue:`1480`)\n- fix: support non-decimal values for the umask command line option (:issue:`1325`)\n\n19.7.0 / 2017/03/01\n===================\n\n- The previously deprecated ``gunicorn_django`` command has been removed.\n  Use the :ref:`gunicorn-cmd` command-line interface instead.\n- The previously deprecated ``django_settings`` setting has been removed.\n  Use the :ref:`raw-env` setting instead.\n- The default value of :ref:`ssl-version` has been changed from\n  ``ssl.PROTOCOL_TLSv1`` to ``ssl.PROTOCOL_SSLv23``.\n- fix: initialize the group access list when initgroups is set (:issue:`1297`)\n- add environment variables to gunicorn access log format (:issue:`1291`)\n- add --paste-global-conf option (:issue:`1304`)\n- fix: print access logs to STDOUT (:issue:`1184`)\n- remove upper limit on max header size config (:issue:`1313`)\n- fix: print original exception on AppImportError (:issue:`1334`)\n- use SO_REUSEPORT if available (:issue:`1344`)\n- `fix leak <https://github.com/benoitc/gunicorn/commit/b4c41481e2d5ef127199a4601417a6819053c3fd>`_ of duplicate file descriptor for bound sockets.\n- add --reload-engine option, support inotify and other backends (:issue:`1368`, :issue:`1459`)\n- fix: reject request with invalid HTTP versions\n- add ``child_exit`` callback (:issue:`1394`)\n- add support for eventlets _AlreadyHandled object (:issue:`1406`)\n- format boot tracebacks properly with reloader (:issue:`1408`)\n- refactor socket activation and fd inheritance for better support of SystemD (:issue:`1310`)\n- fix: o fds are given by default in gunicorn (:issue:`1423`)\n- add ability to pass settings to GUNICORN_CMD_ARGS environment variable which helps in container world (:issue:`1385`)\n- fix:  catch access denied to pid file (:issue:`1091`)\n-  many additions and improvements to the documentation\n\nBreaking Change\n+++++++++++++++\n\n- **Python 2.6.0** is the last supported version\n",
      "source_file": "docs/source/2017-news.rst",
      "chunk_type": "doc"
    },
    {
      "content": ".. _faq:\n\n===\nFAQ\n===\n\nWSGI Bits\n=========\n\nHow do I set SCRIPT_NAME?\n-------------------------\n\nBy default ``SCRIPT_NAME`` is an empty string. The value could be set by\nsetting ``SCRIPT_NAME`` in the environment or as an HTTP header. Note that\nthis headers contains and underscore, so it is only accepted from trusted\nforwarders listed in the :ref:`forwarded-allow-ips` setting.\n\n.. note::\n\n   If your application should appear in a subfolder, your ``SCRIPT_NAME``\n   would typically start with single slash but contain no trailing slash.\n\nServer Stuff\n============\n\nHow do I reload my application in Gunicorn?\n-------------------------------------------\n\nYou can gracefully reload by sending HUP signal to gunicorn::\n\n    $ kill -HUP masterpid\n\nHow might I test a proxy configuration?\n---------------------------------------\n\nThe Hey_ program is a great way to test that your proxy is correctly\nbuffering responses for the synchronous workers::\n\n    $ hey -n 10000 -c 100 http://127.0.0.1:5000/\n\nThis runs a benchmark of 10000 requests with 100 running concurrently.\n\nHow can I name processes?\n-------------------------\n\nIf you install the Python package setproctitle_ Gunicorn will set the process\nnames to something a bit more meaningful. This will affect the output you see\nin tools like ``ps`` and ``top``. This helps for distinguishing the master\nprocess as well as between masters when running more than one app on a single\nmachine. See the proc_name_ setting for more information.\n\nWhy is there no HTTP Keep-Alive?\n--------------------------------\n\nThe default Sync workers are designed to run behind Nginx which only uses\nHTTP/1.0 with its upstream servers. If you want to deploy Gunicorn to\nhandle unbuffered requests (ie, serving requests directly from the internet)\nyou should use one of the async workers.\n\n.. _Hey: https://github.com/rakyll/hey\n.. _setproctitle: https://pypi.python.org/pypi/setproctitle\n.. _proc_name: settings.html#proc-name\n\n\nWorker Processes\n================\n\nHow do I know which type of worker to use?\n------------------------------------------\n\nRead the :ref:`design` page for help on the various worker types.\n\nWhat types of workers are there?\n--------------------------------\n\nCheck out the configuration docs for worker_class_.\n\nHow can I figure out the best number of worker processes?\n---------------------------------------------------------\n\nHere is our recommendation for tuning the `number of workers`_.\n\nHow can I change the number of workers dynamically?\n---------------------------------------------------\n\nTTIN and TTOU signals can be sent to the master to increase or decrease\nthe number of workers.\n\nTo increase the worker count by one::\n\n    $ kill -TTIN $masterpid\n\nTo decrease the worker count by one::\n\n    $ kill -TTOU $masterpid\n\nDoes Gunicorn suffer from the thundering herd problem?\n------------------------------------------------------\n\nThe thundering herd problem occurs when many sleeping request handlers, which\nmay be either threads or processes, wake up at the same time to handle a new\nrequest. Since only one handler will receive the request, the others will have\nbeen awakened for no reason, wasting CPU cycles. At this time, Gunicorn does\nnot implement any IPC solution for coordinating between worker processes. You\nmay experience high load due to this problem when using many workers or\nthreads. However `a work has been started\n<https://github.com/benoitc/gunicorn/issues/792>`_ to remove this issue.\n\n.. _worker_class: settings.html#worker-class\n.. _`number of workers`: design.html#how-many-workers\n\nWhy I don't see any logs in the console?\n----------------------------------------\n\nIn version 19.0, Gunicorn doesn't log by default in the console.\nTo watch the logs in the console you need to use the option ``--log-file=-``.\nIn version 19.2, Gunicorn logs to the console by default again.\n\nKernel Parameters\n=================\n\nWhen dealing with large numbers of concurrent connections there are a handful\nof kernel parameters that you might need to adjust. Generally these should only\naffect sites with a very large concurrent load. These parameters are not\nspecific to Gunicorn, they would apply to any sort of network server you may be\nrunning.\n\nThese commands are for Linux. Your particular OS may have slightly different\nparameters.\n\nHow can I increase the maximum number of file descriptors?\n----------------------------------------------------------\n\nOne of the first settings that usually needs to be bumped is the maximum number\nof open file descriptors for a given process. For the confused out there,\nremember that Unices treat sockets as files.\n\n.. warning:: ``sudo ulimit`` may not work\n\nConsidering non-privileged users are not able to relax the limit, you should\nfirstly switch to root user, increase the limit, then run gunicorn. Using ``sudo\nulimit`` would not take effect.\n\nTry systemd's service unit file, or an initscript which runs as root.\n\nHow can I increase the maximum socket backlog?\n----------------------------------------------\n\nListening sockets have an associated queue of incoming connections that are\nwaiting to be accepted. If you happen to have a stampede of clients that fill\nup this queue new connections will eventually start getting dropped.\n\n::\n\n    $ sudo sysctl -w net.core.somaxconn=\"2048\"\n\nHow can I disable the use of ``sendfile()``\n-------------------------------------------\n\nDisabling the use ``sendfile()`` can be done by using the ``--no-sendfile``\nsetting or by setting the environment variable ``SENDFILE`` to 0.\n\n\n\nTroubleshooting\n===============\n\nHow do I fix Django reporting an ``ImproperlyConfigured`` error?\n----------------------------------------------------------------\n\nWith asynchronous workers, creating URLs with the ``reverse`` function of\n``django.core.urlresolvers`` may fail. Use ``reverse_lazy`` instead.\n\n.. _blocking-os-fchmod:\n\nHow do I avoid Gunicorn excessively blocking in ``os.fchmod``?\n--------------------------------------------------------------\n\nThe current heartbeat system involves calling ``os.fchmod`` on temporary file\nhandlers and may block a worker for arbitrary time if the directory is on a\ndisk-backed filesystem. For example, by default ``/tmp`` is not mounted as\n``tmpfs`` in Ubuntu; in AWS an EBS root instance volume may sometimes hang for\nhalf a minute and during this time Gunicorn workers may completely block in\n``os.fchmod``. ``os.fchmod`` may introduce extra delays if the disk gets full.\nAlso Gunicorn may refuse to start if it can't create the files when the disk is\nfull.\n\nCurrently to avoid these problems you can use a ``tmpfs`` mount (for a new\ndirectory or for ``/tmp``) and pass its path to ``--worker-tmp-dir``. First,\ncheck whether your ``/tmp`` is disk-backed or RAM-backed::\n\n    $ df /tmp\n    Filesystem     1K-blocks    Used Available Use% Mounted on\n    /dev/xvda1           ...     ...       ...  ... /\n\nNo luck. If you are using Fedora or Ubuntu, you should already have a ``tmpfs``\nmount at ``/dev/shm``::\n\n    $ df /dev/shm\n    Filesystem     1K-blocks     Used Available Use% Mounted on\n    tmpfs                 ...     ...       ...  ... /dev/shm\n\nIn this case you can set ``--worker-tmp-dir /dev/shm``, otherwise you can\ncreate a new ``tmpfs`` mount::\n\n    sudo cp /etc/fstab /etc/fstab.orig\n    sudo mkdir /mem\n    echo 'tmpfs       /mem tmpfs defaults,size=64m,mode=1777,noatime,comment=for-gunicorn 0 0' | sudo tee -a /etc/fstab\n    sudo mount /mem\n\nCheck the result::\n\n    $ df /mem\n    Filesystem     1K-blocks  Used Available Use% Mounted on\n    tmpfs              65536     0     65536   0% /mem\n\nNow you can set ``--worker-tmp-dir /mem``.\n\nWhy are Workers Silently Killed?\n--------------------------------------------------------------\n\nA sometimes subtle problem to debug is when a worker process is killed and there\nis little logging information about what happened.\n\nIf you use a reverse proxy like NGINX you might see 502 returned to a client.\n\nIn the gunicorn logs you might simply see ``[35] [INFO] Booting worker with pid: 35``\n\nIt's completely normal for workers to be stop and start, for example due to\nmax-requests setting. Ordinarily gunicorn will capture any signals and log something.\n\nThis particular failure case is usually due to a SIGKILL being received, as it's\nnot possible to catch this signal silence is usually a common side effect! A common\ncause of SIGKILL is when OOM killer terminates a process due to low memory condition.\n\nThis is increasingly common in container deployments where memory limits are enforced\nby cgroups, you'll usually see evidence of this from dmesg::\n\n    dmesg | grep gunicorn\n    Memory cgroup out of memory: Kill process 24534 (gunicorn) score 1506 or sacrifice child\n    Killed process 24534 (gunicorn) total-vm:1016648kB, anon-rss:550160kB, file-rss:25824kB, shmem-rss:0kB\n\nIn these instances adjusting the memory limit is usually your best bet, it's also possible\nto configure OOM not to send SIGKILL by default.\n",
      "source_file": "docs/source/faq.rst",
      "chunk_type": "doc"
    },
    {
      "content": "================\nChangelog - 2023\n================\n\n21.2.0 - 2023-07-19\n===================\n\n- fix thread worker: revert change considering connection as idle . \n\n*** NOTE ***\n\nThis is fixing the bad file description error.\n\n21.1.0 - 2023-07-18\n===================\n\n- fix thread worker: fix socket removal from the queue\n\n21.0.1 - 2023-07-17\n===================\n\n- fix documentation build\n\n21.0.0 - 2023-07-17\n===================\n\n- support python 3.11\n- fix gevent and eventlet workers\n- fix threads support (gththread): improve performance and unblock requests\n- SSL: now use SSLContext object\n- HTTP parser: miscellaneous fixes\n- remove unnecessary setuid calls\n- fix testing\n- improve logging\n- miscellaneous fixes to core engine\n\n*** RELEASE NOTE ***\n\nWe made this release major to start our new release cycle. More info will be provided on our discussion forum.\n",
      "source_file": "docs/source/2023-news.rst",
      "chunk_type": "doc"
    },
    {
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"refresh\" content=\"0;url=http://gunicorn.org/\">\n    <title>Green Unicorn - FAQ</title>\n  </head>\n  <body>\n    <h2>\n      Redirecting to <a href=\"http://gunicorn.org/\">here</a>\n    </h2>\n  </body>\n</html>\n",
      "source_file": "docs/site/tuning.html",
      "chunk_type": "unknown"
    },
    {
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"refresh\" content=\"0;url=http://gunicorn.org/\">\n    <title>Green Unicorn - Install</title>\n  </head>\n  <body>\n    <h2>\n      Redirecting to <a href=\"http://gunicorn.org/\">here</a>\n    </h2>\n  </body>\n</html>\n",
      "source_file": "docs/site/install.html",
      "chunk_type": "unknown"
    },
    {
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"refresh\" content=\"0;url=http://gunicorn.org/\">\n    <title>Green Unicorn - Design</title>\n  </head>\n  <body>\n    <h2>\n      Redirecting to <a href=\"http://gunicorn.org/\">here</a>\n    </h2>\n  </body>\n</html>\n",
      "source_file": "docs/site/design.html",
      "chunk_type": "unknown"
    },
    {
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"refresh\" content=\"0;url=http://gunicorn.org/\">\n    <title>Green Unicorn - Run</title>\n  </head>\n  <body>\n    <h2>\n      Redirecting to <a href=\"http://gunicorn.org/\">here</a>\n    </h2>\n  </body>\n</html>\n",
      "source_file": "docs/site/run.html",
      "chunk_type": "unknown"
    },
    {
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"refresh\" content=\"0;url=http://gunicorn.org/index.html#community\">\n    <title>Green Unicorn - Community</title>\n  </head>\n  <body>\n    <h2>\n      Redirecting to <a href=\"http://gunicorn.org/index.html#community\">here</a>\n    </h2>\n  </body>\n</html>\n",
      "source_file": "docs/site/community.html",
      "chunk_type": "unknown"
    },
    {
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Gunicorn - Python WSGI HTTP Server for UNIX</title>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"css/style.css\" />\n  <link rel=\"shortcut icon\" href=\"images/favicon.png\" type=\"image/x-icon\">\n  <link rel=\"alternate\"\n  href=\"https://github.com/benoitc/gunicorn/commits/master.atom\"\n  type=\"application/atom+xml\" title=\"Gunicorn commits\">\n\n</head>\n<body>\n  <div class=\"logo-wrapper\">\n    <div class=\"logo-div\">\n      <div class=\"latest\">\n        Latest version: <strong><a\n            href=\"https://docs.gunicorn.org/en/stable/\">23.0.0</a></strong>\n      </div>\n\n      <div class=\"logo\"><img src=\"images/logo.jpg\" ></div>\n    </div>\n  </div>\n  <div class=\"banner-wrapper\">\n    <div class=\"banner\">\n      <div class=\"title\"><img src=\"images/title.png\"></div>\n      <h1>Gunicorn 'Green Unicorn' is a Python WSGI HTTP Server for UNIX. It's a pre-fork worker model. The Gunicorn server is broadly compatible with various web frameworks, simply implemented, light on server resources, and fairly speedy.</h1>\n      <div class=\"banner-button\">\n        <a href=\"https://github.com/benoitc/gunicorn\" title=\"View source at github\" class=\"greenbutton\">View source</a>\n        <a href=\"http://pypi.python.org/pypi/gunicorn/\" title=\"Download from PyPi\" class=\"redbutton\">Download</a>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"mid-wrapper\">\n    <div class=\"tabs\">\n      <ul class=\"tab-bar\">\n        <li class=\"active\">\n          <a href=\"#quickstart\" title=\"Quickstart\" class=\"gabout\">\n            <h2>Quickstart</h2>\n            <p>Read the quickstart guide to get started using Gunicorn.</p>\n          </a>\n        </li>\n        <li class=\"withborder\">\n          <a href=\"#deployment\" title=\"Deployment\" class=\"gdownloads\">\n            <h2>Deployment</h2>\n            <p>Learn how to deploy the Gunicorn server.</p>\n          </a>\n        </li>\n        <li class=\"withborder\">\n          <a href=\"#community\" title=\"Community\" class=\"gcommunity\">\n            <h2>Community</h2>\n            <p>Get in touch with the community.</p>\n          </a>\n        </li>\n        <li class=\"withborder\">\n          <a href=\"#docs\" title=\"Documentation\" class=\"gdocuments\">\n            <h2>Documentation</h2>\n            <p>Read the documentation to learn more about Gunicorn.</p>\n          </a>\n        </li>\n      </ul>\n      <div class=\"clearall active\"></div>\n\n      <div class=\"tab-box active\" data-tab=\"quickstart\">\n        <h1>Installation</h1>\n        <p>\n          Here's a quick rundown on how to get started with Gunicorn. For more details read the <a href=\"http://docs.gunicorn.org/en/stable/\">documentation</a>.\n        </p>\n<pre>\n  $ pip install gunicorn\n  $ cat myapp.py\n    def app(environ, start_response):\n        data = b\"Hello, World!\\n\"\n        start_response(\"200 OK\", [\n            (\"Content-Type\", \"text/plain\"),\n            (\"Content-Length\", str(len(data)))\n        ])\n        return iter([data])\n  $ gunicorn -w 4 myapp:app\n  [2014-09-10 10:22:28 +0000] [30869] [INFO] Listening at: http://127.0.0.1:8000 (30869)\n  [2014-09-10 10:22:28 +0000] [30869] [INFO] Using worker: sync\n  [2014-09-10 10:22:28 +0000] [30874] [INFO] Booting worker with pid: 30874\n  [2014-09-10 10:22:28 +0000] [30875] [INFO] Booting worker with pid: 30875\n  [2014-09-10 10:22:28 +0000] [30876] [INFO] Booting worker with pid: 30876\n  [2014-09-10 10:22:28 +0000] [30877] [INFO] Booting worker with pid: 30877\n</pre>\n      </div>\n      <div class=\"tab-box\" data-tab=\"deployment\">\n        <h1>Deployment</h1>\n        <p>\n          Gunicorn is a WSGI HTTP server. It is best to use Gunicorn behind an HTTP proxy server. We strongly advise you to use <a href=\"http://www.nginx.org/\">nginx</a>.\n        </p>\n        <p>Here's an example to help you get started with using nginx:</p>\n<pre>\n  server {\n    listen 80;\n    server_name example.org;\n    access_log  /var/log/nginx/example.log;\n\n    location / {\n        proxy_pass http://127.0.0.1:8000;\n        proxy_set_header Host $host;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    }\n  }\n</pre>\n        <p>Nginx is set up as reverse proxy server to a Gunicorn server running on localhost port 8000.</p>\n        <p>Read the full documentation at <a\n          href=\"http://docs.gunicorn.org/en/latest/deploy.html\">docs.gunicorn.org</a></p>\n      </div>\n      <div class=\"tab-box\" data-tab=\"community\">\n        <h1>Project Management</h1>\n        <p><strong>Gunicorn</strong> uses <a href=\"https://github.com/benoitc/gunicorn/projects\">GitHub for the project management</a>. GitHub issues are used for 3 different purposes:</p>\n        <ul>\n          <li><a href=\"https://github.com/benoitc/gunicorn/projects/2\">Bug tracker</a></li>\n          <li><a href=\"https://github.com/benoitc/gunicorn/projects/4\">Forum</a></li>\n          <li><a href=\"https://github.com/benoitc/gunicorn/projects/3\">Mailing list</a>\n        </ul>\n        <p>Project maintenance guidelines are available on the <a href=\"https://github.com/benoitc/gunicorn/wiki/Project-management\">wiki</a></p>\n        \n        <h1>IRC</h1>\n        <p>The Gunicorn channel is on the <a href=\"https://libera.chat/\">Libera Chat</a> IRC\n          network. You can chat with the community on the <a href=\"https://web.libera.chat/?channels=#gunicorn\">#gunicorn channel</a>.</p>\n\n        <h1>Issue Tracking</h1>\n        <p>Bug reports, enhancement requests and tasks generally go in the <a  href=\"http://github.com/benoitc/gunicorn/issues\">Github\n          issue tracker</a>.</p>\n\n        <h1>Security Issues</h1>\n        <p>The security mailing list is a place to report security issues. Only\n        developers are subscribed to it. To post a message to the list use the\n        address <a  href=\"mailto:security&#64;gunicorn.org\">security&#64;gunicorn.org</a></p>\n\n      </div>\n      <div class=\"tab-box\" data-tab=\"docs\">\n        <h1>Documentation</h1>\n        <p>You can read more comprehensive documentation at <a href=\"http://docs.gunicorn.org\">docs.gunicorn.org</a>.</p>\n        <p>The contents are:</p>\n        <ul>\n          <li><a href=\"http://docs.gunicorn.org/en/latest/install.html\">Installation</a></li>\n          <li><a\n            href=\"http://docs.gunicorn.org/en/latest/run.html\">Running\n            Gunicorn</a></li>\n          <li><a\n            href=\"http://docs.gunicorn.org/en/latest/configure.html\">Configuration\n            Overview</a></li>\n          <li><a href=\"http://docs.gunicorn.org/en/latest/deploy.html\">Deploying Gunicorn</a></li>\n          <li><a href=\"http://docs.gunicorn.org/en/latest/design.html\">Design</a></li>\n          <li><a href=\"http://docs.gunicorn.org/en/latest/faq.html\">FAQ</a></li>\n          <li><a href=\"http://docs.gunicorn.org/en/latest/news.html\">Changelog</a></li>\n      </div>\n    </div>\n  </div>\n\n  <!-- <div class=\"user-wrapper\">\n    <div class=\"users\">\n      <div class=\"left-details\">\n        <h3>Who is using</h3>\n        <h2>Gunicorn</h2>\n      </div>\n      <div class=\"company-logos\">\n        <a href=\"#\"><img src=\"images/user1.jpg\"></a>\n        <a href=\"#\"><img src=\"images/user1.jpg\"></a>\n        <a href=\"#\"><img src=\"images/user1.jpg\"></a>\n        <a href=\"#\"><img src=\"images/user1.jpg\"></a>\n        <a href=\"#\"><img src=\"images/user1.jpg\"></a>\n        <a href=\"#\"><img src=\"images/user1.jpg\"></a>\n      </div>\n      <div class=\"clearall\"></div>\n    </div>\n  </div> -->\n\n  <div class=\"footer\">\n    <div class=\"footer-wp\">\n      This open sourced site is hosted on GitHub. <br>\n      <a href=\"http://github.com/benoitc/gunicorn/issues\">Patches, suggestions, and comments are welcome.</a>\n    </div>\n  </div>\n\n  <script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js\"></script>\n  <script src=\"js/main.js\"></script>\n</body>\n</html>\n",
      "source_file": "docs/site/index.html",
      "chunk_type": "unknown"
    },
    {
      "content": "gunicorn.org\n",
      "source_file": "docs/site/CNAME",
      "chunk_type": "unknown"
    },
    {
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"refresh\" content=\"0;url=http://gunicorn.org/\">\n    <title>Green Unicorn - Configuration</title>\n  </head>\n  <body>\n    <h2>\n      Redirecting to <a href=\"http://gunicorn.org/\">here</a>\n    </h2>\n  </body>\n</html>\n",
      "source_file": "docs/site/configuration.html",
      "chunk_type": "unknown"
    },
    {
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"refresh\" content=\"0;url=http://gunicorn.org/\">\n    <title>Green Unicorn - News</title>\n  </head>\n  <body>\n    <h2>\n      Redirecting to <a href=\"http://gunicorn.org/\">here</a>\n    </h2>\n  </body>\n</html>\n",
      "source_file": "docs/site/news.html",
      "chunk_type": "unknown"
    },
    {
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"refresh\" content=\"0;url=http://gunicorn.org/\">\n    <title>Green Unicorn - Configure</title>\n  </head>\n  <body>\n    <h2>\n      Redirecting to <a href=\"http://gunicorn.org/\">here</a>\n    </h2>\n  </body>\n</html>\n",
      "source_file": "docs/site/configure.html",
      "chunk_type": "unknown"
    },
    {
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"refresh\" content=\"0;url=http://gunicorn.org/index.html#deployment\">\n    <title>Green Unicorn - Deployment</title>\n  </head>\n  <body>\n    <h2>\n      Redirecting to <a href=\"http://gunicorn.org/index.html#deployment\">here</a>\n    </h2>\n  </body>\n</html>\n",
      "source_file": "docs/site/deploy.html",
      "chunk_type": "unknown"
    },
    {
      "content": "<?xml version='1.0' encoding='UTF-8'?>\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n <url>\n  <loc>http://gunicorn.org/</loc>\n  <lastmod>2019-11-27T00:02:48+01:00</lastmod>\n  <priority>1.0</priority>\n </url>\n <url>\n  <loc>http://gunicorn.org/community.html</loc>\n  <lastmod>2012-10-04T00:43:15+05:45</lastmod>\n  <priority>0.5</priority>\n </url>\n <url>\n  <loc>http://gunicorn.org/configuration.html</loc>\n  <lastmod>2012-10-04T00:43:15+05:45</lastmod>\n  <priority>0.5</priority>\n </url>\n <url>\n  <loc>http://gunicorn.org/configure.html</loc>\n  <lastmod>2012-10-04T00:43:15+05:45</lastmod>\n  <priority>0.5</priority>\n </url>\n <url>\n  <loc>http://gunicorn.org/deploy.html</loc>\n  <lastmod>2012-10-04T00:43:15+05:45</lastmod>\n  <priority>0.5</priority>\n </url>\n <url>\n  <loc>http://gunicorn.org/deployment.html</loc>\n  <lastmod>2012-10-04T00:43:15+05:45</lastmod>\n  <priority>0.5</priority>\n </url>\n <url>\n  <loc>http://gunicorn.org/design.html</loc>\n  <lastmod>2012-10-04T00:43:15+05:45</lastmod>\n  <priority>0.5</priority>\n </url>\n <url>\n  <loc>http://gunicorn.org/faq.html</loc>\n  <lastmod>2012-10-04T00:43:15+05:45</lastmod>\n  <priority>0.5</priority>\n </url>\n <url>\n  <loc>http://gunicorn.org/install.html</loc>\n  <lastmod>2012-10-04T00:43:15+05:45</lastmod>\n  <priority>0.5</priority>\n </url>\n <url>\n  <loc>http://gunicorn.org/installation.html</loc>\n  <lastmod>2012-10-04T00:43:15+05:45</lastmod>\n  <priority>0.5</priority>\n </url>\n <url>\n  <loc>http://gunicorn.org/news.html</loc>\n  <lastmod>2012-10-04T00:43:15+05:45</lastmod>\n  <priority>0.5</priority>\n </url>\n <url>\n  <loc>http://gunicorn.org/run.html</loc>\n  <lastmod>2012-10-04T00:43:15+05:45</lastmod>\n  <priority>0.5</priority>\n </url>\n <url>\n  <loc>http://gunicorn.org/tuning.html</loc>\n  <lastmod>2012-10-04T00:43:15+05:45</lastmod>\n  <priority>0.5</priority>\n </url>\n <url>\n  <loc>http://gunicorn.org/usage.html</loc>\n  <lastmod>2012-10-04T00:43:15+05:45</lastmod>\n  <priority>0.5</priority>\n </url>\n</urlset>\n",
      "source_file": "docs/site/sitemap.xml",
      "chunk_type": "unknown"
    },
    {
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"refresh\" content=\"0;url=http://gunicorn.org/index.html#deployment\">\n    <title>Green Unicorn - Deployment</title>\n  </head>\n  <body>\n    <h2>\n      Redirecting to <a href=\"http://gunicorn.org/index.html#deployment\">here</a>\n    </h2>\n  </body>\n</html>",
      "source_file": "docs/site/deployment.html",
      "chunk_type": "unknown"
    },
    {
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"refresh\" content=\"0;url=http://gunicorn.org/\">\n    <title>Green Unicorn - Install</title>\n  </head>\n  <body>\n    <h2>\n      Redirecting to <a href=\"http://gunicorn.org/\">here</a>\n    </h2>\n  </body>\n</html>\n",
      "source_file": "docs/site/installation.html",
      "chunk_type": "unknown"
    },
    {
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"refresh\" content=\"0;url=http://gunicorn.org/\">\n    <title>Green Unicorn - Run</title>\n  </head>\n  <body>\n    <h2>\n      Redirecting to <a href=\"http://gunicorn.org/\">here</a>\n    </h2>\n  </body>\n</html>\n",
      "source_file": "docs/site/usage.html",
      "chunk_type": "unknown"
    },
    {
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"refresh\" content=\"0;url=http://gunicorn.org/\">\n    <title>Green Unicorn - FAQ</title>\n  </head>\n  <body>\n    <h2>\n      Redirecting to <a href=\"http://gunicorn.org/\">here</a>\n    </h2>\n  </body>\n</html>\n",
      "source_file": "docs/site/faq.html",
      "chunk_type": "unknown"
    },
    {
      "content": "html,body {\n    margin: 0;\n    padding: 0;\n}\n\nh1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,cite,\ncode,del,dfn,em,img,q,s,samp,small,strike,strong,sub,sup,tt,var,\ndd,dl,dt,li,ol,ul,fieldset,form,label,legend,button,table,caption,\ntbody,tfoot,thead,tr,th,td {\n    margin: 0;\n    padding: 0;\n    border: 0;\n    font: inherit;\n    vertical-align: baseline;\n}\n\nol,ul {\n    list-style: none;\n}\n\nhtml {\n    overflow-y: scroll;\n    font-size: 100%;\n    -webkit-text-size-adjust: 100%;\n    -ms-text-size-adjust: 100%;\n}\n\na:hover, a:active, a:focus {\n    outline: 0;\n}\n\nimg {\n    border: 0;\n    -ms-interpolation-mode: bicubic;\n}\n\nbody {\n    background: #F8F8F3;\n    margin: 0;\n    font: 14px/1.4 \"Helvetica Neue\", \"HelveticaNeue\", Helvetica, Arial, \"Lucida Grande\", sans-serif;\n    color: #67686B;\n    height: auto;\n}\n\na,\na:hover {\n    text-decoration: none;\n}\n\n.clearall {\n    clear: both;\n    display: block;\n    overflow: hidden;\n    visibility: hidden;\n    width: 0;\n    height: 0;\n}\n\n.logo-wrapper {\n    border-bottom: 1px solid #2A8729;\n}\n\n.latest {\n    width: 150px;\n    top: 0;\n    display: block;\n    float: right;\n    font-weight: bold;\n}\n\n\n.logo-div {\n    width: 1000px;\n    margin: 0 auto;\n    padding: 5px;\n    height: 72px;\n}\n\n.logo {\n    width: 250px;\n    margin: 0 auto;\n    height: 119px;\n    background: url(../images/logo-bottom.png) no-repeat bottom center;\n    position: relative;\n    z-index: 99999;\n}\n\n.banner-wrapper {\n    background: url(../images/banner-bg.jpg) repeat;\n    display: block;\n    width: 100%;\n    min-height: 365px;\n    margin-top: 1px;\n    margin-bottom: 1px;\n}\n\n.banner {\n    width: 1000px;\n    margin: 0 auto;\n    padding: 15px;\n}\n\n.title {\n    width: 250px;\n    margin: 0 auto;\n    margin-top: 32px;\n    text-align:center;\n}\n\n.banner h1 {\n    font-size: 20px;\n    color: #FFF;\n    margin: 15px 10px 0;\n    padding: 5px 40px;\n    text-align: center;\n    line-height: 28px;\n}\n\n.greenbutton {\n    background: url(../images/greenbutton.jpg) repeat-x;\n    height: 54px;\n    width: 224px;\n    line-height: 54px;\n    display: inline-block;\n    text-align: center;\n    border-radius: 3px;\n    border: solid 1px #1D692D;\n    color: #fff;\n    font-size: 22px;\n    letter-spacing: 1px;\n    text-shadow: 1px 1px 1px #000;\n}\n\n.greenbutton:hover {\n    background: url(../images/greenbutton.jpg) repeat-x bottom;\n}\n\n.redbutton {\n    background: url(../images/redbutton.jpg) repeat-x;\n    height: 54px;\n    width: 224px;\n    line-height: 54px;\n    display: inline-block;\n    text-align: center;\n    border-radius: 3px;\n    border: solid 1px #7D180A;\n    color: #fff;\n    font-size: 22px;\n    letter-spacing: 1px;\n    text-shadow: 1px 1px 1px #000;\n}\n\n.redbutton:hover {\n    background: url(../images/redbutton.jpg) repeat-x bottom;\n}\n\n.banner-button {\n    width: 460px;\n    margin: 0 auto;\n    margin-top: 30px;\n}\n\n.banner-link {\n    width: 250px;\n    margin: 0 auto;\n    margin-top: 15px;\n    padding: 5px;\n    text-align: center;\n}\n\n.banner-link a {\n    color: #fff;\n    font-weight: 700;\n    letter-spacing: 1px;\n}\n\n.banner-link a:hover {\n    color: #000;\n}\n\n.mid-wrapper {\n    width: 100%;\n    border-top: 1px solid #2A8729;\n    padding-top: 15px;\n}\n\n.tabs {\n    width: 1000px;\n    margin: 0 auto;\n    padding: 3px;\n    margin-top: 5px;\n    margin-bottom: 25px;\n}\n\n.tab-bar li {\n    width: 230px;\n    padding: 3px;\n    text-align: center;\n    float: left;\n    margin-right: 5px;\n    margin-left: 6px;\n}\n\n.tab-bar li a {\n    display: inline-block;\n}\n\n.tab-bar li a:hover > p,\n.tab-bar li a:hover > h2 {\n    color: #1D692D;\n}\n\n.tab-bar li a p,\n.tab-bar li a h2 {\n    color: #404028;\n    margin-top: 8px;\n    line-height: 1.2;\n}\n\n.tab-bar li a h2 {\n    font-weight: 700;\n    text-transform: uppercase;\n}\n\n.withborder {\n    background: url(../images/separator.jpg) no-repeat;\n}\n\n.gabout, .gcommunity, .gdownloads, .gdocuments {\n    height: 80px;\n    width: 230px;\n    padding-top: 118px;\n}\n\n.gabout {\n    background: url(../images/about.jpg) no-repeat 50% 0;\n}\n\n.gcommunity {\n    background: url(../images/community.jpg) no-repeat 50% 0;\n}\n\n.gdocuments {\n    background: url(../images/documents.jpg) no-repeat 50% 0;\n}\n\n.gdownloads {\n    background: url(../images/downloads.jpg) no-repeat 50% 0;\n}\n\n.tabs li.active a,\n.gabout:hover,\n.gcommunity:hover,\n.gdocuments:hover,\n.gdownloads:hover {\n    background-position: 50% -220px;\n}\n\n.tabs div {\n    display:none;\n}\n\n.tabs div.active {\n    display: block;\n}\n\n.tab-box {\n    color: #3F3F27;\n    border: 1px solid #DDDDD5;\n    padding: 25px 35px;\n    position: relative;\n    margin-top: 20px;\n    border-radius: 3px;\n}\n\n.tab-box h1 {\n    font-size: 28px;\n    color: #2A8729;\n}\n\n.tab-box p {\n    margin: 0 0 9px;\n}\n\n.tab-box ul {\n    padding-left: 40px;\n}\n\n.tab-box li {\n    list-style: disc;\n    margin: 0 0 9px;\n}\n\n.tab-box a,\n.latest a {\n    color: #3F3F27;\n    text-decoration: underline;\n}\n\n.tab-box a:hover,\n.latest a:hover {\n    color: #1D692D;\n}\n\n.arrow {\n    background: url(../images/arrow.png) no-repeat;\n    position: absolute;\n    left: 115px;\n    top: -7px;\n    height: 10px;\n    width: 20px;\n}\n\npre {\n    font-family: Menlo, Monaco, Consolas, \"Courier New\", monospace;\n    font-size: 14px;\n    color: #333333;\n    display: block;\n    padding: 8.5px;\n    margin: 0 0 9px;\n    font-size: 14px;\n    line-height: 18px;\n    word-break: break-all;\n    word-wrap: break-word;\n    white-space: pre;\n    white-space: pre-wrap;\n    background-color: #EEFFCC;\n    border-top: 1px solid #A9CC99;\n    border-bottom: 1px solid #A9CC99;\n}\n\n.user-wrapper {\n    background: url(../images/banner-bg.jpg) repeat;\n    height: 110px;\n}\n\n.users {\n    width: 1000px;\n    padding: 20px 5px;\n    margin: 0 auto;\n    color: #fff;\n}\n\n.users h3 {\n    font-size: 12px;\n    margin-left: 5px;\n    padding-top: 15px;\n}\n\n.users h2 {\n    font-size: 26px;\n    margin-left: 5px;\n}\n\n.users .left-details {\n    width: 120px;\n    float: left;\n    height: 66px;\n    background: url(../images/footer-arrow.png) no-repeat top right;\n    padding-right: 15px;\n    text-align: right;\n}\n\n.users .company-logos {\n    float: left;\n    width: 820px;\n    height: 70px;\n    margin-left: 20px;\n}\n\n.users .company-logos a img {\n    float: left;\n    border: solid 1px #004000;\n    margin: 0 6px;\n}\n\n.users .company-logos a:hover img {\n    border: solid 1px #000;\n}\n\n.footer {\n    background-color: #F8F8F3;\n    display: block;\n    height: 70px;\n}\n\n.footer .footer-wp {\n    margin: 0 auto;\n    padding: 15px 5px;\n    width: 930px;\n    background: url(../images/footer-logo.jpg) no-repeat 0 50%;\n    padding-left: 70px;\n}\n\n.footer-wp a {\n    color: #3F3F27;\n    text-decoration: underline;\n}\n\n.footer-wp a:hover {\n    color: #1D692D;\n}\n",
      "source_file": "docs/site/css/style.css",
      "chunk_type": "unknown"
    },
    {
      "content": "$(document).ready(function() {\n  Tabs.init();\n});\n\nvar Tabs = {\n    init: function(){\n        var activateTab = function ($tab) {\n            var // this links tabs set\n                $tabs = $tab.parents('.tabs'),\n                // currently active tab\n                activeTab = {\n                    'tab' : $tabs.find('ul').children('li.active'),\n                    'content' : $tabs.find('div[data-tab].active')\n                },\n                // newly clicked tab\n                newTab = {\n                    'tab' : $tab.parent('li'),\n                    'content' : $tabs.find('[data-tab=' + $tab.attr('href').replace('#', '') + ']')\n                },\n                x, y;\n\n            // remove active class from tab and content\n            for (x in activeTab) {\n                activeTab[x].removeClass('active');\n            }\n\n            // add active class to tab and content\n            for (y in newTab) {\n                newTab[y].addClass('active');\n            }\n        };\n        // hook up tab links\n        $(document).on('click', '.tabs ul li a', function(e) {\n            activateTab($(this));\n            //alert($(this));\n        });\n\n        // hook up initial load active tab\n        if (window.location.hash) {\n            var $activeTab = $('a[href=\"'  +  window.location.hash  +  '\"]');\n            if ($activeTab.length && $activeTab.parents('.tabs').length) {\n                activateTab($activeTab);\n            }\n        }\n    }\n};",
      "source_file": "docs/site/js/main.js",
      "chunk_type": "code"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\nimport os\n\nfrom gunicorn.errors import ConfigError\nfrom gunicorn.app.base import Application\nfrom gunicorn import util\n\n",
      "start_line": 0,
      "end_line": 11,
      "source_file": "gunicorn/app/wsgiapp.py",
      "chunk_type": "code"
    },
    {
      "content": "class WSGIApplication(Application):",
      "start_line": 11,
      "end_line": 12,
      "source_file": "gunicorn/app/wsgiapp.py",
      "chunk_type": "code"
    },
    {
      "content": "    def init(self, parser, opts, args):\n        self.app_uri = None\n\n        if opts.paste:\n            from .pasterapp import has_logging_config\n\n            config_uri = os.path.abspath(opts.paste)\n            config_file = config_uri.split('#')[0]\n\n            if not os.path.exists(config_file):\n                raise ConfigError(\"%r not found\" % config_file)\n\n            self.cfg.set(\"default_proc_name\", config_file)\n            self.app_uri = config_uri\n\n            if has_logging_config(config_file):\n                self.cfg.set(\"logconfig\", config_file)\n\n            return\n\n        if len(args) > 0:\n            self.cfg.set(\"default_proc_name\", args[0])\n            self.app_uri = args[0]\n",
      "start_line": 12,
      "end_line": 36,
      "source_file": "gunicorn/app/wsgiapp.py",
      "chunk_type": "code"
    },
    {
      "content": "    def load_config(self):\n        super().load_config()\n\n        if self.app_uri is None:\n            if self.cfg.wsgi_app is not None:\n                self.app_uri = self.cfg.wsgi_app\n            else:\n                raise ConfigError(\"No application module specified.\")\n",
      "start_line": 36,
      "end_line": 45,
      "source_file": "gunicorn/app/wsgiapp.py",
      "chunk_type": "code"
    },
    {
      "content": "    def load_wsgiapp(self):\n        return util.import_app(self.app_uri)\n",
      "start_line": 45,
      "end_line": 48,
      "source_file": "gunicorn/app/wsgiapp.py",
      "chunk_type": "code"
    },
    {
      "content": "    def load_pasteapp(self):\n        from .pasterapp import get_wsgi_app\n        return get_wsgi_app(self.app_uri, defaults=self.cfg.paste_global_conf)\n",
      "start_line": 48,
      "end_line": 52,
      "source_file": "gunicorn/app/wsgiapp.py",
      "chunk_type": "code"
    },
    {
      "content": "    def load(self):\n        if self.cfg.paste is not None:\n            return self.load_pasteapp()\n        else:\n            return self.load_wsgiapp()\n\n",
      "start_line": 52,
      "end_line": 59,
      "source_file": "gunicorn/app/wsgiapp.py",
      "chunk_type": "code"
    },
    {
      "content": "def run(prog=None):\n    \"\"\"\\\n    The ``gunicorn`` command line runner for launching Gunicorn with\n    generic WSGI applications.\n    \"\"\"\n    from gunicorn.app.wsgiapp import WSGIApplication\n    WSGIApplication(\"%(prog)s [OPTIONS] [APP_MODULE]\", prog=prog).run()\n\n\nif __name__ == '__main__':\n    run()",
      "start_line": 59,
      "end_line": 70,
      "source_file": "gunicorn/app/wsgiapp.py",
      "chunk_type": "code"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.",
      "start_line": 0,
      "end_line": 3,
      "source_file": "gunicorn/app/__init__.py",
      "chunk_type": "code"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\nimport configparser\nimport os\n\nfrom paste.deploy import loadapp\n\nfrom gunicorn.app.wsgiapp import WSGIApplication\nfrom gunicorn.config import get_default_config_file\n\n",
      "start_line": 0,
      "end_line": 13,
      "source_file": "gunicorn/app/pasterapp.py",
      "chunk_type": "code"
    },
    {
      "content": "def get_wsgi_app(config_uri, name=None, defaults=None):\n    if ':' not in config_uri:\n        config_uri = \"config:%s\" % config_uri\n\n    return loadapp(\n        config_uri,\n        name=name,\n        relative_to=os.getcwd(),\n        global_conf=defaults,\n    )\n\n",
      "start_line": 13,
      "end_line": 25,
      "source_file": "gunicorn/app/pasterapp.py",
      "chunk_type": "code"
    },
    {
      "content": "def has_logging_config(config_file):\n    parser = configparser.ConfigParser()\n    parser.read([config_file])\n    return parser.has_section('loggers')\n\n",
      "start_line": 25,
      "end_line": 31,
      "source_file": "gunicorn/app/pasterapp.py",
      "chunk_type": "code"
    },
    {
      "content": "def serve(app, global_conf, **local_conf):\n    \"\"\"\\\n    A Paste Deployment server runner.\n\n    Example configuration:\n\n        [server:main]\n        use = egg:gunicorn#main\n        host = 127.0.0.1\n        port = 5000\n    \"\"\"\n    config_file = global_conf['__file__']\n    gunicorn_config_file = local_conf.pop('config', None)\n\n    host = local_conf.pop('host', '')\n    port = local_conf.pop('port', '')\n    if host and port:\n        local_conf['bind'] = '%s:%s' % (host, port)\n    elif host:\n        local_conf['bind'] = host.split(',')\n",
      "start_line": 31,
      "end_line": 52,
      "source_file": "gunicorn/app/pasterapp.py",
      "chunk_type": "code"
    },
    {
      "content": "    class PasterServerApplication(WSGIApplication):",
      "start_line": 52,
      "end_line": 53,
      "source_file": "gunicorn/app/pasterapp.py",
      "chunk_type": "code"
    },
    {
      "content": "        def load_config(self):\n            self.cfg.set(\"default_proc_name\", config_file)\n\n            if has_logging_config(config_file):\n                self.cfg.set(\"logconfig\", config_file)\n\n            if gunicorn_config_file:\n                self.load_config_from_file(gunicorn_config_file)\n            else:\n                default_gunicorn_config_file = get_default_config_file()\n                if default_gunicorn_config_file is not None:\n                    self.load_config_from_file(default_gunicorn_config_file)\n\n            for k, v in local_conf.items():\n                if v is not None:\n                    self.cfg.set(k.lower(), v)\n",
      "start_line": 53,
      "end_line": 70,
      "source_file": "gunicorn/app/pasterapp.py",
      "chunk_type": "code"
    },
    {
      "content": "        def load(self):\n            return app\n\n    PasterServerApplication().run()",
      "start_line": 70,
      "end_line": 74,
      "source_file": "gunicorn/app/pasterapp.py",
      "chunk_type": "code"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\nimport importlib.util\nimport importlib.machinery\nimport os\nimport sys\nimport traceback\n\nfrom gunicorn import util\nfrom gunicorn.arbiter import Arbiter\nfrom gunicorn.config import Config, get_default_config_file\nfrom gunicorn import debug\n\n",
      "start_line": 0,
      "end_line": 15,
      "source_file": "gunicorn/app/base.py",
      "chunk_type": "code"
    },
    {
      "content": "class BaseApplication:\n    \"\"\"\n    An application interface for configuring and loading\n    the various necessities for any given web framework.\n    \"\"\"",
      "start_line": 15,
      "end_line": 20,
      "source_file": "gunicorn/app/base.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, usage=None, prog=None):\n        self.usage = usage\n        self.cfg = None\n        self.callable = None\n        self.prog = prog\n        self.logger = None\n        self.do_load_config()\n",
      "start_line": 20,
      "end_line": 28,
      "source_file": "gunicorn/app/base.py",
      "chunk_type": "code"
    },
    {
      "content": "    def do_load_config(self):\n        \"\"\"\n        Loads the configuration\n        \"\"\"\n        try:\n            self.load_default_config()\n            self.load_config()\n        except Exception as e:\n            print(\"\\nError: %s\" % str(e), file=sys.stderr)\n            sys.stderr.flush()\n            sys.exit(1)\n",
      "start_line": 28,
      "end_line": 40,
      "source_file": "gunicorn/app/base.py",
      "chunk_type": "code"
    },
    {
      "content": "    def load_default_config(self):\n        # init configuration\n        self.cfg = Config(self.usage, prog=self.prog)\n",
      "start_line": 40,
      "end_line": 44,
      "source_file": "gunicorn/app/base.py",
      "chunk_type": "code"
    },
    {
      "content": "    def init(self, parser, opts, args):\n        raise NotImplementedError\n",
      "start_line": 44,
      "end_line": 47,
      "source_file": "gunicorn/app/base.py",
      "chunk_type": "code"
    },
    {
      "content": "    def load(self):\n        raise NotImplementedError\n",
      "start_line": 47,
      "end_line": 50,
      "source_file": "gunicorn/app/base.py",
      "chunk_type": "code"
    },
    {
      "content": "    def load_config(self):\n        \"\"\"\n        This method is used to load the configuration from one or several input(s).\n        Custom Command line, configuration file.\n        You have to override this method in your class.\n        \"\"\"\n        raise NotImplementedError\n",
      "start_line": 50,
      "end_line": 58,
      "source_file": "gunicorn/app/base.py",
      "chunk_type": "code"
    },
    {
      "content": "    def reload(self):\n        self.do_load_config()\n        if self.cfg.spew:\n            debug.spew()\n",
      "start_line": 58,
      "end_line": 63,
      "source_file": "gunicorn/app/base.py",
      "chunk_type": "code"
    },
    {
      "content": "    def wsgi(self):\n        if self.callable is None:\n            self.callable = self.load()\n        return self.callable\n",
      "start_line": 63,
      "end_line": 68,
      "source_file": "gunicorn/app/base.py",
      "chunk_type": "code"
    },
    {
      "content": "    def run(self):\n        try:\n            Arbiter(self).run()\n        except RuntimeError as e:\n            print(\"\\nError: %s\\n\" % e, file=sys.stderr)\n            sys.stderr.flush()\n            sys.exit(1)\n\n",
      "start_line": 68,
      "end_line": 77,
      "source_file": "gunicorn/app/base.py",
      "chunk_type": "code"
    },
    {
      "content": "class Application(BaseApplication):\n\n    # 'init' and 'load' methods are implemented by WSGIApplication.\n    # pylint: disable=abstract-method\n",
      "start_line": 77,
      "end_line": 82,
      "source_file": "gunicorn/app/base.py",
      "chunk_type": "code"
    },
    {
      "content": "    def chdir(self):\n        # chdir to the configured path before loading,\n        # default is the current dir\n        os.chdir(self.cfg.chdir)\n\n        # add the path to sys.path\n        if self.cfg.chdir not in sys.path:\n            sys.path.insert(0, self.cfg.chdir)\n",
      "start_line": 82,
      "end_line": 91,
      "source_file": "gunicorn/app/base.py",
      "chunk_type": "code"
    },
    {
      "content": "    def get_config_from_filename(self, filename):\n\n        if not os.path.exists(filename):\n            raise RuntimeError(\"%r doesn't exist\" % filename)\n\n        ext = os.path.splitext(filename)[1]\n\n        try:\n            module_name = '__config__'\n            if ext in [\".py\", \".pyc\"]:\n                spec = importlib.util.spec_from_file_location(module_name, filename)\n            else:\n                msg = \"configuration file should have a valid Python extension.\\n\"\n                util.warn(msg)\n                loader_ = importlib.machinery.SourceFileLoader(module_name, filename)\n                spec = importlib.util.spec_from_file_location(module_name, filename, loader=loader_)\n            mod = importlib.util.module_from_spec(spec)\n            sys.modules[module_name] = mod\n            spec.loader.exec_module(mod)\n        except Exception:\n            print(\"Failed to read config file: %s\" % filename, file=sys.stderr)\n            traceback.print_exc()\n            sys.stderr.flush()\n            sys.exit(1)\n\n        return vars(mod)\n",
      "start_line": 91,
      "end_line": 118,
      "source_file": "gunicorn/app/base.py",
      "chunk_type": "code"
    },
    {
      "content": "    def get_config_from_module_name(self, module_name):\n        return vars(importlib.import_module(module_name))\n",
      "start_line": 118,
      "end_line": 121,
      "source_file": "gunicorn/app/base.py",
      "chunk_type": "code"
    },
    {
      "content": "    def load_config_from_module_name_or_filename(self, location):\n        \"\"\"\n        Loads the configuration file: the file is a python file, otherwise raise an RuntimeError\n        Exception or stop the process if the configuration file contains a syntax error.\n        \"\"\"\n\n        if location.startswith(\"python:\"):\n            module_name = location[len(\"python:\"):]\n            cfg = self.get_config_from_module_name(module_name)\n        else:\n            if location.startswith(\"file:\"):\n                filename = location[len(\"file:\"):]\n            else:\n                filename = location\n            cfg = self.get_config_from_filename(filename)\n\n        for k, v in cfg.items():\n            # Ignore unknown names\n            if k not in self.cfg.settings:\n                continue\n            try:\n                self.cfg.set(k.lower(), v)\n            except Exception:\n                print(\"Invalid value for %s: %s\\n\" % (k, v), file=sys.stderr)\n                sys.stderr.flush()\n                raise\n\n        return cfg\n",
      "start_line": 121,
      "end_line": 150,
      "source_file": "gunicorn/app/base.py",
      "chunk_type": "code"
    },
    {
      "content": "    def load_config_from_file(self, filename):\n        return self.load_config_from_module_name_or_filename(location=filename)\n",
      "start_line": 150,
      "end_line": 153,
      "source_file": "gunicorn/app/base.py",
      "chunk_type": "code"
    },
    {
      "content": "    def load_config(self):\n        # parse console args\n        parser = self.cfg.parser()\n        args = parser.parse_args()\n\n        # optional settings from apps\n        cfg = self.init(parser, args, args.args)\n\n        # set up import paths and follow symlinks\n        self.chdir()\n\n        # Load up the any app specific configuration\n        if cfg:\n            for k, v in cfg.items():\n                self.cfg.set(k.lower(), v)\n\n        env_args = parser.parse_args(self.cfg.get_cmd_args_from_env())\n\n        if args.config:\n            self.load_config_from_file(args.config)\n        elif env_args.config:\n            self.load_config_from_file(env_args.config)\n        else:\n            default_config = get_default_config_file()\n            if default_config is not None:\n                self.load_config_from_file(default_config)\n\n        # Load up environment configuration\n        for k, v in vars(env_args).items():\n            if v is None:\n                continue\n            if k == \"args\":\n                continue\n            self.cfg.set(k.lower(), v)\n\n        # Lastly, update the configuration with any command line settings.\n        for k, v in vars(args).items():\n            if v is None:\n                continue\n            if k == \"args\":\n                continue\n            self.cfg.set(k.lower(), v)\n\n        # current directory might be changed by the config now\n        # set up import paths and follow symlinks\n        self.chdir()\n",
      "start_line": 153,
      "end_line": 200,
      "source_file": "gunicorn/app/base.py",
      "chunk_type": "code"
    },
    {
      "content": "    def run(self):\n        if self.cfg.print_config:\n            print(self.cfg)\n\n        if self.cfg.print_config or self.cfg.check_config:\n            try:\n                self.load()\n            except Exception:\n                msg = \"\\nError while loading the application:\\n\"\n                print(msg, file=sys.stderr)\n                traceback.print_exc()\n                sys.stderr.flush()\n                sys.exit(1)\n            sys.exit(0)\n\n        if self.cfg.spew:\n            debug.spew()\n\n        if self.cfg.daemon:\n            if os.environ.get('NOTIFY_SOCKET'):\n                msg = \"Warning: you shouldn't specify `daemon = True`\" \\\n                      \" when launching by systemd with `Type = notify`\"\n                print(msg, file=sys.stderr, flush=True)\n\n            util.daemonize(self.cfg.enable_stdio_inheritance)\n\n        # set python paths\n        if self.cfg.pythonpath:\n            paths = self.cfg.pythonpath.split(\",\")\n            for path in paths:\n                pythonpath = os.path.abspath(path)\n                if pythonpath not in sys.path:\n                    sys.path.insert(0, pythonpath)\n\n        super().run()",
      "start_line": 200,
      "end_line": 235,
      "source_file": "gunicorn/app/base.py",
      "chunk_type": "code"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\n\"Bare-bones implementation of statsD's protocol, client-side\"\n\nimport logging\nimport socket\nfrom re import sub\n\nfrom gunicorn.glogging import Logger\n\n# Instrumentation constants\nMETRIC_VAR = \"metric\"\nVALUE_VAR = \"value\"\nMTYPE_VAR = \"mtype\"\nGAUGE_TYPE = \"gauge\"\nCOUNTER_TYPE = \"counter\"\nHISTOGRAM_TYPE = \"histogram\"\n\n",
      "start_line": 0,
      "end_line": 21,
      "source_file": "gunicorn/instrument/statsd.py",
      "chunk_type": "code"
    },
    {
      "content": "class Statsd(Logger):\n    \"\"\"statsD-based instrumentation, that passes as a logger\n    \"\"\"",
      "start_line": 21,
      "end_line": 24,
      "source_file": "gunicorn/instrument/statsd.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, cfg):\n        Logger.__init__(self, cfg)\n        self.prefix = sub(r\"^(.+[^.]+)\\.*$\", \"\\\\g<1>.\", cfg.statsd_prefix)\n\n        if isinstance(cfg.statsd_host, str):\n            address_family = socket.AF_UNIX\n        else:\n            address_family = socket.AF_INET\n\n        try:\n            self.sock = socket.socket(address_family, socket.SOCK_DGRAM)\n            self.sock.connect(cfg.statsd_host)\n        except Exception:\n            self.sock = None\n\n        self.dogstatsd_tags = cfg.dogstatsd_tags\n\n    # Log errors and warnings",
      "start_line": 24,
      "end_line": 42,
      "source_file": "gunicorn/instrument/statsd.py",
      "chunk_type": "code"
    },
    {
      "content": "    def critical(self, msg, *args, **kwargs):\n        Logger.critical(self, msg, *args, **kwargs)\n        self.increment(\"gunicorn.log.critical\", 1)\n",
      "start_line": 42,
      "end_line": 46,
      "source_file": "gunicorn/instrument/statsd.py",
      "chunk_type": "code"
    },
    {
      "content": "    def error(self, msg, *args, **kwargs):\n        Logger.error(self, msg, *args, **kwargs)\n        self.increment(\"gunicorn.log.error\", 1)\n",
      "start_line": 46,
      "end_line": 50,
      "source_file": "gunicorn/instrument/statsd.py",
      "chunk_type": "code"
    },
    {
      "content": "    def warning(self, msg, *args, **kwargs):\n        Logger.warning(self, msg, *args, **kwargs)\n        self.increment(\"gunicorn.log.warning\", 1)\n",
      "start_line": 50,
      "end_line": 54,
      "source_file": "gunicorn/instrument/statsd.py",
      "chunk_type": "code"
    },
    {
      "content": "    def exception(self, msg, *args, **kwargs):\n        Logger.exception(self, msg, *args, **kwargs)\n        self.increment(\"gunicorn.log.exception\", 1)\n\n    # Special treatment for info, the most common log level",
      "start_line": 54,
      "end_line": 59,
      "source_file": "gunicorn/instrument/statsd.py",
      "chunk_type": "code"
    },
    {
      "content": "    def info(self, msg, *args, **kwargs):\n        self.log(logging.INFO, msg, *args, **kwargs)\n\n    # skip the run-of-the-mill logs",
      "start_line": 59,
      "end_line": 63,
      "source_file": "gunicorn/instrument/statsd.py",
      "chunk_type": "code"
    },
    {
      "content": "    def debug(self, msg, *args, **kwargs):\n        self.log(logging.DEBUG, msg, *args, **kwargs)\n",
      "start_line": 63,
      "end_line": 66,
      "source_file": "gunicorn/instrument/statsd.py",
      "chunk_type": "code"
    },
    {
      "content": "    def log(self, lvl, msg, *args, **kwargs):\n        \"\"\"Log a given statistic if metric, value and type are present\n        \"\"\"\n        try:\n            extra = kwargs.get(\"extra\", None)\n            if extra is not None:\n                metric = extra.get(METRIC_VAR, None)\n                value = extra.get(VALUE_VAR, None)\n                typ = extra.get(MTYPE_VAR, None)\n                if metric and value and typ:\n                    if typ == GAUGE_TYPE:\n                        self.gauge(metric, value)\n                    elif typ == COUNTER_TYPE:\n                        self.increment(metric, value)\n                    elif typ == HISTOGRAM_TYPE:\n                        self.histogram(metric, value)\n                    else:\n                        pass\n\n            # Log to parent logger only if there is something to say\n            if msg:\n                Logger.log(self, lvl, msg, *args, **kwargs)\n        except Exception:\n            Logger.warning(self, \"Failed to log to statsd\", exc_info=True)\n\n    # access logging",
      "start_line": 66,
      "end_line": 92,
      "source_file": "gunicorn/instrument/statsd.py",
      "chunk_type": "code"
    },
    {
      "content": "    def access(self, resp, req, environ, request_time):\n        \"\"\"Measure request duration\n        request_time is a datetime.timedelta\n        \"\"\"\n        Logger.access(self, resp, req, environ, request_time)\n        duration_in_ms = request_time.seconds * 1000 + float(request_time.microseconds) / 10 ** 3\n        status = resp.status\n        if isinstance(status, bytes):\n            status = status.decode('utf-8')\n        if isinstance(status, str):\n            status = int(status.split(None, 1)[0])\n        self.histogram(\"gunicorn.request.duration\", duration_in_ms)\n        self.increment(\"gunicorn.requests\", 1)\n        self.increment(\"gunicorn.request.status.%d\" % status, 1)\n\n    # statsD methods\n    # you can use those directly if you want",
      "start_line": 92,
      "end_line": 109,
      "source_file": "gunicorn/instrument/statsd.py",
      "chunk_type": "code"
    },
    {
      "content": "    def gauge(self, name, value):\n        self._sock_send(\"{0}{1}:{2}|g\".format(self.prefix, name, value))\n",
      "start_line": 109,
      "end_line": 112,
      "source_file": "gunicorn/instrument/statsd.py",
      "chunk_type": "code"
    },
    {
      "content": "    def increment(self, name, value, sampling_rate=1.0):\n        self._sock_send(\"{0}{1}:{2}|c|@{3}\".format(self.prefix, name, value, sampling_rate))\n",
      "start_line": 112,
      "end_line": 115,
      "source_file": "gunicorn/instrument/statsd.py",
      "chunk_type": "code"
    },
    {
      "content": "    def decrement(self, name, value, sampling_rate=1.0):\n        self._sock_send(\"{0}{1}:-{2}|c|@{3}\".format(self.prefix, name, value, sampling_rate))\n",
      "start_line": 115,
      "end_line": 118,
      "source_file": "gunicorn/instrument/statsd.py",
      "chunk_type": "code"
    },
    {
      "content": "    def histogram(self, name, value):\n        self._sock_send(\"{0}{1}:{2}|ms\".format(self.prefix, name, value))\n",
      "start_line": 118,
      "end_line": 121,
      "source_file": "gunicorn/instrument/statsd.py",
      "chunk_type": "code"
    },
    {
      "content": "    def _sock_send(self, msg):\n        try:\n            if isinstance(msg, str):\n                msg = msg.encode(\"ascii\")\n\n            # http://docs.datadoghq.com/guides/dogstatsd/#datagram-format\n            if self.dogstatsd_tags:\n                msg = msg + b\"|#\" + self.dogstatsd_tags.encode('ascii')\n\n            if self.sock:\n                self.sock.send(msg)\n        except Exception:\n            Logger.warning(self, \"Error sending message to statsd\", exc_info=True)",
      "start_line": 121,
      "end_line": 134,
      "source_file": "gunicorn/instrument/statsd.py",
      "chunk_type": "code"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\nimport io\nimport sys\n\nfrom gunicorn.http.errors import (NoMoreData, ChunkMissingTerminator,\n                                  InvalidChunkSize)\n\n",
      "start_line": 0,
      "end_line": 11,
      "source_file": "gunicorn/http/body.py",
      "chunk_type": "code"
    },
    {
      "content": "class ChunkedReader:",
      "start_line": 11,
      "end_line": 12,
      "source_file": "gunicorn/http/body.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, req, unreader):\n        self.req = req\n        self.parser = self.parse_chunked(unreader)\n        self.buf = io.BytesIO()\n",
      "start_line": 12,
      "end_line": 17,
      "source_file": "gunicorn/http/body.py",
      "chunk_type": "code"
    },
    {
      "content": "    def read(self, size):\n        if not isinstance(size, int):\n            raise TypeError(\"size must be an integer type\")\n        if size < 0:\n            raise ValueError(\"Size must be positive.\")\n        if size == 0:\n            return b\"\"\n\n        if self.parser:\n            while self.buf.tell() < size:\n                try:\n                    self.buf.write(next(self.parser))\n                except StopIteration:\n                    self.parser = None\n                    break\n\n        data = self.buf.getvalue()\n        ret, rest = data[:size], data[size:]\n        self.buf = io.BytesIO()\n        self.buf.write(rest)\n        return ret\n",
      "start_line": 17,
      "end_line": 39,
      "source_file": "gunicorn/http/body.py",
      "chunk_type": "code"
    },
    {
      "content": "    def parse_trailers(self, unreader, data):\n        buf = io.BytesIO()\n        buf.write(data)\n\n        idx = buf.getvalue().find(b\"\\r\\n\\r\\n\")\n        done = buf.getvalue()[:2] == b\"\\r\\n\"\n        while idx < 0 and not done:\n            self.get_data(unreader, buf)\n            idx = buf.getvalue().find(b\"\\r\\n\\r\\n\")\n            done = buf.getvalue()[:2] == b\"\\r\\n\"\n        if done:\n            unreader.unread(buf.getvalue()[2:])\n            return b\"\"\n        self.req.trailers = self.req.parse_headers(buf.getvalue()[:idx], from_trailer=True)\n        unreader.unread(buf.getvalue()[idx + 4:])\n",
      "start_line": 39,
      "end_line": 55,
      "source_file": "gunicorn/http/body.py",
      "chunk_type": "code"
    },
    {
      "content": "    def parse_chunked(self, unreader):\n        (size, rest) = self.parse_chunk_size(unreader)\n        while size > 0:\n            while size > len(rest):\n                size -= len(rest)\n                yield rest\n                rest = unreader.read()\n                if not rest:\n                    raise NoMoreData()\n            yield rest[:size]\n            # Remove \\r\\n after chunk\n            rest = rest[size:]\n            while len(rest) < 2:\n                new_data = unreader.read()\n                if not new_data:\n                    break\n                rest += new_data\n            if rest[:2] != b'\\r\\n':\n                raise ChunkMissingTerminator(rest[:2])\n            (size, rest) = self.parse_chunk_size(unreader, data=rest[2:])\n",
      "start_line": 55,
      "end_line": 76,
      "source_file": "gunicorn/http/body.py",
      "chunk_type": "code"
    },
    {
      "content": "    def parse_chunk_size(self, unreader, data=None):\n        buf = io.BytesIO()\n        if data is not None:\n            buf.write(data)\n\n        idx = buf.getvalue().find(b\"\\r\\n\")\n        while idx < 0:\n            self.get_data(unreader, buf)\n            idx = buf.getvalue().find(b\"\\r\\n\")\n\n        data = buf.getvalue()\n        line, rest_chunk = data[:idx], data[idx + 2:]\n\n        # RFC9112 7.1.1: BWS before chunk-ext - but ONLY then\n        chunk_size, *chunk_ext = line.split(b\";\", 1)\n        if chunk_ext:\n            chunk_size = chunk_size.rstrip(b\" \\t\")\n        if any(n not in b\"0123456789abcdefABCDEF\" for n in chunk_size):\n            raise InvalidChunkSize(chunk_size)\n        if len(chunk_size) == 0:\n            raise InvalidChunkSize(chunk_size)\n        chunk_size = int(chunk_size, 16)\n\n        if chunk_size == 0:\n            try:\n                self.parse_trailers(unreader, rest_chunk)\n            except NoMoreData:\n                pass\n            return (0, None)\n        return (chunk_size, rest_chunk)\n",
      "start_line": 76,
      "end_line": 107,
      "source_file": "gunicorn/http/body.py",
      "chunk_type": "code"
    },
    {
      "content": "    def get_data(self, unreader, buf):\n        data = unreader.read()\n        if not data:\n            raise NoMoreData()\n        buf.write(data)\n\n",
      "start_line": 107,
      "end_line": 114,
      "source_file": "gunicorn/http/body.py",
      "chunk_type": "code"
    },
    {
      "content": "class LengthReader:",
      "start_line": 114,
      "end_line": 115,
      "source_file": "gunicorn/http/body.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, unreader, length):\n        self.unreader = unreader\n        self.length = length\n",
      "start_line": 115,
      "end_line": 119,
      "source_file": "gunicorn/http/body.py",
      "chunk_type": "code"
    },
    {
      "content": "    def read(self, size):\n        if not isinstance(size, int):\n            raise TypeError(\"size must be an integral type\")\n\n        size = min(self.length, size)\n        if size < 0:\n            raise ValueError(\"Size must be positive.\")\n        if size == 0:\n            return b\"\"\n\n        buf = io.BytesIO()\n        data = self.unreader.read()\n        while data:\n            buf.write(data)\n            if buf.tell() >= size:\n                break\n            data = self.unreader.read()\n\n        buf = buf.getvalue()\n        ret, rest = buf[:size], buf[size:]\n        self.unreader.unread(rest)\n        self.length -= size\n        return ret\n\n",
      "start_line": 119,
      "end_line": 144,
      "source_file": "gunicorn/http/body.py",
      "chunk_type": "code"
    },
    {
      "content": "class EOFReader:",
      "start_line": 144,
      "end_line": 145,
      "source_file": "gunicorn/http/body.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, unreader):\n        self.unreader = unreader\n        self.buf = io.BytesIO()\n        self.finished = False\n",
      "start_line": 145,
      "end_line": 150,
      "source_file": "gunicorn/http/body.py",
      "chunk_type": "code"
    },
    {
      "content": "    def read(self, size):\n        if not isinstance(size, int):\n            raise TypeError(\"size must be an integral type\")\n        if size < 0:\n            raise ValueError(\"Size must be positive.\")\n        if size == 0:\n            return b\"\"\n\n        if self.finished:\n            data = self.buf.getvalue()\n            ret, rest = data[:size], data[size:]\n            self.buf = io.BytesIO()\n            self.buf.write(rest)\n            return ret\n\n        data = self.unreader.read()\n        while data:\n            self.buf.write(data)\n            if self.buf.tell() > size:\n                break\n            data = self.unreader.read()\n\n        if not data:\n            self.finished = True\n\n        data = self.buf.getvalue()\n        ret, rest = data[:size], data[size:]\n        self.buf = io.BytesIO()\n        self.buf.write(rest)\n        return ret\n\n",
      "start_line": 150,
      "end_line": 182,
      "source_file": "gunicorn/http/body.py",
      "chunk_type": "code"
    },
    {
      "content": "class Body:",
      "start_line": 182,
      "end_line": 183,
      "source_file": "gunicorn/http/body.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, reader):\n        self.reader = reader\n        self.buf = io.BytesIO()\n",
      "start_line": 183,
      "end_line": 187,
      "source_file": "gunicorn/http/body.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __iter__(self):\n        return self\n",
      "start_line": 187,
      "end_line": 190,
      "source_file": "gunicorn/http/body.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __next__(self):\n        ret = self.readline()\n        if not ret:\n            raise StopIteration()\n        return ret\n\n    next = __next__\n",
      "start_line": 190,
      "end_line": 198,
      "source_file": "gunicorn/http/body.py",
      "chunk_type": "code"
    },
    {
      "content": "    def getsize(self, size):\n        if size is None:\n            return sys.maxsize\n        elif not isinstance(size, int):\n            raise TypeError(\"size must be an integral type\")\n        elif size < 0:\n            return sys.maxsize\n        return size\n",
      "start_line": 198,
      "end_line": 207,
      "source_file": "gunicorn/http/body.py",
      "chunk_type": "code"
    },
    {
      "content": "    def read(self, size=None):\n        size = self.getsize(size)\n        if size == 0:\n            return b\"\"\n\n        if size < self.buf.tell():\n            data = self.buf.getvalue()\n            ret, rest = data[:size], data[size:]\n            self.buf = io.BytesIO()\n            self.buf.write(rest)\n            return ret\n\n        while size > self.buf.tell():\n            data = self.reader.read(1024)\n            if not data:\n                break\n            self.buf.write(data)\n\n        data = self.buf.getvalue()\n        ret, rest = data[:size], data[size:]\n        self.buf = io.BytesIO()\n        self.buf.write(rest)\n        return ret\n",
      "start_line": 207,
      "end_line": 231,
      "source_file": "gunicorn/http/body.py",
      "chunk_type": "code"
    },
    {
      "content": "    def readline(self, size=None):\n        size = self.getsize(size)\n        if size == 0:\n            return b\"\"\n\n        data = self.buf.getvalue()\n        self.buf = io.BytesIO()\n\n        ret = []\n        while 1:\n            idx = data.find(b\"\\n\", 0, size)\n            idx = idx + 1 if idx >= 0 else size if len(data) >= size else 0\n            if idx:\n                ret.append(data[:idx])\n                self.buf.write(data[idx:])\n                break\n\n            ret.append(data)\n            size -= len(data)\n            data = self.reader.read(min(1024, size))\n            if not data:\n                break\n\n        return b\"\".join(ret)\n",
      "start_line": 231,
      "end_line": 256,
      "source_file": "gunicorn/http/body.py",
      "chunk_type": "code"
    },
    {
      "content": "    def readlines(self, size=None):\n        ret = []\n        data = self.read()\n        while data:\n            pos = data.find(b\"\\n\")\n            if pos < 0:\n                ret.append(data)\n                data = b\"\"\n            else:\n                line, data = data[:pos + 1], data[pos + 1:]\n                ret.append(line)\n        return ret",
      "start_line": 256,
      "end_line": 268,
      "source_file": "gunicorn/http/body.py",
      "chunk_type": "code"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\nfrom gunicorn.http.message import Message, Request\nfrom gunicorn.http.parser import RequestParser\n\n__all__ = ['Message', 'Request', 'RequestParser']",
      "start_line": 0,
      "end_line": 8,
      "source_file": "gunicorn/http/__init__.py",
      "chunk_type": "code"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\nimport io\nimport re\nimport socket\n\nfrom gunicorn.http.body import ChunkedReader, LengthReader, EOFReader, Body\nfrom gunicorn.http.errors import (\n    InvalidHeader, InvalidHeaderName, NoMoreData,\n    InvalidRequestLine, InvalidRequestMethod, InvalidHTTPVersion,\n    LimitRequestLine, LimitRequestHeaders,\n    UnsupportedTransferCoding, ObsoleteFolding,\n)\nfrom gunicorn.http.errors import InvalidProxyLine, ForbiddenProxyRequest\nfrom gunicorn.http.errors import InvalidSchemeHeaders\nfrom gunicorn.util import bytes_to_str, split_request_uri\n\nMAX_REQUEST_LINE = 8190\nMAX_HEADERS = 32768\nDEFAULT_MAX_HEADERFIELD_SIZE = 8190\n\n# verbosely on purpose, avoid backslash ambiguity\nRFC9110_5_6_2_TOKEN_SPECIALS = r\"!#$%&'*+-.^_`|~\"\nTOKEN_RE = re.compile(r\"[%s0-9a-zA-Z]+\" % (re.escape(RFC9110_5_6_2_TOKEN_SPECIALS)))\nMETHOD_BADCHAR_RE = re.compile(\"[a-z#]\")\n# usually 1.0 or 1.1 - RFC9112 permits restricting to single-digit versions\nVERSION_RE = re.compile(r\"HTTP/(\\d)\\.(\\d)\")\nRFC9110_5_5_INVALID_AND_DANGEROUS = re.compile(r\"[\\0\\r\\n]\")\n\n",
      "start_line": 0,
      "end_line": 32,
      "source_file": "gunicorn/http/message.py",
      "chunk_type": "code"
    },
    {
      "content": "class Message:",
      "start_line": 32,
      "end_line": 33,
      "source_file": "gunicorn/http/message.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, cfg, unreader, peer_addr):\n        self.cfg = cfg\n        self.unreader = unreader\n        self.peer_addr = peer_addr\n        self.remote_addr = peer_addr\n        self.version = None\n        self.headers = []\n        self.trailers = []\n        self.body = None\n        self.scheme = \"https\" if cfg.is_ssl else \"http\"\n        self.must_close = False\n\n        # set headers limits\n        self.limit_request_fields = cfg.limit_request_fields\n        if (self.limit_request_fields <= 0\n                or self.limit_request_fields > MAX_HEADERS):\n            self.limit_request_fields = MAX_HEADERS\n        self.limit_request_field_size = cfg.limit_request_field_size\n        if self.limit_request_field_size < 0:\n            self.limit_request_field_size = DEFAULT_MAX_HEADERFIELD_SIZE\n\n        # set max header buffer size\n        max_header_field_size = self.limit_request_field_size or DEFAULT_MAX_HEADERFIELD_SIZE\n        self.max_buffer_headers = self.limit_request_fields * \\\n            (max_header_field_size + 2) + 4\n\n        unused = self.parse(self.unreader)\n        self.unreader.unread(unused)\n        self.set_body_reader()\n",
      "start_line": 33,
      "end_line": 63,
      "source_file": "gunicorn/http/message.py",
      "chunk_type": "code"
    },
    {
      "content": "    def force_close(self):\n        self.must_close = True\n",
      "start_line": 63,
      "end_line": 66,
      "source_file": "gunicorn/http/message.py",
      "chunk_type": "code"
    },
    {
      "content": "    def parse(self, unreader):\n        raise NotImplementedError()\n",
      "start_line": 66,
      "end_line": 69,
      "source_file": "gunicorn/http/message.py",
      "chunk_type": "code"
    },
    {
      "content": "    def parse_headers(self, data, from_trailer=False):\n        cfg = self.cfg\n        headers = []\n\n        # Split lines on \\r\\n\n        lines = [bytes_to_str(line) for line in data.split(b\"\\r\\n\")]\n\n        # handle scheme headers\n        scheme_header = False\n        secure_scheme_headers = {}\n        forwarder_headers = []\n        if from_trailer:\n            # nonsense. either a request is https from the beginning\n            #  .. or we are just behind a proxy who does not remove conflicting trailers\n            pass\n        elif ('*' in cfg.forwarded_allow_ips or\n              not isinstance(self.peer_addr, tuple)\n              or self.peer_addr[0] in cfg.forwarded_allow_ips):\n            secure_scheme_headers = cfg.secure_scheme_headers\n            forwarder_headers = cfg.forwarder_headers\n\n        # Parse headers into key/value pairs paying attention\n        # to continuation lines.\n        while lines:\n            if len(headers) >= self.limit_request_fields:\n                raise LimitRequestHeaders(\"limit request headers fields\")\n\n            # Parse initial header name: value pair.\n            curr = lines.pop(0)\n            header_length = len(curr) + len(\"\\r\\n\")\n            if curr.find(\":\") <= 0:\n                raise InvalidHeader(curr)\n            name, value = curr.split(\":\", 1)\n            if self.cfg.strip_header_spaces:\n                name = name.rstrip(\" \\t\")\n            if not TOKEN_RE.fullmatch(name):\n                raise InvalidHeaderName(name)\n\n            # this is still a dangerous place to do this\n            #  but it is more correct than doing it before the pattern match:\n            # after we entered Unicode wonderland, 8bits could case-shift into ASCII:\n            # b\"\\xDF\".decode(\"latin-1\").upper().encode(\"ascii\") == b\"SS\"\n            name = name.upper()\n\n            value = [value.strip(\" \\t\")]\n\n            # Consume value continuation lines..\n            while lines and lines[0].startswith((\" \", \"\\t\")):\n                # .. which is obsolete here, and no longer done by default\n                if not self.cfg.permit_obsolete_folding:\n                    raise ObsoleteFolding(name)\n                curr = lines.pop(0)\n                header_length += len(curr) + len(\"\\r\\n\")\n                if header_length > self.limit_request_field_size > 0:\n                    raise LimitRequestHeaders(\"limit request headers \"\n                                              \"fields size\")\n                value.append(curr.strip(\"\\t \"))\n            value = \" \".join(value)\n\n            if RFC9110_5_5_INVALID_AND_DANGEROUS.search(value):\n                raise InvalidHeader(name)\n\n            if header_length > self.limit_request_field_size > 0:\n                raise LimitRequestHeaders(\"limit request headers fields size\")\n\n            if name in secure_scheme_headers:\n                secure = value == secure_scheme_headers[name]\n                scheme = \"https\" if secure else \"http\"\n                if scheme_header:\n                    if scheme != self.scheme:\n                        raise InvalidSchemeHeaders()\n                else:\n                    scheme_header = True\n                    self.scheme = scheme\n\n            # ambiguous mapping allows fooling downstream, e.g. merging non-identical headers:\n            # X-Forwarded-For: 2001:db8::ha:cc:ed\n            # X_Forwarded_For: 127.0.0.1,::1\n            # HTTP_X_FORWARDED_FOR = 2001:db8::ha:cc:ed,127.0.0.1,::1\n            # Only modify after fixing *ALL* header transformations; network to wsgi env\n            if \"_\" in name:\n                if name in forwarder_headers or \"*\" in forwarder_headers:\n                    # This forwarder may override our environment\n                    pass\n                elif self.cfg.header_map == \"dangerous\":\n                    # as if we did not know we cannot safely map this\n                    pass\n                elif self.cfg.header_map == \"drop\":\n                    # almost as if it never had been there\n                    # but still counts against resource limits\n                    continue\n                else:\n                    # fail-safe fallthrough: refuse\n                    raise InvalidHeaderName(name)\n\n            headers.append((name, value))\n\n        return headers\n",
      "start_line": 69,
      "end_line": 168,
      "source_file": "gunicorn/http/message.py",
      "chunk_type": "code"
    },
    {
      "content": "    def set_body_reader(self):\n        chunked = False\n        content_length = None\n\n        for (name, value) in self.headers:\n            if name == \"CONTENT-LENGTH\":\n                if content_length is not None:\n                    raise InvalidHeader(\"CONTENT-LENGTH\", req=self)\n                content_length = value\n            elif name == \"TRANSFER-ENCODING\":\n                # T-E can be a list\n                # https://datatracker.ietf.org/doc/html/rfc9112#name-transfer-encoding\n                vals = [v.strip() for v in value.split(',')]\n                for val in vals:\n                    if val.lower() == \"chunked\":\n                        # DANGER: transfer codings stack, and stacked chunking is never intended\n                        if chunked:\n                            raise InvalidHeader(\"TRANSFER-ENCODING\", req=self)\n                        chunked = True\n                    elif val.lower() == \"identity\":\n                        # does not do much, could still plausibly desync from what the proxy does\n                        # safe option: nuke it, its never needed\n                        if chunked:\n                            raise InvalidHeader(\"TRANSFER-ENCODING\", req=self)\n                    elif val.lower() in ('compress', 'deflate', 'gzip'):\n                        # chunked should be the last one\n                        if chunked:\n                            raise InvalidHeader(\"TRANSFER-ENCODING\", req=self)\n                        self.force_close()\n                    else:\n                        raise UnsupportedTransferCoding(value)\n\n        if chunked:\n            # two potentially dangerous cases:\n            #  a) CL + TE (TE overrides CL.. only safe if the recipient sees it that way too)\n            #  b) chunked HTTP/1.0 (always faulty)\n            if self.version < (1, 1):\n                # framing wonky, see RFC 9112 Section 6.1\n                raise InvalidHeader(\"TRANSFER-ENCODING\", req=self)\n            if content_length is not None:\n                # we cannot be certain the message framing we understood matches proxy intent\n                #  -> whatever happens next, remaining input must not be trusted\n                raise InvalidHeader(\"CONTENT-LENGTH\", req=self)\n            self.body = Body(ChunkedReader(self, self.unreader))\n        elif content_length is not None:\n            try:\n                if str(content_length).isnumeric():\n                    content_length = int(content_length)\n                else:\n                    raise InvalidHeader(\"CONTENT-LENGTH\", req=self)\n            except ValueError:\n                raise InvalidHeader(\"CONTENT-LENGTH\", req=self)\n\n            if content_length < 0:\n                raise InvalidHeader(\"CONTENT-LENGTH\", req=self)\n\n            self.body = Body(LengthReader(self.unreader, content_length))\n        else:\n            self.body = Body(EOFReader(self.unreader))\n",
      "start_line": 168,
      "end_line": 228,
      "source_file": "gunicorn/http/message.py",
      "chunk_type": "code"
    },
    {
      "content": "    def should_close(self):\n        if self.must_close:\n            return True\n        for (h, v) in self.headers:\n            if h == \"CONNECTION\":\n                v = v.lower().strip(\" \\t\")\n                if v == \"close\":\n                    return True\n                elif v == \"keep-alive\":\n                    return False\n                break\n        return self.version <= (1, 0)\n\n",
      "start_line": 228,
      "end_line": 242,
      "source_file": "gunicorn/http/message.py",
      "chunk_type": "code"
    },
    {
      "content": "class Request(Message):",
      "start_line": 242,
      "end_line": 243,
      "source_file": "gunicorn/http/message.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, cfg, unreader, peer_addr, req_number=1):\n        self.method = None\n        self.uri = None\n        self.path = None\n        self.query = None\n        self.fragment = None\n\n        # get max request line size\n        self.limit_request_line = cfg.limit_request_line\n        if (self.limit_request_line < 0\n                or self.limit_request_line >= MAX_REQUEST_LINE):\n            self.limit_request_line = MAX_REQUEST_LINE\n\n        self.req_number = req_number\n        self.proxy_protocol_info = None\n        super().__init__(cfg, unreader, peer_addr)\n",
      "start_line": 243,
      "end_line": 260,
      "source_file": "gunicorn/http/message.py",
      "chunk_type": "code"
    },
    {
      "content": "    def get_data(self, unreader, buf, stop=False):\n        data = unreader.read()\n        if not data:\n            if stop:\n                raise StopIteration()\n            raise NoMoreData(buf.getvalue())\n        buf.write(data)\n",
      "start_line": 260,
      "end_line": 268,
      "source_file": "gunicorn/http/message.py",
      "chunk_type": "code"
    },
    {
      "content": "    def parse(self, unreader):\n        buf = io.BytesIO()\n        self.get_data(unreader, buf, stop=True)\n\n        # get request line\n        line, rbuf = self.read_line(unreader, buf, self.limit_request_line)\n\n        # proxy protocol\n        if self.proxy_protocol(bytes_to_str(line)):\n            # get next request line\n            buf = io.BytesIO()\n            buf.write(rbuf)\n            line, rbuf = self.read_line(unreader, buf, self.limit_request_line)\n\n        self.parse_request_line(line)\n        buf = io.BytesIO()\n        buf.write(rbuf)\n\n        # Headers\n        data = buf.getvalue()\n        idx = data.find(b\"\\r\\n\\r\\n\")\n\n        done = data[:2] == b\"\\r\\n\"\n        while True:\n            idx = data.find(b\"\\r\\n\\r\\n\")\n            done = data[:2] == b\"\\r\\n\"\n\n            if idx < 0 and not done:\n                self.get_data(unreader, buf)\n                data = buf.getvalue()\n                if len(data) > self.max_buffer_headers:\n                    raise LimitRequestHeaders(\"max buffer headers\")\n            else:\n                break\n\n        if done:\n            self.unreader.unread(data[2:])\n            return b\"\"\n\n        self.headers = self.parse_headers(data[:idx], from_trailer=False)\n\n        ret = data[idx + 4:]\n        buf = None\n        return ret\n",
      "start_line": 268,
      "end_line": 313,
      "source_file": "gunicorn/http/message.py",
      "chunk_type": "code"
    },
    {
      "content": "    def read_line(self, unreader, buf, limit=0):\n        data = buf.getvalue()\n\n        while True:\n            idx = data.find(b\"\\r\\n\")\n            if idx >= 0:\n                # check if the request line is too large\n                if idx > limit > 0:\n                    raise LimitRequestLine(idx, limit)\n                break\n            if len(data) - 2 > limit > 0:\n                raise LimitRequestLine(len(data), limit)\n            self.get_data(unreader, buf)\n            data = buf.getvalue()\n\n        return (data[:idx],  # request line,\n                data[idx + 2:])  # residue in the buffer, skip \\r\\n\n",
      "start_line": 313,
      "end_line": 331,
      "source_file": "gunicorn/http/message.py",
      "chunk_type": "code"
    },
    {
      "content": "    def proxy_protocol(self, line):\n        \"\"\"\\\n        Detect, check and parse proxy protocol.\n\n        :raises: ForbiddenProxyRequest, InvalidProxyLine.\n        :return: True for proxy protocol line else False\n        \"\"\"\n        if not self.cfg.proxy_protocol:\n            return False\n\n        if self.req_number != 1:\n            return False\n\n        if not line.startswith(\"PROXY\"):\n            return False\n\n        self.proxy_protocol_access_check()\n        self.parse_proxy_protocol(line)\n\n        return True\n",
      "start_line": 331,
      "end_line": 352,
      "source_file": "gunicorn/http/message.py",
      "chunk_type": "code"
    },
    {
      "content": "    def proxy_protocol_access_check(self):\n        # check in allow list\n        if (\"*\" not in self.cfg.proxy_allow_ips and\n            isinstance(self.peer_addr, tuple) and\n                self.peer_addr[0] not in self.cfg.proxy_allow_ips):\n            raise ForbiddenProxyRequest(self.peer_addr[0])\n",
      "start_line": 352,
      "end_line": 359,
      "source_file": "gunicorn/http/message.py",
      "chunk_type": "code"
    },
    {
      "content": "    def parse_proxy_protocol(self, line):\n        bits = line.split(\" \")\n\n        if len(bits) != 6:\n            raise InvalidProxyLine(line)\n\n        # Extract data\n        proto = bits[1]\n        s_addr = bits[2]\n        d_addr = bits[3]\n\n        # Validation\n        if proto not in [\"TCP4\", \"TCP6\"]:\n            raise InvalidProxyLine(\"protocol '%s' not supported\" % proto)\n        if proto == \"TCP4\":\n            try:\n                socket.inet_pton(socket.AF_INET, s_addr)\n                socket.inet_pton(socket.AF_INET, d_addr)\n            except OSError:\n                raise InvalidProxyLine(line)\n        elif proto == \"TCP6\":\n            try:\n                socket.inet_pton(socket.AF_INET6, s_addr)\n                socket.inet_pton(socket.AF_INET6, d_addr)\n            except OSError:\n                raise InvalidProxyLine(line)\n\n        try:\n            s_port = int(bits[4])\n            d_port = int(bits[5])\n        except ValueError:\n            raise InvalidProxyLine(\"invalid port %s\" % line)\n\n        if not ((0 <= s_port <= 65535) and (0 <= d_port <= 65535)):\n            raise InvalidProxyLine(\"invalid port %s\" % line)\n\n        # Set data\n        self.proxy_protocol_info = {\n            \"proxy_protocol\": proto,\n            \"client_addr\": s_addr,\n            \"client_port\": s_port,\n            \"proxy_addr\": d_addr,\n            \"proxy_port\": d_port\n        }\n",
      "start_line": 359,
      "end_line": 404,
      "source_file": "gunicorn/http/message.py",
      "chunk_type": "code"
    },
    {
      "content": "    def parse_request_line(self, line_bytes):\n        bits = [bytes_to_str(bit) for bit in line_bytes.split(b\" \", 2)]\n        if len(bits) != 3:\n            raise InvalidRequestLine(bytes_to_str(line_bytes))\n\n        # Method: RFC9110 Section 9\n        self.method = bits[0]\n\n        # nonstandard restriction, suitable for all IANA registered methods\n        # partially enforced in previous gunicorn versions\n        if not self.cfg.permit_unconventional_http_method:\n            if METHOD_BADCHAR_RE.search(self.method):\n                raise InvalidRequestMethod(self.method)\n            if not 3 <= len(bits[0]) <= 20:\n                raise InvalidRequestMethod(self.method)\n        # standard restriction: RFC9110 token\n        if not TOKEN_RE.fullmatch(self.method):\n            raise InvalidRequestMethod(self.method)\n        # nonstandard and dangerous\n        # methods are merely uppercase by convention, no case-insensitive treatment is intended\n        if self.cfg.casefold_http_method:\n            self.method = self.method.upper()\n\n        # URI\n        self.uri = bits[1]\n\n        # Python stdlib explicitly tells us it will not perform validation.\n        # https://docs.python.org/3/library/urllib.parse.html#url-parsing-security\n        # There are *four* `request-target` forms in rfc9112, none of them can be empty:\n        # 1. origin-form, which starts with a slash\n        # 2. absolute-form, which starts with a non-empty scheme\n        # 3. authority-form, (for CONNECT) which contains a colon after the host\n        # 4. asterisk-form, which is an asterisk (`\\x2A`)\n        # => manually reject one always invalid URI: empty\n        if len(self.uri) == 0:\n            raise InvalidRequestLine(bytes_to_str(line_bytes))\n\n        try:\n            parts = split_request_uri(self.uri)\n        except ValueError:\n            raise InvalidRequestLine(bytes_to_str(line_bytes))\n        self.path = parts.path or \"\"\n        self.query = parts.query or \"\"\n        self.fragment = parts.fragment or \"\"\n\n        # Version\n        match = VERSION_RE.fullmatch(bits[2])\n        if match is None:\n            raise InvalidHTTPVersion(bits[2])\n        self.version = (int(match.group(1)), int(match.group(2)))\n        if not (1, 0) <= self.version < (2, 0):\n            # if ever relaxing this, carefully review Content-Encoding processing\n            if not self.cfg.permit_unconventional_http_version:\n                raise InvalidHTTPVersion(self.version)\n",
      "start_line": 404,
      "end_line": 459,
      "source_file": "gunicorn/http/message.py",
      "chunk_type": "code"
    },
    {
      "content": "    def set_body_reader(self):\n        super().set_body_reader()\n        if isinstance(self.body.reader, EOFReader):\n            self.body = Body(LengthReader(self.unreader, 0))",
      "start_line": 459,
      "end_line": 463,
      "source_file": "gunicorn/http/message.py",
      "chunk_type": "code"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\nimport io\nimport os\n\n# Classes that can undo reading data from\n# a given type of data source.\n\n",
      "start_line": 0,
      "end_line": 11,
      "source_file": "gunicorn/http/unreader.py",
      "chunk_type": "code"
    },
    {
      "content": "class Unreader:",
      "start_line": 11,
      "end_line": 12,
      "source_file": "gunicorn/http/unreader.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self):\n        self.buf = io.BytesIO()\n",
      "start_line": 12,
      "end_line": 15,
      "source_file": "gunicorn/http/unreader.py",
      "chunk_type": "code"
    },
    {
      "content": "    def chunk(self):\n        raise NotImplementedError()\n",
      "start_line": 15,
      "end_line": 18,
      "source_file": "gunicorn/http/unreader.py",
      "chunk_type": "code"
    },
    {
      "content": "    def read(self, size=None):\n        if size is not None and not isinstance(size, int):\n            raise TypeError(\"size parameter must be an int or long.\")\n\n        if size is not None:\n            if size == 0:\n                return b\"\"\n            if size < 0:\n                size = None\n\n        self.buf.seek(0, os.SEEK_END)\n\n        if size is None and self.buf.tell():\n            ret = self.buf.getvalue()\n            self.buf = io.BytesIO()\n            return ret\n        if size is None:\n            d = self.chunk()\n            return d\n\n        while self.buf.tell() < size:\n            chunk = self.chunk()\n            if not chunk:\n                ret = self.buf.getvalue()\n                self.buf = io.BytesIO()\n                return ret\n            self.buf.write(chunk)\n        data = self.buf.getvalue()\n        self.buf = io.BytesIO()\n        self.buf.write(data[size:])\n        return data[:size]\n",
      "start_line": 18,
      "end_line": 50,
      "source_file": "gunicorn/http/unreader.py",
      "chunk_type": "code"
    },
    {
      "content": "    def unread(self, data):\n        self.buf.seek(0, os.SEEK_END)\n        self.buf.write(data)\n\n",
      "start_line": 50,
      "end_line": 55,
      "source_file": "gunicorn/http/unreader.py",
      "chunk_type": "code"
    },
    {
      "content": "class SocketUnreader(Unreader):",
      "start_line": 55,
      "end_line": 56,
      "source_file": "gunicorn/http/unreader.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, sock, max_chunk=8192):\n        super().__init__()\n        self.sock = sock\n        self.mxchunk = max_chunk\n",
      "start_line": 56,
      "end_line": 61,
      "source_file": "gunicorn/http/unreader.py",
      "chunk_type": "code"
    },
    {
      "content": "    def chunk(self):\n        return self.sock.recv(self.mxchunk)\n\n",
      "start_line": 61,
      "end_line": 65,
      "source_file": "gunicorn/http/unreader.py",
      "chunk_type": "code"
    },
    {
      "content": "class IterUnreader(Unreader):",
      "start_line": 65,
      "end_line": 66,
      "source_file": "gunicorn/http/unreader.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, iterable):\n        super().__init__()\n        self.iter = iter(iterable)\n",
      "start_line": 66,
      "end_line": 70,
      "source_file": "gunicorn/http/unreader.py",
      "chunk_type": "code"
    },
    {
      "content": "    def chunk(self):\n        if not self.iter:\n            return b\"\"\n        try:\n            return next(self.iter)\n        except StopIteration:\n            self.iter = None\n            return b\"\"",
      "start_line": 70,
      "end_line": 78,
      "source_file": "gunicorn/http/unreader.py",
      "chunk_type": "code"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\nfrom gunicorn.http.message import Request\nfrom gunicorn.http.unreader import SocketUnreader, IterUnreader\n\n",
      "start_line": 0,
      "end_line": 8,
      "source_file": "gunicorn/http/parser.py",
      "chunk_type": "code"
    },
    {
      "content": "class Parser:\n\n    mesg_class = None\n",
      "start_line": 8,
      "end_line": 12,
      "source_file": "gunicorn/http/parser.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, cfg, source, source_addr):\n        self.cfg = cfg\n        if hasattr(source, \"recv\"):\n            self.unreader = SocketUnreader(source)\n        else:\n            self.unreader = IterUnreader(source)\n        self.mesg = None\n        self.source_addr = source_addr\n\n        # request counter (for keepalive connetions)\n        self.req_count = 0\n",
      "start_line": 12,
      "end_line": 24,
      "source_file": "gunicorn/http/parser.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __iter__(self):\n        return self\n",
      "start_line": 24,
      "end_line": 27,
      "source_file": "gunicorn/http/parser.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __next__(self):\n        # Stop if HTTP dictates a stop.\n        if self.mesg and self.mesg.should_close():\n            raise StopIteration()\n\n        # Discard any unread body of the previous message\n        if self.mesg:\n            data = self.mesg.body.read(8192)\n            while data:\n                data = self.mesg.body.read(8192)\n\n        # Parse the next request\n        self.req_count += 1\n        self.mesg = self.mesg_class(self.cfg, self.unreader, self.source_addr, self.req_count)\n        if not self.mesg:\n            raise StopIteration()\n        return self.mesg\n\n    next = __next__\n\n",
      "start_line": 27,
      "end_line": 48,
      "source_file": "gunicorn/http/parser.py",
      "chunk_type": "code"
    },
    {
      "content": "class RequestParser(Parser):\n\n    mesg_class = Request",
      "start_line": 48,
      "end_line": 51,
      "source_file": "gunicorn/http/parser.py",
      "chunk_type": "code"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\n# We don't need to call super() in __init__ methods of our\n# BaseException and Exception classes because we also define\n# our own __str__ methods so there is no need to pass 'message'\n# to the base class to get a meaningful output from 'str(exc)'.\n# pylint: disable=super-init-not-called\n\n",
      "start_line": 0,
      "end_line": 11,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "class ParseException(Exception):\n    pass\n\n",
      "start_line": 11,
      "end_line": 15,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "class NoMoreData(IOError):",
      "start_line": 15,
      "end_line": 16,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, buf=None):\n        self.buf = buf\n",
      "start_line": 16,
      "end_line": 19,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __str__(self):\n        return \"No more data after: %r\" % self.buf\n\n",
      "start_line": 19,
      "end_line": 23,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "class ConfigurationProblem(ParseException):",
      "start_line": 23,
      "end_line": 24,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, info):\n        self.info = info\n        self.code = 500\n",
      "start_line": 24,
      "end_line": 28,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __str__(self):\n        return \"Configuration problem: %s\" % self.info\n\n",
      "start_line": 28,
      "end_line": 32,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "class InvalidRequestLine(ParseException):",
      "start_line": 32,
      "end_line": 33,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, req):\n        self.req = req\n        self.code = 400\n",
      "start_line": 33,
      "end_line": 37,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __str__(self):\n        return \"Invalid HTTP request line: %r\" % self.req\n\n",
      "start_line": 37,
      "end_line": 41,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "class InvalidRequestMethod(ParseException):",
      "start_line": 41,
      "end_line": 42,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, method):\n        self.method = method\n",
      "start_line": 42,
      "end_line": 45,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __str__(self):\n        return \"Invalid HTTP method: %r\" % self.method\n\n",
      "start_line": 45,
      "end_line": 49,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "class InvalidHTTPVersion(ParseException):",
      "start_line": 49,
      "end_line": 50,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, version):\n        self.version = version\n",
      "start_line": 50,
      "end_line": 53,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __str__(self):\n        return \"Invalid HTTP Version: %r\" % (self.version,)\n\n",
      "start_line": 53,
      "end_line": 57,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "class InvalidHeader(ParseException):",
      "start_line": 57,
      "end_line": 58,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, hdr, req=None):\n        self.hdr = hdr\n        self.req = req\n",
      "start_line": 58,
      "end_line": 62,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __str__(self):\n        return \"Invalid HTTP Header: %r\" % self.hdr\n\n",
      "start_line": 62,
      "end_line": 66,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "class ObsoleteFolding(ParseException):",
      "start_line": 66,
      "end_line": 67,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, hdr):\n        self.hdr = hdr\n",
      "start_line": 67,
      "end_line": 70,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __str__(self):\n        return \"Obsolete line folding is unacceptable: %r\" % (self.hdr, )\n\n",
      "start_line": 70,
      "end_line": 74,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "class InvalidHeaderName(ParseException):",
      "start_line": 74,
      "end_line": 75,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, hdr):\n        self.hdr = hdr\n",
      "start_line": 75,
      "end_line": 78,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __str__(self):\n        return \"Invalid HTTP header name: %r\" % self.hdr\n\n",
      "start_line": 78,
      "end_line": 82,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "class UnsupportedTransferCoding(ParseException):",
      "start_line": 82,
      "end_line": 83,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, hdr):\n        self.hdr = hdr\n        self.code = 501\n",
      "start_line": 83,
      "end_line": 87,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __str__(self):\n        return \"Unsupported transfer coding: %r\" % self.hdr\n\n",
      "start_line": 87,
      "end_line": 91,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "class InvalidChunkSize(IOError):",
      "start_line": 91,
      "end_line": 92,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, data):\n        self.data = data\n",
      "start_line": 92,
      "end_line": 95,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __str__(self):\n        return \"Invalid chunk size: %r\" % self.data\n\n",
      "start_line": 95,
      "end_line": 99,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "class ChunkMissingTerminator(IOError):",
      "start_line": 99,
      "end_line": 100,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, term):\n        self.term = term\n",
      "start_line": 100,
      "end_line": 103,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __str__(self):\n        return \"Invalid chunk terminator is not '\\\\r\\\\n': %r\" % self.term\n\n",
      "start_line": 103,
      "end_line": 107,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "class LimitRequestLine(ParseException):",
      "start_line": 107,
      "end_line": 108,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, size, max_size):\n        self.size = size\n        self.max_size = max_size\n",
      "start_line": 108,
      "end_line": 112,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __str__(self):\n        return \"Request Line is too large (%s > %s)\" % (self.size, self.max_size)\n\n",
      "start_line": 112,
      "end_line": 116,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "class LimitRequestHeaders(ParseException):",
      "start_line": 116,
      "end_line": 117,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, msg):\n        self.msg = msg\n",
      "start_line": 117,
      "end_line": 120,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __str__(self):\n        return self.msg\n\n",
      "start_line": 120,
      "end_line": 124,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "class InvalidProxyLine(ParseException):",
      "start_line": 124,
      "end_line": 125,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, line):\n        self.line = line\n        self.code = 400\n",
      "start_line": 125,
      "end_line": 129,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __str__(self):\n        return \"Invalid PROXY line: %r\" % self.line\n\n",
      "start_line": 129,
      "end_line": 133,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "class ForbiddenProxyRequest(ParseException):",
      "start_line": 133,
      "end_line": 134,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, host):\n        self.host = host\n        self.code = 403\n",
      "start_line": 134,
      "end_line": 138,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __str__(self):\n        return \"Proxy request from %r not allowed\" % self.host\n\n",
      "start_line": 138,
      "end_line": 142,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "class InvalidSchemeHeaders(ParseException):",
      "start_line": 142,
      "end_line": 143,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __str__(self):\n        return \"Contradictory scheme headers\"",
      "start_line": 143,
      "end_line": 145,
      "source_file": "gunicorn/http/errors.py",
      "chunk_type": "code"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\nimport io\nimport logging\nimport os\nimport re\nimport sys\n\nfrom gunicorn.http.message import TOKEN_RE\nfrom gunicorn.http.errors import ConfigurationProblem, InvalidHeader, InvalidHeaderName\nfrom gunicorn import SERVER_SOFTWARE, SERVER\nfrom gunicorn import util\n\n# Send files in at most 1GB blocks as some operating systems can have problems\n# with sending files in blocks over 2GB.\nBLKSIZE = 0x3FFFFFFF\n\n# RFC9110 5.5: field-vchar = VCHAR / obs-text\n# RFC4234 B.1: VCHAR = 0x21-x07E = printable ASCII\nHEADER_VALUE_RE = re.compile(r'[ \\t\\x21-\\x7e\\x80-\\xff]*')\n\nlog = logging.getLogger(__name__)\n\n",
      "start_line": 0,
      "end_line": 26,
      "source_file": "gunicorn/http/wsgi.py",
      "chunk_type": "code"
    },
    {
      "content": "class FileWrapper:\n",
      "start_line": 26,
      "end_line": 28,
      "source_file": "gunicorn/http/wsgi.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, filelike, blksize=8192):\n        self.filelike = filelike\n        self.blksize = blksize\n        if hasattr(filelike, 'close'):\n            self.close = filelike.close\n",
      "start_line": 28,
      "end_line": 34,
      "source_file": "gunicorn/http/wsgi.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __getitem__(self, key):\n        data = self.filelike.read(self.blksize)\n        if data:\n            return data\n        raise IndexError\n\n",
      "start_line": 34,
      "end_line": 41,
      "source_file": "gunicorn/http/wsgi.py",
      "chunk_type": "code"
    },
    {
      "content": "class WSGIErrorsWrapper(io.RawIOBase):\n",
      "start_line": 41,
      "end_line": 43,
      "source_file": "gunicorn/http/wsgi.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, cfg):\n        # There is no public __init__ method for RawIOBase so\n        # we don't need to call super() in the __init__ method.\n        # pylint: disable=super-init-not-called\n        errorlog = logging.getLogger(\"gunicorn.error\")\n        handlers = errorlog.handlers\n        self.streams = []\n\n        if cfg.errorlog == \"-\":\n            self.streams.append(sys.stderr)\n            handlers = handlers[1:]\n\n        for h in handlers:\n            if hasattr(h, \"stream\"):\n                self.streams.append(h.stream)\n",
      "start_line": 43,
      "end_line": 59,
      "source_file": "gunicorn/http/wsgi.py",
      "chunk_type": "code"
    },
    {
      "content": "    def write(self, data):\n        for stream in self.streams:\n            try:\n                stream.write(data)\n            except UnicodeError:\n                stream.write(data.encode(\"UTF-8\"))\n            stream.flush()\n\n",
      "start_line": 59,
      "end_line": 68,
      "source_file": "gunicorn/http/wsgi.py",
      "chunk_type": "code"
    },
    {
      "content": "def base_environ(cfg):\n    return {\n        \"wsgi.errors\": WSGIErrorsWrapper(cfg),\n        \"wsgi.version\": (1, 0),\n        \"wsgi.multithread\": False,\n        \"wsgi.multiprocess\": (cfg.workers > 1),\n        \"wsgi.run_once\": False,\n        \"wsgi.file_wrapper\": FileWrapper,\n        \"wsgi.input_terminated\": True,\n        \"SERVER_SOFTWARE\": SERVER_SOFTWARE,\n    }\n\n",
      "start_line": 68,
      "end_line": 81,
      "source_file": "gunicorn/http/wsgi.py",
      "chunk_type": "code"
    },
    {
      "content": "def default_environ(req, sock, cfg):\n    env = base_environ(cfg)\n    env.update({\n        \"wsgi.input\": req.body,\n        \"gunicorn.socket\": sock,\n        \"REQUEST_METHOD\": req.method,\n        \"QUERY_STRING\": req.query,\n        \"RAW_URI\": req.uri,\n        \"SERVER_PROTOCOL\": \"HTTP/%s\" % \".\".join([str(v) for v in req.version])\n    })\n    return env\n\n",
      "start_line": 81,
      "end_line": 94,
      "source_file": "gunicorn/http/wsgi.py",
      "chunk_type": "code"
    },
    {
      "content": "def proxy_environ(req):\n    info = req.proxy_protocol_info\n\n    if not info:\n        return {}\n\n    return {\n        \"PROXY_PROTOCOL\": info[\"proxy_protocol\"],\n        \"REMOTE_ADDR\": info[\"client_addr\"],\n        \"REMOTE_PORT\": str(info[\"client_port\"]),\n        \"PROXY_ADDR\": info[\"proxy_addr\"],\n        \"PROXY_PORT\": str(info[\"proxy_port\"]),\n    }\n\n",
      "start_line": 94,
      "end_line": 109,
      "source_file": "gunicorn/http/wsgi.py",
      "chunk_type": "code"
    },
    {
      "content": "def create(req, sock, client, server, cfg):\n    resp = Response(req, sock, cfg)\n\n    # set initial environ\n    environ = default_environ(req, sock, cfg)\n\n    # default variables\n    host = None\n    script_name = os.environ.get(\"SCRIPT_NAME\", \"\")\n\n    # add the headers to the environ\n    for hdr_name, hdr_value in req.headers:\n        if hdr_name == \"EXPECT\":\n            # handle expect\n            if hdr_value.lower() == \"100-continue\":\n                sock.send(b\"HTTP/1.1 100 Continue\\r\\n\\r\\n\")\n        elif hdr_name == 'HOST':\n            host = hdr_value\n        elif hdr_name == \"SCRIPT_NAME\":\n            script_name = hdr_value\n        elif hdr_name == \"CONTENT-TYPE\":\n            environ['CONTENT_TYPE'] = hdr_value\n            continue\n        elif hdr_name == \"CONTENT-LENGTH\":\n            environ['CONTENT_LENGTH'] = hdr_value\n            continue\n\n        # do not change lightly, this is a common source of security problems\n        # RFC9110 Section 17.10 discourages ambiguous or incomplete mappings\n        key = 'HTTP_' + hdr_name.replace('-', '_')\n        if key in environ:\n            hdr_value = \"%s,%s\" % (environ[key], hdr_value)\n        environ[key] = hdr_value\n\n    # set the url scheme\n    environ['wsgi.url_scheme'] = req.scheme\n\n    # set the REMOTE_* keys in environ\n    # authors should be aware that REMOTE_HOST and REMOTE_ADDR\n    # may not qualify the remote addr:\n    # http://www.ietf.org/rfc/rfc3875\n    if isinstance(client, str):\n        environ['REMOTE_ADDR'] = client\n    elif isinstance(client, bytes):\n        environ['REMOTE_ADDR'] = client.decode()\n    else:\n        environ['REMOTE_ADDR'] = client[0]\n        environ['REMOTE_PORT'] = str(client[1])\n\n    # handle the SERVER_*\n    # Normally only the application should use the Host header but since the\n    # WSGI spec doesn't support unix sockets, we are using it to create\n    # viable SERVER_* if possible.\n    if isinstance(server, str):\n        server = server.split(\":\")\n        if len(server) == 1:\n            # unix socket\n            if host:\n                server = host.split(':')\n                if len(server) == 1:\n                    if req.scheme == \"http\":\n                        server.append(80)\n                    elif req.scheme == \"https\":\n                        server.append(443)\n                    else:\n                        server.append('')\n            else:\n                # no host header given which means that we are not behind a\n                # proxy, so append an empty port.\n                server.append('')\n    environ['SERVER_NAME'] = server[0]\n    environ['SERVER_PORT'] = str(server[1])\n\n    # set the path and script name\n    path_info = req.path\n    if script_name:\n        if not path_info.startswith(script_name):\n            raise ConfigurationProblem(\n                \"Request path %r does not start with SCRIPT_NAME %r\" %\n                (path_info, script_name))\n        path_info = path_info[len(script_name):]\n    environ['PATH_INFO'] = util.unquote_to_wsgi_str(path_info)\n    environ['SCRIPT_NAME'] = script_name\n\n    # override the environ with the correct remote and server address if\n    # we are behind a proxy using the proxy protocol.\n    environ.update(proxy_environ(req))\n    return resp, environ\n\n",
      "start_line": 109,
      "end_line": 199,
      "source_file": "gunicorn/http/wsgi.py",
      "chunk_type": "code"
    },
    {
      "content": "class Response:\n",
      "start_line": 199,
      "end_line": 201,
      "source_file": "gunicorn/http/wsgi.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, req, sock, cfg):\n        self.req = req\n        self.sock = sock\n        self.version = SERVER\n        self.status = None\n        self.chunked = False\n        self.must_close = False\n        self.headers = []\n        self.headers_sent = False\n        self.response_length = None\n        self.sent = 0\n        self.upgrade = False\n        self.cfg = cfg\n",
      "start_line": 201,
      "end_line": 215,
      "source_file": "gunicorn/http/wsgi.py",
      "chunk_type": "code"
    },
    {
      "content": "    def force_close(self):\n        self.must_close = True\n",
      "start_line": 215,
      "end_line": 218,
      "source_file": "gunicorn/http/wsgi.py",
      "chunk_type": "code"
    },
    {
      "content": "    def should_close(self):\n        if self.must_close or self.req.should_close():\n            return True\n        if self.response_length is not None or self.chunked:\n            return False\n        if self.req.method == 'HEAD':\n            return False\n        if self.status_code < 200 or self.status_code in (204, 304):\n            return False\n        return True\n",
      "start_line": 218,
      "end_line": 229,
      "source_file": "gunicorn/http/wsgi.py",
      "chunk_type": "code"
    },
    {
      "content": "    def start_response(self, status, headers, exc_info=None):\n        if exc_info:\n            try:\n                if self.status and self.headers_sent:\n                    util.reraise(exc_info[0], exc_info[1], exc_info[2])\n            finally:\n                exc_info = None\n        elif self.status is not None:\n            raise AssertionError(\"Response headers already set!\")\n\n        self.status = status\n\n        # get the status code from the response here so we can use it to check\n        # the need for the connection header later without parsing the string\n        # each time.\n        try:\n            self.status_code = int(self.status.split()[0])\n        except ValueError:\n            self.status_code = None\n\n        self.process_headers(headers)\n        self.chunked = self.is_chunked()\n        return self.write\n",
      "start_line": 229,
      "end_line": 253,
      "source_file": "gunicorn/http/wsgi.py",
      "chunk_type": "code"
    },
    {
      "content": "    def process_headers(self, headers):\n        for name, value in headers:\n            if not isinstance(name, str):\n                raise TypeError('%r is not a string' % name)\n\n            if not TOKEN_RE.fullmatch(name):\n                raise InvalidHeaderName('%r' % name)\n\n            if not isinstance(value, str):\n                raise TypeError('%r is not a string' % value)\n\n            if not HEADER_VALUE_RE.fullmatch(value):\n                raise InvalidHeader('%r' % value)\n\n            # RFC9110 5.5\n            value = value.strip(\" \\t\")\n            lname = name.lower()\n            if lname == \"content-length\":\n                self.response_length = int(value)\n            elif util.is_hoppish(name):\n                if lname == \"connection\":\n                    # handle websocket\n                    if value.lower() == \"upgrade\":\n                        self.upgrade = True\n                elif lname == \"upgrade\":\n                    if value.lower() == \"websocket\":\n                        self.headers.append((name, value))\n\n                # ignore hopbyhop headers\n                continue\n            self.headers.append((name, value))\n",
      "start_line": 253,
      "end_line": 285,
      "source_file": "gunicorn/http/wsgi.py",
      "chunk_type": "code"
    },
    {
      "content": "    def is_chunked(self):\n        # Only use chunked responses when the client is\n        # speaking HTTP/1.1 or newer and there was\n        # no Content-Length header set.\n        if self.response_length is not None:\n            return False\n        elif self.req.version <= (1, 0):\n            return False\n        elif self.req.method == 'HEAD':\n            # Responses to a HEAD request MUST NOT contain a response body.\n            return False\n        elif self.status_code in (204, 304):\n            # Do not use chunked responses when the response is guaranteed to\n            # not have a response body.\n            return False\n        return True\n",
      "start_line": 285,
      "end_line": 302,
      "source_file": "gunicorn/http/wsgi.py",
      "chunk_type": "code"
    },
    {
      "content": "    def default_headers(self):\n        # set the connection header\n        if self.upgrade:\n            connection = \"upgrade\"\n        elif self.should_close():\n            connection = \"close\"\n        else:\n            connection = \"keep-alive\"\n\n        headers = [\n            \"HTTP/%s.%s %s\\r\\n\" % (self.req.version[0],\n                                   self.req.version[1], self.status),\n            \"Server: %s\\r\\n\" % self.version,\n            \"Date: %s\\r\\n\" % util.http_date(),\n            \"Connection: %s\\r\\n\" % connection\n        ]\n        if self.chunked:\n            headers.append(\"Transfer-Encoding: chunked\\r\\n\")\n        return headers\n",
      "start_line": 302,
      "end_line": 322,
      "source_file": "gunicorn/http/wsgi.py",
      "chunk_type": "code"
    },
    {
      "content": "    def send_headers(self):\n        if self.headers_sent:\n            return\n        tosend = self.default_headers()\n        tosend.extend([\"%s: %s\\r\\n\" % (k, v) for k, v in self.headers])\n\n        header_str = \"%s\\r\\n\" % \"\".join(tosend)\n        util.write(self.sock, util.to_bytestring(header_str, \"latin-1\"))\n        self.headers_sent = True\n",
      "start_line": 322,
      "end_line": 332,
      "source_file": "gunicorn/http/wsgi.py",
      "chunk_type": "code"
    },
    {
      "content": "    def write(self, arg):\n        self.send_headers()\n        if not isinstance(arg, bytes):\n            raise TypeError('%r is not a byte' % arg)\n        arglen = len(arg)\n        tosend = arglen\n        if self.response_length is not None:\n            if self.sent >= self.response_length:\n                # Never write more than self.response_length bytes\n                return\n\n            tosend = min(self.response_length - self.sent, tosend)\n            if tosend < arglen:\n                arg = arg[:tosend]\n\n        # Sending an empty chunk signals the end of the\n        # response and prematurely closes the response\n        if self.chunked and tosend == 0:\n            return\n\n        self.sent += tosend\n        util.write(self.sock, arg, self.chunked)\n",
      "start_line": 332,
      "end_line": 355,
      "source_file": "gunicorn/http/wsgi.py",
      "chunk_type": "code"
    },
    {
      "content": "    def can_sendfile(self):\n        return self.cfg.sendfile is not False\n",
      "start_line": 355,
      "end_line": 358,
      "source_file": "gunicorn/http/wsgi.py",
      "chunk_type": "code"
    },
    {
      "content": "    def sendfile(self, respiter):\n        if self.cfg.is_ssl or not self.can_sendfile():\n            return False\n\n        if not util.has_fileno(respiter.filelike):\n            return False\n\n        fileno = respiter.filelike.fileno()\n        try:\n            offset = os.lseek(fileno, 0, os.SEEK_CUR)\n            if self.response_length is None:\n                filesize = os.fstat(fileno).st_size\n                nbytes = filesize - offset\n            else:\n                nbytes = self.response_length\n        except (OSError, io.UnsupportedOperation):\n            return False\n\n        self.send_headers()\n\n        if self.is_chunked():\n            chunk_size = \"%X\\r\\n\" % nbytes\n            self.sock.sendall(chunk_size.encode('utf-8'))\n        if nbytes > 0:\n            self.sock.sendfile(respiter.filelike, offset=offset, count=nbytes)\n\n        if self.is_chunked():\n            self.sock.sendall(b\"\\r\\n\")\n\n        os.lseek(fileno, offset, os.SEEK_SET)\n\n        return True\n",
      "start_line": 358,
      "end_line": 391,
      "source_file": "gunicorn/http/wsgi.py",
      "chunk_type": "code"
    },
    {
      "content": "    def write_file(self, respiter):\n        if not self.sendfile(respiter):\n            for item in respiter:\n                self.write(item)\n",
      "start_line": 391,
      "end_line": 396,
      "source_file": "gunicorn/http/wsgi.py",
      "chunk_type": "code"
    },
    {
      "content": "    def close(self):\n        if not self.headers_sent:\n            self.send_headers()\n        if self.chunked:\n            util.write_chunk(self.sock, b\"\")",
      "start_line": 396,
      "end_line": 401,
      "source_file": "gunicorn/http/wsgi.py",
      "chunk_type": "code"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n#\n\nfrom datetime import datetime\nimport errno\nimport os\nimport select\nimport socket\nimport ssl\nimport sys\n\nfrom gunicorn import http\nfrom gunicorn.http import wsgi\nfrom gunicorn import sock\nfrom gunicorn import util\nfrom gunicorn.workers import base\n\n",
      "start_line": 0,
      "end_line": 20,
      "source_file": "gunicorn/workers/sync.py",
      "chunk_type": "code"
    },
    {
      "content": "class StopWaiting(Exception):\n    \"\"\" exception raised to stop waiting for a connection \"\"\"\n\n",
      "start_line": 20,
      "end_line": 24,
      "source_file": "gunicorn/workers/sync.py",
      "chunk_type": "code"
    },
    {
      "content": "class SyncWorker(base.Worker):\n",
      "start_line": 24,
      "end_line": 26,
      "source_file": "gunicorn/workers/sync.py",
      "chunk_type": "code"
    },
    {
      "content": "    def accept(self, listener):\n        client, addr = listener.accept()\n        client.setblocking(1)\n        util.close_on_exec(client)\n        self.handle(listener, client, addr)\n",
      "start_line": 26,
      "end_line": 32,
      "source_file": "gunicorn/workers/sync.py",
      "chunk_type": "code"
    },
    {
      "content": "    def wait(self, timeout):\n        try:\n            self.notify()\n            ret = select.select(self.wait_fds, [], [], timeout)\n            if ret[0]:\n                if self.PIPE[0] in ret[0]:\n                    os.read(self.PIPE[0], 1)\n                return ret[0]\n\n        except OSError as e:\n            if e.args[0] == errno.EINTR:\n                return self.sockets\n            if e.args[0] == errno.EBADF:\n                if self.nr < 0:\n                    return self.sockets\n                else:\n                    raise StopWaiting\n            raise\n",
      "start_line": 32,
      "end_line": 51,
      "source_file": "gunicorn/workers/sync.py",
      "chunk_type": "code"
    },
    {
      "content": "    def is_parent_alive(self):\n        # If our parent changed then we shut down.\n        if self.ppid != os.getppid():\n            self.log.info(\"Parent changed, shutting down: %s\", self)\n            return False\n        return True\n",
      "start_line": 51,
      "end_line": 58,
      "source_file": "gunicorn/workers/sync.py",
      "chunk_type": "code"
    },
    {
      "content": "    def run_for_one(self, timeout):\n        listener = self.sockets[0]\n        while self.alive:\n            self.notify()\n\n            # Accept a connection. If we get an error telling us\n            # that no connection is waiting we fall down to the\n            # select which is where we'll wait for a bit for new\n            # workers to come give us some love.\n            try:\n                self.accept(listener)\n                # Keep processing clients until no one is waiting. This\n                # prevents the need to select() for every client that we\n                # process.\n                continue\n\n            except OSError as e:\n                if e.errno not in (errno.EAGAIN, errno.ECONNABORTED,\n                                   errno.EWOULDBLOCK):\n                    raise\n\n            if not self.is_parent_alive():\n                return\n\n            try:\n                self.wait(timeout)\n            except StopWaiting:\n                return\n",
      "start_line": 58,
      "end_line": 87,
      "source_file": "gunicorn/workers/sync.py",
      "chunk_type": "code"
    },
    {
      "content": "    def run_for_multiple(self, timeout):\n        while self.alive:\n            self.notify()\n\n            try:\n                ready = self.wait(timeout)\n            except StopWaiting:\n                return\n\n            if ready is not None:\n                for listener in ready:\n                    if listener == self.PIPE[0]:\n                        continue\n\n                    try:\n                        self.accept(listener)\n                    except OSError as e:\n                        if e.errno not in (errno.EAGAIN, errno.ECONNABORTED,\n                                           errno.EWOULDBLOCK):\n                            raise\n\n            if not self.is_parent_alive():\n                return\n",
      "start_line": 87,
      "end_line": 111,
      "source_file": "gunicorn/workers/sync.py",
      "chunk_type": "code"
    },
    {
      "content": "    def run(self):\n        # if no timeout is given the worker will never wait and will\n        # use the CPU for nothing. This minimal timeout prevent it.\n        timeout = self.timeout or 0.5\n\n        # self.socket appears to lose its blocking status after\n        # we fork in the arbiter. Reset it here.\n        for s in self.sockets:\n            s.setblocking(0)\n\n        if len(self.sockets) > 1:\n            self.run_for_multiple(timeout)\n        else:\n            self.run_for_one(timeout)\n",
      "start_line": 111,
      "end_line": 126,
      "source_file": "gunicorn/workers/sync.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle(self, listener, client, addr):\n        req = None\n        try:\n            if self.cfg.is_ssl:\n                client = sock.ssl_wrap_socket(client, self.cfg)\n            parser = http.RequestParser(self.cfg, client, addr)\n            req = next(parser)\n            self.handle_request(listener, req, client, addr)\n        except http.errors.NoMoreData as e:\n            self.log.debug(\"Ignored premature client disconnection. %s\", e)\n        except StopIteration as e:\n            self.log.debug(\"Closing connection. %s\", e)\n        except ssl.SSLError as e:\n            if e.args[0] == ssl.SSL_ERROR_EOF:\n                self.log.debug(\"ssl connection closed\")\n                client.close()\n            else:\n                self.log.debug(\"Error processing SSL request.\")\n                self.handle_error(req, client, addr, e)\n        except OSError as e:\n            if e.errno not in (errno.EPIPE, errno.ECONNRESET, errno.ENOTCONN):\n                self.log.exception(\"Socket error processing request.\")\n            else:\n                if e.errno == errno.ECONNRESET:\n                    self.log.debug(\"Ignoring connection reset\")\n                elif e.errno == errno.ENOTCONN:\n                    self.log.debug(\"Ignoring socket not connected\")\n                else:\n                    self.log.debug(\"Ignoring EPIPE\")\n        except BaseException as e:\n            self.handle_error(req, client, addr, e)\n        finally:\n            util.close(client)\n",
      "start_line": 126,
      "end_line": 160,
      "source_file": "gunicorn/workers/sync.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_request(self, listener, req, client, addr):\n        environ = {}\n        resp = None\n        try:\n            self.cfg.pre_request(self, req)\n            request_start = datetime.now()\n            resp, environ = wsgi.create(req, client, addr,\n                                        listener.getsockname(), self.cfg)\n            # Force the connection closed until someone shows\n            # a buffering proxy that supports Keep-Alive to\n            # the backend.\n            resp.force_close()\n            self.nr += 1\n            if self.nr >= self.max_requests:\n                self.log.info(\"Autorestarting worker after current request.\")\n                self.alive = False\n            respiter = self.wsgi(environ, resp.start_response)\n            try:\n                if isinstance(respiter, environ['wsgi.file_wrapper']):\n                    resp.write_file(respiter)\n                else:\n                    for item in respiter:\n                        resp.write(item)\n                resp.close()\n            finally:\n                request_time = datetime.now() - request_start\n                self.log.access(resp, req, environ, request_time)\n                if hasattr(respiter, \"close\"):\n                    respiter.close()\n        except OSError:\n            # pass to next try-except level\n            util.reraise(*sys.exc_info())\n        except Exception:\n            if resp and resp.headers_sent:\n                # If the requests have already been sent, we should close the\n                # connection to indicate the error.\n                self.log.exception(\"Error handling request\")\n                try:\n                    client.shutdown(socket.SHUT_RDWR)\n                    client.close()\n                except OSError:\n                    pass\n                raise StopIteration()\n            raise\n        finally:\n            try:\n                self.cfg.post_request(self, req, environ, resp)\n            except Exception:\n                self.log.exception(\"Exception in post_request hook\")",
      "start_line": 160,
      "end_line": 209,
      "source_file": "gunicorn/workers/sync.py",
      "chunk_type": "code"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\nfrom datetime import datetime\nimport errno\nimport socket\nimport ssl\nimport sys\n\nfrom gunicorn import http\nfrom gunicorn.http import wsgi\nfrom gunicorn import util\nfrom gunicorn.workers import base\n\nALREADY_HANDLED = object()\n\n",
      "start_line": 0,
      "end_line": 18,
      "source_file": "gunicorn/workers/base_async.py",
      "chunk_type": "code"
    },
    {
      "content": "class AsyncWorker(base.Worker):\n",
      "start_line": 18,
      "end_line": 20,
      "source_file": "gunicorn/workers/base_async.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.worker_connections = self.cfg.worker_connections\n",
      "start_line": 20,
      "end_line": 24,
      "source_file": "gunicorn/workers/base_async.py",
      "chunk_type": "code"
    },
    {
      "content": "    def timeout_ctx(self):\n        raise NotImplementedError()\n",
      "start_line": 24,
      "end_line": 27,
      "source_file": "gunicorn/workers/base_async.py",
      "chunk_type": "code"
    },
    {
      "content": "    def is_already_handled(self, respiter):\n        # some workers will need to overload this function to raise a StopIteration\n        return respiter == ALREADY_HANDLED\n",
      "start_line": 27,
      "end_line": 31,
      "source_file": "gunicorn/workers/base_async.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle(self, listener, client, addr):\n        req = None\n        try:\n            parser = http.RequestParser(self.cfg, client, addr)\n            try:\n                listener_name = listener.getsockname()\n                if not self.cfg.keepalive:\n                    req = next(parser)\n                    self.handle_request(listener_name, req, client, addr)\n                else:\n                    # keepalive loop\n                    proxy_protocol_info = {}\n                    while True:\n                        req = None\n                        with self.timeout_ctx():\n                            req = next(parser)\n                        if not req:\n                            break\n                        if req.proxy_protocol_info:\n                            proxy_protocol_info = req.proxy_protocol_info\n                        else:\n                            req.proxy_protocol_info = proxy_protocol_info\n                        self.handle_request(listener_name, req, client, addr)\n            except http.errors.NoMoreData as e:\n                self.log.debug(\"Ignored premature client disconnection. %s\", e)\n            except StopIteration as e:\n                self.log.debug(\"Closing connection. %s\", e)\n            except ssl.SSLError:\n                # pass to next try-except level\n                util.reraise(*sys.exc_info())\n            except OSError:\n                # pass to next try-except level\n                util.reraise(*sys.exc_info())\n            except Exception as e:\n                self.handle_error(req, client, addr, e)\n        except ssl.SSLError as e:\n            if e.args[0] == ssl.SSL_ERROR_EOF:\n                self.log.debug(\"ssl connection closed\")\n                client.close()\n            else:\n                self.log.debug(\"Error processing SSL request.\")\n                self.handle_error(req, client, addr, e)\n        except OSError as e:\n            if e.errno not in (errno.EPIPE, errno.ECONNRESET, errno.ENOTCONN):\n                self.log.exception(\"Socket error processing request.\")\n            else:\n                if e.errno == errno.ECONNRESET:\n                    self.log.debug(\"Ignoring connection reset\")\n                elif e.errno == errno.ENOTCONN:\n                    self.log.debug(\"Ignoring socket not connected\")\n                else:\n                    self.log.debug(\"Ignoring EPIPE\")\n        except BaseException as e:\n            self.handle_error(req, client, addr, e)\n        finally:\n            util.close(client)\n",
      "start_line": 31,
      "end_line": 88,
      "source_file": "gunicorn/workers/base_async.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_request(self, listener_name, req, sock, addr):\n        request_start = datetime.now()\n        environ = {}\n        resp = None\n        try:\n            self.cfg.pre_request(self, req)\n            resp, environ = wsgi.create(req, sock, addr,\n                                        listener_name, self.cfg)\n            environ[\"wsgi.multithread\"] = True\n            self.nr += 1\n            if self.nr >= self.max_requests:\n                if self.alive:\n                    self.log.info(\"Autorestarting worker after current request.\")\n                    self.alive = False\n\n            if not self.alive or not self.cfg.keepalive:\n                resp.force_close()\n\n            respiter = self.wsgi(environ, resp.start_response)\n            if self.is_already_handled(respiter):\n                return False\n            try:\n                if isinstance(respiter, environ['wsgi.file_wrapper']):\n                    resp.write_file(respiter)\n                else:\n                    for item in respiter:\n                        resp.write(item)\n                resp.close()\n            finally:\n                request_time = datetime.now() - request_start\n                self.log.access(resp, req, environ, request_time)\n                if hasattr(respiter, \"close\"):\n                    respiter.close()\n            if resp.should_close():\n                raise StopIteration()\n        except StopIteration:\n            raise\n        except OSError:\n            # If the original exception was a socket.error we delegate\n            # handling it to the caller (where handle() might ignore it)\n            util.reraise(*sys.exc_info())\n        except Exception:\n            if resp and resp.headers_sent:\n                # If the requests have already been sent, we should close the\n                # connection to indicate the error.\n                self.log.exception(\"Error handling request\")\n                try:\n                    sock.shutdown(socket.SHUT_RDWR)\n                    sock.close()\n                except OSError:\n                    pass\n                raise StopIteration()\n            raise\n        finally:\n            try:\n                self.cfg.post_request(self, req, environ, resp)\n            except Exception:\n                self.log.exception(\"Exception in post_request hook\")\n        return True",
      "start_line": 88,
      "end_line": 147,
      "source_file": "gunicorn/workers/base_async.py",
      "chunk_type": "code"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\nimport os\nimport sys\n\ntry:\n    import tornado\nexcept ImportError:\n    raise RuntimeError(\"You need tornado installed to use this worker.\")\nimport tornado.web\nimport tornado.httpserver\nfrom tornado.ioloop import IOLoop, PeriodicCallback\nfrom tornado.wsgi import WSGIContainer\nfrom gunicorn.workers.base import Worker\nfrom gunicorn import __version__ as gversion\nfrom gunicorn.sock import ssl_context\n\n\n# Tornado 5.0 updated its IOLoop, and the `io_loop` arguments to many\n# Tornado functions have been removed in Tornado 5.0. Also, they no\n# longer store PeriodCallbacks in ioloop._callbacks. Instead we store\n# them on our side, and use stop() on them when stopping the worker.\n# See https://www.tornadoweb.org/en/stable/releases/v5.0.0.html#backwards-compatibility-notes\n# for more details.\nTORNADO5 = tornado.version_info >= (5, 0, 0)\n\n",
      "start_line": 0,
      "end_line": 29,
      "source_file": "gunicorn/workers/gtornado.py",
      "chunk_type": "code"
    },
    {
      "content": "class TornadoWorker(Worker):\n\n    @classmethod",
      "start_line": 29,
      "end_line": 32,
      "source_file": "gunicorn/workers/gtornado.py",
      "chunk_type": "code"
    },
    {
      "content": "    def setup(cls):\n        web = sys.modules.pop(\"tornado.web\")\n        old_clear = web.RequestHandler.clear\n",
      "start_line": 32,
      "end_line": 36,
      "source_file": "gunicorn/workers/gtornado.py",
      "chunk_type": "code"
    },
    {
      "content": "        def clear(self):\n            old_clear(self)\n            if \"Gunicorn\" not in self._headers[\"Server\"]:\n                self._headers[\"Server\"] += \" (Gunicorn/%s)\" % gversion\n        web.RequestHandler.clear = clear\n        sys.modules[\"tornado.web\"] = web\n",
      "start_line": 36,
      "end_line": 43,
      "source_file": "gunicorn/workers/gtornado.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_exit(self, sig, frame):\n        if self.alive:\n            super().handle_exit(sig, frame)\n",
      "start_line": 43,
      "end_line": 47,
      "source_file": "gunicorn/workers/gtornado.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_request(self):\n        self.nr += 1\n        if self.alive and self.nr >= self.max_requests:\n            self.log.info(\"Autorestarting worker after current request.\")\n            self.alive = False\n",
      "start_line": 47,
      "end_line": 53,
      "source_file": "gunicorn/workers/gtornado.py",
      "chunk_type": "code"
    },
    {
      "content": "    def watchdog(self):\n        if self.alive:\n            self.notify()\n\n        if self.ppid != os.getppid():\n            self.log.info(\"Parent changed, shutting down: %s\", self)\n            self.alive = False\n",
      "start_line": 53,
      "end_line": 61,
      "source_file": "gunicorn/workers/gtornado.py",
      "chunk_type": "code"
    },
    {
      "content": "    def heartbeat(self):\n        if not self.alive:\n            if self.server_alive:\n                if hasattr(self, 'server'):\n                    try:\n                        self.server.stop()\n                    except Exception:\n                        pass\n                self.server_alive = False\n            else:\n                if TORNADO5:\n                    for callback in self.callbacks:\n                        callback.stop()\n                    self.ioloop.stop()\n                else:\n                    if not self.ioloop._callbacks:\n                        self.ioloop.stop()\n",
      "start_line": 61,
      "end_line": 79,
      "source_file": "gunicorn/workers/gtornado.py",
      "chunk_type": "code"
    },
    {
      "content": "    def init_process(self):\n        # IOLoop cannot survive a fork or be shared across processes\n        # in any way. When multiple processes are being used, each process\n        # should create its own IOLoop. We should clear current IOLoop\n        # if exists before os.fork.\n        IOLoop.clear_current()\n        super().init_process()\n",
      "start_line": 79,
      "end_line": 87,
      "source_file": "gunicorn/workers/gtornado.py",
      "chunk_type": "code"
    },
    {
      "content": "    def run(self):\n        self.ioloop = IOLoop.instance()\n        self.alive = True\n        self.server_alive = False\n\n        if TORNADO5:\n            self.callbacks = []\n            self.callbacks.append(PeriodicCallback(self.watchdog, 1000))\n            self.callbacks.append(PeriodicCallback(self.heartbeat, 1000))\n            for callback in self.callbacks:\n                callback.start()\n        else:\n            PeriodicCallback(self.watchdog, 1000, io_loop=self.ioloop).start()\n            PeriodicCallback(self.heartbeat, 1000, io_loop=self.ioloop).start()\n\n        # Assume the app is a WSGI callable if its not an\n        # instance of tornado.web.Application or is an\n        # instance of tornado.wsgi.WSGIApplication\n        app = self.wsgi\n\n        if tornado.version_info[0] < 6:\n            if not isinstance(app, tornado.web.Application) or \\\n                    isinstance(app, tornado.wsgi.WSGIApplication):\n                app = WSGIContainer(app)\n        elif not isinstance(app, WSGIContainer) and \\\n                not isinstance(app, tornado.web.Application):\n            app = WSGIContainer(app)\n\n        # Monkey-patching HTTPConnection.finish to count the\n        # number of requests being handled by Tornado. This\n        # will help gunicorn shutdown the worker if max_requests\n        # is exceeded.\n        httpserver = sys.modules[\"tornado.httpserver\"]\n        if hasattr(httpserver, 'HTTPConnection'):\n            old_connection_finish = httpserver.HTTPConnection.finish\n",
      "start_line": 87,
      "end_line": 123,
      "source_file": "gunicorn/workers/gtornado.py",
      "chunk_type": "code"
    },
    {
      "content": "            def finish(other):\n                self.handle_request()\n                old_connection_finish(other)\n            httpserver.HTTPConnection.finish = finish\n            sys.modules[\"tornado.httpserver\"] = httpserver\n\n            server_class = tornado.httpserver.HTTPServer\n        else:\n",
      "start_line": 123,
      "end_line": 132,
      "source_file": "gunicorn/workers/gtornado.py",
      "chunk_type": "code"
    },
    {
      "content": "            class _HTTPServer(tornado.httpserver.HTTPServer):\n",
      "start_line": 132,
      "end_line": 134,
      "source_file": "gunicorn/workers/gtornado.py",
      "chunk_type": "code"
    },
    {
      "content": "                def on_close(instance, server_conn):\n                    self.handle_request()\n                    super().on_close(server_conn)\n\n            server_class = _HTTPServer\n\n        if self.cfg.is_ssl:\n            if TORNADO5:\n                server = server_class(app, ssl_options=ssl_context(self.cfg))\n            else:\n                server = server_class(app, io_loop=self.ioloop,\n                                      ssl_options=ssl_context(self.cfg))\n        else:\n            if TORNADO5:\n                server = server_class(app)\n            else:\n                server = server_class(app, io_loop=self.ioloop)\n\n        self.server = server\n        self.server_alive = True\n\n        for s in self.sockets:\n            s.setblocking(0)\n            if hasattr(server, \"add_socket\"):  # tornado > 2.0\n                server.add_socket(s)\n            elif hasattr(server, \"_sockets\"):  # tornado 2.0\n                server._sockets[s.fileno()] = s\n\n        server.no_keep_alive = self.cfg.keepalive <= 0\n        server.start(num_processes=1)\n\n        self.ioloop.start()",
      "start_line": 134,
      "end_line": 166,
      "source_file": "gunicorn/workers/gtornado.py",
      "chunk_type": "code"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\n# supported gunicorn workers.\nSUPPORTED_WORKERS = {\n    \"sync\": \"gunicorn.workers.sync.SyncWorker\",\n    \"eventlet\": \"gunicorn.workers.geventlet.EventletWorker\",\n    \"gevent\": \"gunicorn.workers.ggevent.GeventWorker\",\n    \"gevent_wsgi\": \"gunicorn.workers.ggevent.GeventPyWSGIWorker\",\n    \"gevent_pywsgi\": \"gunicorn.workers.ggevent.GeventPyWSGIWorker\",\n    \"tornado\": \"gunicorn.workers.gtornado.TornadoWorker\",\n    \"gthread\": \"gunicorn.workers.gthread.ThreadWorker\",\n}",
      "start_line": 0,
      "end_line": 14,
      "source_file": "gunicorn/workers/__init__.py",
      "chunk_type": "code"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\nfrom functools import partial\nimport sys\n\ntry:\n    import eventlet\nexcept ImportError:\n    raise RuntimeError(\"eventlet worker requires eventlet 0.24.1 or higher\")\nelse:\n    from packaging.version import parse as parse_version\n    if parse_version(eventlet.__version__) < parse_version('0.24.1'):\n        raise RuntimeError(\"eventlet worker requires eventlet 0.24.1 or higher\")\n\nfrom eventlet import hubs, greenthread\nfrom eventlet.greenio import GreenSocket\nimport eventlet.wsgi\nimport greenlet\n\nfrom gunicorn.workers.base_async import AsyncWorker\nfrom gunicorn.sock import ssl_wrap_socket\n\n# ALREADY_HANDLED is removed in 0.30.3+ now it's `WSGI_LOCAL.already_handled: bool`\n# https://github.com/eventlet/eventlet/pull/544\nEVENTLET_WSGI_LOCAL = getattr(eventlet.wsgi, \"WSGI_LOCAL\", None)\nEVENTLET_ALREADY_HANDLED = getattr(eventlet.wsgi, \"ALREADY_HANDLED\", None)\n\n",
      "start_line": 0,
      "end_line": 30,
      "source_file": "gunicorn/workers/geventlet.py",
      "chunk_type": "code"
    },
    {
      "content": "def _eventlet_socket_sendfile(self, file, offset=0, count=None):\n    # Based on the implementation in gevent which in turn is slightly\n    # modified from the standard library implementation.\n    if self.gettimeout() == 0:\n        raise ValueError(\"non-blocking sockets are not supported\")\n    if offset:\n        file.seek(offset)\n    blocksize = min(count, 8192) if count else 8192\n    total_sent = 0\n    # localize variable access to minimize overhead\n    file_read = file.read\n    sock_send = self.send\n    try:\n        while True:\n            if count:\n                blocksize = min(count - total_sent, blocksize)\n                if blocksize <= 0:\n                    break\n            data = memoryview(file_read(blocksize))\n            if not data:\n                break  # EOF\n            while True:\n                try:\n                    sent = sock_send(data)\n                except BlockingIOError:\n                    continue\n                else:\n                    total_sent += sent\n                    if sent < len(data):\n                        data = data[sent:]\n                    else:\n                        break\n        return total_sent\n    finally:\n        if total_sent > 0 and hasattr(file, 'seek'):\n            file.seek(offset + total_sent)\n\n",
      "start_line": 30,
      "end_line": 68,
      "source_file": "gunicorn/workers/geventlet.py",
      "chunk_type": "code"
    },
    {
      "content": "def _eventlet_serve(sock, handle, concurrency):\n    \"\"\"\n    Serve requests forever.\n\n    This code is nearly identical to ``eventlet.convenience.serve`` except\n    that it attempts to join the pool at the end, which allows for gunicorn\n    graceful shutdowns.\n    \"\"\"\n    pool = eventlet.greenpool.GreenPool(concurrency)\n    server_gt = eventlet.greenthread.getcurrent()\n\n    while True:\n        try:\n            conn, addr = sock.accept()\n            gt = pool.spawn(handle, conn, addr)\n            gt.link(_eventlet_stop, server_gt, conn)\n            conn, addr, gt = None, None, None\n        except eventlet.StopServe:\n            sock.close()\n            pool.waitall()\n            return\n\n",
      "start_line": 68,
      "end_line": 91,
      "source_file": "gunicorn/workers/geventlet.py",
      "chunk_type": "code"
    },
    {
      "content": "def _eventlet_stop(client, server, conn):\n    \"\"\"\n    Stop a greenlet handling a request and close its connection.\n\n    This code is lifted from eventlet so as not to depend on undocumented\n    functions in the library.\n    \"\"\"\n    try:\n        try:\n            client.wait()\n        finally:\n            conn.close()\n    except greenlet.GreenletExit:\n        pass\n    except Exception:\n        greenthread.kill(server, *sys.exc_info())\n\n",
      "start_line": 91,
      "end_line": 109,
      "source_file": "gunicorn/workers/geventlet.py",
      "chunk_type": "code"
    },
    {
      "content": "def patch_sendfile():\n    # As of eventlet 0.25.1, GreenSocket.sendfile doesn't exist,\n    # meaning the native implementations of socket.sendfile will be used.\n    # If os.sendfile exists, it will attempt to use that, failing explicitly\n    # if the socket is in non-blocking mode, which the underlying\n    # socket object /is/. Even the regular _sendfile_use_send will\n    # fail in that way; plus, it would use the underlying socket.send which isn't\n    # properly cooperative. So we have to monkey-patch a working socket.sendfile()\n    # into GreenSocket; in this method, `self.send` will be the GreenSocket's\n    # send method which is properly cooperative.\n    if not hasattr(GreenSocket, 'sendfile'):\n        GreenSocket.sendfile = _eventlet_socket_sendfile\n\n",
      "start_line": 109,
      "end_line": 123,
      "source_file": "gunicorn/workers/geventlet.py",
      "chunk_type": "code"
    },
    {
      "content": "class EventletWorker(AsyncWorker):\n",
      "start_line": 123,
      "end_line": 125,
      "source_file": "gunicorn/workers/geventlet.py",
      "chunk_type": "code"
    },
    {
      "content": "    def patch(self):\n        hubs.use_hub()\n        eventlet.monkey_patch()\n        patch_sendfile()\n",
      "start_line": 125,
      "end_line": 130,
      "source_file": "gunicorn/workers/geventlet.py",
      "chunk_type": "code"
    },
    {
      "content": "    def is_already_handled(self, respiter):\n        # eventlet >= 0.30.3\n        if getattr(EVENTLET_WSGI_LOCAL, \"already_handled\", None):\n            raise StopIteration()\n        # eventlet < 0.30.3\n        if respiter == EVENTLET_ALREADY_HANDLED:\n            raise StopIteration()\n        return super().is_already_handled(respiter)\n",
      "start_line": 130,
      "end_line": 139,
      "source_file": "gunicorn/workers/geventlet.py",
      "chunk_type": "code"
    },
    {
      "content": "    def init_process(self):\n        self.patch()\n        super().init_process()\n",
      "start_line": 139,
      "end_line": 143,
      "source_file": "gunicorn/workers/geventlet.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_quit(self, sig, frame):\n        eventlet.spawn(super().handle_quit, sig, frame)\n",
      "start_line": 143,
      "end_line": 146,
      "source_file": "gunicorn/workers/geventlet.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_usr1(self, sig, frame):\n        eventlet.spawn(super().handle_usr1, sig, frame)\n",
      "start_line": 146,
      "end_line": 149,
      "source_file": "gunicorn/workers/geventlet.py",
      "chunk_type": "code"
    },
    {
      "content": "    def timeout_ctx(self):\n        return eventlet.Timeout(self.cfg.keepalive or None, False)\n",
      "start_line": 149,
      "end_line": 152,
      "source_file": "gunicorn/workers/geventlet.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle(self, listener, client, addr):\n        if self.cfg.is_ssl:\n            client = ssl_wrap_socket(client, self.cfg)\n        super().handle(listener, client, addr)\n",
      "start_line": 152,
      "end_line": 157,
      "source_file": "gunicorn/workers/geventlet.py",
      "chunk_type": "code"
    },
    {
      "content": "    def run(self):\n        acceptors = []\n        for sock in self.sockets:\n            gsock = GreenSocket(sock)\n            gsock.setblocking(1)\n            hfun = partial(self.handle, gsock)\n            acceptor = eventlet.spawn(_eventlet_serve, gsock, hfun,\n                                      self.worker_connections)\n\n            acceptors.append(acceptor)\n            eventlet.sleep(0.0)\n\n        while self.alive:\n            self.notify()\n            eventlet.sleep(1.0)\n\n        self.notify()\n        t = None\n        try:\n            with eventlet.Timeout(self.cfg.graceful_timeout) as t:\n                for a in acceptors:\n                    a.kill(eventlet.StopServe())\n                for a in acceptors:\n                    a.wait()\n        except eventlet.Timeout as te:\n            if te != t:\n                raise\n            for a in acceptors:\n                a.kill()",
      "start_line": 157,
      "end_line": 186,
      "source_file": "gunicorn/workers/geventlet.py",
      "chunk_type": "code"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\nimport os\nimport sys\nfrom datetime import datetime\nfrom functools import partial\nimport time\n\ntry:\n    import gevent\nexcept ImportError:\n    raise RuntimeError(\"gevent worker requires gevent 1.4 or higher\")\nelse:\n    from packaging.version import parse as parse_version\n    if parse_version(gevent.__version__) < parse_version('1.4'):\n        raise RuntimeError(\"gevent worker requires gevent 1.4 or higher\")\n\nfrom gevent.pool import Pool\nfrom gevent.server import StreamServer\nfrom gevent import hub, monkey, socket, pywsgi\n\nimport gunicorn\nfrom gunicorn.http.wsgi import base_environ\nfrom gunicorn.sock import ssl_context\nfrom gunicorn.workers.base_async import AsyncWorker\n\nVERSION = \"gevent/%s gunicorn/%s\" % (gevent.__version__, gunicorn.__version__)\n\n",
      "start_line": 0,
      "end_line": 31,
      "source_file": "gunicorn/workers/ggevent.py",
      "chunk_type": "code"
    },
    {
      "content": "class GeventWorker(AsyncWorker):\n\n    server_class = None\n    wsgi_handler = None\n",
      "start_line": 31,
      "end_line": 36,
      "source_file": "gunicorn/workers/ggevent.py",
      "chunk_type": "code"
    },
    {
      "content": "    def patch(self):\n        monkey.patch_all()\n\n        # patch sockets\n        sockets = []\n        for s in self.sockets:\n            sockets.append(socket.socket(s.FAMILY, socket.SOCK_STREAM,\n                                         fileno=s.sock.detach()))\n        self.sockets = sockets\n",
      "start_line": 36,
      "end_line": 46,
      "source_file": "gunicorn/workers/ggevent.py",
      "chunk_type": "code"
    },
    {
      "content": "    def notify(self):\n        super().notify()\n        if self.ppid != os.getppid():\n            self.log.info(\"Parent changed, shutting down: %s\", self)\n            sys.exit(0)\n",
      "start_line": 46,
      "end_line": 52,
      "source_file": "gunicorn/workers/ggevent.py",
      "chunk_type": "code"
    },
    {
      "content": "    def timeout_ctx(self):\n        return gevent.Timeout(self.cfg.keepalive, False)\n",
      "start_line": 52,
      "end_line": 55,
      "source_file": "gunicorn/workers/ggevent.py",
      "chunk_type": "code"
    },
    {
      "content": "    def run(self):\n        servers = []\n        ssl_args = {}\n\n        if self.cfg.is_ssl:\n            ssl_args = {\"ssl_context\": ssl_context(self.cfg)}\n\n        for s in self.sockets:\n            s.setblocking(1)\n            pool = Pool(self.worker_connections)\n            if self.server_class is not None:\n                environ = base_environ(self.cfg)\n                environ.update({\n                    \"wsgi.multithread\": True,\n                    \"SERVER_SOFTWARE\": VERSION,\n                })\n                server = self.server_class(\n                    s, application=self.wsgi, spawn=pool, log=self.log,\n                    handler_class=self.wsgi_handler, environ=environ,\n                    **ssl_args)\n            else:\n                hfun = partial(self.handle, s)\n                server = StreamServer(s, handle=hfun, spawn=pool, **ssl_args)\n                if self.cfg.workers > 1:\n                    server.max_accept = 1\n\n            server.start()\n            servers.append(server)\n\n        while self.alive:\n            self.notify()\n            gevent.sleep(1.0)\n\n        try:\n            # Stop accepting requests\n            for server in servers:\n                if hasattr(server, 'close'):  # gevent 1.0\n                    server.close()\n                if hasattr(server, 'kill'):  # gevent < 1.0\n                    server.kill()\n\n            # Handle current requests until graceful_timeout\n            ts = time.time()\n            while time.time() - ts <= self.cfg.graceful_timeout:\n                accepting = 0\n                for server in servers:\n                    if server.pool.free_count() != server.pool.size:\n                        accepting += 1\n\n                # if no server is accepting a connection, we can exit\n                if not accepting:\n                    return\n\n                self.notify()\n                gevent.sleep(1.0)\n\n            # Force kill all active the handlers\n            self.log.warning(\"Worker graceful timeout (pid:%s)\", self.pid)\n            for server in servers:\n                server.stop(timeout=1)\n        except Exception:\n            pass\n",
      "start_line": 55,
      "end_line": 118,
      "source_file": "gunicorn/workers/ggevent.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle(self, listener, client, addr):\n        # Connected socket timeout defaults to socket.getdefaulttimeout().\n        # This forces to blocking mode.\n        client.setblocking(1)\n        super().handle(listener, client, addr)\n",
      "start_line": 118,
      "end_line": 124,
      "source_file": "gunicorn/workers/ggevent.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_request(self, listener_name, req, sock, addr):\n        try:\n            super().handle_request(listener_name, req, sock, addr)\n        except gevent.GreenletExit:\n            pass\n        except SystemExit:\n            pass\n",
      "start_line": 124,
      "end_line": 132,
      "source_file": "gunicorn/workers/ggevent.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_quit(self, sig, frame):\n        # Move this out of the signal handler so we can use\n        # blocking calls. See #1126\n        gevent.spawn(super().handle_quit, sig, frame)\n",
      "start_line": 132,
      "end_line": 137,
      "source_file": "gunicorn/workers/ggevent.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_usr1(self, sig, frame):\n        # Make the gevent workers handle the usr1 signal\n        # by deferring to a new greenlet. See #1645\n        gevent.spawn(super().handle_usr1, sig, frame)\n",
      "start_line": 137,
      "end_line": 142,
      "source_file": "gunicorn/workers/ggevent.py",
      "chunk_type": "code"
    },
    {
      "content": "    def init_process(self):\n        self.patch()\n        hub.reinit()\n        super().init_process()\n\n",
      "start_line": 142,
      "end_line": 148,
      "source_file": "gunicorn/workers/ggevent.py",
      "chunk_type": "code"
    },
    {
      "content": "class GeventResponse:\n\n    status = None\n    headers = None\n    sent = None\n",
      "start_line": 148,
      "end_line": 154,
      "source_file": "gunicorn/workers/ggevent.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, status, headers, clength):\n        self.status = status\n        self.headers = headers\n        self.sent = clength\n\n",
      "start_line": 154,
      "end_line": 160,
      "source_file": "gunicorn/workers/ggevent.py",
      "chunk_type": "code"
    },
    {
      "content": "class PyWSGIHandler(pywsgi.WSGIHandler):\n",
      "start_line": 160,
      "end_line": 162,
      "source_file": "gunicorn/workers/ggevent.py",
      "chunk_type": "code"
    },
    {
      "content": "    def log_request(self):\n        start = datetime.fromtimestamp(self.time_start)\n        finish = datetime.fromtimestamp(self.time_finish)\n        response_time = finish - start\n        resp_headers = getattr(self, 'response_headers', {})\n\n        # Status is expected to be a string but is encoded to bytes in gevent for PY3\n        # Except when it isn't because gevent uses hardcoded strings for network errors.\n        status = self.status.decode() if isinstance(self.status, bytes) else self.status\n        resp = GeventResponse(status, resp_headers, self.response_length)\n        if hasattr(self, 'headers'):\n            req_headers = self.headers.items()\n        else:\n            req_headers = []\n        self.server.log.access(resp, req_headers, self.environ, response_time)\n",
      "start_line": 162,
      "end_line": 178,
      "source_file": "gunicorn/workers/ggevent.py",
      "chunk_type": "code"
    },
    {
      "content": "    def get_environ(self):\n        env = super().get_environ()\n        env['gunicorn.sock'] = self.socket\n        env['RAW_URI'] = self.path\n        return env\n\n",
      "start_line": 178,
      "end_line": 185,
      "source_file": "gunicorn/workers/ggevent.py",
      "chunk_type": "code"
    },
    {
      "content": "class PyWSGIServer(pywsgi.WSGIServer):\n    pass\n\n",
      "start_line": 185,
      "end_line": 189,
      "source_file": "gunicorn/workers/ggevent.py",
      "chunk_type": "code"
    },
    {
      "content": "class GeventPyWSGIWorker(GeventWorker):\n    \"The Gevent StreamServer based workers.\"\n    server_class = PyWSGIServer\n    wsgi_handler = PyWSGIHandler",
      "start_line": 189,
      "end_line": 193,
      "source_file": "gunicorn/workers/ggevent.py",
      "chunk_type": "code"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\n# design:\n# A threaded worker accepts connections in the main loop, accepted\n# connections are added to the thread pool as a connection job.\n# Keepalive connections are put back in the loop waiting for an event.\n# If no event happen after the keep alive timeout, the connection is\n# closed.\n# pylint: disable=no-else-break\n\nfrom concurrent import futures\nimport errno\nimport os\nimport selectors\nimport socket\nimport ssl\nimport sys\nimport time\nfrom collections import deque\nfrom datetime import datetime\nfrom functools import partial\nfrom threading import RLock\n\nfrom . import base\nfrom .. import http\nfrom .. import util\nfrom .. import sock\nfrom ..http import wsgi\n\n",
      "start_line": 0,
      "end_line": 32,
      "source_file": "gunicorn/workers/gthread.py",
      "chunk_type": "code"
    },
    {
      "content": "class TConn:\n",
      "start_line": 32,
      "end_line": 34,
      "source_file": "gunicorn/workers/gthread.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, cfg, sock, client, server):\n        self.cfg = cfg\n        self.sock = sock\n        self.client = client\n        self.server = server\n\n        self.timeout = None\n        self.parser = None\n        self.initialized = False\n\n        # set the socket to non blocking\n        self.sock.setblocking(False)\n",
      "start_line": 34,
      "end_line": 47,
      "source_file": "gunicorn/workers/gthread.py",
      "chunk_type": "code"
    },
    {
      "content": "    def init(self):\n        self.initialized = True\n        self.sock.setblocking(True)\n\n        if self.parser is None:\n            # wrap the socket if needed\n            if self.cfg.is_ssl:\n                self.sock = sock.ssl_wrap_socket(self.sock, self.cfg)\n\n            # initialize the parser\n            self.parser = http.RequestParser(self.cfg, self.sock, self.client)\n",
      "start_line": 47,
      "end_line": 59,
      "source_file": "gunicorn/workers/gthread.py",
      "chunk_type": "code"
    },
    {
      "content": "    def set_timeout(self):\n        # set the timeout\n        self.timeout = time.time() + self.cfg.keepalive\n",
      "start_line": 59,
      "end_line": 63,
      "source_file": "gunicorn/workers/gthread.py",
      "chunk_type": "code"
    },
    {
      "content": "    def close(self):\n        util.close(self.sock)\n\n",
      "start_line": 63,
      "end_line": 67,
      "source_file": "gunicorn/workers/gthread.py",
      "chunk_type": "code"
    },
    {
      "content": "class ThreadWorker(base.Worker):\n",
      "start_line": 67,
      "end_line": 69,
      "source_file": "gunicorn/workers/gthread.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.worker_connections = self.cfg.worker_connections\n        self.max_keepalived = self.cfg.worker_connections - self.cfg.threads\n        # initialise the pool\n        self.tpool = None\n        self.poller = None\n        self._lock = None\n        self.futures = deque()\n        self._keep = deque()\n        self.nr_conns = 0\n\n    @classmethod",
      "start_line": 69,
      "end_line": 82,
      "source_file": "gunicorn/workers/gthread.py",
      "chunk_type": "code"
    },
    {
      "content": "    def check_config(cls, cfg, log):\n        max_keepalived = cfg.worker_connections - cfg.threads\n\n        if max_keepalived <= 0 and cfg.keepalive:\n            log.warning(\"No keepalived connections can be handled. \" +\n                        \"Check the number of worker connections and threads.\")\n",
      "start_line": 82,
      "end_line": 89,
      "source_file": "gunicorn/workers/gthread.py",
      "chunk_type": "code"
    },
    {
      "content": "    def init_process(self):\n        self.tpool = self.get_thread_pool()\n        self.poller = selectors.DefaultSelector()\n        self._lock = RLock()\n        super().init_process()\n",
      "start_line": 89,
      "end_line": 95,
      "source_file": "gunicorn/workers/gthread.py",
      "chunk_type": "code"
    },
    {
      "content": "    def get_thread_pool(self):\n        \"\"\"Override this method to customize how the thread pool is created\"\"\"\n        return futures.ThreadPoolExecutor(max_workers=self.cfg.threads)\n",
      "start_line": 95,
      "end_line": 99,
      "source_file": "gunicorn/workers/gthread.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_quit(self, sig, frame):\n        self.alive = False\n        # worker_int callback\n        self.cfg.worker_int(self)\n        self.tpool.shutdown(False)\n        time.sleep(0.1)\n        sys.exit(0)\n",
      "start_line": 99,
      "end_line": 107,
      "source_file": "gunicorn/workers/gthread.py",
      "chunk_type": "code"
    },
    {
      "content": "    def _wrap_future(self, fs, conn):\n        fs.conn = conn\n        self.futures.append(fs)\n        fs.add_done_callback(self.finish_request)\n",
      "start_line": 107,
      "end_line": 112,
      "source_file": "gunicorn/workers/gthread.py",
      "chunk_type": "code"
    },
    {
      "content": "    def enqueue_req(self, conn):\n        conn.init()\n        # submit the connection to a worker\n        fs = self.tpool.submit(self.handle, conn)\n        self._wrap_future(fs, conn)\n",
      "start_line": 112,
      "end_line": 118,
      "source_file": "gunicorn/workers/gthread.py",
      "chunk_type": "code"
    },
    {
      "content": "    def accept(self, server, listener):\n        try:\n            sock, client = listener.accept()\n            # initialize the connection object\n            conn = TConn(self.cfg, sock, client, server)\n\n            self.nr_conns += 1\n            # wait until socket is readable\n            with self._lock:\n                self.poller.register(conn.sock, selectors.EVENT_READ,\n                                     partial(self.on_client_socket_readable, conn))\n        except OSError as e:\n            if e.errno not in (errno.EAGAIN, errno.ECONNABORTED,\n                               errno.EWOULDBLOCK):\n                raise\n",
      "start_line": 118,
      "end_line": 134,
      "source_file": "gunicorn/workers/gthread.py",
      "chunk_type": "code"
    },
    {
      "content": "    def on_client_socket_readable(self, conn, client):\n        with self._lock:\n            # unregister the client from the poller\n            self.poller.unregister(client)\n\n            if conn.initialized:\n                # remove the connection from keepalive\n                try:\n                    self._keep.remove(conn)\n                except ValueError:\n                    # race condition\n                    return\n\n        # submit the connection to a worker\n        self.enqueue_req(conn)\n",
      "start_line": 134,
      "end_line": 150,
      "source_file": "gunicorn/workers/gthread.py",
      "chunk_type": "code"
    },
    {
      "content": "    def murder_keepalived(self):\n        now = time.time()\n        while True:\n            with self._lock:\n                try:\n                    # remove the connection from the queue\n                    conn = self._keep.popleft()\n                except IndexError:\n                    break\n\n            delta = conn.timeout - now\n            if delta > 0:\n                # add the connection back to the queue\n                with self._lock:\n                    self._keep.appendleft(conn)\n                break\n            else:\n                self.nr_conns -= 1\n                # remove the socket from the poller\n                with self._lock:\n                    try:\n                        self.poller.unregister(conn.sock)\n                    except OSError as e:\n                        if e.errno != errno.EBADF:\n                            raise\n                    except KeyError:\n                        # already removed by the system, continue\n                        pass\n                    except ValueError:\n                        # already removed by the system continue\n                        pass\n\n                # close the socket\n                conn.close()\n",
      "start_line": 150,
      "end_line": 185,
      "source_file": "gunicorn/workers/gthread.py",
      "chunk_type": "code"
    },
    {
      "content": "    def is_parent_alive(self):\n        # If our parent changed then we shut down.\n        if self.ppid != os.getppid():\n            self.log.info(\"Parent changed, shutting down: %s\", self)\n            return False\n        return True\n",
      "start_line": 185,
      "end_line": 192,
      "source_file": "gunicorn/workers/gthread.py",
      "chunk_type": "code"
    },
    {
      "content": "    def run(self):\n        # init listeners, add them to the event loop\n        for sock in self.sockets:\n            sock.setblocking(False)\n            # a race condition during graceful shutdown may make the listener\n            # name unavailable in the request handler so capture it once here\n            server = sock.getsockname()\n            acceptor = partial(self.accept, server)\n            self.poller.register(sock, selectors.EVENT_READ, acceptor)\n\n        while self.alive:\n            # notify the arbiter we are alive\n            self.notify()\n\n            # can we accept more connections?\n            if self.nr_conns < self.worker_connections:\n                # wait for an event\n                events = self.poller.select(1.0)\n                for key, _ in events:\n                    callback = key.data\n                    callback(key.fileobj)\n\n                # check (but do not wait) for finished requests\n                result = futures.wait(self.futures, timeout=0,\n                                      return_when=futures.FIRST_COMPLETED)\n            else:\n                # wait for a request to finish\n                result = futures.wait(self.futures, timeout=1.0,\n                                      return_when=futures.FIRST_COMPLETED)\n\n            # clean up finished requests\n            for fut in result.done:\n                self.futures.remove(fut)\n\n            if not self.is_parent_alive():\n                break\n\n            # handle keepalive timeouts\n            self.murder_keepalived()\n\n        self.tpool.shutdown(False)\n        self.poller.close()\n\n        for s in self.sockets:\n            s.close()\n\n        futures.wait(self.futures, timeout=self.cfg.graceful_timeout)\n",
      "start_line": 192,
      "end_line": 240,
      "source_file": "gunicorn/workers/gthread.py",
      "chunk_type": "code"
    },
    {
      "content": "    def finish_request(self, fs):\n        if fs.cancelled():\n            self.nr_conns -= 1\n            fs.conn.close()\n            return\n\n        try:\n            (keepalive, conn) = fs.result()\n            # if the connection should be kept alived add it\n            # to the eventloop and record it\n            if keepalive and self.alive:\n                # flag the socket as non blocked\n                conn.sock.setblocking(False)\n\n                # register the connection\n                conn.set_timeout()\n                with self._lock:\n                    self._keep.append(conn)\n\n                    # add the socket to the event loop\n                    self.poller.register(conn.sock, selectors.EVENT_READ,\n                                         partial(self.on_client_socket_readable, conn))\n            else:\n                self.nr_conns -= 1\n                conn.close()\n        except Exception:\n            # an exception happened, make sure to close the\n            # socket.\n            self.nr_conns -= 1\n            fs.conn.close()\n",
      "start_line": 240,
      "end_line": 271,
      "source_file": "gunicorn/workers/gthread.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle(self, conn):\n        keepalive = False\n        req = None\n        try:\n            req = next(conn.parser)\n            if not req:\n                return (False, conn)\n\n            # handle the request\n            keepalive = self.handle_request(req, conn)\n            if keepalive:\n                return (keepalive, conn)\n        except http.errors.NoMoreData as e:\n            self.log.debug(\"Ignored premature client disconnection. %s\", e)\n\n        except StopIteration as e:\n            self.log.debug(\"Closing connection. %s\", e)\n        except ssl.SSLError as e:\n            if e.args[0] == ssl.SSL_ERROR_EOF:\n                self.log.debug(\"ssl connection closed\")\n                conn.sock.close()\n            else:\n                self.log.debug(\"Error processing SSL request.\")\n                self.handle_error(req, conn.sock, conn.client, e)\n\n        except OSError as e:\n            if e.errno not in (errno.EPIPE, errno.ECONNRESET, errno.ENOTCONN):\n                self.log.exception(\"Socket error processing request.\")\n            else:\n                if e.errno == errno.ECONNRESET:\n                    self.log.debug(\"Ignoring connection reset\")\n                elif e.errno == errno.ENOTCONN:\n                    self.log.debug(\"Ignoring socket not connected\")\n                else:\n                    self.log.debug(\"Ignoring connection epipe\")\n        except Exception as e:\n            self.handle_error(req, conn.sock, conn.client, e)\n\n        return (False, conn)\n",
      "start_line": 271,
      "end_line": 311,
      "source_file": "gunicorn/workers/gthread.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_request(self, req, conn):\n        environ = {}\n        resp = None\n        try:\n            self.cfg.pre_request(self, req)\n            request_start = datetime.now()\n            resp, environ = wsgi.create(req, conn.sock, conn.client,\n                                        conn.server, self.cfg)\n            environ[\"wsgi.multithread\"] = True\n            self.nr += 1\n            if self.nr >= self.max_requests:\n                if self.alive:\n                    self.log.info(\"Autorestarting worker after current request.\")\n                    self.alive = False\n                resp.force_close()\n\n            if not self.alive or not self.cfg.keepalive:\n                resp.force_close()\n            elif len(self._keep) >= self.max_keepalived:\n                resp.force_close()\n\n            respiter = self.wsgi(environ, resp.start_response)\n            try:\n                if isinstance(respiter, environ['wsgi.file_wrapper']):\n                    resp.write_file(respiter)\n                else:\n                    for item in respiter:\n                        resp.write(item)\n\n                resp.close()\n            finally:\n                request_time = datetime.now() - request_start\n                self.log.access(resp, req, environ, request_time)\n                if hasattr(respiter, \"close\"):\n                    respiter.close()\n\n            if resp.should_close():\n                self.log.debug(\"Closing connection.\")\n                return False\n        except OSError:\n            # pass to next try-except level\n            util.reraise(*sys.exc_info())\n        except Exception:\n            if resp and resp.headers_sent:\n                # If the requests have already been sent, we should close the\n                # connection to indicate the error.\n                self.log.exception(\"Error handling request\")\n                try:\n                    conn.sock.shutdown(socket.SHUT_RDWR)\n                    conn.sock.close()\n                except OSError:\n                    pass\n                raise StopIteration()\n            raise\n        finally:\n            try:\n                self.cfg.post_request(self, req, environ, resp)\n            except Exception:\n                self.log.exception(\"Exception in post_request hook\")\n\n        return True",
      "start_line": 311,
      "end_line": 372,
      "source_file": "gunicorn/workers/gthread.py",
      "chunk_type": "code"
    },
    {
      "content": "#\n# This file is part of gunicorn released under the MIT license.\n# See the NOTICE for more information.\n\nimport io\nimport os\nimport signal\nimport sys\nimport time\nimport traceback\nfrom datetime import datetime\nfrom random import randint\nfrom ssl import SSLError\n\nfrom gunicorn import util\nfrom gunicorn.http.errors import (\n    ForbiddenProxyRequest, InvalidHeader,\n    InvalidHeaderName, InvalidHTTPVersion,\n    InvalidProxyLine, InvalidRequestLine,\n    InvalidRequestMethod, InvalidSchemeHeaders,\n    LimitRequestHeaders, LimitRequestLine,\n    UnsupportedTransferCoding,\n    ConfigurationProblem, ObsoleteFolding,\n)\nfrom gunicorn.http.wsgi import Response, default_environ\nfrom gunicorn.reloader import reloader_engines\nfrom gunicorn.workers.workertmp import WorkerTmp\n\n",
      "start_line": 0,
      "end_line": 29,
      "source_file": "gunicorn/workers/base.py",
      "chunk_type": "code"
    },
    {
      "content": "class Worker:\n\n    SIGNALS = [getattr(signal, \"SIG%s\" % x) for x in (\n        \"ABRT HUP QUIT INT TERM USR1 USR2 WINCH CHLD\".split()\n    )]\n\n    PIPE = []\n",
      "start_line": 29,
      "end_line": 37,
      "source_file": "gunicorn/workers/base.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __init__(self, age, ppid, sockets, app, timeout, cfg, log):\n        \"\"\"\\\n        This is called pre-fork so it shouldn't do anything to the\n        current process. If there's a need to make process wide\n        changes you'll want to do that in ``self.init_process()``.\n        \"\"\"\n        self.age = age\n        self.pid = \"[booting]\"\n        self.ppid = ppid\n        self.sockets = sockets\n        self.app = app\n        self.timeout = timeout\n        self.cfg = cfg\n        self.booted = False\n        self.aborted = False\n        self.reloader = None\n\n        self.nr = 0\n\n        if cfg.max_requests > 0:\n            jitter = randint(0, cfg.max_requests_jitter)\n            self.max_requests = cfg.max_requests + jitter\n        else:\n            self.max_requests = sys.maxsize\n\n        self.alive = True\n        self.log = log\n        self.tmp = WorkerTmp(cfg)\n",
      "start_line": 37,
      "end_line": 66,
      "source_file": "gunicorn/workers/base.py",
      "chunk_type": "code"
    },
    {
      "content": "    def __str__(self):\n        return \"<Worker %s>\" % self.pid\n",
      "start_line": 66,
      "end_line": 69,
      "source_file": "gunicorn/workers/base.py",
      "chunk_type": "code"
    },
    {
      "content": "    def notify(self):\n        \"\"\"\\\n        Your worker subclass must arrange to have this method called\n        once every ``self.timeout`` seconds. If you fail in accomplishing\n        this task, the master process will murder your workers.\n        \"\"\"\n        self.tmp.notify()\n",
      "start_line": 69,
      "end_line": 77,
      "source_file": "gunicorn/workers/base.py",
      "chunk_type": "code"
    },
    {
      "content": "    def run(self):\n        \"\"\"\\\n        This is the mainloop of a worker process. You should override\n        this method in a subclass to provide the intended behaviour\n        for your particular evil schemes.\n        \"\"\"\n        raise NotImplementedError()\n",
      "start_line": 77,
      "end_line": 85,
      "source_file": "gunicorn/workers/base.py",
      "chunk_type": "code"
    },
    {
      "content": "    def init_process(self):\n        \"\"\"\\\n        If you override this method in a subclass, the last statement\n        in the function should be to call this method with\n        super().init_process() so that the ``run()`` loop is initiated.\n        \"\"\"\n\n        # set environment' variables\n        if self.cfg.env:\n            for k, v in self.cfg.env.items():\n                os.environ[k] = v\n\n        util.set_owner_process(self.cfg.uid, self.cfg.gid,\n                               initgroups=self.cfg.initgroups)\n\n        # Reseed the random number generator\n        util.seed()\n\n        # For waking ourselves up\n        self.PIPE = os.pipe()\n        for p in self.PIPE:\n            util.set_non_blocking(p)\n            util.close_on_exec(p)\n\n        # Prevent fd inheritance\n        for s in self.sockets:\n            util.close_on_exec(s)\n        util.close_on_exec(self.tmp.fileno())\n\n        self.wait_fds = self.sockets + [self.PIPE[0]]\n\n        self.log.close_on_exec()\n\n        self.init_signals()\n\n        # start the reloader\n        if self.cfg.reload:",
      "start_line": 85,
      "end_line": 122,
      "source_file": "gunicorn/workers/base.py",
      "chunk_type": "code"
    },
    {
      "content": "            def changed(fname):\n                self.log.info(\"Worker reloading: %s modified\", fname)\n                self.alive = False\n                os.write(self.PIPE[1], b\"1\")\n                self.cfg.worker_int(self)\n                time.sleep(0.1)\n                sys.exit(0)\n\n            reloader_cls = reloader_engines[self.cfg.reload_engine]\n            self.reloader = reloader_cls(extra_files=self.cfg.reload_extra_files,\n                                         callback=changed)\n\n        self.load_wsgi()\n        if self.reloader:\n            self.reloader.start()\n\n        self.cfg.post_worker_init(self)\n\n        # Enter main run loop\n        self.booted = True\n        self.run()\n",
      "start_line": 122,
      "end_line": 144,
      "source_file": "gunicorn/workers/base.py",
      "chunk_type": "code"
    },
    {
      "content": "    def load_wsgi(self):\n        try:\n            self.wsgi = self.app.wsgi()\n        except SyntaxError as e:\n            if not self.cfg.reload:\n                raise\n\n            self.log.exception(e)\n\n            # fix from PR #1228\n            # storing the traceback into exc_tb will create a circular reference.\n            # per https://docs.python.org/2/library/sys.html#sys.exc_info warning,\n            # delete the traceback after use.\n            try:\n                _, exc_val, exc_tb = sys.exc_info()\n                self.reloader.add_extra_file(exc_val.filename)\n\n                tb_string = io.StringIO()\n                traceback.print_tb(exc_tb, file=tb_string)\n                self.wsgi = util.make_fail_app(tb_string.getvalue())\n            finally:\n                del exc_tb\n",
      "start_line": 144,
      "end_line": 167,
      "source_file": "gunicorn/workers/base.py",
      "chunk_type": "code"
    },
    {
      "content": "    def init_signals(self):\n        # reset signaling\n        for s in self.SIGNALS:\n            signal.signal(s, signal.SIG_DFL)\n        # init new signaling\n        signal.signal(signal.SIGQUIT, self.handle_quit)\n        signal.signal(signal.SIGTERM, self.handle_exit)\n        signal.signal(signal.SIGINT, self.handle_quit)\n        signal.signal(signal.SIGWINCH, self.handle_winch)\n        signal.signal(signal.SIGUSR1, self.handle_usr1)\n        signal.signal(signal.SIGABRT, self.handle_abort)\n\n        # Don't let SIGTERM and SIGUSR1 disturb active requests\n        # by interrupting system calls\n        signal.siginterrupt(signal.SIGTERM, False)\n        signal.siginterrupt(signal.SIGUSR1, False)\n\n        if hasattr(signal, 'set_wakeup_fd'):\n            signal.set_wakeup_fd(self.PIPE[1])\n",
      "start_line": 167,
      "end_line": 187,
      "source_file": "gunicorn/workers/base.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_usr1(self, sig, frame):\n        self.log.reopen_files()\n",
      "start_line": 187,
      "end_line": 190,
      "source_file": "gunicorn/workers/base.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_exit(self, sig, frame):\n        self.alive = False\n",
      "start_line": 190,
      "end_line": 193,
      "source_file": "gunicorn/workers/base.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_quit(self, sig, frame):\n        self.alive = False\n        # worker_int callback\n        self.cfg.worker_int(self)\n        time.sleep(0.1)\n        sys.exit(0)\n",
      "start_line": 193,
      "end_line": 200,
      "source_file": "gunicorn/workers/base.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_abort(self, sig, frame):\n        self.alive = False\n        self.cfg.worker_abort(self)\n        sys.exit(1)\n",
      "start_line": 200,
      "end_line": 205,
      "source_file": "gunicorn/workers/base.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_error(self, req, client, addr, exc):\n        request_start = datetime.now()\n        addr = addr or ('', -1)  # unix socket case\n        if isinstance(exc, (\n            InvalidRequestLine, InvalidRequestMethod,\n            InvalidHTTPVersion, InvalidHeader, InvalidHeaderName,\n            LimitRequestLine, LimitRequestHeaders,\n            InvalidProxyLine, ForbiddenProxyRequest,\n            InvalidSchemeHeaders, UnsupportedTransferCoding,\n            ConfigurationProblem, ObsoleteFolding,\n            SSLError,\n        )):\n\n            status_int = 400\n            reason = \"Bad Request\"\n\n            if isinstance(exc, InvalidRequestLine):\n                mesg = \"Invalid Request Line '%s'\" % str(exc)\n            elif isinstance(exc, InvalidRequestMethod):\n                mesg = \"Invalid Method '%s'\" % str(exc)\n            elif isinstance(exc, InvalidHTTPVersion):\n                mesg = \"Invalid HTTP Version '%s'\" % str(exc)\n            elif isinstance(exc, UnsupportedTransferCoding):\n                mesg = \"%s\" % str(exc)\n                status_int = 501\n            elif isinstance(exc, ConfigurationProblem):\n                mesg = \"%s\" % str(exc)\n                status_int = 500\n            elif isinstance(exc, ObsoleteFolding):\n                mesg = \"%s\" % str(exc)\n            elif isinstance(exc, (InvalidHeaderName, InvalidHeader,)):\n                mesg = \"%s\" % str(exc)\n                if not req and hasattr(exc, \"req\"):\n                    req = exc.req  # for access log\n            elif isinstance(exc, LimitRequestLine):\n                mesg = \"%s\" % str(exc)\n            elif isinstance(exc, LimitRequestHeaders):\n                reason = \"Request Header Fields Too Large\"\n                mesg = \"Error parsing headers: '%s'\" % str(exc)\n                status_int = 431\n            elif isinstance(exc, InvalidProxyLine):\n                mesg = \"'%s'\" % str(exc)\n            elif isinstance(exc, ForbiddenProxyRequest):\n                reason = \"Forbidden\"\n                mesg = \"Request forbidden\"\n                status_int = 403\n            elif isinstance(exc, InvalidSchemeHeaders):\n                mesg = \"%s\" % str(exc)\n            elif isinstance(exc, SSLError):\n                reason = \"Forbidden\"\n                mesg = \"'%s'\" % str(exc)\n                status_int = 403\n\n            msg = \"Invalid request from ip={ip}: {error}\"\n            self.log.warning(msg.format(ip=addr[0], error=str(exc)))\n        else:\n            if hasattr(req, \"uri\"):\n                self.log.exception(\"Error handling request %s\", req.uri)\n            else:\n                self.log.exception(\"Error handling request (no URI read)\")\n            status_int = 500\n            reason = \"Internal Server Error\"\n            mesg = \"\"\n\n        if req is not None:\n            request_time = datetime.now() - request_start\n            environ = default_environ(req, client, self.cfg)\n            environ['REMOTE_ADDR'] = addr[0]\n            environ['REMOTE_PORT'] = str(addr[1])\n            resp = Response(req, client, self.cfg)\n            resp.status = \"%s %s\" % (status_int, reason)\n            resp.response_length = len(mesg)\n            self.log.access(resp, req, environ, request_time)\n\n        try:\n            util.write_error(client, status_int, reason, mesg)\n        except Exception:\n            self.log.debug(\"Failed to send error message.\")\n",
      "start_line": 205,
      "end_line": 284,
      "source_file": "gunicorn/workers/base.py",
      "chunk_type": "code"
    },
    {
      "content": "    def handle_winch(self, sig, fname):\n        # Ignore SIGWINCH in worker. Fixes a crash on OpenBSD.\n        self.log.debug(\"worker: SIGWINCH ignored.\")",
      "start_line": 284,
      "end_line": 287,
      "source_file": "gunicorn/workers/base.py",
      "chunk_type": "code"
    }
  ],
  "_metadata": {
    "generation_info": {
      "model": "gemini-2.5-flash",
      "provider": "gemini",
      "base_url": "https://generativelanguage.googleapis.com/v1beta/openai/",
      "start_time": "2025-07-11T11:00:32.734089",
      "command": "analyze",
      "config_file": null,
      "version": "0.1.0"
    }
  }
}